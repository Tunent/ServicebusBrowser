// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"CvJj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__extends = __extends;
exports.__rest = __rest;
exports.__decorate = __decorate;
exports.__param = __param;
exports.__metadata = __metadata;
exports.__awaiter = __awaiter;
exports.__generator = __generator;
exports.__exportStar = __exportStar;
exports.__values = __values;
exports.__read = __read;
exports.__spread = __spread;
exports.__spreadArrays = __spreadArrays;
exports.__spreadArray = __spreadArray;
exports.__await = __await;
exports.__asyncGenerator = __asyncGenerator;
exports.__asyncDelegator = __asyncDelegator;
exports.__asyncValues = __asyncValues;
exports.__makeTemplateObject = __makeTemplateObject;
exports.__importStar = __importStar;
exports.__importDefault = __importDefault;
exports.__classPrivateFieldGet = __classPrivateFieldGet;
exports.__classPrivateFieldSet = __classPrivateFieldSet;
exports.__createBinding = exports.__assign = void 0;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function () {
  exports.__assign = __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

exports.__assign = __assign;

function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

var __createBinding = Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
};

exports.__createBinding = __createBinding;

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}
/** @deprecated */


function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
}
/** @deprecated */


function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

function __spreadArray(to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];

  return to;
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;

  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }

  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }

  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }

  function fulfill(value) {
    resume("next", value);
  }

  function reject(value) {
    resume("throw", value);
  }

  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;

  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
      i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);

  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }

  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }

  return cooked;
}

;

var __setModuleDefault = Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
}

function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}

function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }

  return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }

  privateMap.set(receiver, value);
  return value;
}
},{}],"fKpN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.abortSignal = abortSignal;
exports.AbortSignal = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var listenersMap = new WeakMap();
var abortedMap = new WeakMap();
/**
 * An aborter instance implements AbortSignal interface, can abort HTTP requests.
 *
 * - Call AbortSignal.none to create a new AbortSignal instance that cannot be cancelled.
 * Use `AbortSignal.none` when you are required to pass a cancellation token but the operation
 * cannot or will not ever be cancelled.
 *
 * @example
 * Abort without timeout
 * ```ts
 * await doAsyncWork(AbortSignal.none);
 * ```
 */

var AbortSignal =
/** @class */
function () {
  function AbortSignal() {
    /**
     * onabort event listener.
     */
    this.onabort = null;
    listenersMap.set(this, []);
    abortedMap.set(this, false);
  }

  Object.defineProperty(AbortSignal.prototype, "aborted", {
    /**
     * Status of whether aborted or not.
     *
     * @readonly
     */
    get: function () {
      if (!abortedMap.has(this)) {
        throw new TypeError("Expected `this` to be an instance of AbortSignal.");
      }

      return abortedMap.get(this);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbortSignal, "none", {
    /**
     * Creates a new AbortSignal instance that will never be aborted.
     *
     * @readonly
     */
    get: function () {
      return new AbortSignal();
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Added new "abort" event listener, only support "abort" event.
   *
   * @param _type - Only support "abort" event
   * @param listener - The listener to be added
   */

  AbortSignal.prototype.addEventListener = function ( // tslint:disable-next-line:variable-name
  _type, listener) {
    if (!listenersMap.has(this)) {
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    }

    var listeners = listenersMap.get(this);
    listeners.push(listener);
  };
  /**
   * Remove "abort" event listener, only support "abort" event.
   *
   * @param _type - Only support "abort" event
   * @param listener - The listener to be removed
   */


  AbortSignal.prototype.removeEventListener = function ( // tslint:disable-next-line:variable-name
  _type, listener) {
    if (!listenersMap.has(this)) {
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    }

    var listeners = listenersMap.get(this);
    var index = listeners.indexOf(listener);

    if (index > -1) {
      listeners.splice(index, 1);
    }
  };
  /**
   * Dispatches a synthetic event to the AbortSignal.
   */


  AbortSignal.prototype.dispatchEvent = function (_event) {
    throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
  };

  return AbortSignal;
}();

exports.AbortSignal = AbortSignal;

/**
 * Helper to trigger an abort event immediately, the onabort and all abort event listeners will be triggered.
 * Will try to trigger abort event for all linked AbortSignal nodes.
 *
 * - If there is a timeout, the timer will be cancelled.
 * - If aborted is true, nothing will happen.
 *
 * @internal
 */
// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
function abortSignal(signal) {
  if (signal.aborted) {
    return;
  }

  if (signal.onabort) {
    signal.onabort.call(signal);
  }

  var listeners = listenersMap.get(signal);

  if (listeners) {
    listeners.forEach(function (listener) {
      listener.call(signal, {
        type: "abort"
      });
    });
  }

  abortedMap.set(signal, true);
}
},{}],"Dixl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbortController = exports.AbortError = void 0;

var _tslib = require("tslib");

var _AbortSignal = require("./AbortSignal");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * This error is thrown when an asynchronous operation has been aborted.
 * Check for this error by testing the `name` that the name property of the
 * error matches `"AbortError"`.
 *
 * @example
 * ```ts
 * const controller = new AbortController();
 * controller.abort();
 * try {
 *   doAsyncWork(controller.signal)
 * } catch (e) {
 *   if (e.name === 'AbortError') {
 *     // handle abort error here.
 *   }
 * }
 * ```
 */
var AbortError =
/** @class */
function (_super) {
  (0, _tslib.__extends)(AbortError, _super);

  function AbortError(message) {
    var _this = _super.call(this, message) || this;

    _this.name = "AbortError";
    return _this;
  }

  return AbortError;
}(Error);

exports.AbortError = AbortError;

/**
 * An AbortController provides an AbortSignal and the associated controls to signal
 * that an asynchronous operation should be aborted.
 *
 * @example
 * Abort an operation when another event fires
 * ```ts
 * const controller = new AbortController();
 * const signal = controller.signal;
 * doAsyncWork(signal);
 * button.addEventListener('click', () => controller.abort());
 * ```
 *
 * @example
 * Share aborter cross multiple operations in 30s
 * ```ts
 * // Upload the same data to 2 different data centers at the same time,
 * // abort another when any of them is finished
 * const controller = AbortController.withTimeout(30 * 1000);
 * doAsyncWork(controller.signal).then(controller.abort);
 * doAsyncWork(controller.signal).then(controller.abort);
 *```
 *
 * @example
 * Cascaded aborting
 * ```ts
 * // All operations can't take more than 30 seconds
 * const aborter = Aborter.timeout(30 * 1000);
 *
 * // Following 2 operations can't take more than 25 seconds
 * await doAsyncWork(aborter.withTimeout(25 * 1000));
 * await doAsyncWork(aborter.withTimeout(25 * 1000));
 * ```
 */
var AbortController =
/** @class */
function () {
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  function AbortController(parentSignals) {
    var _this = this;

    this._signal = new _AbortSignal.AbortSignal();

    if (!parentSignals) {
      return;
    } // coerce parentSignals into an array


    if (!Array.isArray(parentSignals)) {
      // eslint-disable-next-line prefer-rest-params
      parentSignals = arguments;
    }

    for (var _i = 0, parentSignals_1 = parentSignals; _i < parentSignals_1.length; _i++) {
      var parentSignal = parentSignals_1[_i]; // if the parent signal has already had abort() called,
      // then call abort on this signal as well.

      if (parentSignal.aborted) {
        this.abort();
      } else {
        // when the parent signal aborts, this signal should as well.
        parentSignal.addEventListener("abort", function () {
          _this.abort();
        });
      }
    }
  }

  Object.defineProperty(AbortController.prototype, "signal", {
    /**
     * The AbortSignal associated with this controller that will signal aborted
     * when the abort method is called on this controller.
     *
     * @readonly
     */
    get: function () {
      return this._signal;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Signal that any operations passed this controller's associated abort signal
   * to cancel any remaining work and throw an `AbortError`.
   */

  AbortController.prototype.abort = function () {
    (0, _AbortSignal.abortSignal)(this._signal);
  };
  /**
   * Creates a new AbortSignal instance that will abort after the provided ms.
   * @param ms - Elapsed time in milliseconds to trigger an abort.
   */


  AbortController.timeout = function (ms) {
    var signal = new _AbortSignal.AbortSignal();
    var timer = setTimeout(_AbortSignal.abortSignal, ms, signal); // Prevent the active Timer from keeping the Node.js event loop active.

    if (typeof timer.unref === "function") {
      timer.unref();
    }

    return signal;
  };

  return AbortController;
}();

exports.AbortController = AbortController;
},{"tslib":"CvJj","./AbortSignal":"fKpN"}],"wyb9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AbortController", {
  enumerable: true,
  get: function () {
    return _AbortController.AbortController;
  }
});
Object.defineProperty(exports, "AbortError", {
  enumerable: true,
  get: function () {
    return _AbortController.AbortError;
  }
});
Object.defineProperty(exports, "AbortSignal", {
  enumerable: true,
  get: function () {
    return _AbortSignal.AbortSignal;
  }
});

var _AbortController = require("./AbortController");

var _AbortSignal = require("./AbortSignal");
},{"./AbortController":"Dixl","./AbortSignal":"fKpN"}],"oklo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Constants = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const Constants = {
  associatedLinkName: "associated-link-name",
  partitionKey: "x-opt-partition-key",
  sequenceNumber: "x-opt-sequence-number",
  enqueueSequenceNumber: "x-opt-enqueue-sequence-number",
  enqueuedTime: "x-opt-enqueued-time",
  scheduledEnqueueTime: "x-opt-scheduled-enqueue-time",
  offset: "x-opt-offset",
  lockedUntil: "x-opt-locked-until",
  partitionIdName: "x-opt-partition-id",
  publisher: "x-opt-publisher-name",
  viaPartitionKey: "x-opt-via-partition-key",
  deadLetterSource: "x-opt-deadletter-source",
  enqueuedTimeAnnotation: `amqp.annotation.x-opt-enqueued-time`,
  offsetAnnotation: `amqp.annotation.x-opt-offset`,
  sequenceNumberAnnotation: `amqp.annotation.x-opt-sequence-number`,
  guidSize: 16,
  message: "message",
  error: "error",
  statusCode: "status-code",
  statusDescription: "status-description",
  errorCondition: "error-condition",
  management: "$management",
  partition: "partition",
  partitionId: "partitionId",
  readOperation: "READ",
  TLS: "tls",
  establishConnection: "establishConnection",
  defaultConsumerGroup: "$default",
  eventHub: "eventhub",
  cbsEndpoint: "$cbs",
  cbsReplyTo: "cbs",
  operationPutToken: "put-token",
  aadEventHubsAudience: "https://eventhubs.azure.net/",
  aadEventHubsScope: "https://eventhubs.azure.net//.default",
  aadServiceBusAudience: "https://servicebus.azure.net/",
  aadServiceBusScope: "https://servicebus.azure.net//.default",
  maxUserAgentLength: 512,
  vendorString: "com.microsoft",
  attachEpoch: `com.microsoft:epoch`,
  receiverIdentifierName: `com.microsoft:receiver-name`,
  enableReceiverRuntimeMetricName: `com.microsoft:enable-receiver-runtime-metric`,
  timespan: `com.microsoft:timespan`,
  uri: `com.microsoft:uri`,
  dateTimeOffset: `com.microsoft:datetime-offset`,
  sessionFilterName: `com.microsoft:session-filter`,
  receiverError: "receiver_error",
  senderError: "sender_error",
  sessionError: "session_error",
  connectionError: "connection_error",
  defaultOperationTimeoutInMs: 60000,
  defaultConnectionIdleTimeoutInMs: 60000,
  managementRequestKey: "managementRequest",
  negotiateCbsKey: "negotiateCbs",
  negotiateClaim: "negotiateClaim",
  ensureContainerAndBlob: "ensureContainerAndBlob",
  defaultPrefetchCount: 1000,
  reconnectLimit: 100,
  maxMessageIdLength: 128,
  maxPartitionKeyLength: 128,
  maxSessionIdLength: 128,
  pathDelimiter: "/",
  ruleNameMaximumLength: 50,
  maximumSqlFilterStatementLength: 1024,
  maximumSqlRuleActionStatementLength: 1024,
  maxDeadLetterReasonLength: 4096,
  // https://stackoverflow.com/questions/11526504/minimum-and-maximum-date for js
  // However we are setting this to the TimeSpan.MaxValue of C#.
  maxDurationValue: 922337203685477,
  minDurationValue: -922337203685477,
  // https://github.com/Azure/azure-amqp/blob/master/Microsoft.Azure.Amqp/Amqp/AmqpConstants.cs#L47
  maxAbsoluteExpiryTime: new Date("9999-12-31T07:59:59.000Z").getTime(),
  aadTokenValidityMarginInMs: 5000,
  connectionReconnectDelay: 300,
  defaultMaxRetries: 3,
  defaultMaxRetriesForConnection: 150,
  defaultDelayBetweenOperationRetriesInMs: 30000,
  defaultMaxDelayForExponentialRetryInMs: 90000,
  receiverSettleMode: "receiver-settle-mode",
  dispositionStatus: "disposition-status",
  fromSequenceNumber: "from-sequence-number",
  messageCount: "message-count",
  lockTokens: "lock-tokens",
  messageIdMapKey: "message-id",
  sequenceNumberMapKey: "sequence-number",
  lockTokenMapKey: "lock-token",
  sessionIdMapKey: "session-id",
  sequenceNumbers: "sequence-numbers",
  deadLetterReason: "deadletter-reason",
  deadLetterDescription: "deadletter-description",
  propertiesToModify: "properties-to-modify",
  deadLetterName: "com.microsoft:dead-letter",
  trackingId: "com.microsoft:tracking-id",
  serverTimeout: "com.microsoft:server-timeout",
  operations: {
    putToken: "put-token",
    read: "READ",
    cancelScheduledMessage: "com.microsoft:cancel-scheduled-message",
    scheduleMessage: "com.microsoft:schedule-message",
    renewLock: "com.microsoft:renew-lock",
    peekMessage: "com.microsoft:peek-message",
    receiveBySequenceNumber: "com.microsoft:receive-by-sequence-number",
    updateDisposition: "com.microsoft:update-disposition",
    renewSessionLock: "com.microsoft:renew-session-lock",
    setSessionState: "com.microsoft:set-session-state",
    getSessionState: "com.microsoft:get-session-state",
    enumerateSessions: "com.microsoft:get-message-sessions",
    addRule: "com.microsoft:add-rule",
    removeRule: "com.microsoft:remove-rule",
    enumerateRules: "com.microsoft:enumerate-rules"
  },
  descriptorCodes: {
    ruleDescriptionList: 1335734829060,
    sqlFilterList: 83483426822,
    correlationFilterList: 83483426825,
    sqlRuleActionList: 1335734829062,
    trueFilterList: 83483426823,
    falseFilterList: 83483426824
  }
};
exports.Constants = Constants;
},{}],"HTeN":[function(require,module,exports) {
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"v3DX":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"g5IB":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"nIH4":[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};

  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }

  return descriptors;
};

var formatRegExp = /%[sdj%]/g;

exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];

    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }

    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;

    switch (x) {
      case '%s':
        return String(args[i++]);

      case '%d':
        return Number(args[i++]);

      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }

      default:
        return x;
    }
  });

  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
}; // Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.


exports.deprecate = function (fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  } // Allow for deprecating things in the process of starting up.


  if (typeof process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;

exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = undefined || '';
  set = set.toUpperCase();

  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;

      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }

  return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/


function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


function isArray(ar) {
  return Array.isArray(ar);
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */


exports.inherits = require('inherits');

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];

    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }

    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};

exports.promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }

  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  } // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.


  function callbackified() {
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();

    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }

    var self = this;

    var cb = function () {
      return maybeCb.apply(self, arguments);
    }; // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)


    original.apply(this, args).then(function (ret) {
      process.nextTick(cb, null, ret);
    }, function (rej) {
      process.nextTick(callbackifyOnRejected, rej, cb);
    });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}

exports.callbackify = callbackify;
},{"./support/isBuffer":"HTeN","inherits":"v3DX","process":"g5IB"}],"vdFv":[function(require,module,exports) {
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var util = require('util');

function ProtocolError(message) {
    Error.call(this);
    this.message = message;
    this.name = 'ProtocolError';
}
util.inherits(ProtocolError, Error);

function TypeError(message) {
    ProtocolError.call(this, message);
    this.message = message;
    this.name = 'TypeError';
}

util.inherits(TypeError, ProtocolError);

function ConnectionError(message, condition, connection) {
    Error.call(this, message);
    this.message = message;
    this.name = 'ConnectionError';
    this.condition = condition;
    this.description = message;
    Object.defineProperty(this, 'connection', { value: connection, enumerable: false });
}

util.inherits(ConnectionError, Error);

ConnectionError.prototype.toJSON = function () {
    return {
        type: this.name,
        code: this.condition,
        message: this.description
    };
};

module.exports = {
    ProtocolError: ProtocolError,
    TypeError: TypeError,
    ConnectionError: ConnectionError
};

},{"util":"nIH4"}],"FRly":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"Quj6":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"aqZJ":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"z1tx":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"FRly","ieee754":"Quj6","isarray":"aqZJ","buffer":"z1tx"}],"AVyJ":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var errors = require('./errors.js');

var util = {};

util.allocate_buffer = function (size) {
    return Buffer.alloc ? Buffer.alloc(size) : new Buffer(size);
};

util.generate_uuid = function () {
    return util.uuid_to_string(util.uuid4());
};

util.uuid4 = function () {
    var bytes = util.allocate_buffer(16);
    for (var i = 0; i < bytes.length; i++) {
        bytes[i] = Math.random()*255|0;
    }

    // From RFC4122, the version bits are set to 0100
    bytes[7] &= 0x0F;
    bytes[7] |= 0x40;

    // From RFC4122, the top two bits of byte 8 get set to 01
    bytes[8] &= 0x3F;
    bytes[8] |= 0x80;

    return bytes;
};


util.uuid_to_string = function (buffer) {
    if (buffer.length === 16) {
        var chunks = [buffer.slice(0, 4), buffer.slice(4, 6), buffer.slice(6, 8), buffer.slice(8, 10), buffer.slice(10, 16)];
        return chunks.map(function (b) { return b.toString('hex'); }).join('-');
    } else {
        throw new errors.TypeError('Not a UUID, expecting 16 byte buffer');
    }
};

var parse_uuid = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/;

util.string_to_uuid = function (uuid_string) {
    var parts = parse_uuid.exec(uuid_string.toLowerCase());
    if (parts) {
        return Buffer.from(parts.slice(1).join(''), 'hex');
    } else {
        throw new errors.TypeError('Not a valid UUID string: ' + uuid_string);
    }
};

util.clone = function (o) {
    var copy = Object.create(o.prototype || {});
    var names = Object.getOwnPropertyNames(o);
    for (var i = 0; i < names.length; i++) {
        var key = names[i];
        copy[key] = o[key];
    }
    return copy;
};

util.and = function (f, g) {
    if (g === undefined) return f;
    return function (o) {
        return f(o) && g(o);
    };
};

util.is_sender = function (o) { return o.is_sender(); };
util.is_receiver = function (o) { return o.is_receiver(); };
util.sender_filter = function (filter) { return util.and(util.is_sender, filter); };
util.receiver_filter = function (filter) { return util.and(util.is_receiver, filter); };

util.is_defined = function (field) {
    return field !== undefined && field !== null;
};

module.exports = util;

},{"./errors.js":"vdFv","buffer":"z1tx"}],"LFdS":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var errors = require('./errors.js');
var util = require('./util.js');

var CAT_FIXED = 1;
var CAT_VARIABLE = 2;
var CAT_COMPOUND = 3;
var CAT_ARRAY = 4;

function Typed(type, value, code, descriptor) {
    this.type = type;
    this.value = value;
    if (code) {
        this.array_constructor = {'typecode':code};
        if (descriptor) {
            this.array_constructor.descriptor = descriptor;
        }
    }
}

Typed.prototype.toString = function() {
    return this.value ? this.value.toString() : null;
};

Typed.prototype.toLocaleString = function() {
    return this.value ? this.value.toLocaleString() : null;
};

Typed.prototype.valueOf = function() {
    return this.value;
};

Typed.prototype.toJSON = function() {
    return this.value && this.value.toJSON ? this.value.toJSON() : this.value;
};

function TypeDesc(name, typecode, props, empty_value) {
    this.name = name;
    this.typecode = typecode;
    var subcategory = typecode >>> 4;
    switch (subcategory) {
    case 0x4:
        this.width = 0;
        this.category = CAT_FIXED;
        break;
    case 0x5:
        this.width = 1;
        this.category = CAT_FIXED;
        break;
    case 0x6:
        this.width = 2;
        this.category = CAT_FIXED;
        break;
    case 0x7:
        this.width = 4;
        this.category = CAT_FIXED;
        break;
    case 0x8:
        this.width = 8;
        this.category = CAT_FIXED;
        break;
    case 0x9:
        this.width = 16;
        this.category = CAT_FIXED;
        break;
    case 0xA:
        this.width = 1;
        this.category = CAT_VARIABLE;
        break;
    case 0xB:
        this.width = 4;
        this.category = CAT_VARIABLE;
        break;
    case 0xC:
        this.width = 1;
        this.category = CAT_COMPOUND;
        break;
    case 0xD:
        this.width = 4;
        this.category = CAT_COMPOUND;
        break;
    case 0xE:
        this.width = 1;
        this.category = CAT_ARRAY;
        break;
    case 0xF:
        this.width = 4;
        this.category = CAT_ARRAY;
        break;
    default:
        //can't happen
        break;
    }

    if (props) {
        if (props.read) {
            this.read = props.read;
        }
        if (props.write) {
            this.write = props.write;
        }
        if (props.encoding) {
            this.encoding = props.encoding;
        }
    }

    var t = this;
    if (subcategory === 0x4) {
        // 'empty' types don't take a value
        this.create = function () {
            return new Typed(t, empty_value);
        };
    } else if (subcategory === 0xE || subcategory === 0xF) {
        this.create = function (v, code, descriptor) {
            return new Typed(t, v, code, descriptor);
        };
    } else {
        this.create = function (v) {
            return new Typed(t, v);
        };
    }
}

TypeDesc.prototype.toString = function () {
    return this.name + '#' + hex(this.typecode);
};

function hex(i) {
    return Number(i).toString(16);
}

var types = {'by_code':{}};
Object.defineProperty(types, 'MAX_UINT', {value: 4294967295, writable: false, configurable: false});
Object.defineProperty(types, 'MAX_USHORT', {value: 65535, writable: false, configurable: false});

function define_type(name, typecode, annotations, empty_value) {
    var t = new TypeDesc(name, typecode, annotations, empty_value);
    t.create.typecode = t.typecode;//hack
    types.by_code[t.typecode] = t;
    types[name] = t.create;
}

function buffer_uint8_ops() {
    return {
        'read': function (buffer, offset) { return buffer.readUInt8(offset); },
        'write': function (buffer, value, offset) { buffer.writeUInt8(value, offset); }
    };
}

function buffer_uint16be_ops() {
    return {
        'read': function (buffer, offset) { return buffer.readUInt16BE(offset); },
        'write': function (buffer, value, offset) { buffer.writeUInt16BE(value, offset); }
    };
}

function buffer_uint32be_ops() {
    return {
        'read': function (buffer, offset) { return buffer.readUInt32BE(offset); },
        'write': function (buffer, value, offset) { buffer.writeUInt32BE(value, offset); }
    };
}

function buffer_int8_ops() {
    return {
        'read': function (buffer, offset) { return buffer.readInt8(offset); },
        'write': function (buffer, value, offset) { buffer.writeInt8(value, offset); }
    };
}

function buffer_int16be_ops() {
    return {
        'read': function (buffer, offset) { return buffer.readInt16BE(offset); },
        'write': function (buffer, value, offset) { buffer.writeInt16BE(value, offset); }
    };
}

function buffer_int32be_ops() {
    return {
        'read': function (buffer, offset) { return buffer.readInt32BE(offset); },
        'write': function (buffer, value, offset) { buffer.writeInt32BE(value, offset); }
    };
}

function buffer_floatbe_ops() {
    return {
        'read': function (buffer, offset) { return buffer.readFloatBE(offset); },
        'write': function (buffer, value, offset) { buffer.writeFloatBE(value, offset); }
    };
}

function buffer_doublebe_ops() {
    return {
        'read': function (buffer, offset) { return buffer.readDoubleBE(offset); },
        'write': function (buffer, value, offset) { buffer.writeDoubleBE(value, offset); }
    };
}

var MAX_UINT = 4294967296; // 2^32
var MIN_INT = -2147483647;
function write_ulong(buffer, value, offset) {
    if ((typeof value) === 'number' || value instanceof Number) {
        var hi = Math.floor(value / MAX_UINT);
        var lo = value % MAX_UINT;
        buffer.writeUInt32BE(hi, offset);
        buffer.writeUInt32BE(lo, offset + 4);
    } else {
        value.copy(buffer, offset);
    }
}

function read_ulong(buffer, offset) {
    var hi = buffer.readUInt32BE(offset);
    var lo = buffer.readUInt32BE(offset + 4);
    if (hi < 2097153) {
        return hi * MAX_UINT + lo;
    } else {
        return buffer.slice(offset, offset + 8);
    }
}

function write_long(buffer, value, offset) {
    if ((typeof value) === 'number' || value instanceof Number) {
        var abs = Math.abs(value);
        var hi = Math.floor(abs / MAX_UINT);
        var lo = abs % MAX_UINT;
        buffer.writeInt32BE(hi, offset);
        buffer.writeUInt32BE(lo, offset + 4);
        if (value < 0) {
            var carry = 1;
            for (var i = 0; i < 8; i++) {
                var index = offset + (7 - i);
                var v = (buffer[index] ^ 0xFF) + carry;
                buffer[index] = v & 0xFF;
                carry = v >> 8;
            }
        }
    } else {
        value.copy(buffer, offset);
    }
}

function read_long(buffer, offset) {
    var hi = buffer.readInt32BE(offset);
    var lo = buffer.readUInt32BE(offset + 4);
    if (hi < 2097153 && hi > -2097153) {
        return hi * MAX_UINT + lo;
    } else {
        return buffer.slice(offset, offset + 8);
    }
}

define_type('Null', 0x40, undefined, null);
define_type('Boolean', 0x56, buffer_uint8_ops());
define_type('True', 0x41, undefined, true);
define_type('False', 0x42, undefined, false);
define_type('Ubyte', 0x50, buffer_uint8_ops());
define_type('Ushort', 0x60, buffer_uint16be_ops());
define_type('Uint', 0x70, buffer_uint32be_ops());
define_type('SmallUint', 0x52, buffer_uint8_ops());
define_type('Uint0', 0x43, undefined, 0);
define_type('Ulong', 0x80, {'write':write_ulong, 'read':read_ulong});
define_type('SmallUlong', 0x53, buffer_uint8_ops());
define_type('Ulong0', 0x44, undefined, 0);
define_type('Byte', 0x51, buffer_int8_ops());
define_type('Short', 0x61, buffer_int16be_ops());
define_type('Int', 0x71, buffer_int32be_ops());
define_type('SmallInt', 0x54, buffer_int8_ops());
define_type('Long', 0x81, {'write':write_long, 'read':read_long});
define_type('SmallLong', 0x55, buffer_int8_ops());
define_type('Float', 0x72, buffer_floatbe_ops());
define_type('Double', 0x82, buffer_doublebe_ops());
define_type('Decimal32', 0x74);
define_type('Decimal64', 0x84);
define_type('Decimal128', 0x94);
define_type('CharUTF32', 0x73, buffer_uint32be_ops());
define_type('Timestamp', 0x83, {'write':write_long, 'read':read_long});//TODO: convert to/from Date
define_type('Uuid', 0x98);//TODO: convert to/from stringified form?
define_type('Vbin8', 0xa0);
define_type('Vbin32', 0xb0);
define_type('Str8', 0xa1, {'encoding':'utf8'});
define_type('Str32', 0xb1, {'encoding':'utf8'});
define_type('Sym8', 0xa3, {'encoding':'ascii'});
define_type('Sym32', 0xb3, {'encoding':'ascii'});
define_type('List0', 0x45, undefined, []);
define_type('List8', 0xc0);
define_type('List32', 0xd0);
define_type('Map8', 0xc1);
define_type('Map32', 0xd1);
define_type('Array8', 0xe0);
define_type('Array32', 0xf0);

function is_one_of(o, typelist) {
    for (var i = 0; i < typelist.length; i++) {
        if (o.type.typecode === typelist[i].typecode) return true;
    }
    return false;
}
function buffer_zero(b, len, neg) {
    for (var i = 0; i < len && i < b.length; i++) {
        if (b[i] !== (neg ? 0xff : 0)) return false;
    }
    return true;
}
types.is_ulong = function(o) {
    return is_one_of(o, [types.Ulong, types.Ulong0, types.SmallUlong]);
};
types.is_string = function(o) {
    return is_one_of(o, [types.Str8, types.Str32]);
};
types.is_symbol = function(o) {
    return is_one_of(o, [types.Sym8, types.Sym32]);
};
types.is_list = function(o) {
    return is_one_of(o, [types.List0, types.List8, types.List32]);
};
types.is_map = function(o) {
    return is_one_of(o, [types.Map8, types.Map32]);
};

types.wrap_boolean = function(v) {
    return v ? types.True() : types.False();
};
types.wrap_ulong = function(l) {
    if (Buffer.isBuffer(l)) {
        if (buffer_zero(l, 8, false)) return types.Ulong0();
        return buffer_zero(l, 7, false) ? types.SmallUlong(l[7]) : types.Ulong(l);
    } else {
        if (l === 0) return types.Ulong0();
        else return l > 255 ? types.Ulong(l) : types.SmallUlong(l);
    }
};
types.wrap_uint = function(l) {
    if (l === 0) return types.Uint0();
    else return l > 255 ? types.Uint(l) : types.SmallUint(l);
};
types.wrap_ushort = function(l) {
    return types.Ushort(l);
};
types.wrap_ubyte = function(l) {
    return types.Ubyte(l);
};
types.wrap_long = function(l) {
    if (Buffer.isBuffer(l)) {
        var negFlag = (l[0] & 0x80) !== 0;
        if (buffer_zero(l, 7, negFlag) && (l[7] & 0x80) === (negFlag ? 0x80 : 0)) {
            return types.SmallLong(negFlag ? -((l[7] ^ 0xff) + 1) : l[7]);
        }
        return types.Long(l);
    } else {
        return l > 127 || l < -128 ? types.Long(l) : types.SmallLong(l);
    }
};
types.wrap_int = function(l) {
    return l > 127 || l < -128 ? types.Int(l) : types.SmallInt(l);
};
types.wrap_short = function(l) {
    return types.Short(l);
};
types.wrap_byte = function(l) {
    return types.Byte(l);
};
types.wrap_float = function(l) {
    return types.Float(l);
};
types.wrap_double = function(l) {
    return types.Double(l);
};
types.wrap_timestamp = function(l) {
    return types.Timestamp(l);
};
types.wrap_char = function(v) {
    return types.CharUTF32(v);
};
types.wrap_uuid = function(v) {
    return types.Uuid(v);
};
types.wrap_binary = function (s) {
    return s.length > 255 ? types.Vbin32(s) : types.Vbin8(s);
};
types.wrap_string = function (s) {
    return Buffer.byteLength(s) > 255 ? types.Str32(s) : types.Str8(s);
};
types.wrap_symbol = function (s) {
    return Buffer.byteLength(s) > 255 ? types.Sym32(s) : types.Sym8(s);
};
types.wrap_list = function(l) {
    if (l.length === 0) return types.List0();
    var items = l.map(types.wrap);
    return types.List32(items);
};
types.wrap_map = function(m, key_wrapper) {
    var items = [];
    for (var k in m) {
        items.push(key_wrapper ? key_wrapper(k) : types.wrap(k));
        items.push(types.wrap(m[k]));
    }
    return types.Map32(items);
};
types.wrap_symbolic_map = function(m) {
    return types.wrap_map(m, types.wrap_symbol);
};
types.wrap_array = function(l, code, descriptors) {
    if (code) {
        return types.Array32(l, code, descriptors);
    } else {
        console.trace('An array must specify a type for its elements');
        throw new errors.TypeError('An array must specify a type for its elements');
    }
};
types.wrap = function(o) {
    var t = typeof o;
    if (t === 'string') {
        return types.wrap_string(o);
    } else if (t === 'boolean') {
        return o ? types.True() : types.False();
    } else if (t === 'number' || o instanceof Number) {
        if (isNaN(o)) {
            return types.Null();
        } else if (Math.floor(o) - o !== 0) {
            return types.Double(o);
        } else if (o > 0) {
            if (o < MAX_UINT) {
                return types.wrap_uint(o);
            } else {
                return types.wrap_ulong(o);
            }
        } else {
            if (o > MIN_INT) {
                return types.wrap_int(o);
            } else {
                return types.wrap_long(o);
            }
        }
    } else if (o instanceof Date) {
        return types.wrap_timestamp(o.getTime());
    } else if (o instanceof Typed) {
        return o;
    } else if (o instanceof Buffer || o instanceof Uint8Array) {
        return types.wrap_binary(o);
    } else if (t === 'undefined' || o === null) {
        return types.Null();
    } else if (Array.isArray(o)) {
        return types.wrap_list(o);
    } else {
        return types.wrap_map(o);
    }
};

types.wrap_described = function(value, descriptor) {
    var result = types.wrap(value);
    if (descriptor) {
        if (typeof descriptor === 'string') {
            result = types.described(types.wrap_symbol(descriptor), result);
        } else if (typeof descriptor === 'number' || descriptor instanceof Number) {
            result = types.described(types.wrap_ulong(descriptor), result);
        }
    }
    return result;
};

types.wrap_message_id = function(o) {
    var t = typeof o;
    if (t === 'string') {
        return types.wrap_string(o);
    } else if (t === 'number' || o instanceof Number) {
        return types.wrap_ulong(o);
    } else if (Buffer.isBuffer(o)) {
        return types.wrap_uuid(o);
    } else {
        //TODO handle uuids
        throw new errors.TypeError('invalid message id:' + o);
    }
};

/**
 * Converts the list of keys and values that comprise an AMQP encoded
 * map into a proper javascript map/object.
 */
function mapify(elements) {
    var result = {};
    for (var i = 0; i+1 < elements.length;) {
        result[elements[i++]] = elements[i++];
    }
    return result;
}

var by_descriptor = {};

types.unwrap_map_simple = function(o) {
    return mapify(o.value.map(function (i) { return types.unwrap(i, true); }));
};

types.unwrap = function(o, leave_described) {
    if (o instanceof Typed) {
        if (o.descriptor) {
            var c = by_descriptor[o.descriptor.value];
            if (c) {
                return new c(o.value);
            } else if (leave_described) {
                return o;
            }
        }
        var u = types.unwrap(o.value, true);
        return types.is_map(o) ? mapify(u) : u;
    } else if (Array.isArray(o)) {
        return o.map(function (i) { return types.unwrap(i, true); });
    } else {
        return o;
    }
};

/*
types.described = function (descriptor, typedvalue) {
    var o = Object.create(typedvalue);
    if (descriptor.length) {
        o.descriptor = descriptor.shift();
        return types.described(descriptor, o);
    } else {
        o.descriptor = descriptor;
        return o;
    }
};
*/
types.described_nc = function (descriptor, o) {
    if (descriptor.length) {
        o.descriptor = descriptor.shift();
        return types.described(descriptor, o);
    } else {
        o.descriptor = descriptor;
        return o;
    }
};
types.described = types.described_nc;

function get_type(code) {
    var type = types.by_code[code];
    if (!type) {
        throw new errors.TypeError('Unrecognised typecode: ' + hex(code));
    }
    return type;
}

types.Reader = function (buffer) {
    this.buffer = buffer;
    this.position = 0;
};

types.Reader.prototype.read_typecode = function () {
    return this.read_uint(1);
};

types.Reader.prototype.read_uint = function (width) {
    var current = this.position;
    this.position += width;
    if (width === 1) {
        return this.buffer.readUInt8(current);
    } else if (width === 2) {
        return this.buffer.readUInt16BE(current);
    } else if (width === 4) {
        return this.buffer.readUInt32BE(current);
    } else {
        throw new errors.TypeError('Unexpected width for uint ' + width);
    }
};

types.Reader.prototype.read_fixed_width = function (type) {
    var current = this.position;
    this.position += type.width;
    if (type.read) {
        return type.read(this.buffer, current);
    } else {
        return this.buffer.slice(current, this.position);
    }
};

types.Reader.prototype.read_variable_width = function (type) {
    var size = this.read_uint(type.width);
    var slice = this.read_bytes(size);
    return type.encoding ? slice.toString(type.encoding) : slice;
};

types.Reader.prototype.read = function () {
    var constructor = this.read_constructor();
    var value = this.read_value(get_type(constructor.typecode));
    return constructor.descriptor ? types.described_nc(constructor.descriptor, value) : value;
};

types.Reader.prototype.read_constructor = function () {
    var code = this.read_typecode();
    if (code === 0x00) {
        var d = [];
        d.push(this.read());
        var c = this.read_constructor();
        while (c.descriptor) {
            d.push(c.descriptor);
            c = this.read_constructor();
        }
        return {'typecode': c.typecode, 'descriptor':  d.length === 1 ? d[0] : d};
    } else {
        return {'typecode': code};
    }
};

types.Reader.prototype.read_value = function (type) {
    if (type.width === 0) {
        return type.create();
    } else if (type.category === CAT_FIXED) {
        return type.create(this.read_fixed_width(type));
    } else if (type.category === CAT_VARIABLE) {
        return type.create(this.read_variable_width(type));
    } else if (type.category === CAT_COMPOUND) {
        return this.read_compound(type);
    } else if (type.category === CAT_ARRAY) {
        return this.read_array(type);
    } else {
        throw new errors.TypeError('Invalid category for type: ' + type);
    }
};

types.Reader.prototype.read_array_items = function (n, type) {
    var items = [];
    while (items.length < n) {
        items.push(this.read_value(type));
    }
    return items;
};

types.Reader.prototype.read_n = function (n) {
    var items = new Array(n);
    for (var i = 0; i < n; i++) {
        items[i] = this.read();
    }
    return items;
};

types.Reader.prototype.read_size_count = function (width) {
    return {'size': this.read_uint(width), 'count': this.read_uint(width)};
};

types.Reader.prototype.read_compound = function (type) {
    var limits = this.read_size_count(type.width);
    return type.create(this.read_n(limits.count));
};

types.Reader.prototype.read_array = function (type) {
    var limits = this.read_size_count(type.width);
    var constructor = this.read_constructor();
    return type.create(this.read_array_items(limits.count, get_type(constructor.typecode)), constructor.typecode, constructor.descriptor);
};

types.Reader.prototype.toString = function () {
    var s = 'buffer@' + this.position;
    if (this.position) s += ': ';
    for (var i = this.position; i < this.buffer.length; i++) {
        if (i > 0) s+= ',';
        s += '0x' + Number(this.buffer[i]).toString(16);
    }
    return s;
};

types.Reader.prototype.reset = function () {
    this.position = 0;
};

types.Reader.prototype.skip = function (bytes) {
    this.position += bytes;
};

types.Reader.prototype.read_bytes = function (bytes) {
    var current = this.position;
    this.position += bytes;
    return this.buffer.slice(current, this.position);
};

types.Reader.prototype.remaining = function () {
    return this.buffer.length - this.position;
};

types.Writer = function (buffer) {
    this.buffer = buffer ? buffer : util.allocate_buffer(1024);
    this.position = 0;
};

types.Writer.prototype.toBuffer = function () {
    return this.buffer.slice(0, this.position);
};

function max(a, b) {
    return a > b ? a : b;
}

types.Writer.prototype.ensure = function (length) {
    if (this.buffer.length < length) {
        var bigger = util.allocate_buffer(max(this.buffer.length*2, length));
        this.buffer.copy(bigger);
        this.buffer = bigger;
    }
};

types.Writer.prototype.write_typecode = function (code) {
    this.write_uint(code, 1);
};

types.Writer.prototype.write_uint = function (value, width) {
    var current = this.position;
    this.ensure(this.position + width);
    this.position += width;
    if (width === 1) {
        return this.buffer.writeUInt8(value, current);
    } else if (width === 2) {
        return this.buffer.writeUInt16BE(value, current);
    } else if (width === 4) {
        return this.buffer.writeUInt32BE(value, current);
    } else {
        throw new errors.TypeError('Unexpected width for uint ' + width);
    }
};


types.Writer.prototype.write_fixed_width = function (type, value) {
    var current = this.position;
    this.ensure(this.position + type.width);
    this.position += type.width;
    if (type.write) {
        type.write(this.buffer, value, current);
    } else if (value.copy) {
        value.copy(this.buffer, current);
    } else {
        throw new errors.TypeError('Cannot handle write for ' + type);
    }
};

types.Writer.prototype.write_variable_width = function (type, value) {
    var source = type.encoding ? Buffer.from(value, type.encoding) : Buffer.from(value);//TODO: avoid creating new buffers
    this.write_uint(source.length, type.width);
    this.write_bytes(source);
};

types.Writer.prototype.write_bytes = function (source) {
    var current = this.position;
    this.ensure(this.position + source.length);
    this.position += source.length;
    source.copy(this.buffer, current);
};

types.Writer.prototype.write_constructor = function (typecode, descriptor) {
    if (descriptor) {
        this.write_typecode(0x00);
        this.write(descriptor);
    }
    this.write_typecode(typecode);
};

types.Writer.prototype.write = function (o) {
    if (o.type === undefined) {
        if (o.described) {
            this.write(o.described());
        } else {
            throw new errors.TypeError('Cannot write ' + JSON.stringify(o));
        }
    } else {
        this.write_constructor(o.type.typecode, o.descriptor);
        this.write_value(o.type, o.value, o.array_constructor);
    }
};

types.Writer.prototype.write_value = function (type, value, constructor/*for arrays only*/) {
    if (type.width === 0) {
        return;//nothing further to do
    } else if (type.category === CAT_FIXED) {
        this.write_fixed_width(type, value);
    } else if (type.category === CAT_VARIABLE) {
        this.write_variable_width(type, value);
    } else if (type.category === CAT_COMPOUND) {
        this.write_compound(type, value);
    } else if (type.category === CAT_ARRAY) {
        this.write_array(type, value, constructor);
    } else {
        throw new errors.TypeError('Invalid category ' + type.category + ' for type: ' + type);
    }
};

types.Writer.prototype.backfill_size = function (width, saved) {
    var gap = this.position - saved;
    this.position = saved;
    this.write_uint(gap - width, width);
    this.position += (gap - width);
};

types.Writer.prototype.write_compound = function (type, value) {
    var saved = this.position;
    this.position += type.width;//skip size field
    this.write_uint(value.length, type.width);//count field
    for (var i = 0; i < value.length; i++) {
        if (value[i] === undefined || value[i] === null) {
            this.write(types.Null());
        } else {
            this.write(value[i]);
        }
    }
    this.backfill_size(type.width, saved);
};

types.Writer.prototype.write_array = function (type, value, constructor) {
    var saved = this.position;
    this.position += type.width;//skip size field
    this.write_uint(value.length, type.width);//count field
    this.write_constructor(constructor.typecode, constructor.descriptor);
    var ctype = get_type(constructor.typecode);
    for (var i = 0; i < value.length; i++) {
        this.write_value(ctype, value[i]);
    }
    this.backfill_size(type.width, saved);
};

types.Writer.prototype.toString = function () {
    var s = 'buffer@' + this.position;
    if (this.position) s += ': ';
    for (var i = 0; i < this.position; i++) {
        if (i > 0) s+= ',';
        s += ('00' + Number(this.buffer[i]).toString(16)).slice(-2);
    }
    return s;
};

types.Writer.prototype.skip = function (bytes) {
    this.ensure(this.position + bytes);
    this.position += bytes;
};

types.Writer.prototype.clear = function () {
    this.buffer.fill(0x00);
    this.position = 0;
};

types.Writer.prototype.remaining = function () {
    return this.buffer.length - this.position;
};


function get_constructor(typename) {
    if (typename === 'symbol') {
        return {typecode:types.Sym8.typecode};
    }
    throw new errors.TypeError('TODO: Array of type ' + typename + ' not yet supported');
}

function wrap_field(definition, instance) {
    if (instance !== undefined && instance !== null) {
        if (Array.isArray(instance)) {
            if (!definition.multiple) {
                throw new errors.TypeError('Field ' + definition.name + ' does not support multiple values, got ' + JSON.stringify(instance));
            }
            var constructor = get_constructor(definition.type);
            return types.wrap_array(instance, constructor.typecode, constructor.descriptor);
        } else if (definition.type === '*') {
            return instance;
        } else {
            var wrapper = types['wrap_' + definition.type];
            if (wrapper) {
                return wrapper(instance);
            } else {
                throw new errors.TypeError('No wrapper for field ' + definition.name + ' of type ' + definition.type);
            }
        }
    } else if (definition.mandatory) {
        throw new errors.TypeError('Field ' + definition.name + ' is mandatory');
    } else {
        return types.Null();
    }
}

function get_accessors(index, field_definition) {
    var getter;
    if (field_definition.type === '*') {
        getter = function() { return this.value[index]; };
    } else {
        getter = function() { return types.unwrap(this.value[index]); };
    }
    var setter = function(o) { this.value[index] = wrap_field(field_definition, o); };
    return {'get': getter, 'set': setter, 'enumerable':true, 'configurable':false};
}

types.define_composite = function(def) {
    var c = function(fields) {
        this.value = fields ? fields : [];
    };
    c.descriptor = {
        numeric: def.code,
        symbolic: 'amqp:' + def.name + ':list'
    };
    c.prototype.dispatch = function (target, frame) {
        target['on_' + def.name](frame);
    };
    //c.prototype.descriptor = c.descriptor.numeric;
    //c.prototype = Object.create(types.List8.prototype);
    for (var i = 0; i < def.fields.length; i++) {
        var f = def.fields[i];
        Object.defineProperty(c.prototype, f.name, get_accessors(i, f));
    }
    c.toString = function() {
        return def.name + '#' + Number(def.code).toString(16);
    };
    c.prototype.toJSON = function() {
        var o = {};
        for (var f in this) {
            if (f !== 'value' && this[f]) {
                o[f] = this[f];
            }
        }
        return o;
    };
    c.create = function(fields) {
        var o = new c;
        for (var f in fields) {
            o[f] = fields[f];
        }
        return o;
    };
    c.prototype.described = function() {
        return types.described_nc(types.wrap_ulong(c.descriptor.numeric), types.wrap_list(this.value));
    };
    return c;
};

function add_type(def) {
    var c = types.define_composite(def);
    types['wrap_' + def.name] = function (fields) {
        return c.create(fields).described();
    };
    by_descriptor[Number(c.descriptor.numeric).toString(10)] = c;
    by_descriptor[c.descriptor.symbolic] = c;
}

add_type({
    name: 'error',
    code: 0x1d,
    fields: [
        {name:'condition', type:'symbol', mandatory:true},
        {name:'description', type:'string'},
        {name:'info', type:'map'}
    ]
});

module.exports = types;

},{"./errors.js":"vdFv","./util.js":"AVyJ","buffer":"z1tx"}],"tWUB":[function(require,module,exports) {
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var types = require('./types.js');
var errors = require('./errors.js');

var frames = {};
var by_descriptor = {};

frames.read_header = function(buffer) {
    var offset = 4;
    var header = {};
    var name = buffer.toString('ascii', 0, offset);
    if (name !== 'AMQP') {
        throw new errors.ProtocolError('Invalid protocol header for AMQP ' + name);
    }
    header.protocol_id = buffer.readUInt8(offset++);
    header.major = buffer.readUInt8(offset++);
    header.minor = buffer.readUInt8(offset++);
    header.revision = buffer.readUInt8(offset++);
    //the protocol header is interpreted in different ways for
    //different versions(!); check some special cases to give clearer
    //error messages:
    if (header.protocol_id === 0 && header.major === 0 && header.minor === 9 && header.revision === 1) {
        throw new errors.ProtocolError('Unsupported AMQP version: 0-9-1');
    }
    if (header.protocol_id === 1 && header.major === 1 && header.minor === 0 && header.revision === 10) {
        throw new errors.ProtocolError('Unsupported AMQP version: 0-10');
    }
    if (header.major !== 1 || header.minor !== 0) {
        throw new errors.ProtocolError('Unsupported AMQP version: ' + JSON.stringify(header));
    }
    return header;
};
frames.write_header = function(buffer, header) {
    var offset = 4;
    buffer.write('AMQP', 0, offset, 'ascii');
    buffer.writeUInt8(header.protocol_id, offset++);
    buffer.writeUInt8(header.major, offset++);
    buffer.writeUInt8(header.minor, offset++);
    buffer.writeUInt8(header.revision, offset++);
    return 8;
};
//todo: define enumeration for frame types
frames.TYPE_AMQP = 0x00;
frames.TYPE_SASL = 0x01;

frames.read_frame = function(buffer) {
    var reader = new types.Reader(buffer);
    var frame = {};
    frame.size = reader.read_uint(4);
    if (reader.remaining < frame.size) {
        return null;
    }
    var doff = reader.read_uint(1);
    if (doff < 2) {
        throw new errors.ProtocolError('Invalid data offset, must be at least 2 was ' + doff);
    }
    frame.type = reader.read_uint(1);
    if (frame.type === frames.TYPE_AMQP) {
        frame.channel = reader.read_uint(2);
    } else if (frame.type === frames.TYPE_SASL) {
        reader.skip(2);
        frame.channel = 0;
    } else {
        throw new errors.ProtocolError('Unknown frame type ' + frame.type);
    }
    if (doff > 1) {
        //ignore any extended header
        reader.skip(doff * 4 - 8);
    }
    if (reader.remaining()) {
        frame.performative = reader.read();
        var c = by_descriptor[frame.performative.descriptor.value];
        if (c) {
            frame.performative = new c(frame.performative.value);
        }
        if (reader.remaining()) {
            frame.payload = reader.read_bytes(reader.remaining());
        }
    }
    return frame;
};

frames.write_frame = function(frame) {
    var writer = new types.Writer();
    writer.skip(4);//skip size until we know how much we have written
    writer.write_uint(2, 1);//doff
    writer.write_uint(frame.type, 1);
    if (frame.type === frames.TYPE_AMQP) {
        writer.write_uint(frame.channel, 2);
    } else if (frame.type === frames.TYPE_SASL) {
        writer.write_uint(0, 2);
    } else {
        throw new errors.ProtocolError('Unknown frame type ' + frame.type);
    }
    if (frame.performative) {
        writer.write(frame.performative);
        if (frame.payload) {
            writer.write_bytes(frame.payload);
        }
    }
    var buffer = writer.toBuffer();
    buffer.writeUInt32BE(buffer.length, 0);//fill in the size
    return buffer;
};

frames.amqp_frame = function(channel, performative, payload) {
    return {'channel': channel || 0, 'type': frames.TYPE_AMQP, 'performative': performative, 'payload': payload};
};
frames.sasl_frame = function(performative) {
    return {'channel': 0, 'type': frames.TYPE_SASL, 'performative': performative};
};

function define_frame(type, def) {
    var c = types.define_composite(def);
    frames[def.name] = c.create;
    by_descriptor[Number(c.descriptor.numeric).toString(10)] = c;
    by_descriptor[c.descriptor.symbolic] = c;
}

var open = {
    name: 'open',
    code: 0x10,
    fields: [
        {name: 'container_id', type: 'string', mandatory: true},
        {name: 'hostname', type: 'string'},
        {name: 'max_frame_size', type: 'uint', default_value: 4294967295},
        {name: 'channel_max', type: 'ushort', default_value: 65535},
        {name: 'idle_time_out', type: 'uint'},
        {name: 'outgoing_locales', type: 'symbol', multiple: true},
        {name: 'incoming_locales', type: 'symbol', multiple: true},
        {name: 'offered_capabilities', type: 'symbol', multiple: true},
        {name: 'desired_capabilities', type: 'symbol', multiple: true},
        {name: 'properties', type: 'symbolic_map'}
    ]
};

var begin = {
    name: 'begin',
    code: 0x11,
    fields:[
        {name: 'remote_channel', type: 'ushort'},
        {name: 'next_outgoing_id', type: 'uint', mandatory: true},
        {name: 'incoming_window', type: 'uint', mandatory: true},
        {name: 'outgoing_window', type: 'uint', mandatory: true},
        {name: 'handle_max', type: 'uint', default_value: '4294967295'},
        {name: 'offered_capabilities', type: 'symbol', multiple: true},
        {name: 'desired_capabilities', type: 'symbol', multiple: true},
        {name: 'properties', type: 'symbolic_map'}
    ]
};

var attach = {
    name: 'attach',
    code: 0x12,
    fields:[
        {name: 'name', type: 'string', mandatory: true},
        {name: 'handle', type: 'uint', mandatory: true},
        {name: 'role', type: 'boolean', mandatory: true},
        {name: 'snd_settle_mode', type: 'ubyte', default_value: 2},
        {name: 'rcv_settle_mode', type: 'ubyte', default_value: 0},
        {name: 'source', type: '*'},
        {name: 'target', type: '*'},
        {name: 'unsettled', type: 'map'},
        {name: 'incomplete_unsettled', type: 'boolean', default_value: false},
        {name: 'initial_delivery_count', type: 'uint'},
        {name: 'max_message_size', type: 'ulong'},
        {name: 'offered_capabilities', type: 'symbol', multiple: true},
        {name: 'desired_capabilities', type: 'symbol', multiple: true},
        {name: 'properties', type: 'symbolic_map'}
    ]
};

var flow = {
    name: 'flow',
    code: 0x13,
    fields:[
        {name: 'next_incoming_id', type: 'uint'},
        {name: 'incoming_window', type: 'uint', mandatory: true},
        {name: 'next_outgoing_id', type: 'uint', mandatory: true},
        {name: 'outgoing_window', type: 'uint', mandatory: true},
        {name: 'handle', type: 'uint'},
        {name: 'delivery_count', type: 'uint'},
        {name: 'link_credit', type: 'uint'},
        {name: 'available', type: 'uint'},
        {name: 'drain', type: 'boolean', default_value: false},
        {name: 'echo', type: 'boolean', default_value: false},
        {name: 'properties', type: 'symbolic_map'}
    ]
};

var transfer = {
    name: 'transfer',
    code: 0x14,
    fields:[
        {name: 'handle', type: 'uint', mandatory: true},
        {name: 'delivery_id', type: 'uint'},
        {name: 'delivery_tag', type: 'binary'},
        {name: 'message_format', type: 'uint'},
        {name: 'settled', type: 'boolean'},
        {name: 'more', type: 'boolean', default_value: false},
        {name: 'rcv_settle_mode', type: 'ubyte'},
        {name: 'state', type: 'delivery_state'},
        {name: 'resume', type: 'boolean', default_value: false},
        {name: 'aborted', type: 'boolean', default_value: false},
        {name: 'batchable', type: 'boolean', default_value: false}
    ]
};

var disposition = {
    name: 'disposition',
    code: 0x15,
    fields:[
        {name: 'role', type: 'boolean', mandatory: true},
        {name: 'first', type: 'uint', mandatory: true},
        {name: 'last', type: 'uint'},
        {name: 'settled', type: 'boolean', default_value: false},
        {name: 'state', type: '*'},
        {name: 'batchable', type: 'boolean', default_value: false}
    ]
};

var detach = {
    name: 'detach',
    code: 0x16,
    fields: [
        {name: 'handle', type: 'uint', mandatory: true},
        {name: 'closed', type: 'boolean', default_value: false},
        {name: 'error', type: 'error'}
    ]
};

var end = {
    name: 'end',
    code: 0x17,
    fields: [
        {name: 'error', type: 'error'}
    ]
};

var close = {
    name: 'close',
    code: 0x18,
    fields: [
        {name: 'error', type: 'error'}
    ]
};

define_frame(frames.TYPE_AMQP, open);
define_frame(frames.TYPE_AMQP, begin);
define_frame(frames.TYPE_AMQP, attach);
define_frame(frames.TYPE_AMQP, flow);
define_frame(frames.TYPE_AMQP, transfer);
define_frame(frames.TYPE_AMQP, disposition);
define_frame(frames.TYPE_AMQP, detach);
define_frame(frames.TYPE_AMQP, end);
define_frame(frames.TYPE_AMQP, close);

var sasl_mechanisms = {
    name: 'sasl_mechanisms',
    code: 0x40,
    fields: [
        {name: 'sasl_server_mechanisms', type: 'symbol', multiple: true, mandatory: true}
    ]
};

var sasl_init = {
    name: 'sasl_init',
    code: 0x41,
    fields: [
        {name: 'mechanism', type: 'symbol', mandatory: true},
        {name: 'initial_response', type: 'binary'},
        {name: 'hostname', type: 'string'}
    ]
};

var sasl_challenge = {
    name: 'sasl_challenge',
    code: 0x42,
    fields: [
        {name: 'challenge', type: 'binary', mandatory: true}
    ]
};

var sasl_response = {
    name: 'sasl_response',
    code: 0x43,
    fields: [
        {name: 'response', type: 'binary', mandatory: true}
    ]
};

var sasl_outcome = {
    name: 'sasl_outcome',
    code: 0x44,
    fields: [
        {name: 'code', type: 'ubyte', mandatory: true},
        {name: 'additional_data', type: 'binary'}
    ]
};

define_frame(frames.TYPE_SASL, sasl_mechanisms);
define_frame(frames.TYPE_SASL, sasl_init);
define_frame(frames.TYPE_SASL, sasl_challenge);
define_frame(frames.TYPE_SASL, sasl_response);
define_frame(frames.TYPE_SASL, sasl_outcome);

module.exports = frames;

},{"./types.js":"LFdS","./errors.js":"vdFv"}],"LVkZ":[function(require,module,exports) {
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],"MTTc":[function(require,module,exports) {
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      // Disabled?
      if (!debug.enabled) {
        return;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":"LVkZ"}],"jD9Y":[function(require,module,exports) {
var process = require("process");
"use strict";

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */


exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console; // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'


  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = undefined;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};
},{"./common":"MTTc","process":"g5IB"}],"G8Vf":[function(require,module,exports) {
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var debug = require('debug');

if (debug.formatters) {
    debug.formatters.h = function (v) {
        return v.toString('hex');
    };
}

module.exports = {
    'config' : debug('rhea:config'),
    'frames' : debug('rhea:frames'),
    'raw' : debug('rhea:raw'),
    'reconnect' : debug('rhea:reconnect'),
    'events' : debug('rhea:events'),
    'message' : debug('rhea:message'),
    'flow' : debug('rhea:flow'),
    'io' : debug('rhea:io')
};

},{"debug":"jD9Y"}],"mq7g":[function(require,module,exports) {
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var errors = require('./errors.js');
var frames = require('./frames.js');
var log = require('./log.js');
var util = require('./util.js');


var Transport = function (identifier, protocol_id, frame_type, handler) {
    this.identifier = identifier;
    this.protocol_id = protocol_id;
    this.frame_type = frame_type;
    this.handler = handler;
    this.pending = [];
    this.header_sent = undefined;
    this.header_received = undefined;
    this.write_complete = false;
    this.read_complete = false;
};

Transport.prototype.has_writes_pending = function () {
    return this.pending.length > 0 || !this.header_sent;
};

Transport.prototype.encode = function (frame) {
    this.pending.push(frame);
};

Transport.prototype.write = function (socket) {
    if (!this.header_sent) {
        var buffer = util.allocate_buffer(8);
        var header = {protocol_id:this.protocol_id, major:1, minor:0, revision:0};
        log.frames('[%s] -> %o', this.identifier, header);
        frames.write_header(buffer, header);
        socket.write(buffer);
        this.header_sent = header;
    }
    for (var i = 0; i < this.pending.length; i++) {
        var frame = this.pending[i];
        var buffer = frames.write_frame(frame);
        socket.write(buffer);
        if (frame.performative) {
            log.frames('[%s]:%s -> %s %j', this.identifier, frame.channel, frame.performative.constructor, frame.performative, frame.payload || '');
        } else {
            log.frames('[%s]:%s -> empty', this.identifier, frame.channel);
        }
        log.raw('[%s] SENT: %d %h', this.identifier, buffer.length, buffer);
    }
    this.pending = [];
};

Transport.prototype.read = function (buffer) {
    var offset = 0;
    if (!this.header_received) {
        if (buffer.length < 8) {
            return offset;
        } else {
            this.header_received = frames.read_header(buffer);
            log.frames('[%s] <- %o', this.identifier, this.header_received);
            if (this.header_received.protocol_id !== this.protocol_id) {
                if (this.protocol_id === 3 && this.header_received.protocol_id === 0) {
                    throw new errors.ProtocolError('Expecting SASL layer');
                } else if (this.protocol_id === 0 && this.header_received.protocol_id === 3) {
                    throw new errors.ProtocolError('SASL layer not enabled');
                } else {
                    throw new errors.ProtocolError('Invalid AMQP protocol id ' + this.header_received.protocol_id + ' expecting: ' + this.protocol_id);
                }
            }
            offset = 8;
        }
    }
    while (offset < (buffer.length - 4) && !this.read_complete) {
        var frame_size = buffer.readUInt32BE(offset);
        log.io('[%s] got frame of size %d', this.identifier, frame_size);
        if (buffer.length < offset + frame_size) {
            log.io('[%s] incomplete frame; have only %d of %d', this.identifier, (buffer.length - offset), frame_size);
            //don't have enough data for a full frame yet
            break;
        } else {
            var slice = buffer.slice(offset, offset + frame_size);
            log.raw('[%s] RECV: %d %h', this.identifier, slice.length, slice);
            var frame = frames.read_frame(slice);
            if (frame.performative) {
                log.frames('[%s]:%s <- %s %j', this.identifier, frame.channel, frame.performative.constructor, frame.performative, frame.payload || '');
            } else {
                log.frames('[%s]:%s <- empty', this.identifier, frame.channel);

            }
            if (frame.type !== this.frame_type) {
                throw new errors.ProtocolError('Invalid frame type: ' + frame.type);
            }
            offset += frame_size;
            if (frame.performative) {
                frame.performative.dispatch(this.handler, frame);
            }
        }
    }
    return offset;
};

module.exports = Transport;

},{"./errors.js":"vdFv","./frames.js":"tWUB","./log.js":"G8Vf","./util.js":"AVyJ"}],"EIGA":[function(require,module,exports) {
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var errors = require('./errors.js');
var frames = require('./frames.js');
var Transport = require('./transport.js');
var util = require('./util.js');

var sasl_codes = {
    'OK':0,
    'AUTH':1,
    'SYS':2,
    'SYS_PERM':3,
    'SYS_TEMP':4,
};

var SASL_PROTOCOL_ID = 0x03;

function extract(buffer) {
    var results = [];
    var start = 0;
    var i = 0;
    while (i < buffer.length) {
        if (buffer[i] === 0x00) {
            if (i > start) results.push(buffer.toString('utf8', start, i));
            else results.push(null);
            start = ++i;
        } else {
            ++i;
        }
    }
    if (i > start) results.push(buffer.toString('utf8', start, i));
    else results.push(null);
    return results;
}

var PlainServer = function(callback) {
    this.callback = callback;
    this.outcome = undefined;
    this.username = undefined;
};

PlainServer.prototype.start = function(response, hostname) {
    var fields = extract(response);
    if (fields.length !== 3) {
        return Promise.reject('Unexpected response in PLAIN, got ' + fields.length + ' fields, expected 3');
    }
    var self = this;
    return Promise.resolve(this.callback(fields[1], fields[2], hostname))
        .then(function (result) {
            if (result) {
                self.outcome = true;
                self.username = fields[1];
            } else {
                self.outcome = false;
            }
        });
};

var PlainClient = function(username, password) {
    this.username = username;
    this.password = password;
};

PlainClient.prototype.start = function(callback) {
    var response = util.allocate_buffer(1 + this.username.length + 1 + this.password.length);
    response.writeUInt8(0, 0);
    response.write(this.username, 1);
    response.writeUInt8(0, 1 + this.username.length);
    response.write(this.password, 1 + this.username.length + 1);
    callback(undefined, response);
};

var AnonymousServer = function() {
    this.outcome = undefined;
    this.username = undefined;
};

AnonymousServer.prototype.start = function(response) {
    this.outcome = true;
    this.username = response ? response.toString('utf8') : 'anonymous';
};

var AnonymousClient = function(name) {
    this.username = name ? name : 'anonymous';
};

AnonymousClient.prototype.start = function(callback) {
    var response = util.allocate_buffer(1 + this.username.length);
    response.writeUInt8(0, 0);
    response.write(this.username, 1);
    callback(undefined, response);
};

var ExternalServer = function() {
    this.outcome = undefined;
    this.username = undefined;
};

ExternalServer.prototype.start = function() {
    this.outcome = true;
};

var ExternalClient = function() {
    this.username = undefined;
};

ExternalClient.prototype.start = function(callback) {
    callback(undefined, '');
};

ExternalClient.prototype.step = function(callback) {
    callback(undefined, '');
};

var XOAuth2Client = function(username, token) {
    this.username = username;
    this.token = token;
};

XOAuth2Client.prototype.start = function(callback) {
    var response = util.allocate_buffer(this.username.length + this.token.length + 5 + 12 + 3);
    var count = 0;
    response.write('user=', count);
    count += 5;
    response.write(this.username, count);
    count += this.username.length;
    response.writeUInt8(1, count);
    count += 1;
    response.write('auth=Bearer ', count);
    count += 12;
    response.write(this.token, count);
    count += this.token.length;
    response.writeUInt8(1, count);
    count += 1;
    response.writeUInt8(1, count);
    count += 1;
    callback(undefined, response);
};

/**
 * The mechanisms argument is a map of mechanism names to factory
 * functions for objects that implement that mechanism.
 */
var SaslServer = function (connection, mechanisms) {
    this.connection = connection;
    this.transport = new Transport(connection.amqp_transport.identifier, SASL_PROTOCOL_ID, frames.TYPE_SASL, this);
    this.next = connection.amqp_transport;
    this.mechanisms = mechanisms;
    this.mechanism = undefined;
    this.outcome = undefined;
    this.username = undefined;
    var mechlist = Object.getOwnPropertyNames(mechanisms);
    this.transport.encode(frames.sasl_frame(frames.sasl_mechanisms({sasl_server_mechanisms:mechlist})));
};

SaslServer.prototype.do_step = function (challenge) {
    if (this.mechanism.outcome === undefined) {
        this.transport.encode(frames.sasl_frame(frames.sasl_challenge({'challenge':challenge})));
        this.connection.output();
    } else {
        this.outcome = this.mechanism.outcome ? sasl_codes.OK : sasl_codes.AUTH;
        var frame = frames.sasl_frame(frames.sasl_outcome({code: this.outcome}));
        this.transport.encode(frame);
        this.connection.output();
        if (this.outcome === sasl_codes.OK) {
            this.username = this.mechanism.username;
            this.transport.write_complete = true;
            this.transport.read_complete = true;
        }
    }
};

SaslServer.prototype.on_sasl_init = function (frame) {
    var saslctor = this.mechanisms[frame.performative.mechanism];
    if (saslctor) {
        this.mechanism = saslctor();
        Promise.resolve(this.mechanism.start(frame.performative.initial_response, frame.performative.hostname))
            .then(this.do_step.bind(this))
            .catch(this.do_fail.bind(this));
    } else {
        this.outcome = sasl_codes.AUTH;
        this.transport.encode(frames.sasl_frame(frames.sasl_outcome({code: this.outcome})));
    }
};

SaslServer.prototype.on_sasl_response = function (frame) {
    Promise.resolve(this.mechanism.step(frame.performative.response))
        .then(this.do_step.bind(this))
        .catch(this.do_fail.bind(this));
};

SaslServer.prototype.do_fail = function (e) {
    var frame = frames.sasl_frame(frames.sasl_outcome({code: sasl_codes.SYS}));
    this.transport.encode(frame);
    this.connection.output();
    try {
        this.connection.sasl_failed('Sasl callback promise failed with ' + e, 'amqp:internal-error');
    } catch (e) {
        console.error('Uncaught error: ', e.message);
    }
};

SaslServer.prototype.has_writes_pending = function () {
    return this.transport.has_writes_pending() || this.next.has_writes_pending();
};

SaslServer.prototype.write = function (socket) {
    if (this.transport.write_complete && this.transport.pending.length === 0) {
        return this.next.write(socket);
    } else {
        return this.transport.write(socket);
    }
};

SaslServer.prototype.read = function (buffer) {
    if (this.transport.read_complete) {
        return this.next.read(buffer);
    } else {
        return this.transport.read(buffer);
    }
};

var SaslClient = function (connection, mechanisms, hostname) {
    this.connection = connection;
    this.transport = new Transport(connection.amqp_transport.identifier, SASL_PROTOCOL_ID, frames.TYPE_SASL, this);
    this.next = connection.amqp_transport;
    this.mechanisms = mechanisms;
    this.mechanism = undefined;
    this.mechanism_name = undefined;
    this.hostname = hostname;
    this.failed = false;
};

SaslClient.prototype.on_sasl_mechanisms = function (frame) {
    var offered_mechanisms = [];
    if (Array.isArray(frame.performative.sasl_server_mechanisms)) {
        offered_mechanisms = frame.performative.sasl_server_mechanisms;
    } else if (frame.performative.sasl_server_mechanisms) {
        offered_mechanisms = [frame.performative.sasl_server_mechanisms];
    }
    for (var i = 0; this.mechanism === undefined && i < offered_mechanisms.length; i++) {
        var mech = offered_mechanisms[i];
        var f = this.mechanisms[mech];
        if (f) {
            this.mechanism = typeof f === 'function' ? f() : f;
            this.mechanism_name = mech;
        }
    }
    if (this.mechanism) {
        var self = this;
        this.mechanism.start(function (err, response) {
            if (err) {
                self.failed = true;
                self.connection.sasl_failed('SASL mechanism init failed: ' + err);
            } else {
                var init = {'mechanism':self.mechanism_name,'initial_response':response};
                if (self.hostname) {
                    init.hostname = self.hostname;
                }
                self.transport.encode(frames.sasl_frame(frames.sasl_init(init)));
                self.connection.output();
            }
        });
    } else {
        this.failed = true;
        this.connection.sasl_failed('No suitable mechanism; server supports ' + frame.performative.sasl_server_mechanisms);
    }
};
SaslClient.prototype.on_sasl_challenge = function (frame) {
    var self = this;
    this.mechanism.step(frame.performative.challenge, function (err, response) {
        if (err) {
            self.failed = true;
            self.connection.sasl_failed('SASL mechanism challenge failed: ' + err);
        } else {
            self.transport.encode(frames.sasl_frame(frames.sasl_response({'response':response})));
            self.connection.output();
        }
    });
};
SaslClient.prototype.on_sasl_outcome = function (frame) {
    switch (frame.performative.code) {
    case sasl_codes.OK:
        this.transport.read_complete = true;
        this.transport.write_complete = true;
        break;
    case sasl_codes.SYS:
    case sasl_codes.SYS_PERM:
    case sasl_codes.SYS_TEMP:
        this.transport.write_complete = true;
        this.connection.sasl_failed('Failed to authenticate: ' + frame.performative.code, 'amqp:internal-error');
        break;
    default:
        this.transport.write_complete = true;
        this.connection.sasl_failed('Failed to authenticate: ' + frame.performative.code);
    }
};

SaslClient.prototype.has_writes_pending = function () {
    return this.transport.has_writes_pending() || this.next.has_writes_pending();
};

SaslClient.prototype.write = function (socket) {
    if (this.transport.write_complete) {
        return this.next.write(socket);
    } else {
        return this.transport.write(socket);
    }
};

SaslClient.prototype.read = function (buffer) {
    if (this.transport.read_complete) {
        return this.next.read(buffer);
    } else {
        return this.transport.read(buffer);
    }
};

var SelectiveServer = function (connection, mechanisms) {
    this.header_received = false;
    this.transports = {
        0: connection.amqp_transport,
        3: new SaslServer(connection, mechanisms)
    };
    this.selected = undefined;
};

SelectiveServer.prototype.has_writes_pending = function () {
    return this.header_received && this.selected.has_writes_pending();
};

SelectiveServer.prototype.write = function (socket) {
    if (this.selected) {
        return this.selected.write(socket);
    } else {
        return 0;
    }
};

SelectiveServer.prototype.read = function (buffer) {
    if (!this.header_received) {
        if (buffer.length < 8) {
            return 0;
        } else {
            this.header_received = frames.read_header(buffer);
            this.selected = this.transports[this.header_received.protocol_id];
            if (this.selected === undefined) {
                throw new errors.ProtocolError('Invalid AMQP protocol id ' + this.header_received.protocol_id);
            }
        }
    }
    return this.selected.read(buffer);
};

var default_server_mechanisms = {
    enable_anonymous: function () {
        this['ANONYMOUS'] = function() { return new AnonymousServer(); };
    },
    enable_plain: function (callback) {
        this['PLAIN'] = function() { return new PlainServer(callback); };
    }
};

var default_client_mechanisms = {
    enable_anonymous: function (name) {
        this['ANONYMOUS'] = function() { return new AnonymousClient(name); };
    },
    enable_plain: function (username, password) {
        this['PLAIN'] = function() { return new PlainClient(username, password); };
    },
    enable_external: function () {
        this['EXTERNAL'] = function() { return new ExternalClient(); };
    },
    enable_xoauth2: function (username, token) {
        if (username && token) {
            this['XOAUTH2'] = function() { return new XOAuth2Client(username, token); };
        } else if (token === undefined) {
            throw Error('token must be specified');
        } else if (username === undefined) {
            throw Error('username must be specified');
        }
    }
};

module.exports = {
    Client : SaslClient,
    Server : SaslServer,
    Selective: SelectiveServer,
    server_mechanisms : function () {
        return Object.create(default_server_mechanisms);
    },
    client_mechanisms : function () {
        return Object.create(default_client_mechanisms);
    },
    server_add_external: function (mechs) {
        mechs['EXTERNAL'] = function() { return new ExternalServer(); };
        return mechs;
    }
};

},{"./errors.js":"vdFv","./frames.js":"tWUB","./transport.js":"mq7g","./util.js":"AVyJ"}],"rwSj":[function(require,module,exports) {
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var EndpointState = function () {
    this.init();
};

EndpointState.prototype.init = function () {
    this.local_open = false;
    this.remote_open = false;
    this.open_requests = 0;
    this.close_requests = 0;
    this.initialised = false;
    this.marker = undefined;
};

EndpointState.prototype.mark = function (o) {
    this.marker = o || Date.now();
    return this.marker;
};

EndpointState.prototype.open = function () {
    this.marker = undefined;
    this.initialised = true;
    if (!this.local_open) {
        this.local_open = true;
        this.open_requests++;
        return true;
    } else {
        return false;
    }
};

EndpointState.prototype.close = function () {
    this.marker = undefined;
    if (this.local_open) {
        this.local_open = false;
        this.close_requests++;
        return true;
    } else {
        return false;
    }
};

EndpointState.prototype.disconnected = function () {
    var was_initialised = this.initialised;
    this.was_open = this.local_open;
    this.init();
    this.initialised = was_initialised;
};

EndpointState.prototype.reconnect = function () {
    if (this.was_open) {
        this.open();
        this.was_open = undefined;
    }
};

EndpointState.prototype.remote_opened = function () {
    if (!this.remote_open) {
        this.remote_open = true;
        return true;
    } else {
        return false;
    }
};

EndpointState.prototype.remote_closed = function () {
    if (this.remote_open) {
        this.remote_open = false;
        return true;
    } else {
        return false;
    }
};

EndpointState.prototype.is_open = function () {
    return this.local_open && this.remote_open;
};

EndpointState.prototype.is_closed = function () {
    return this.initialised && !(this.local_open || this.was_open) && !this.remote_open;
};

EndpointState.prototype.has_settled = function () {
    return this.open_requests === 0 && this.close_requests === 0;
};

EndpointState.prototype.need_open = function () {
    if (this.open_requests > 0) {
        this.open_requests--;
        return true;
    } else {
        return false;
    }
};

EndpointState.prototype.need_close = function () {
    if (this.close_requests > 0) {
        this.close_requests--;
        return true;
    } else {
        return false;
    }
};

module.exports = EndpointState;

},{}],"ZkFW":[function(require,module,exports) {
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var log = require('./log.js');
var types = require('./types.js');

var by_descriptor = {};
var unwrappers = {};
var wrappers = [];
var message = {};

function define_section(descriptor, unwrap, wrap) {
    unwrap.descriptor = descriptor;
    unwrappers[descriptor.symbolic] = unwrap;
    unwrappers[Number(descriptor.numeric).toString(10)] = unwrap;
    if (wrap) {
        wrappers.push(wrap);
    }
}

function define_composite_section(def) {
    var c = types.define_composite(def);
    message[def.name] = c.create;
    by_descriptor[Number(c.descriptor.numeric).toString(10)] = c;
    by_descriptor[c.descriptor.symbolic] = c;

    var unwrap = function (msg, section) {
        var composite = new c(section.value);
        for (var i = 0; i < def.fields.length; i++) {
            var f = def.fields[i];
            var v = composite[f.name];
            if (v !== undefined && v !== null) {
                msg[f.name] = v;
            }
        }
    };

    var wrap = function (sections, msg) {
        sections.push(c.create(msg).described());
    };
    define_section(c.descriptor, unwrap, wrap);
}


function define_map_section(def, symbolic) {
    var wrapper = symbolic ? types.wrap_symbolic_map : types.wrap_map;
    var descriptor = {numeric:def.code};
    descriptor.symbolic = 'amqp:' + def.name.replace(/_/g, '-') + ':map';
    var unwrap = function (msg, section) {
        msg[def.name] = types.unwrap_map_simple(section);
    };
    var wrap = function (sections, msg) {
        if (msg[def.name]) {
            sections.push(types.described_nc(types.wrap_ulong(descriptor.numeric), wrapper(msg[def.name])));
        }
    };
    define_section(descriptor, unwrap, wrap);
}

function Section(typecode, content, multiple) {
    this.typecode = typecode;
    this.content = content;
    this.multiple = multiple;
}

Section.prototype.described = function (item) {
    return types.described(types.wrap_ulong(this.typecode), types.wrap(item || this.content));
};

Section.prototype.collect_sections = function (sections) {
    if (this.multiple) {
        for (var i = 0; i < this.content.length; i++) {
            sections.push(this.described(this.content[i]));
        }
    } else {
        sections.push(this.described());
    }
};

define_composite_section({
    name:'header',
    code:0x70,
    fields:[
        {name:'durable', type:'boolean', default_value:false},
        {name:'priority', type:'ubyte', default_value:4},
        {name:'ttl', type:'uint'},
        {name:'first_acquirer', type:'boolean', default_value:false},
        {name:'delivery_count', type:'uint', default_value:0}
    ]
});
define_map_section({name:'delivery_annotations', code:0x71}, true);
define_map_section({name:'message_annotations', code:0x72}, true);
define_composite_section({
    name:'properties',
    code:0x73,
    fields:[
        {name:'message_id', type:'message_id'},
        {name:'user_id', type:'binary'},
        {name:'to', type:'string'},
        {name:'subject', type:'string'},
        {name:'reply_to', type:'string'},
        {name:'correlation_id', type:'message_id'},
        {name:'content_type', type:'symbol'},
        {name:'content_encoding', type:'symbol'},
        {name:'absolute_expiry_time', type:'timestamp'},
        {name:'creation_time', type:'timestamp'},
        {name:'group_id', type:'string'},
        {name:'group_sequence', type:'uint'},
        {name:'reply_to_group_id', type:'string'}
    ]
});
define_map_section({name:'application_properties', code:0x74});

function unwrap_body_section (msg, section, typecode) {
    if (msg.body === undefined) {
        msg.body = new Section(typecode, types.unwrap(section));
    } else if (msg.body.constructor === Section && msg.body.typecode === typecode) {
        if (msg.body.multiple) {
            msg.body.content.push(types.unwrap(section));
        } else {
            msg.body.multiple = true;
            msg.body.content = [msg.body.content, types.unwrap(section)];
        }
    }
}

define_section({numeric:0x75, symbolic:'amqp:data:binary'}, function (msg, section) { unwrap_body_section(msg, section, 0x75); });
define_section({numeric:0x76, symbolic:'amqp:amqp-sequence:list'}, function (msg, section) { unwrap_body_section(msg, section, 0x76); });
define_section({numeric:0x77, symbolic:'amqp:value:*'}, function (msg, section) { msg.body = types.unwrap(section); });

define_map_section({name:'footer', code:0x78});


function wrap_body (sections, msg) {
    if (msg.body && msg.body.collect_sections) {
        msg.body.collect_sections(sections);
    } else {
        sections.push(types.described(types.wrap_ulong(0x77), types.wrap(msg.body)));
    }
}

wrappers.push(wrap_body);

message.data_section = function (data) {
    return new Section(0x75, data);
};

message.sequence_section = function (list) {
    return new Section(0x76, list);
};

message.data_sections = function (data_elements) {
    return new Section(0x75, data_elements, true);
};

message.sequence_sections = function (lists) {
    return new Section(0x76, lists, true);
};

function copy(src, tgt) {
    for (var k in src) {
        var v = src[k];
        if (typeof v === 'object') {
            copy(v, tgt[k]);
        } else {
            tgt[k] = v;
        }
    }
}

function Message(o) {
    if (o) {
        copy(o, this);
    }
}

Message.prototype.toJSON = function () {
    var o = {};
    for (var key in this) {
        if (typeof this[key] === 'function') continue;
        o[key] = this[key];
    }
    return o;
};

Message.prototype.toString = function () {
    return JSON.stringify(this.toJSON());
};


message.encode = function(msg) {
    var sections = [];
    wrappers.forEach(function (wrapper_fn) { wrapper_fn(sections, msg); });
    var writer = new types.Writer();
    for (var i = 0; i < sections.length; i++) {
        log.message('Encoding section %d of %d: %o', (i+1), sections.length, sections[i]);
        writer.write(sections[i]);
    }
    var data = writer.toBuffer();
    log.message('encoded %d bytes', data.length);
    return data;
};

message.decode = function(buffer) {
    var msg = new Message();
    var reader = new types.Reader(buffer);
    while (reader.remaining()) {
        var s = reader.read();
        log.message('decoding section: %o of type: %o', s, s.descriptor);
        if (s.descriptor) {
            var unwrap = unwrappers[s.descriptor.value];
            if (unwrap) {
                unwrap(msg, s);
            } else {
                console.warn('WARNING: did not recognise message section with descriptor ' + s.descriptor);
            }
        } else {
            console.warn('WARNING: expected described message section got ' + JSON.stringify(s));
        }
    }
    return msg;
};

var outcomes = {};

function define_outcome(def) {
    var c = types.define_composite(def);
    c.composite_type = def.name;
    message[def.name] = c.create;
    outcomes[Number(c.descriptor.numeric).toString(10)] = c;
    outcomes[c.descriptor.symbolic] = c;
    message['is_' + def.name] = function (o) {
        if (o && o.descriptor) {
            var c = outcomes[o.descriptor.value];
            if (c) {
                return c.descriptor.numeric === def.code;
            }
        }
        return false;
    };
}

message.unwrap_outcome = function (outcome) {
    if (outcome && outcome.descriptor) {
        var c = outcomes[outcome.descriptor.value];
        if (c) {
            return new c(outcome.value);
        }
    }
    console.error('unrecognised outcome: ' + JSON.stringify(outcome));
    return outcome;
};

message.are_outcomes_equivalent = function(a, b) {
    if (a === undefined && b === undefined) return true;
    else if (a === undefined || b === undefined) return false;
    else return a.descriptor.value === b.descriptor.value && a.descriptor.value === 0x24;//only batch accepted
};

define_outcome({
    name:'received',
    code:0x23,
    fields:[
        {name:'section_number', type:'uint', mandatory:true},
        {name:'section_offset', type:'ulong', mandatory:true}
    ]});
define_outcome({name:'accepted', code:0x24, fields:[]});
define_outcome({name:'rejected', code:0x25, fields:[{name:'error', type:'error'}]});
define_outcome({name:'released', code:0x26, fields:[]});
define_outcome({
    name:'modified',
    code:0x27,
    fields:[
        {name:'delivery_failed', type:'boolean'},
        {name:'undeliverable_here', type:'boolean'},
        {name:'message_annotations', type:'map'}
    ]});

module.exports = message;

},{"./log.js":"G8Vf","./types.js":"LFdS"}],"z411":[function(require,module,exports) {
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var types = require('./types.js');

var terminus = {};
var by_descriptor = {};

function define_terminus(def) {
    var c = types.define_composite(def);
    terminus[def.name] = c.create;
    by_descriptor[Number(c.descriptor.numeric).toString(10)] = c;
    by_descriptor[c.descriptor.symbolic] = c;
}

terminus.unwrap = function(field) {
    if (field && field.descriptor) {
        var c = by_descriptor[field.descriptor.value];
        if (c) {
            return new c(field.value);
        } else {
            console.warn('Unknown terminus: ' + field.descriptor);
        }
    }
    return null;
};

define_terminus({
    name: 'source',
    code: 0x28,
    fields: [
        {name: 'address', type: 'string'},
        {name: 'durable', type: 'uint', default_value: 0},
        {name: 'expiry_policy', type: 'symbol', default_value: 'session-end'},
        {name: 'timeout', type: 'uint', default_value: 0},
        {name: 'dynamic', type: 'boolean', default_value: false},
        {name: 'dynamic_node_properties', type: 'symbolic_map'},
        {name: 'distribution_mode', type: 'symbol'},
        {name: 'filter', type: 'symbolic_map'},
        {name: 'default_outcome', type: '*'},
        {name: 'outcomes', type: 'symbol', multiple: true},
        {name: 'capabilities', type: 'symbol', multiple: true}
    ]
});

define_terminus({
    name: 'target',
    code: 0x29,
    fields: [
        {name: 'address', type: 'string'},
        {name: 'durable', type: 'uint', default_value: 0},
        {name: 'expiry_policy', type: 'symbol', default_value: 'session-end'},
        {name: 'timeout', type: 'uint', default_value: 0},
        {name: 'dynamic', type: 'boolean', default_value: false},
        {name: 'dynamic_node_properties', type: 'symbolic_map'},
        {name: 'capabilities', type: 'symbol', multiple: true}
    ]
});

module.exports = terminus;

},{"./types.js":"LFdS"}],"wIHY":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    var errorListener; // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.

    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}
},{}],"R3KQ":[function(require,module,exports) {
var process = require("process");
var Buffer = require("buffer").Buffer;
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var frames = require('./frames.js');
var log = require('./log.js');
var message = require('./message.js');
var terminus = require('./terminus.js');
var EndpointState = require('./endpoint.js');

var FlowController = function (window) {
    this.window = window;
};
FlowController.prototype.update = function (context) {
    var delta = this.window - context.receiver.credit;
    if (delta >= (this.window/4)) {
        context.receiver.flow(delta);
    }
};

function auto_settle(context) {
    context.delivery.settled = true;
}

function auto_accept(context) {
    context.delivery.update(undefined, message.accepted().described());
}

function LinkError(message, condition, link) {
    Error.call(this);
    Error.captureStackTrace(this, this.constructor);
    this.message = message;
    this.condition = condition;
    this.description = message;
    this.link = link;
}
require('util').inherits(LinkError, Error);

var EventEmitter = require('events').EventEmitter;

var link = Object.create(EventEmitter.prototype);
link.dispatch = function(name) {
    log.events('[%s] Link got event: %s', this.connection.options.id, name);
    EventEmitter.prototype.emit.apply(this.observers, arguments);
    if (this.listeners(name).length) {
        EventEmitter.prototype.emit.apply(this, arguments);
        return true;
    } else {
        return this.session.dispatch.apply(this.session, arguments);
    }
};
link.set_source = function (fields) {
    this.local.attach.source = terminus.source(fields).described();
};
link.set_target = function (fields) {
    this.local.attach.target = terminus.target(fields).described();
};

link.attach = function () {
    if (this.state.open()) {
        this.connection._register();
    }
};
link.open = link.attach;

link.detach = function () {
    this.local.detach.closed = false;
    if (this.state.close()) {
        this.connection._register();
    }
};
link.close = function(error) {
    if (error) this.local.detach.error = error;
    this.local.detach.closed = true;
    if (this.state.close()) {
        this.connection._register();
    }
};

/**
 * This forcibly removes the link from the parent session. It should
 * not be called for a link on an active session/connection, where
 * close() should be used instead.
 */
link.remove = function() {
    this.session.remove_link(this);
};

link.is_open = function () {
    return this.session.is_open() && this.state.is_open();
};

link.is_remote_open = function () {
    return this.session.is_remote_open() && this.state.remote_open;
};

link.is_itself_closed = function() {
    return this.state.is_closed();
};

link.is_closed = function () {
    return this.session.is_closed() || this.is_itself_closed();
};

link._process = function () {
    do {
        if (this.state.need_open()) {
            this.session.output(this.local.attach);
        }

        if (this.issue_flow && this.state.local_open) {
            this.session._write_flow(this);
            this.issue_flow = false;
        }

        if (this.state.need_close()) {
            this.session.output(this.local.detach);
        }
    } while (!this.state.has_settled());
};

link.on_attach = function (frame) {
    if (this.state.remote_opened()) {
        if (!this.remote.handle) {
            this.remote.handle = frame.handle;
        }
        frame.performative.source = terminus.unwrap(frame.performative.source);
        frame.performative.target = terminus.unwrap(frame.performative.target);
        this.remote.attach = frame.performative;
        this.open();
        this.dispatch(this.is_receiver() ? 'receiver_open' : 'sender_open', this._context());
    } else {
        throw Error('Attach already received');
    }
};

link.prefix_event = function (event) {
    return (this.local.attach.role ? 'receiver_' : 'sender_') + event;
};

link.on_detach = function (frame) {
    if (this.state.remote_closed()) {
        if (this._incomplete) {
            this._incomplete.settled = true;
        }
        this.remote.detach = frame.performative;
        var error = this.remote.detach.error;
        if (error) {
            var handled = this.dispatch(this.prefix_event('error'), this._context());
            handled = this.dispatch(this.prefix_event('close'), this._context()) || handled;
            if (!handled) {
                EventEmitter.prototype.emit.call(this.connection.container, 'error', new LinkError(error.description, error.condition, this));
            }
        } else {
            this.dispatch(this.prefix_event('close'), this._context());
        }
        var self = this;
        var token = this.state.mark();
        process.nextTick(function () {
            if (self.state.marker === token) {
                self.close();
                process.nextTick(function () { self.remove(); });
            }
        });
    } else {
        throw Error('Detach already received');
    }
};

function is_internal(name) {
    switch (name) {
    case 'name':
    case 'handle':
    case 'role':
    case 'initial_delivery_count':
        return true;
    default:
        return false;
    }
}


var aliases = [
    'snd_settle_mode',
    'rcv_settle_mode',
    'source',
    'target',
    'max_message_size',
    'offered_capabilities',
    'desired_capabilities',
    'properties'
];

function remote_property_shortcut(name) {
    return function() { return this.remote.attach ? this.remote.attach[name] : undefined; };
}

link.init = function (session, name, local_handle, opts, is_receiver) {
    this.session = session;
    this.connection = session.connection;
    this.name = name;
    this.options = opts === undefined ? {} : opts;
    this.state = new EndpointState();
    this.issue_flow = false;
    this.local = {'handle': local_handle};
    this.local.attach = frames.attach({'handle':local_handle,'name':name, role:is_receiver});
    for (var field in this.local.attach) {
        if (!is_internal(field) && this.options[field] !== undefined) {
            this.local.attach[field] = this.options[field];
        }
    }
    this.local.detach = frames.detach({'handle':local_handle, 'closed':true});
    this.remote = {'handle':undefined};
    this.delivery_count = 0;
    this.credit = 0;
    this.observers = new EventEmitter();
    var self = this;
    aliases.forEach(function (alias) { Object.defineProperty(self, alias, { get: remote_property_shortcut(alias) }); });
    Object.defineProperty(this, 'error', { get:  function() { return this.remote.detach ? this.remote.detach.error : undefined; }});
};

link._disconnect = function() {
    this.state.disconnected();
    if (!this.state.was_open) {
        this.remove();
    }
};

link._reconnect = function() {
    this.state.reconnect();
    this.remote = {'handle':undefined};
    this.delivery_count = 0;
    this.credit = 0;
};

link.has_credit = function () {
    return this.credit > 0;
};
link.is_receiver = function () {
    return this.local.attach.role;
};
link.is_sender = function () {
    return !this.is_receiver();
};
link._context = function (c) {
    var context = c ? c : {};
    if (this.is_receiver()) {
        context.receiver = this;
    } else {
        context.sender = this;
    }
    return this.session._context(context);
};
link.get_option = function (name, default_value) {
    if (this.options[name] !== undefined) return this.options[name];
    else return this.session.get_option(name, default_value);
};

var Sender = function (session, name, local_handle, opts) {
    this.init(session, name, local_handle, opts, false);
    this._draining = false;
    this._drained = false;
    this.local.attach.initial_delivery_count = 0;
    this.tag = 0;
    if (this.get_option('autosettle', true)) {
        this.observers.on('settled', auto_settle);
    }
    var sender = this;
    if (this.get_option('treat_modified_as_released', true)) {
        this.observers.on('modified', function (context) {
            sender.dispatch('released', context);
        });
    }
};
Sender.prototype = Object.create(link);
Sender.prototype.constructor = Sender;
Sender.prototype._get_drain = function () {
    if (this._draining && this._drained && this.credit) {
        while (this.credit) {
            ++this.delivery_count;
            --this.credit;
        }
        return true;
    } else {
        return false;
    }
};
Sender.prototype.set_drained = function (drained) {
    this._drained = drained;
    if (this._draining && this._drained) {
        this.issue_flow = true;
    }
};
Sender.prototype.next_tag = function () {
    return Buffer.from(new String(this.tag++));
};
Sender.prototype.sendable = function () {
    return Boolean(this.credit && this.session.outgoing.available());
};
Sender.prototype.on_flow = function (frame) {
    var flow = frame.performative;
    this.credit = flow.delivery_count + flow.link_credit - this.delivery_count;
    this._draining = flow.drain;
    this._drained = this.credit > 0;
    if (this.is_open()) {
        this.dispatch('sender_flow', this._context());
        if (this._draining) {
            this.dispatch('sender_draining', this._context());
        }
        if (this.sendable()) {
            this.dispatch('sendable', this._context());
        }
    }
};
Sender.prototype.on_transfer = function () {
    throw Error('got transfer on sending link');
};

Sender.prototype.send = function (msg, tag, format) {
    var payload = format === undefined ? message.encode(msg) : msg;
    var delivery = this.session.send(this, tag ? tag : this.next_tag(), payload, format);
    if (this.local.attach.snd_settle_mode === 1) {
        delivery.settled = true;
    }
    return delivery;
};

var Receiver = function (session, name, local_handle, opts) {
    this.init(session, name, local_handle, opts, true);
    this.drain = false;
    this.set_credit_window(this.get_option('credit_window', 1000));
    if (this.get_option('autoaccept', true)) {
        this.observers.on('message', auto_accept);
    }
    if (this.local.attach.rcv_settle_mode === 1 && this.get_option('autosettle', true)) {
        this.observers.on('settled', auto_settle);
    }
};
Receiver.prototype = Object.create(link);
Receiver.prototype.constructor = Receiver;
Receiver.prototype.on_flow = function (frame) {
    this.dispatch('receiver_flow', this._context());
    if (frame.performative.drain) {
        this.credit = frame.performative.link_credit;
        this.delivery_count = frame.performative.delivery_count;
        if (frame.performative.link_credit > 0) console.error('ERROR: received flow with drain set, but non zero credit');
        else this.dispatch('receiver_drained', this._context());
    }
};
Receiver.prototype.flow = function(credit) {
    if (credit > 0) {
        this.credit += credit;
        this.issue_flow = true;
        this.connection._register();
    }
};
Receiver.prototype.add_credit = Receiver.prototype.flow;//alias
Receiver.prototype._get_drain = function () {
    return this.drain;
};

Receiver.prototype.set_credit_window = function(credit_window) {
    if (credit_window > 0) {
        var flow_controller = new FlowController(credit_window);
        var listener = flow_controller.update.bind(flow_controller);
        this.observers.on('message', listener);
        this.observers.on('receiver_open', listener);
    }
};

module.exports = {'Sender': Sender, 'Receiver':Receiver};

},{"./frames.js":"tWUB","./log.js":"G8Vf","./message.js":"ZkFW","./terminus.js":"z411","./endpoint.js":"rwSj","util":"nIH4","events":"wIHY","process":"g5IB","buffer":"z1tx"}],"zdAo":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var process = require("process");
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var frames = require('./frames.js');
var link = require('./link.js');
var log = require('./log.js');
var message = require('./message.js');
var types = require('./types.js');
var util = require('./util.js');
var EndpointState = require('./endpoint.js');

var EventEmitter = require('events').EventEmitter;

function SessionError(message, condition, session) {
    Error.call(this);
    Error.captureStackTrace(this, this.constructor);
    this.message = message;
    this.condition = condition;
    this.description = message;
    this.session = session;
}
require('util').inherits(SessionError, Error);

var CircularBuffer = function (capacity) {
    this.capacity = capacity;
    this.size = 0;
    this.head = 0;
    this.tail = 0;
    this.entries = [];
};

CircularBuffer.prototype.available = function () {
    return this.capacity - this.size;
};

CircularBuffer.prototype.push = function (o) {
    if (this.size < this.capacity) {
        this.entries[this.tail] = o;
        this.tail = (this.tail + 1) % this.capacity;
        this.size++;
    } else {
        throw Error('circular buffer overflow: head=' + this.head + ' tail=' + this.tail + ' size=' + this.size + ' capacity=' + this.capacity);
    }
};

CircularBuffer.prototype.pop_if = function (f) {
    var count = 0;
    while (this.size && f(this.entries[this.head])) {
        this.entries[this.head] = undefined;
        this.head = (this.head + 1) % this.capacity;
        this.size--;
        count++;
    }
    return count;
};

CircularBuffer.prototype.by_id = function (id) {
    if (this.size > 0) {
        var gap = id - this.entries[this.head].id;
        if (gap < this.size) {
            return this.entries[(this.head + gap) % this.capacity];
        }
    }
    return undefined;
};

CircularBuffer.prototype.get_head = function () {
    return this.size > 0 ? this.entries[this.head] : undefined;
};

CircularBuffer.prototype.get_tail = function () {
    return this.size > 0 ? this.entries[(this.head + this.size - 1) % this.capacity] : undefined;
};

function write_dispositions(deliveries) {
    var first, last, next_id, i, delivery;

    for (i = 0; i < deliveries.length; i++) {
        delivery = deliveries[i];
        if (first === undefined) {
            first = delivery;
            last = delivery;
            next_id = delivery.id;
        }

        if ((first !== last && !message.are_outcomes_equivalent(last.state, delivery.state)) || last.settled !== delivery.settled || next_id !== delivery.id) {
            first.link.session.output(frames.disposition({'role' : first.link.is_receiver(), 'first' : first.id, 'last' : last.id, 'state' : first.state, 'settled' : first.settled}));
            first = delivery;
            last = delivery;
            next_id = delivery.id;
        } else {
            if (last.id !== delivery.id) {
                last = delivery;
            }
            next_id++;
        }
    }
    if (first !== undefined && last !== undefined) {
        first.link.session.output(frames.disposition({'role' : first.link.is_receiver(), 'first' : first.id, 'last' : last.id, 'state' : first.state, 'settled' : first.settled}));
    }
}

var Outgoing = function (connection) {
    /* TODO: make size configurable? */
    this.deliveries = new CircularBuffer(2048);
    this.updated = [];
    this.pending_dispositions = [];
    this.next_delivery_id = 0;
    this.next_pending_delivery = 0;
    this.next_transfer_id = 0;
    this.window = types.MAX_UINT;
    this.remote_next_transfer_id = undefined;
    this.remote_window = undefined;
    this.connection = connection;
};

Outgoing.prototype.available = function () {
    return this.deliveries.available();
};

Outgoing.prototype.compute_max_payload = function (tag) {
    if (this.connection.max_frame_size) {
        return this.connection.max_frame_size - (50 + tag.length);
    } else {
        return undefined;
    }
};

Outgoing.prototype.send = function (sender, tag, data, format) {
    var fragments = [];
    var max_payload = this.compute_max_payload(tag);
    if (max_payload && data.length > max_payload) {
        var start = 0;
        while (start < data.length) {
            var end = Math.min(start + max_payload, data.length);
            fragments.push(data.slice(start, end));
            start = end;
        }
    } else {
        fragments.push(data);
    }
    var d = {
        'id':this.next_delivery_id++,
        'tag':tag,
        'link':sender,
        'data': fragments,
        'format':format ? format : 0,
        'sent': false,
        'settled': false,
        'state': undefined,
        'remote_settled': false,
        'remote_state': undefined
    };
    var self = this;
    d.update = function (settled, state) {
        self.update(d, settled, state);
    };
    this.deliveries.push(d);
    return d;
};

Outgoing.prototype.on_begin = function (fields) {
    this.remote_window = fields.incoming_window;
};

Outgoing.prototype.on_flow = function (fields) {
    this.remote_next_transfer_id = fields.next_incoming_id;
    this.remote_window = fields.incoming_window;
};

Outgoing.prototype.on_disposition = function (fields) {
    var last = fields.last ? fields.last : fields.first;
    for (var i = fields.first; i <= last; i++) {
        var d = this.deliveries.by_id(i);
        if (d && !d.remote_settled) {
            var updated = false;
            if (fields.settled) {
                d.remote_settled = fields.settled;
                updated = true;
            }
            if (fields.state && fields.state !== d.remote_state) {
                d.remote_state = message.unwrap_outcome(fields.state);
                updated = true;
            }
            if (updated) {
                this.updated.push(d);
            }
        }
    }
};

Outgoing.prototype.update = function (delivery, settled, state) {
    if (delivery) {
        delivery.settled = settled;
        if (state !== undefined) delivery.state = state;
        if (!delivery.remote_settled) {
            this.pending_dispositions.push(delivery);
        }
        delivery.link.connection._register();
    }
};

Outgoing.prototype.transfer_window = function() {
    if (this.remote_window) {
        return this.remote_window - (this.next_transfer_id - this.remote_next_transfer_id);
    } else {
        return 0;
    }
};

Outgoing.prototype.process = function() {
    var d;
    // send pending deliveries for which there is credit:
    while (this.next_pending_delivery < this.next_delivery_id) {
        d = this.deliveries.by_id(this.next_pending_delivery);
        if (d) {
            if (d.link.has_credit()) {
                if (this.transfer_window() >= d.data.length) {
                    this.window -= d.data.length;
                    for (var i = 0; i < d.data.length; i++) {
                        this.next_transfer_id++;
                        var more = (i+1) < d.data.length;
                        var transfer = frames.transfer({'handle':d.link.local.handle,'message_format':d.format,'delivery_id':d.id, 'delivery_tag':d.tag, 'settled':d.settled, 'more':more});
                        d.link.session.output(transfer, d.data[i]);
                        if (d.settled) {
                            d.remote_settled = true;//if sending presettled, it can now be cleaned up
                        }
                    }
                    d.link.credit--;
                    d.link.delivery_count++;
                    this.next_pending_delivery++;
                } else {
                    log.flow('[%s] Incoming window of peer preventing sending further transfers: remote_window=%d, remote_next_transfer_id=%d, next_transfer_id=%d',
                        this.connection.options.id, this.remote_window, this.remote_next_transfer_id, this.next_transfer_id);
                    break;
                }
            } else {
                log.flow('[%s] Link has no credit', this.connection.options.id);
                break;
            }
        } else {
            console.error('ERROR: Next pending delivery not found: ' + this.next_pending_delivery);
            break;
        }
    }

    // notify application of any updated deliveries:
    for (var i = 0; i < this.updated.length; i++) {
        d = this.updated[i];
        if (d.remote_state && d.remote_state.constructor.composite_type) {
            d.link.dispatch(d.remote_state.constructor.composite_type, d.link._context({'delivery':d}));
        }
        if (d.remote_settled) d.link.dispatch('settled', d.link._context({'delivery':d}));
    }
    this.updated = [];

    if (this.pending_dispositions.length) {
        write_dispositions(this.pending_dispositions);
        this.pending_dispositions = [];
    }

    // remove any fully settled deliveries:
    this.deliveries.pop_if(function (d) { return d.settled && d.remote_settled; });
};

var Incoming = function () {
    this.deliveries = new CircularBuffer(2048/*TODO: configurable?*/);
    this.updated = [];
    this.next_transfer_id = 0;
    this.next_delivery_id = undefined;
    Object.defineProperty(this, 'window', { get: function () { return this.deliveries.available(); } });
    this.remote_next_transfer_id = undefined;
    this.remote_window = undefined;
    this.max_transfer_id = this.next_transfer_id + this.window;
};

Incoming.prototype.update = function (delivery, settled, state) {
    if (delivery) {
        delivery.settled = settled;
        if (state !== undefined) delivery.state = state;
        if (!delivery.remote_settled) {
            this.updated.push(delivery);
        }
        delivery.link.connection._register();
    }
};

Incoming.prototype.on_transfer = function(frame, receiver) {
    this.next_transfer_id++;
    if (receiver.is_remote_open()) {
        if (this.next_delivery_id === undefined) {
            this.next_delivery_id = frame.performative.delivery_id;
        }
        var current;
        var data;
        if (receiver._incomplete) {
            current = receiver._incomplete;
            if (util.is_defined(frame.performative.delivery_id) && current.id !== frame.performative.delivery_id) {
                throw Error('frame sequence error: delivery ' + current.id + ' not complete, got ' + frame.performative.delivery_id);
            }
            data = Buffer.concat([current.data, frame.payload], current.data.length + frame.payload.length);
        } else if (this.next_delivery_id === frame.performative.delivery_id) {
            current = {'id':frame.performative.delivery_id,
                'tag':frame.performative.delivery_tag,
                'format':frame.performative.message_format,
                'link':receiver,
                'settled': false,
                'state': undefined,
                'remote_settled': frame.performative.settled === undefined ? false : frame.performative.settled,
                'remote_state': frame.performative.state};
            var self = this;
            current.update = function (settled, state) {
                var settled_ = settled;
                if (settled_ === undefined) {
                    settled_ = receiver.local.attach.rcv_settle_mode !== 1;
                }
                self.update(current, settled_, state);
            };
            current.accept = function () { this.update(undefined, message.accepted().described()); };
            current.release = function (params) {
                if (params) {
                    this.update(undefined, message.modified(params).described());
                } else {
                    this.update(undefined, message.released().described());
                }
            };
            current.reject = function (error) { this.update(undefined, message.rejected({'error':error}).described()); };
            current.modified = function (params) { this.update(undefined, message.modified(params).described()); };

            this.deliveries.push(current);
            this.next_delivery_id++;
            data = frame.payload;
        } else {
            //TODO: better error handling
            throw Error('frame sequence error: expected ' + this.next_delivery_id + ', got ' + frame.performative.delivery_id);
        }
        current.incomplete = frame.performative.more;
        if (current.incomplete) {
            receiver._incomplete = current;
            current.data = data;
        } else {
            receiver._incomplete = undefined;
            if (receiver.credit > 0) receiver.credit--;
            else console.error('Received transfer when credit was %d', receiver.credit);
            receiver.delivery_count++;
            var msgctxt = current.format === 0 ? {'message':message.decode(data), 'delivery':current} : {'message':data, 'delivery':current, 'format':current.format};
            receiver.dispatch('message', receiver._context(msgctxt));
        }
    } else {
        throw Error('transfer after detach');
    }
};

Incoming.prototype.process = function (session) {
    if (this.updated.length > 0) {
        write_dispositions(this.updated);
        this.updated = [];
    }

    // remove any fully settled deliveries:
    this.deliveries.pop_if(function (d) { return d.settled; });

    if (this.max_transfer_id - this.next_transfer_id < (this.window / 2)) {
        session._write_flow();
    }
};

Incoming.prototype.on_begin = function (fields) {
    this.remote_window = fields.outgoing_window;
    this.remote_next_transfer_id = fields.next_outgoing_id;
};

Incoming.prototype.on_flow = function (fields) {
    this.remote_next_transfer_id = fields.next_outgoing_id;
    this.remote_window = fields.outgoing_window;
};

Incoming.prototype.on_disposition = function (fields) {
    var last = fields.last ? fields.last : fields.first;
    for (var i = fields.first; i <= last; i++) {
        var d = this.deliveries.by_id(i);
        if (d && !d.remote_settled) {
            if (fields.state && fields.state !== d.remote_state) {
                d.remote_state = message.unwrap_outcome(fields.state);
            }
            if (fields.settled) {
                d.remote_settled = fields.settled;
                d.link.dispatch('settled', d.link._context({'delivery':d}));
            }
        }
    }
};

var Session = function (connection, local_channel) {
    this.connection = connection;
    this.outgoing = new Outgoing(connection);
    this.incoming = new Incoming();
    this.state = new EndpointState();
    this.local = {'channel': local_channel, 'handles':{}};
    this.local.begin = frames.begin({next_outgoing_id:this.outgoing.next_transfer_id,incoming_window:this.incoming.window,outgoing_window:this.outgoing.window});
    this.local.end = frames.end();
    this.remote = {'handles':{}};
    this.links = {}; // map by name
    this.options = {};
    Object.defineProperty(this, 'error', { get:  function() { return this.remote.end ? this.remote.end.error : undefined; }});
    this.observers = new EventEmitter();
};
Session.prototype = Object.create(EventEmitter.prototype);
Session.prototype.constructor = Session;

Session.prototype._disconnect = function() {
    this.state.disconnected();
    for (var l in this.links) {
        this.links[l]._disconnect();
    }
    if (!this.state.was_open) {
        this.remove();
    }
};

Session.prototype._reconnect = function() {
    this.state.reconnect();
    this.outgoing = new Outgoing(this.connection);
    this.incoming = new Incoming();
    this.remote = {'handles':{}};
    for (var l in this.links) {
        this.links[l]._reconnect();
    }
};

Session.prototype.dispatch = function(name) {
    log.events('[%s] Session got event: %s', this.connection.options.id, name);
    EventEmitter.prototype.emit.apply(this.observers, arguments);
    if (this.listeners(name).length) {
        EventEmitter.prototype.emit.apply(this, arguments);
        return true;
    } else {
        return this.connection.dispatch.apply(this.connection, arguments);
    }
};
Session.prototype.output = function (frame, payload) {
    this.connection._write_frame(this.local.channel, frame, payload);
};

Session.prototype.create_sender = function (name, opts) {
    if (!opts) {
        opts = this.get_option('sender_options', {});
    }
    return this.create_link(name, link.Sender, opts);
};

Session.prototype.create_receiver = function (name, opts) {
    if (!opts) {
        opts = this.get_option('receiver_options', {});
    }
    return this.create_link(name, link.Receiver, opts);
};

function merge(defaults, specific) {
    for (var f in specific) {
        if (f === 'properties' && defaults.properties) {
            merge(defaults.properties, specific.properties);
        } else {
            defaults[f] = specific[f];
        }
    }
}

function attach(factory, args, remote_terminus, default_args) {
    var opts = Object.create(default_args || {});
    if (typeof args === 'string') {
        opts[remote_terminus] = args;
    } else if (args) {
        merge(opts, args);
    }
    if (!opts.name) opts.name = util.generate_uuid();
    var l = factory(opts.name, opts);
    for (var t in {'source':0, 'target':0}) {
        if (opts[t]) {
            if (typeof opts[t] === 'string') {
                opts[t] = {'address' : opts[t]};
            }
            l['set_' + t](opts[t]);
        }
    }
    if (l.is_sender() && opts.source === undefined) {
        opts.source = l.set_source({});
    }
    if (l.is_receiver() && opts.target === undefined) {
        opts.target = l.set_target({});
    }
    l.attach();
    return l;
}

Session.prototype.get_option = function (name, default_value) {
    if (this.options[name] !== undefined) return this.options[name];
    else return this.connection.get_option(name, default_value);
};

Session.prototype.attach_sender = function (args) {
    return attach(this.create_sender.bind(this), args, 'target', this.get_option('sender_options', {}));
};
Session.prototype.open_sender = Session.prototype.attach_sender;//alias

Session.prototype.attach_receiver = function (args) {
    return attach(this.create_receiver.bind(this), args, 'source', this.get_option('receiver_options', {}));
};
Session.prototype.open_receiver = Session.prototype.attach_receiver;//alias

Session.prototype.find_sender = function (filter) {
    return this.find_link(util.sender_filter(filter));
};

Session.prototype.find_receiver = function (filter) {
    return this.find_link(util.receiver_filter(filter));
};

Session.prototype.find_link = function (filter) {
    for (var name in this.links) {
        var link = this.links[name];
        if (filter(link)) return link;
    }
    return undefined;
};

Session.prototype.each_receiver = function (action, filter) {
    this.each_link(action, util.receiver_filter(filter));
};

Session.prototype.each_sender = function (action, filter) {
    this.each_link(action, util.sender_filter(filter));
};

Session.prototype.each_link = function (action, filter) {
    for (var name in this.links) {
        var link = this.links[name];
        if (filter === undefined || filter(link)) action(link);
    }
};

Session.prototype.create_link = function (name, constructor, opts) {
    var i = 0;
    while (this.local.handles[i]) i++;
    var l = new constructor(this, name, i, opts);
    this.links[name] = l;
    this.local.handles[i] = l;
    return l;
};

Session.prototype.begin = function () {
    if (this.state.open()) {
        this.connection._register();
    }
};
Session.prototype.open = Session.prototype.begin;

Session.prototype.end = function (error) {
    if (error) this.local.end.error = error;
    if (this.state.close()) {
        this.connection._register();
    }
};
Session.prototype.close = Session.prototype.end;

Session.prototype.is_open = function () {
    return this.connection.is_open() && this.state.is_open();
};

Session.prototype.is_remote_open = function () {
    return this.connection.is_remote_open() && this.state.remote_open;
};

Session.prototype.is_itself_closed = function () {
    return this.state.is_closed();
};

Session.prototype.is_closed = function () {
    return this.connection.is_closed() || this.is_itself_closed();
};

function notify_sendable(sender) {
    sender.dispatch('sendable', sender._context());
}

function is_sender_sendable(sender) {
    return sender.is_open() && sender.sendable();
}

Session.prototype._process = function () {
    do {
        if (this.state.need_open()) {
            this.output(this.local.begin);
        }

        var was_blocked = this.outgoing.deliveries.available() === 0;
        this.outgoing.process();
        if (was_blocked && this.outgoing.deliveries.available()) {
            this.each_sender(notify_sendable, is_sender_sendable);
        }
        this.incoming.process(this);
        for (var k in this.links) {
            this.links[k]._process();
        }

        if (this.state.need_close()) {
            this.output(this.local.end);
        }
    } while (!this.state.has_settled());
};

Session.prototype.send = function (sender, tag, data, format) {
    var d = this.outgoing.send(sender, tag, data, format);
    this.connection._register();
    return d;
};

Session.prototype._write_flow = function (link) {
    var fields = {'next_incoming_id':this.incoming.next_transfer_id,
        'incoming_window':this.incoming.window,
        'next_outgoing_id':this.outgoing.next_transfer_id,
        'outgoing_window':this.outgoing.window
    };
    this.incoming.max_transfer_id = fields.next_incoming_id + fields.incoming_window;
    if (link) {
        if (link._get_drain()) fields.drain = true;
        fields.delivery_count = link.delivery_count;
        fields.handle = link.local.handle;
        fields.link_credit = link.credit;
    }
    this.output(frames.flow(fields));
};

Session.prototype.on_begin = function (frame) {
    if (this.state.remote_opened()) {
        if (!this.remote.channel) {
            this.remote.channel = frame.channel;
        }
        this.remote.begin = frame.performative;
        this.outgoing.on_begin(frame.performative);
        this.incoming.on_begin(frame.performative);
        this.open();
        this.dispatch('session_open', this._context());
    } else {
        throw Error('Begin already received');
    }
};
Session.prototype.on_end = function (frame) {
    if (this.state.remote_closed()) {
        this.remote.end = frame.performative;
        var error = this.remote.end.error;
        if (error) {
            var handled = this.dispatch('session_error', this._context());
            handled = this.dispatch('session_close', this._context()) || handled;
            if (!handled) {
                EventEmitter.prototype.emit.call(this.connection.container, 'error', new SessionError(error.description, error.condition, this));
            }
        } else {
            this.dispatch('session_close', this._context());
        }
        var self = this;
        var token = this.state.mark();
        process.nextTick(function () {
            if (self.state.marker === token) {
                self.close();
                process.nextTick(function () { self.remove(); });
            }
        });
    } else {
        throw Error('End already received');
    }
};

Session.prototype.on_attach = function (frame) {
    var name = frame.performative.name;
    var link = this.links[name];
    if (!link) {
        // if role is true, peer is receiver, so we are sender
        link = frame.performative.role ? this.create_sender(name) : this.create_receiver(name);
    }
    this.remote.handles[frame.performative.handle] = link;
    link.on_attach(frame);
    link.remote.attach = frame.performative;
};

Session.prototype.on_disposition = function (frame) {
    if (frame.performative.role) {
        log.events('[%s] Received disposition for outgoing transfers', this.connection.options.id);
        this.outgoing.on_disposition(frame.performative);
    } else {
        log.events('[%s] Received disposition for incoming transfers', this.connection.options.id);
        this.incoming.on_disposition(frame.performative);
    }
    this.connection._register();
};

Session.prototype.on_flow = function (frame) {
    this.outgoing.on_flow(frame.performative);
    this.incoming.on_flow(frame.performative);
    if (util.is_defined(frame.performative.handle)) {
        this._get_link(frame).on_flow(frame);
    }
    this.connection._register();
};

Session.prototype._context = function (c) {
    var context = c ? c : {};
    context.session = this;
    return this.connection._context(context);
};

Session.prototype._get_link = function (frame) {
    var handle = frame.performative.handle;
    var link = this.remote.handles[handle];
    if (!link) {
        throw Error('Invalid handle ' + handle);
    }
    return link;
};

Session.prototype.on_detach = function (frame) {
    this._get_link(frame).on_detach(frame);
};

Session.prototype.remove_link = function (link) {
    delete this.remote.handles[link.remote.handle];
    delete this.local.handles[link.local.handle];
    delete this.links[link.name];
};

/**
 * This forcibly removes the session from the parent connection. It
 * should not be called for a link on an active connection, where
 * close() should be used instead.
 */
Session.prototype.remove = function () {
    this.connection.remove_session(this);
};

Session.prototype.on_transfer = function (frame) {
    this.incoming.on_transfer(frame, this._get_link(frame));
};

module.exports = Session;

},{"./frames.js":"tWUB","./link.js":"R3KQ","./log.js":"G8Vf","./message.js":"ZkFW","./types.js":"LFdS","./util.js":"AVyJ","./endpoint.js":"rwSj","events":"wIHY","util":"nIH4","buffer":"z1tx","process":"g5IB"}],"sC8V":[function(require,module,exports) {

},{}],"war4":[function(require,module,exports) {
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};

},{}],"sNrv":[function(require,module,exports) {
var process = require("process");
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

},{"process":"g5IB"}],"oMJg":[function(require,module,exports) {
var process = require("process");
var Buffer = require("buffer").Buffer;
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var errors = require('./errors.js');

var frames = require('./frames.js');

var log = require('./log.js');

var sasl = require('./sasl.js');

var util = require('./util.js');

var EndpointState = require('./endpoint.js');

var Session = require('./session.js');

var Transport = require('./transport.js');

var fs = require('fs');

var os = require('os');

var path = require('path');

var net = require('net');

var tls = require('tls');

var EventEmitter = require('events').EventEmitter;

var AMQP_PROTOCOL_ID = 0x00;

function find_connect_config() {
  var paths;

  if (undefined) {
    paths = [undefined];
  } else {
    paths = [process.cwd(), path.join(os.homedir(), '.config/messaging'), '/etc/messaging'].map(function (base) {
      return path.join(base, '/connect.json');
    });
  }

  for (var i = 0; i < paths.length; i++) {
    if (fs.existsSync(paths[i])) {
      var obj = JSON.parse(fs.readFileSync(paths[i], 'utf8'));
      log.config('using config from %s: %j', paths[i], obj);
      return obj;
    }
  }

  return {};
}

function get_default_connect_config() {
  var config = find_connect_config();
  var options = {};
  if (config.scheme === 'amqps') options.transport = 'tls';
  if (config.host) options.host = config.host;
  if (config.port === 'amqp') options.port = 5672;else if (config.port === 'amqps') options.port = 5671;else options.port = config.port;

  if (!(config.sasl && config.sasl.enabled === false)) {
    if (config.user) options.username = config.user;else options.username = 'anonymous';
    if (config.password) options.password = config.password;
    if (config.sasl_mechanisms) options.sasl_mechanisms = config.sasl_mechanisms;
  }

  if (config.tls) {
    if (config.tls.key) options.key = fs.readFileSync(config.tls.key);
    if (config.tls.cert) options.cert = fs.readFileSync(config.tls.cert);
    if (config.tls.ca) options.ca = [fs.readFileSync(config.tls.ca)];
    if (config.verify === false || config.tls.verify === false) options.rejectUnauthorized = false;
  }

  if (options.transport === 'tls') {
    options.servername = options.host;
  }

  return options;
}

function get_socket_id(socket) {
  if (socket.get_id_string) return socket.get_id_string();
  return socket.localAddress + ':' + socket.localPort + ' -> ' + socket.remoteAddress + ':' + socket.remotePort;
}

function session_per_connection(conn) {
  var ssn = null;
  return {
    'get_session': function () {
      if (!ssn) {
        ssn = conn.create_session();
        ssn.observers.on('session_close', function () {
          ssn = null;
        });
        ssn.begin();
      }

      return ssn;
    }
  };
}

function restrict(count, f) {
  if (count) {
    var current = count;
    var reset;
    return function (successful_attempts) {
      if (reset !== successful_attempts) {
        current = count;
        reset = successful_attempts;
      }

      if (current--) return f(successful_attempts);else return -1;
    };
  } else {
    return f;
  }
}

function backoff(initial, max) {
  var delay = initial;
  var reset;
  return function (successful_attempts) {
    if (reset !== successful_attempts) {
      delay = initial;
      reset = successful_attempts;
    }

    var current = delay;
    var next = delay * 2;
    delay = max > next ? next : max;
    return current;
  };
}

function get_connect_fn(options) {
  if (options.transport === undefined || options.transport === 'tcp') {
    return net.connect;
  } else if (options.transport === 'tls' || options.transport === 'ssl') {
    return tls.connect;
  } else {
    throw Error('Unrecognised transport: ' + options.transport);
  }
}

function connection_details(options) {
  var details = {};
  details.connect = options.connect ? options.connect : get_connect_fn(options);
  details.host = options.host ? options.host : 'localhost';
  details.port = options.port ? options.port : 5672;
  details.options = options;
  return details;
}

var aliases = ['container_id', 'hostname', 'max_frame_size', 'channel_max', 'idle_time_out', 'outgoing_locales', 'incoming_locales', 'offered_capabilities', 'desired_capabilities', 'properties'];

function remote_property_shortcut(name) {
  return function () {
    return this.remote.open ? this.remote.open[name] : undefined;
  };
}

function connection_fields(fields) {
  var o = {};
  aliases.forEach(function (name) {
    if (fields[name] !== undefined) {
      o[name] = fields[name];
    }
  });
  return o;
}

function set_reconnect(reconnect, connection) {
  if (typeof reconnect === 'boolean') {
    if (reconnect) {
      var initial = connection.get_option('initial_reconnect_delay', 100);
      var max = connection.get_option('max_reconnect_delay', 60000);
      connection.options.reconnect = restrict(connection.get_option('reconnect_limit'), backoff(initial, max));
    } else {
      connection.options.reconnect = false;
    }
  } else if (typeof reconnect === 'number') {
    var fixed = connection.options.reconnect;
    connection.options.reconnect = restrict(connection.get_option('reconnect_limit'), function () {
      return fixed;
    });
  }
}

var conn_counter = 1;

var Connection = function (options, container) {
  this.options = {};

  if (options) {
    for (var k in options) {
      this.options[k] = options[k];
    }

    if ((options.transport === 'tls' || options.transport === 'ssl') && options.servername === undefined && options.host !== undefined) {
      this.options.servername = options.host;
    }
  } else {
    this.options = get_default_connect_config();
  }

  this.container = container;

  if (!this.options.id) {
    this.options.id = 'connection-' + conn_counter++;
  }

  if (!this.options.container_id) {
    this.options.container_id = container ? container.id : util.generate_uuid();
  }

  if (!this.options.connection_details) {
    var self = this;

    this.options.connection_details = function () {
      return connection_details(self.options);
    };
  }

  var reconnect = this.get_option('reconnect', true);
  set_reconnect(reconnect, this);
  this.registered = false;
  this.state = new EndpointState();
  this.local_channel_map = {};
  this.remote_channel_map = {};
  this.local = {};
  this.remote = {};
  this.local.open = frames.open(connection_fields(this.options));
  this.local.close = frames.close({});
  this.session_policy = session_per_connection(this);
  this.amqp_transport = new Transport(this.options.id, AMQP_PROTOCOL_ID, frames.TYPE_AMQP, this);
  this.sasl_transport = undefined;
  this.transport = this.amqp_transport;
  this.conn_established_counter = 0;
  this.heartbeat_out = undefined;
  this.heartbeat_in = undefined;
  this.abort_idle = false;
  this.socket_ready = false;
  this.scheduled_reconnect = undefined;
  this.default_sender = undefined;
  this.closed_with_non_fatal_error = false;
  var self = this;
  aliases.forEach(function (alias) {
    Object.defineProperty(self, alias, {
      get: remote_property_shortcut(alias)
    });
  });
  Object.defineProperty(this, 'error', {
    get: function () {
      return this.remote.close ? this.remote.close.error : undefined;
    }
  });
};

Connection.prototype = Object.create(EventEmitter.prototype);
Connection.prototype.constructor = Connection;

Connection.prototype.dispatch = function (name) {
  log.events('[%s] Connection got event: %s', this.options.id, name);

  if (this.listeners(name).length) {
    EventEmitter.prototype.emit.apply(this, arguments);
    return true;
  } else if (this.container) {
    return this.container.dispatch.apply(this.container, arguments);
  } else {
    return false;
  }
};

Connection.prototype._disconnect = function () {
  this.state.disconnected();

  for (var k in this.local_channel_map) {
    this.local_channel_map[k]._disconnect();
  }

  this.socket_ready = false;
};

Connection.prototype._reconnect = function () {
  if (this.abort_idle) {
    this.abort_idle = false;
    this.local.close.error = undefined;
    this.state = new EndpointState();
    this.state.open();
  }

  this.state.reconnect();

  this._reset_remote_state();
};

Connection.prototype._reset_remote_state = function () {
  //reset transport
  this.amqp_transport = new Transport(this.options.id, AMQP_PROTOCOL_ID, frames.TYPE_AMQP, this);
  this.sasl_transport = undefined;
  this.transport = this.amqp_transport; //reset remote endpoint state

  this.remote = {}; //reset sessions:

  this.remote_channel_map = {};

  for (var k in this.local_channel_map) {
    this.local_channel_map[k]._reconnect();
  }
};

Connection.prototype.connect = function () {
  this.is_server = false;
  this.abort_idle = false;

  this._reset_remote_state();

  this._connect(this.options.connection_details(this.conn_established_counter));

  this.open();
  return this;
};

Connection.prototype.reconnect = function () {
  this.scheduled_reconnect = undefined;
  log.reconnect('[%s] reconnecting...', this.options.id);

  this._reconnect();

  this._connect(this.options.connection_details(this.conn_established_counter));

  process.nextTick(this._process.bind(this));
  return this;
};

Connection.prototype.set_reconnect = function (reconnect) {
  set_reconnect(reconnect, this);
};

Connection.prototype._connect = function (details) {
  if (details.connect) {
    this.init(details.connect(details.port, details.host, details.options, this.connected.bind(this)));
  } else {
    this.init(get_connect_fn(details)(details.port, details.host, details.options, this.connected.bind(this)));
  }

  return this;
};

Connection.prototype.accept = function (socket) {
  this.is_server = true;
  log.io('[%s] client accepted: %s', this.id, get_socket_id(socket));
  this.socket_ready = true;
  return this.init(socket);
};

Connection.prototype.abort_socket = function (socket) {
  if (socket === this.socket) {
    log.io('[%s] aborting socket', this.options.id);
    this.socket.end();

    if (this.socket.removeAllListeners) {
      this.socket.removeAllListeners('data');
      this.socket.removeAllListeners('error');
      this.socket.removeAllListeners('end');
    }

    if (typeof this.socket.destroy === 'function') {
      this.socket.destroy();
    }

    this._disconnected();
  }
};

Connection.prototype.init = function (socket) {
  this.socket = socket;

  if (this.get_option('tcp_no_delay', false) && this.socket.setNoDelay) {
    this.socket.setNoDelay(true);
  }

  this.socket.on('data', this.input.bind(this));
  this.socket.on('error', this.on_error.bind(this));
  this.socket.on('end', this.eof.bind(this));

  if (this.is_server) {
    var mechs;

    if (this.container && Object.getOwnPropertyNames(this.container.sasl_server_mechanisms).length) {
      mechs = this.container.sasl_server_mechanisms;
    }

    if (this.socket.encrypted && this.socket.authorized && this.get_option('enable_sasl_external', false)) {
      mechs = sasl.server_add_external(mechs ? util.clone(mechs) : {});
    }

    if (mechs) {
      if (mechs.ANONYMOUS !== undefined && !this.get_option('require_sasl', false)) {
        this.sasl_transport = new sasl.Selective(this, mechs);
      } else {
        this.sasl_transport = new sasl.Server(this, mechs);
      }
    } else {
      if (!this.get_option('disable_sasl', false)) {
        var anon = sasl.server_mechanisms();
        anon.enable_anonymous();
        this.sasl_transport = new sasl.Selective(this, anon);
      }
    }
  } else {
    var mechanisms = this.get_option('sasl_mechanisms');

    if (!mechanisms) {
      var username = this.get_option('username');
      var password = this.get_option('password');
      var token = this.get_option('token');

      if (username) {
        mechanisms = sasl.client_mechanisms();
        if (password) mechanisms.enable_plain(username, password);else if (token) mechanisms.enable_xoauth2(username, token);else mechanisms.enable_anonymous(username);
      }
    }

    if (this.socket.encrypted && this.options.cert && this.get_option('enable_sasl_external', false)) {
      if (!mechanisms) mechanisms = sasl.client_mechanisms();
      mechanisms.enable_external();
    }

    if (mechanisms) {
      this.sasl_transport = new sasl.Client(this, mechanisms, this.options.sasl_init_hostname || this.options.servername || this.options.host);
    }
  }

  this.transport = this.sasl_transport ? this.sasl_transport : this.amqp_transport;
  return this;
};

Connection.prototype.attach_sender = function (options) {
  return this.session_policy.get_session().attach_sender(options);
};

Connection.prototype.open_sender = Connection.prototype.attach_sender; //alias

Connection.prototype.attach_receiver = function (options) {
  if (this.get_option('tcp_no_delay', true) && this.socket.setNoDelay) {
    this.socket.setNoDelay(true);
  }

  return this.session_policy.get_session().attach_receiver(options);
};

Connection.prototype.open_receiver = Connection.prototype.attach_receiver; //alias

Connection.prototype.get_option = function (name, default_value) {
  if (this.options[name] !== undefined) return this.options[name];else if (this.container) return this.container.get_option(name, default_value);else return default_value;
};

Connection.prototype.send = function (msg) {
  if (this.default_sender === undefined) {
    this.default_sender = this.open_sender({
      target: {}
    });
  }

  return this.default_sender.send(msg);
};

Connection.prototype.connected = function () {
  this.socket_ready = true;
  this.conn_established_counter++;
  log.io('[%s] connected %s', this.options.id, get_socket_id(this.socket));
  this.output();
};

Connection.prototype.sasl_failed = function (text, condition) {
  this.transport_error = new errors.ConnectionError(text, condition ? condition : 'amqp:unauthorized-access', this);

  this._handle_error();

  this.socket.end();
};

Connection.prototype._is_fatal = function (error_condition) {
  var non_fatal = this.get_option('non_fatal_errors', ['amqp:connection:forced']);
  return non_fatal.indexOf(error_condition) < 0;
};

Connection.prototype._handle_error = function () {
  var error = this.get_error();

  if (error) {
    var handled = this.dispatch('connection_error', this._context({
      error: error
    }));
    handled = this.dispatch('connection_close', this._context({
      error: error
    })) || handled;

    if (!this._is_fatal(error.condition)) {
      this.closed_with_non_fatal_error = true;
    } else if (!handled) {
      this.dispatch('error', new errors.ConnectionError(error.description, error.condition, this));
    }

    return true;
  } else {
    return false;
  }
};

Connection.prototype.get_error = function () {
  if (this.transport_error) return this.transport_error;

  if (this.remote.close && this.remote.close.error) {
    return new errors.ConnectionError(this.remote.close.error.description, this.remote.close.error.condition, this);
  }

  return undefined;
};

Connection.prototype._get_peer_details = function () {
  var s = '';

  if (this.remote.open && this.remote.open.container) {
    s += this.remote.open.container + ' ';
  }

  if (this.remote.open && this.remote.open.properties) {
    s += JSON.stringify(this.remote.open.properties);
  }

  return s;
};

Connection.prototype.output = function () {
  try {
    if (this.socket && this.socket_ready) {
      if (this.heartbeat_out) clearTimeout(this.heartbeat_out);
      this.transport.write(this.socket);

      if ((this.is_closed() && this.state.has_settled() || this.abort_idle || this.transport_error) && !this.transport.has_writes_pending()) {
        this.socket.end();
      } else if (this.is_open() && this.remote.open.idle_time_out) {
        this.heartbeat_out = setTimeout(this._write_frame.bind(this), this.remote.open.idle_time_out / 2);
      }

      if (this.local.open.idle_time_out && this.heartbeat_in === undefined) {
        this.heartbeat_in = setTimeout(this.idle.bind(this), this.local.open.idle_time_out);
      }
    }
  } catch (e) {
    this.saved_error = e;

    if (e.name === 'ProtocolError') {
      console.error('[' + this.options.id + '] error on write: ' + e + ' ' + this._get_peer_details() + ' ' + e.name);
      this.dispatch('protocol_error', e) || console.error('[' + this.options.id + '] error on write: ' + e + ' ' + this._get_peer_details());
    } else {
      this.dispatch('error', e);
    }

    this.socket.end();
  }
};

function byte_to_hex(value) {
  if (value < 16) return '0x0' + Number(value).toString(16);else return '0x' + Number(value).toString(16);
}

function buffer_to_hex(buffer) {
  var bytes = [];

  for (var i = 0; i < buffer.length; i++) {
    bytes.push(byte_to_hex(buffer[i]));
  }

  return bytes.join(',');
}

Connection.prototype.input = function (buff) {
  var buffer;

  try {
    if (this.heartbeat_in) clearTimeout(this.heartbeat_in);
    log.io('[%s] read %d bytes', this.options.id, buff.length);

    if (this.previous_input) {
      buffer = Buffer.concat([this.previous_input, buff], this.previous_input.length + buff.length);
      this.previous_input = null;
    } else {
      buffer = buff;
    }

    var read = this.transport.read(buffer, this);

    if (read < buffer.length) {
      this.previous_input = buffer.slice(read);
    }

    if (this.local.open.idle_time_out) this.heartbeat_in = setTimeout(this.idle.bind(this), this.local.open.idle_time_out);

    if (this.transport.has_writes_pending()) {
      this.output();
    } else if (this.is_closed() && this.state.has_settled()) {
      this.socket.end();
    } else if (this.is_open() && this.remote.open.idle_time_out && !this.heartbeat_out) {
      this.heartbeat_out = setTimeout(this._write_frame.bind(this), this.remote.open.idle_time_out / 2);
    }
  } catch (e) {
    this.saved_error = e;

    if (e.name === 'ProtocolError') {
      this.dispatch('protocol_error', e) || console.error('[' + this.options.id + '] error on read: ' + e + ' ' + this._get_peer_details() + ' (buffer:' + buffer_to_hex(buffer) + ')');
    } else {
      this.dispatch('error', e);
    }

    this.socket.end();
  }
};

Connection.prototype.idle = function () {
  if (!this.is_closed()) {
    this.abort_idle = true;
    this.closed_with_non_fatal_error = true;
    this.local.close.error = {
      condition: 'amqp:resource-limit-exceeded',
      description: 'max idle time exceeded'
    };
    this.close();
    setTimeout(this.abort_socket.bind(this, this.socket), 1000);
  }
};

Connection.prototype.on_error = function (e) {
  this._disconnected(e);
};

Connection.prototype.eof = function (e) {
  var error = e || this.saved_error;
  this.saved_error = undefined;

  this._disconnected(error);
};

Connection.prototype._disconnected = function (error) {
  if (this.heartbeat_out) {
    clearTimeout(this.heartbeat_out);
    this.heartbeat_out = undefined;
  }

  if (this.heartbeat_in) {
    clearTimeout(this.heartbeat_in);
    this.heartbeat_in = undefined;
  }

  var was_closed_with_non_fatal_error = this.closed_with_non_fatal_error;

  if (this.closed_with_non_fatal_error) {
    this.closed_with_non_fatal_error = false;
    if (this.options.reconnect) this.open();
  }

  if ((!this.is_closed() || was_closed_with_non_fatal_error) && this.scheduled_reconnect === undefined) {
    this._disconnect();

    var disconnect_ctxt = {};

    if (error) {
      disconnect_ctxt.error = error;
    }

    if (!this.is_server && !this.transport_error && this.options.reconnect) {
      var delay = this.options.reconnect(this.conn_established_counter);

      if (delay >= 0) {
        log.reconnect('[%s] Scheduled reconnect in ' + delay + 'ms', this.options.id);
        this.scheduled_reconnect = setTimeout(this.reconnect.bind(this), delay);
        disconnect_ctxt.reconnecting = true;
      } else {
        disconnect_ctxt.reconnecting = false;
      }
    }

    if (!this.dispatch('disconnected', this._context(disconnect_ctxt))) {
      console.warn('[' + this.options.id + '] disconnected %s', disconnect_ctxt.error || '');
    }
  }
};

Connection.prototype.open = function () {
  if (this.state.open()) {
    this._register();
  }
};

Connection.prototype.close = function (error) {
  if (error) this.local.close.error = error;

  if (this.state.close()) {
    this._register();
  }
};

Connection.prototype.is_open = function () {
  return this.state.is_open();
};

Connection.prototype.is_remote_open = function () {
  return this.state.remote_open;
};

Connection.prototype.is_closed = function () {
  return this.state.is_closed();
};

Connection.prototype.create_session = function () {
  var i = 0;

  while (this.local_channel_map[i]) i++;

  var session = new Session(this, i);
  this.local_channel_map[i] = session;
  return session;
};

Connection.prototype.find_sender = function (filter) {
  return this.find_link(util.sender_filter(filter));
};

Connection.prototype.find_receiver = function (filter) {
  return this.find_link(util.receiver_filter(filter));
};

Connection.prototype.find_link = function (filter) {
  for (var channel in this.local_channel_map) {
    var session = this.local_channel_map[channel];
    var result = session.find_link(filter);
    if (result) return result;
  }

  return undefined;
};

Connection.prototype.each_receiver = function (action, filter) {
  this.each_link(action, util.receiver_filter(filter));
};

Connection.prototype.each_sender = function (action, filter) {
  this.each_link(action, util.sender_filter(filter));
};

Connection.prototype.each_link = function (action, filter) {
  for (var channel in this.local_channel_map) {
    var session = this.local_channel_map[channel];
    session.each_link(action, filter);
  }
};

Connection.prototype.on_open = function (frame) {
  if (this.state.remote_opened()) {
    this.remote.open = frame.performative;
    this.open();
    this.dispatch('connection_open', this._context());
  } else {
    throw new errors.ProtocolError('Open already received');
  }
};

Connection.prototype.on_close = function (frame) {
  if (this.state.remote_closed()) {
    this.remote.close = frame.performative;

    if (this.remote.close.error) {
      this._handle_error();
    } else {
      this.dispatch('connection_close', this._context());
    }

    if (this.heartbeat_out) clearTimeout(this.heartbeat_out);
    var self = this;
    process.nextTick(function () {
      self.close();
    });
  } else {
    throw new errors.ProtocolError('Close already received');
  }
};

Connection.prototype._register = function () {
  if (!this.registered) {
    this.registered = true;
    process.nextTick(this._process.bind(this));
  }
};

Connection.prototype._process = function () {
  this.registered = false;

  do {
    if (this.state.need_open()) {
      this._write_open();
    }

    for (var k in this.local_channel_map) {
      this.local_channel_map[k]._process();
    }

    if (this.state.need_close()) {
      this._write_close();
    }
  } while (!this.state.has_settled());
};

Connection.prototype._write_frame = function (channel, frame, payload) {
  this.amqp_transport.encode(frames.amqp_frame(channel, frame, payload));
  this.output();
};

Connection.prototype._write_open = function () {
  this._write_frame(0, this.local.open);
};

Connection.prototype._write_close = function () {
  this._write_frame(0, this.local.close);
};

Connection.prototype.on_begin = function (frame) {
  var session;

  if (frame.performative.remote_channel === null || frame.performative.remote_channel === undefined) {
    //peer initiated
    session = this.create_session();
    session.local.begin.remote_channel = frame.channel;
  } else {
    session = this.local_channel_map[frame.performative.remote_channel];
    if (!session) throw new errors.ProtocolError('Invalid value for remote channel ' + frame.performative.remote_channel);
  }

  session.on_begin(frame);
  this.remote_channel_map[frame.channel] = session;
};

Connection.prototype.get_peer_certificate = function () {
  if (this.socket && this.socket.getPeerCertificate) {
    return this.socket.getPeerCertificate();
  } else {
    return undefined;
  }
};

Connection.prototype.get_tls_socket = function () {
  if (this.socket && (this.options.transport === 'tls' || this.options.transport === 'ssl')) {
    return this.socket;
  } else {
    return undefined;
  }
};

Connection.prototype._context = function (c) {
  var context = c ? c : {};
  context.connection = this;
  if (this.container) context.container = this.container;
  return context;
};

Connection.prototype.remove_session = function (session) {
  if (this.remote_channel_map[session.remote.channel] === session) {
    delete this.remote_channel_map[session.remote.channel];
  }

  if (this.local_channel_map[session.local.channel] === session) {
    delete this.local_channel_map[session.local.channel];
  }
};

Connection.prototype.remove_all_sessions = function () {
  this.remote_channel_map = {};
  this.local_channel_map = {};
};

function delegate_to_session(name) {
  Connection.prototype['on_' + name] = function (frame) {
    var session = this.remote_channel_map[frame.channel];

    if (!session) {
      throw new errors.ProtocolError(name + ' received on invalid channel ' + frame.channel);
    }

    session['on_' + name](frame);
  };
}

delegate_to_session('end');
delegate_to_session('attach');
delegate_to_session('detach');
delegate_to_session('transfer');
delegate_to_session('disposition');
delegate_to_session('flow');
module.exports = Connection;
},{"./errors.js":"vdFv","./frames.js":"tWUB","./log.js":"G8Vf","./sasl.js":"EIGA","./util.js":"AVyJ","./endpoint.js":"rwSj","./session.js":"zdAo","./transport.js":"mq7g","fs":"sC8V","os":"war4","path":"sNrv","net":"sC8V","tls":"sC8V","events":"wIHY","process":"g5IB","buffer":"z1tx"}],"cK9G":[function(require,module,exports) {
/*
 * Copyright 2018 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var ReceiverEvents;
(function (ReceiverEvents) {
    /**
     * @property {string} message Raised when a message is received.
     */
    ReceiverEvents['message'] = 'message';
    /**
     * @property {string} receiverOpen Raised when the remote peer indicates the link is
     * open (i.e. attached in AMQP parlance).
     */
    ReceiverEvents['receiverOpen'] = 'receiver_open';
    /**
     * @property {string} receiverDrained Raised when the remote peer
     * indicates that it has drained all credit (and therefore there
     * are no more messages at present that it can send).
     */
    ReceiverEvents['receiverDrained'] = 'receiver_drained';
    /**
     * @property {string} receiverFlow Raised when a flow is received for receiver.
     */
    ReceiverEvents['receiverFlow'] = 'receiver_flow';
    /**
     * @property {string} receiverError Raised when the remote peer
     * closes the receiver with an error. The context may also have an
     * error property giving some information about the reason for the
     * error.
     */
    ReceiverEvents['receiverError'] = 'receiver_error';
    /**
     * @property {string} receiverClose Raised when the remote peer indicates the link is closed.
     */
    ReceiverEvents['receiverClose'] = 'receiver_close';
    /**
     * @property {string} settled Raised when the receiver link receives a disposition.
     */
    ReceiverEvents['settled'] = 'settled';
})(ReceiverEvents || (ReceiverEvents = {}));

var SenderEvents;
(function (SenderEvents) {
    /**
     * @property {string} sendable Raised when the sender has sufficient credit to be able
     * to transmit messages to its peer.
     */
    SenderEvents['sendable'] = 'sendable';
    /**
     * @property {string} senderOpen Raised when the remote peer indicates the link is
     * open (i.e. attached in AMQP parlance).
     */
    SenderEvents['senderOpen'] = 'sender_open';
    /**
     * @property {string} senderDraining Raised when the remote peer
     * requests that the sender drain its credit; sending all
     * available messages within the credit limit and ensuring credit
     * is used up..
     */
    SenderEvents['senderDraining'] = 'sender_draining';
    /**
     * @property {string} senderFlow Raised when a flow is received for sender.
     */
    SenderEvents['senderFlow'] = 'sender_flow';
    /**
     * @property {string} senderError Raised when the remote peer
     * closes the sender with an error. The context may also have an
     * error property giving some information about the reason for the
     * error.
     */
    SenderEvents['senderError'] = 'sender_error';
    /**
     * @property {string} senderClose Raised when the remote peer indicates the link is closed.
     */
    SenderEvents['senderClose'] = 'sender_close';
    /**
     * @property {string} accepted Raised when a sent message is accepted by the peer.
     */
    SenderEvents['accepted'] = 'accepted';
    /**
     * @property {string} released Raised when a sent message is released by the peer.
     */
    SenderEvents['released'] = 'released';
    /**
     * @property {string} rejected Raised when a sent message is rejected by the peer.
     */
    SenderEvents['rejected'] = 'rejected';
    /**
     * @property {string} modified Raised when a sent message is modified by the peer.
     */
    SenderEvents['modified'] = 'modified';
    /**
     * @property {string} settled Raised when the sender link receives a disposition.
     */
    SenderEvents['settled'] = 'settled';
})(SenderEvents || (SenderEvents = {}));


var SessionEvents;
(function (SessionEvents) {
    /**
     * @property {string} sessionOpen Raised when the remote peer indicates the session is
     * open (i.e. attached in AMQP parlance).
     */
    SessionEvents['sessionOpen'] = 'session_open';
    /**
     * @property {string} sessionError Raised when the remote peer receives an error. The context
     * may also have an error property giving some information about the reason for the error.
     */
    SessionEvents['sessionError'] = 'session_error';
    /**
     * @property {string} sessionClose Raised when the remote peer indicates the session is closed.
     */
    SessionEvents['sessionClose'] = 'session_close';
    /**
     * @property {string} settled Raised when the session receives a disposition.
     */
    SessionEvents['settled'] = 'settled';
})(SessionEvents || (SessionEvents = {}));

var ConnectionEvents;
(function (ConnectionEvents) {
    /**
     * @property {string} connectionOpen Raised when the remote peer indicates the connection is open.
     */
    ConnectionEvents['connectionOpen'] = 'connection_open';
    /**
     * @property {string} connectionClose Raised when the remote peer indicates the connection is closed.
     */
    ConnectionEvents['connectionClose'] = 'connection_close';
    /**
     * @property {string} connectionError Raised when the remote peer indicates an error occurred on
     * the connection.
     */
    ConnectionEvents['connectionError'] = 'connection_error';
    /**
     * @property {string} protocolError Raised when a protocol error is received on the underlying socket.
     */
    ConnectionEvents['protocolError'] = 'protocol_error',
    /**
     * @property {string} error Raised when an error is received on the underlying socket.
     */
    ConnectionEvents['error'] = 'error',
    /**
     * @property {string} disconnected Raised when the underlying tcp connection is lost. The context
     * has a reconnecting property which is true if the library is attempting to automatically reconnect
     * and false if it has reached the reconnect limit. If reconnect has not been enabled or if the connection
     * is a tcp server, then the reconnecting property is undefined. The context may also have an error
     * property giving some information about the reason for the disconnect.
     */
    ConnectionEvents['disconnected'] = 'disconnected';
    /**
     * @property {string} settled Raised when the connection receives a disposition.
     */
    ConnectionEvents['settled'] = 'settled';
})(ConnectionEvents || (ConnectionEvents = {}));

module.exports = {
    ReceiverEvents: ReceiverEvents,
    SenderEvents: SenderEvents,
    SessionEvents: SessionEvents,
    ConnectionEvents: ConnectionEvents
};

},{}],"gf4K":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function nulltransform(data) { return data; }

function from_arraybuffer(data) {
    if (data instanceof ArrayBuffer) return Buffer.from(new Uint8Array(data));
    else return Buffer.from(data);
}

function to_typedarray(data) {
    return new Uint8Array(data);
}

function wrap(ws) {
    var data_recv = nulltransform;
    var data_send = nulltransform;
    if (ws.binaryType) {
        ws.binaryType = 'arraybuffer';
        data_recv = from_arraybuffer;
        data_send = to_typedarray;
    }
    return {
        end: function() {
            ws.close();
        },
        write: function(data) {
            try {
                ws.send(data_send(data), {binary:true});
            } catch (e) {
                ws.onerror(e);
            }
        },
        on: function(event, handler) {
            if (event === 'data') {
                ws.onmessage = function(msg_evt) {
                    handler(data_recv(msg_evt.data));
                };
            } else if (event === 'end') {
                ws.onclose = handler;
            } else if (event === 'error') {
                ws.onerror = handler;
            } else {
                console.error('ERROR: Attempt to set unrecognised handler on websocket wrapper: ' + event);
            }
        },
        get_id_string: function() {
            return ws.url;
        }
    };
}

module.exports = {

    'connect': function(Impl) {
        return function (url, protocols, options) {
            return function () {
                return {
                    connect: function(port_ignore, host_ignore, options_ignore, callback) {
                        var c = new Impl(url, protocols, options);
                        c.onopen = callback;
                        return wrap(c);
                    }
                };
            };
        };
    },
    'wrap': wrap
};

},{"buffer":"z1tx"}],"xssi":[function(require,module,exports) {
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var amqp_types = require('./types.js');

module.exports = {
    selector : function (s) {
        return {'jms-selector':amqp_types.wrap_described(s, 0x468C00000004)};
    }
};

},{"./types.js":"LFdS"}],"w9Vx":[function(require,module,exports) {
var process = require("process");
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Connection = require('./connection.js');
var log = require('./log.js');
var sasl = require('./sasl.js');
var util = require('./util.js');
var eventTypes = require('./eventTypes.js');

var net = require('net');
var tls = require('tls');
var EventEmitter = require('events').EventEmitter;

var Container = function (options) {
    this.options = options ? Object.create(options) : {};
    if (!this.options.id) {
        this.options.id = util.generate_uuid();
    }
    this.id = this.options.id;
    this.sasl_server_mechanisms = sasl.server_mechanisms();
};

Container.prototype = Object.create(EventEmitter.prototype);
Container.prototype.constructor = Container;
Container.prototype.dispatch = function(name) {
    log.events('[%s] Container got event: ' + name, this.id);
    EventEmitter.prototype.emit.apply(this, arguments);
    if (this.listeners(name).length) {
        return true;
    } else {
        return false;
    }
};

Container.prototype.connect = function (options) {
    return new Connection(options, this).connect();
};

Container.prototype.create_connection = function (options) {
    return new Connection(options, this);
};

Container.prototype.listen = function (options) {
    var container = this;
    var server;
    if (options.transport === undefined || options.transport === 'tcp') {
        server = net.createServer();
        server.on('connection', function (socket) {
            new Connection(options, container).accept(socket);
        });
    } else if (options.transport === 'tls' || options.transport === 'ssl') {
        server = tls.createServer(options);
        server.on('secureConnection', function (socket) {
            new Connection(options, container).accept(socket);
        });
    } else {
        throw Error('Unrecognised transport: ' + options.transport);
    }
    if (process.version.match(/v0\.10\.\d+/)) {
        server.listen(options.port, options.host);
    } else {
        server.listen(options);
    }
    return server;
};

Container.prototype.create_container = function (options) {
    return new Container(options);
};

Container.prototype.get_option = function (name, default_value) {
    if (this.options[name] !== undefined) return this.options[name];
    else return default_value;
};

Container.prototype.generate_uuid = util.generate_uuid;
Container.prototype.string_to_uuid = util.string_to_uuid;
Container.prototype.uuid_to_string = util.uuid_to_string;
var ws = require('./ws.js');
Container.prototype.websocket_accept = function(socket, options) {
    new Connection(options, this).accept(ws.wrap(socket));
};
Container.prototype.websocket_connect = ws.connect;
Container.prototype.filter = require('./filter.js');
Container.prototype.types = require('./types.js');
Container.prototype.message = require('./message.js');
Container.prototype.sasl = sasl;
Container.prototype.ReceiverEvents = eventTypes.ReceiverEvents;
Container.prototype.SenderEvents = eventTypes.SenderEvents;
Container.prototype.SessionEvents = eventTypes.SessionEvents;
Container.prototype.ConnectionEvents = eventTypes.ConnectionEvents;

module.exports = new Container();

},{"./connection.js":"oMJg","./log.js":"G8Vf","./sasl.js":"EIGA","./util.js":"AVyJ","./eventTypes.js":"cK9G","net":"sC8V","tls":"sC8V","events":"wIHY","./ws.js":"gf4K","./filter.js":"xssi","./types.js":"LFdS","./message.js":"ZkFW","process":"g5IB"}],"fCvn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__extends = __extends;
exports.__rest = __rest;
exports.__decorate = __decorate;
exports.__param = __param;
exports.__metadata = __metadata;
exports.__awaiter = __awaiter;
exports.__generator = __generator;
exports.__createBinding = __createBinding;
exports.__exportStar = __exportStar;
exports.__values = __values;
exports.__read = __read;
exports.__spread = __spread;
exports.__spreadArrays = __spreadArrays;
exports.__await = __await;
exports.__asyncGenerator = __asyncGenerator;
exports.__asyncDelegator = __asyncDelegator;
exports.__asyncValues = __asyncValues;
exports.__makeTemplateObject = __makeTemplateObject;
exports.__importStar = __importStar;
exports.__importDefault = __importDefault;
exports.__classPrivateFieldGet = __classPrivateFieldGet;
exports.__classPrivateFieldSet = __classPrivateFieldSet;
exports.__assign = void 0;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function () {
  exports.__assign = __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

exports.__assign = __assign;

function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

function __createBinding(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
}

function __exportStar(m, exports) {
  for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}

function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
}

function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

;

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;

  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }

  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }

  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }

  function fulfill(value) {
    resume("next", value);
  }

  function reject(value) {
    resume("throw", value);
  }

  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;

  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
      i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);

  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }

  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }

  return cooked;
}

;

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result.default = mod;
  return result;
}

function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}

function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }

  return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }

  privateMap.set(receiver, value);
  return value;
}
},{}],"d1sB":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const debugModule = require("debug");
/**
 * @ignore
 * log statements for container
 */
exports.container = debugModule("rhea-promise:container");
/**
 * @ignore
 * log statements for connection
 */
exports.connection = debugModule("rhea-promise:connection");
/**
 * @ignore
 * log statements for session
 */
exports.session = debugModule("rhea-promise:session");
/**
 * @ignore
 * log statements for sender
 */
exports.sender = debugModule("rhea-promise:sender");
/**
 * @ignore
 * log statements for receiver
 */
exports.receiver = debugModule("rhea-promise:receiver");
/**
 * @ignore
 * log statements for error
 */
exports.error = debugModule("rhea-promise:error");
/**
 * @ignore
 * log statements for error
 */
exports.eventHandler = debugModule("rhea-promise:eventhandler");
/**
 * @ignore
 * log statements for error
 */
exports.contextTranslator = debugModule("rhea-promise:translate");

},{"debug":"jD9Y"}],"w9fr":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const log = require("../log");
const eventContext_1 = require("../eventContext");
/**
 * Defines a mapping for Http like response status codes for different status-code values
 * provided by an AMQP broker.
 * @enum AmqpResponseStatusCode
 */
var AmqpResponseStatusCode;
(function (AmqpResponseStatusCode) {
    AmqpResponseStatusCode[AmqpResponseStatusCode["Continue"] = 100] = "Continue";
    AmqpResponseStatusCode[AmqpResponseStatusCode["SwitchingProtocols"] = 101] = "SwitchingProtocols";
    AmqpResponseStatusCode[AmqpResponseStatusCode["OK"] = 200] = "OK";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Created"] = 201] = "Created";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Accepted"] = 202] = "Accepted";
    AmqpResponseStatusCode[AmqpResponseStatusCode["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
    AmqpResponseStatusCode[AmqpResponseStatusCode["NoContent"] = 204] = "NoContent";
    AmqpResponseStatusCode[AmqpResponseStatusCode["ResetContent"] = 205] = "ResetContent";
    AmqpResponseStatusCode[AmqpResponseStatusCode["PartialContent"] = 206] = "PartialContent";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Ambiguous"] = 300] = "Ambiguous";
    AmqpResponseStatusCode[AmqpResponseStatusCode["MultipleChoices"] = 300] = "MultipleChoices";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Moved"] = 301] = "Moved";
    AmqpResponseStatusCode[AmqpResponseStatusCode["MovedPermanently"] = 301] = "MovedPermanently";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Found"] = 302] = "Found";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Redirect"] = 302] = "Redirect";
    AmqpResponseStatusCode[AmqpResponseStatusCode["RedirectMethod"] = 303] = "RedirectMethod";
    AmqpResponseStatusCode[AmqpResponseStatusCode["SeeOther"] = 303] = "SeeOther";
    AmqpResponseStatusCode[AmqpResponseStatusCode["NotModified"] = 304] = "NotModified";
    AmqpResponseStatusCode[AmqpResponseStatusCode["UseProxy"] = 305] = "UseProxy";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Unused"] = 306] = "Unused";
    AmqpResponseStatusCode[AmqpResponseStatusCode["RedirectKeepVerb"] = 307] = "RedirectKeepVerb";
    AmqpResponseStatusCode[AmqpResponseStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    AmqpResponseStatusCode[AmqpResponseStatusCode["BadRequest"] = 400] = "BadRequest";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Unauthorized"] = 401] = "Unauthorized";
    AmqpResponseStatusCode[AmqpResponseStatusCode["PaymentRequired"] = 402] = "PaymentRequired";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Forbidden"] = 403] = "Forbidden";
    AmqpResponseStatusCode[AmqpResponseStatusCode["NotFound"] = 404] = "NotFound";
    AmqpResponseStatusCode[AmqpResponseStatusCode["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    AmqpResponseStatusCode[AmqpResponseStatusCode["NotAcceptable"] = 406] = "NotAcceptable";
    AmqpResponseStatusCode[AmqpResponseStatusCode["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    AmqpResponseStatusCode[AmqpResponseStatusCode["RequestTimeout"] = 408] = "RequestTimeout";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Conflict"] = 409] = "Conflict";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Gone"] = 410] = "Gone";
    AmqpResponseStatusCode[AmqpResponseStatusCode["LengthRequired"] = 411] = "LengthRequired";
    AmqpResponseStatusCode[AmqpResponseStatusCode["PreconditionFailed"] = 412] = "PreconditionFailed";
    AmqpResponseStatusCode[AmqpResponseStatusCode["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
    AmqpResponseStatusCode[AmqpResponseStatusCode["RequestUriTooLong"] = 414] = "RequestUriTooLong";
    AmqpResponseStatusCode[AmqpResponseStatusCode["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    AmqpResponseStatusCode[AmqpResponseStatusCode["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
    AmqpResponseStatusCode[AmqpResponseStatusCode["ExpectationFailed"] = 417] = "ExpectationFailed";
    AmqpResponseStatusCode[AmqpResponseStatusCode["UpgradeRequired"] = 426] = "UpgradeRequired";
    AmqpResponseStatusCode[AmqpResponseStatusCode["InternalServerError"] = 500] = "InternalServerError";
    AmqpResponseStatusCode[AmqpResponseStatusCode["NotImplemented"] = 501] = "NotImplemented";
    AmqpResponseStatusCode[AmqpResponseStatusCode["BadGateway"] = 502] = "BadGateway";
    AmqpResponseStatusCode[AmqpResponseStatusCode["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    AmqpResponseStatusCode[AmqpResponseStatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
    AmqpResponseStatusCode[AmqpResponseStatusCode["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
})(AmqpResponseStatusCode = exports.AmqpResponseStatusCode || (exports.AmqpResponseStatusCode = {}));
/**
 * Provides a list of predefined (amqp) protocol level properties for an amqp message.
 */
exports.messageProperties = [
    "message_id", "reply_to", "to", "correlation_id", "content_type", "absolute_expiry_time",
    "group_id", "group_sequence", "reply_to_group_id", "content_encoding", "creation_time", "subject",
    "user_id"
];
/**
 * Provides a list of predefined (amqp) protocol level properties for an amqp message header.
 */
exports.messageHeader = [
    "first_acquirer", "delivery_count", "ttl", "durable", "priority"
];
/**
 * Determines whether the given error object is like an AmqpError object.
 * @param {object} err The AmqpError object
 * @returns {boolean} result - `true` if it is an AMQP Error; `false` otherwise.
 */
function isAmqpError(err) {
    if (!err || typeof err !== "object") {
        throw new Error("err is a required parameter and must be of type 'object'.");
    }
    let result = false;
    if (((err.condition && typeof err.condition === "string") && (err.description && typeof err.description === "string"))
        || (err.value && Array.isArray(err.value))
        || (err.constructor && err.constructor.name === "c")) {
        result = true;
    }
    return result;
}
exports.isAmqpError = isAmqpError;
/**
 * A wrapper for setTimeout that resolves a promise after t milliseconds.
 * @param {number} t - The number of milliseconds to be delayed.
 * @param {T} value - The value to be resolved with after a timeout of t milliseconds.
 * @returns {Promise<T>} - Resolved promise
 */
function delay(t, value) {
    return new Promise((resolve) => setTimeout(() => resolve(value), t));
}
exports.delay = delay;
/**
 * Parses the connection string and returns an object of type T.
 * @param {string} connectionString The connection string to be parsed.
 * @returns {ParsedOutput<T>} ParsedOutput<T>.
 */
function parseConnectionString(connectionString, options) {
    if (!options)
        options = {};
    const entitySeperator = options.entitySeperator || ";";
    const keyValueSeparator = options.keyValueSeparator || "=";
    return connectionString.split(entitySeperator).reduce((acc, part) => {
        const splitIndex = part.indexOf(keyValueSeparator);
        return Object.assign({}, acc, { [part.substring(0, splitIndex)]: part.substring(splitIndex + 1) });
    }, {});
}
exports.parseConnectionString = parseConnectionString;
/**
 * @ignore
 * Emits an event.
 * @param params parameters needed to emit an event from one of the rhea-promise objects.
 * @returns void
 */
function emitEvent(params) {
    const emit = () => {
        const id = params.emitter &&
            (params.emitter.id || params.emitter.name);
        log[params.emitterType]("[%s] %s '%s' got event: '%s'. Re-emitting the translated context.", params.connectionId, params.emitterType, id, params.eventName);
        params.emitter.emit(params.eventName, eventContext_1.EventContext.translate(params.rheaContext, params.emitter, params.eventName));
    };
    if (params.eventName.indexOf("error") !== -1 && params.emitter.actionInitiated > 0) {
        log[params.emitterType]("[%s] %s got event: '%s'. Will re-emit in the next tick, since " +
            "this happened before the promise for create/close was resolved.", params.connectionId, params.emitterType, params.eventName);
        // setTimeout() without any time is equivalent to process.nextTick() and works in node.js and
        // browsers. We wait for a tick to emit error events in general. This should give enough
        // time for promises to resolve on *_open (create) and *_close (close).
        setTimeout(emit);
    }
    else {
        emit();
    }
}
exports.emitEvent = emitEvent;

},{"../log":"d1sB","../eventContext":"AAmz"}],"G7IJ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
/**
 * Abstract base class for all the entities like Connection, Session, Sender, Receiver in the
 * AMQP protocol.
 * @class Entity
 */
class Entity extends events_1.EventEmitter {
    constructor() {
        super();
        /**
         * @property actionInitiated Indicates whether the action of creating or closing an entity has
         * been initiated. Whenever an action has been initiated, the count will be incremented by 1.
         * Whenever the action completes (succeeds/fails) the count will be decremented by 1.
         * Default value: `0`.
         */
        this.actionInitiated = 0;
    }
}
exports.Entity = Entity;

},{"events":"wIHY"}],"vVcP":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Defines the error that occurs when an operation timeout occurs.
 */
class OperationTimeoutError extends Error {
    constructor(message) {
        super(message);
        /**
         * Describes the name of the error.
         */
        this.name = "OperationTimeoutError";
    }
}
exports.OperationTimeoutError = OperationTimeoutError;
/**
 * Defines the error that occurs when the Sender does not have enough credit.
 */
class InsufficientCreditError extends Error {
    constructor(message) {
        super(message);
        /**
         * Describes the name of the error.
         */
        this.name = "InsufficientCreditError";
    }
}
exports.InsufficientCreditError = InsufficientCreditError;
/**
 * Defines the error that occurs when the Sender fails to send a message.
 */
class SendOperationFailedError extends Error {
    constructor(
    /**
     * Provides descriptive information about the error.
     */
    message, 
    /**
     * Provides the corresponding event associated with the `SendOperationFailedError`.
     * - If the code is `"sender_error"` | `"session_error"`, then the send operation failed
     * due to the sender link getting disconnected.
     * - If the code is `"rejected"` | `"released"` | `"modified"`, then the send operation failed
     * because the server is currently unable to accept the message being sent. Please take a look
     * at the [AMQP 1.0 specification - "Section 3.4 Delivery State"](http://www.amqp.org/sites/amqp.org/files/amqp.pdf)
     * for details about `"rejected"` | `"released"` | `"modified"` disposition.
     */
    code, 
    /**
     * Describes the underlying error that caused the send operation to fail.
     */
    innerError) {
        super(message);
        this.message = message;
        this.code = code;
        this.innerError = innerError;
        /**
         * Describes the name of the error.
         */
        this.name = "SendOperationFailedError";
        this.code = code;
        this.innerError = innerError;
    }
}
exports.SendOperationFailedError = SendOperationFailedError;

},{}],"b4Zd":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const log = require("./log");
const rhea_1 = require("rhea");
const utils_1 = require("./util/utils");
const entity_1 = require("./entity");
const errorDefinitions_1 = require("./errorDefinitions");
var LinkType;
(function (LinkType) {
    LinkType["sender"] = "sender";
    LinkType["receiver"] = "receiver";
})(LinkType = exports.LinkType || (exports.LinkType = {}));
class Link extends entity_1.Entity {
    constructor(type, session, link, options) {
        super();
        this.type = type;
        this._session = session;
        this._link = link;
        this.linkOptions = options;
        this._initializeEventListeners();
    }
    get name() {
        return this._link.name;
    }
    get error() {
        return this._link.error;
    }
    get properties() {
        return this._link.properties;
    }
    get sendSettleMode() {
        return this._link.snd_settle_mode;
    }
    get receiveSettleMode() {
        return this._link.rcv_settle_mode;
    }
    get source() {
        return this._link.source;
    }
    set source(fields) {
        this._link.set_source(fields);
    }
    get target() {
        return this._link.target;
    }
    set target(fields) {
        this._link.set_source(fields);
    }
    get maxMessageSize() {
        return this._link.max_message_size;
    }
    get offeredCapabilities() {
        return this._link.offered_capabilities;
    }
    get desiredCapabilities() {
        return this._link.desired_capabilities;
    }
    get address() {
        return this.source.address;
    }
    get credit() {
        return this._link.credit;
    }
    get session() {
        return this._session;
    }
    get connection() {
        return this._session.connection;
    }
    /**
     * Determines whether the sender link and its underlying session is open.
     * @returns {boolean} `true` open. `false` closed.
     */
    isOpen() {
        let result = false;
        if (this._session.isOpen() && this._link.is_open()) {
            result = true;
        }
        return result;
    }
    /**
     * Determines whether the remote end of the link is open.
     * @return {boolean} boolean `true` - is open; `false` otherwise.
     */
    isRemoteOpen() {
        return this._link.is_remote_open();
    }
    /**
     * Determines whether the link has credit.
     * @return {boolean} boolean `true` - has credit; `false` otherwise.
     */
    hasCredit() {
        return this._link.has_credit();
    }
    /**
     * Determines whether the link is a sender.
     * @return {boolean} boolean `true` - sender; `false` otherwise.
     */
    isSender() {
        return this._link.is_sender();
    }
    /**
     * Determines whether the link is a receiver.
     * @return {boolean} boolean `true` - receiver; `false` otherwise.
     */
    isReceiver() {
        return this._link.is_receiver();
    }
    /**
     * Determines whether both local and remote endpoint for link or it's underlying session
     * or it's underlying connection are closed.
     * Within the "sender_close", "session_close" event handler, if this
     * method returns `false` it means that the local end is still open. It can be useful to
     * determine whether the close was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` if closed, `false` otherwise.
     */
    isClosed() {
        return this._link.is_closed();
    }
    /**
     * Determines whether both local and remote endpoint for just the link itself are closed.
     * Within the "sender_close" event handler, if this method returns `false` it
     * means that the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isItselfClosed() {
        return this._link.is_itself_closed();
    }
    /**
     * Determines whether both local and remote endpoint for session or it's underlying
     * connection are closed.
     *
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isSessionClosed() {
        return this._session.isClosed();
    }
    /**
     * Determines whether both local and remote endpoint for just the session itself are closed.
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isSessionItselfClosed() {
        return this._session.isItselfClosed();
    }
    /**
     * Removes the underlying amqp link and it's session from the internal map in rhea. Also removes
     * all the event handlers added in the rhea-promise library on the link and it's session.
     * @returns {void} void
     */
    remove() {
        if (this._link) {
            // Remove our listeners and listeners from rhea's link object.
            this.removeAllListeners();
            this._link.removeAllListeners();
            this._link.remove();
        }
        if (this._session) {
            this._session.remove();
        }
    }
    /**
     * Closes the underlying amqp link and optionally the session as well in rhea if open.
     * Also removes all the event handlers added in the rhea-promise library on the link
     * and optionally it's session.
     * @returns Promise<void>
     * - **Resolves** the promise when rhea emits the "sender_close" | "receiver_close" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the
     * "sender_error" | "receiver_error" event while trying to close the amqp link.
     */
    close(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!options)
                options = {};
            if (options.closeSession == undefined)
                options.closeSession = true;
            this.removeAllListeners();
            yield new Promise((resolve, reject) => {
                log.error("[%s] The %s '%s' on amqp session '%s' is open ? -> %s", this.connection.id, this.type, this.name, this.session.id, this.isOpen());
                if (this.isOpen()) {
                    const errorEvent = this.type === LinkType.sender
                        ? rhea_1.SenderEvents.senderError
                        : rhea_1.ReceiverEvents.receiverError;
                    const closeEvent = this.type === LinkType.sender
                        ? rhea_1.SenderEvents.senderClose
                        : rhea_1.ReceiverEvents.receiverClose;
                    let onError;
                    let onClose;
                    let onDisconnected;
                    let waitTimer;
                    const removeListeners = () => {
                        clearTimeout(waitTimer);
                        this.actionInitiated--;
                        this._link.removeListener(errorEvent, onError);
                        this._link.removeListener(closeEvent, onClose);
                        this._link.connection.removeListener(rhea_1.ConnectionEvents.disconnected, onDisconnected);
                    };
                    onClose = (context) => {
                        removeListeners();
                        log[this.type]("[%s] Resolving the promise as the %s '%s' on amqp session '%s' " +
                            "has been closed.", this.connection.id, this.type, this.name, this.session.id);
                        return resolve();
                    };
                    onError = (context) => {
                        removeListeners();
                        log.error("[%s] Error occurred while closing %s '%s' on amqp session '%s': %O.", this.connection.id, this.type, this.name, this.session.id, context.session.error);
                        return reject(context.session.error);
                    };
                    onDisconnected = (context) => {
                        removeListeners();
                        const error = context.connection && context.connection.error
                            ? context.connection.error
                            : context.error;
                        log.error("[%s] Connection got disconnected while closing amqp %s '%s' on amqp " +
                            "session '%s': %O.", this.connection.id, this.type, this.name, this.session.id, error);
                    };
                    const actionAfterTimeout = () => {
                        removeListeners();
                        const msg = `Unable to close the ${this.type} '${this.name}' ` +
                            `on amqp session '${this.session.id}' due to operation timeout.`;
                        log.error("[%s] %s", this.connection.id, msg);
                        return reject(new errorDefinitions_1.OperationTimeoutError(msg));
                    };
                    // listeners that we add for completing the operation are added directly to rhea's objects.
                    this._link.once(closeEvent, onClose);
                    this._link.once(errorEvent, onError);
                    this._link.connection.once(rhea_1.ConnectionEvents.disconnected, onDisconnected);
                    waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
                    this._link.close();
                    this.actionInitiated++;
                }
                else {
                    return resolve();
                }
            });
            if (options.closeSession) {
                log[this.type]("[%s] %s '%s' has been closed, now closing it's amqp session '%s'.", this.connection.id, this.type, this.name, this.session.id);
                return this._session.close();
            }
        });
    }
    /**
     * Adds event listeners for the possible events that can occur on the link object and
     * re-emits the same event back with the received arguments from rhea's event emitter.
     * @private
     * @returns {void} void
     */
    _initializeEventListeners() {
        const events = this.type === LinkType.sender ? rhea_1.SenderEvents : rhea_1.ReceiverEvents;
        for (const eventName in events) {
            this._link.on(events[eventName], (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: events[eventName],
                    emitterType: this.type,
                    connectionId: this.connection.id
                };
                utils_1.emitEvent(params);
            });
        }
        if (typeof this._link.eventNames === "function") {
            log.eventHandler("[%s] rhea-promise '%s' object is listening for events: %o " +
                "emitted by rhea's '%s' object.", this.connection.id, this.type, this._link.eventNames(), this.type);
        }
        if (typeof this._link.listenerCount === "function") {
            log.eventHandler("[%s] ListenerCount for event '%s_error' on rhea's '%s' object is: %d.", this.connection.id, this.type, this.type, this._link.listenerCount(`${this.type}_error`));
        }
    }
}
exports.Link = Link;

},{"tslib":"fCvn","./log":"d1sB","rhea":"w9Vx","./util/utils":"w9fr","./entity":"G7IJ","./errorDefinitions":"vVcP"}],"Cr7S":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const link_1 = require("./link");
/**
 * Describes the receiver that wraps the rhea receiver.
 * @class Receiver.
 */
class Receiver extends link_1.Link {
    constructor(session, receiver, options) {
        super(link_1.LinkType.receiver, session, receiver, options);
    }
    get drain() {
        return this._link.drain;
    }
    set drain(value) {
        this._link.drain = value;
    }
    addCredit(credit) {
        this._link.add_credit(credit);
    }
    setCreditWindow(creditWindow) {
        this._link.set_credit_window(creditWindow);
    }
}
exports.Receiver = Receiver;

},{"./link":"b4Zd"}],"vnLO":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const link_1 = require("./link");
/**
 * Describes the base sender that wraps the rhea sender.
 * @class BaseSender
 */
class BaseSender extends link_1.Link {
    constructor(session, sender, options) {
        super(link_1.LinkType.sender, session, sender, options);
    }
    setDrained(drained) {
        this._link.set_drained(drained);
    }
    /**
     * Determines whether the message is sendable.
     * @returns {boolean} `true` Sendable. `false` Not Sendable.
     */
    sendable() {
        return this._link.sendable();
    }
}
exports.BaseSender = BaseSender;
/**
 * Describes the AMQP Sender.
 * @class Sender
 */
class Sender extends BaseSender {
    constructor(session, sender, options) {
        super(session, sender, options);
    }
    /**
     * Sends the message
     * @param {Message | Buffer} msg The message to be sent. For default AMQP format msg parameter
     * should be of type Message interface. For a custom format, the msg parameter should be a Buffer
     * and a valid value should be passed to the `format` argument.
     * @param {Buffer | string} [tag] The message tag if any.
     * @param {number} [format] The message format. Specify this if a message with custom format needs
     * to be sent. `0` implies the standard AMQP 1.0 defined format. If no value is provided, then the
     * given message is assumed to be of type Message interface and encoded appropriately.
     * @returns {Delivery} Delivery The delivery information about the sent message.
     */
    send(msg, tag, format) {
        return this._link.send(msg, tag, format);
    }
}
exports.Sender = Sender;

},{"./link":"b4Zd"}],"Cwy0":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const rhea_1 = require("rhea");
const log = require("./log");
const sender_1 = require("./sender");
const rhea_2 = require("rhea");
const errorDefinitions_1 = require("./errorDefinitions");
/**
 * Describes the sender where one can await on the message being sent.
 * @class AwaitableSender
 */
class AwaitableSender extends sender_1.BaseSender {
    constructor(session, sender, options = {}) {
        super(session, sender, options);
        /**
         * @property {Map<number, PromiseLike} deliveryDispositionMap Maintains a map of delivery of
         * messages that are being sent. It acts as a store for correlating the dispositions received
         * for sent messages.
         */
        this.deliveryDispositionMap = new Map();
        this.sendTimeoutInSeconds = options.sendTimeoutInSeconds || 20;
        /**
         * The handler that will be added on the Sender for `accepted` event. If the delivery id is
         * present in the disposition map then it will clear the timer and resolve the promise with the
         * delivery.
         * @param delivery Delivery associated with message that was sent.
         */
        const onSendSuccess = (delivery) => {
            const id = delivery.id;
            if (this.deliveryDispositionMap.has(delivery.id)) {
                const promise = this.deliveryDispositionMap.get(id);
                clearTimeout(promise.timer);
                const deleteResult = this.deliveryDispositionMap.delete(id);
                log.sender("[%s] Event: 'Accepted', Successfully deleted the delivery with id %d from " +
                    "the map of sender '%s' on amqp session '%s' and cleared the timer: %s.", this.connection.id, id, this.name, this.session.id, deleteResult);
                return promise.resolve(delivery);
            }
        };
        /**
         * The handler is added on the Sender for `rejected`, `released` and `modified` events.
         * If the delivery is found in the disposition map then the timer will be cleared and the
         * promise will be rejected with an appropriate error message.
         * @param eventName Name of the event that was raised.
         * @param id Delivery id.
         * @param error Error from the context if any.
         */
        const onSendFailure = (eventName, id, error) => {
            if (this.deliveryDispositionMap.has(id)) {
                const promise = this.deliveryDispositionMap.get(id);
                clearTimeout(promise.timer);
                const deleteResult = this.deliveryDispositionMap.delete(id);
                log.sender("[%s] Event: '%s', Successfully deleted the delivery with id %d from the " +
                    " map of sender '%s' on amqp session '%s' and cleared the timer: %s.", this.connection.id, eventName, id, this.name, this.session.id, deleteResult);
                const msg = `Sender '${this.name}' on amqp session '${this.session.id}', received a ` +
                    `'${eventName}' disposition. Hence we are rejecting the promise.`;
                const err = new errorDefinitions_1.SendOperationFailedError(msg, eventName, error);
                log.error("[%s] %s", this.connection.id, msg);
                return promise.reject(err);
            }
        };
        /**
         * The handler that will be added on the Sender link for `sender_error` and on it's underlying
         * session for `session_error` event. These events are raised when the sender link or it's
         * underlying session get disconnected.
         * The handler will clear the timer and reject the promise for every pending send in the map.
         * @param eventName Name of the event that was raised.
         * @param error Error from the context if any
         */
        const onError = (eventName, error) => {
            for (const id of this.deliveryDispositionMap.keys()) {
                onSendFailure(eventName, id, error);
            }
        };
        this.on(rhea_2.SenderEvents.accepted, (context) => {
            onSendSuccess(context.delivery);
        });
        this.on(rhea_2.SenderEvents.rejected, (context) => {
            const delivery = context.delivery;
            onSendFailure(rhea_2.SenderEvents.rejected, delivery.id, delivery.remote_state && delivery.remote_state.error);
        });
        this.on(rhea_2.SenderEvents.released, (context) => {
            const delivery = context.delivery;
            onSendFailure(rhea_2.SenderEvents.released, delivery.id, delivery.remote_state && delivery.remote_state.error);
        });
        this.on(rhea_2.SenderEvents.modified, (context) => {
            const delivery = context.delivery;
            onSendFailure(rhea_2.SenderEvents.modified, delivery.id, delivery.remote_state && delivery.remote_state.error);
        });
        // The user may have it's custom reconnect logic for bringing the sender link back online and
        // retry logic for sending messages on failures hence they can provide their error handlers
        // for `sender_error` and `session_error`.
        // If the user did not provide its error handler for `sender_error` and `session_error`,
        // then we add our handlers and make sure we clear the timer and reject the promise for sending
        // messages with appropriate Error.
        if (!options.onError) {
            this.on(rhea_2.SenderEvents.senderError, (context) => {
                onError(rhea_2.SenderEvents.senderError, context.sender.error);
            });
        }
        if (!options.onSessionError) {
            this.session.on(rhea_1.SessionEvents.sessionError, (context) => {
                onError(rhea_1.SessionEvents.sessionError, context.session.error);
            });
        }
    }
    /**
     * Sends the message on which one can await to ensure that the message has been successfully
     * delivered.
     * @param {Message | Buffer} msg The message to be sent. For default AMQP format msg parameter
     * should be of type Message interface. For a custom format, the msg parameter should be a Buffer
     * and a valid value should be passed to the `format` argument.
     * @param {Buffer | string} [tag] The message tag if any.
     * @param {number} [format] The message format. Specify this if a message with custom format needs
     * to be sent. `0` implies the standard AMQP 1.0 defined format. If no value is provided, then the
     * given message is assumed to be of type Message interface and encoded appropriately.
     * @returns {Promise<Delivery>} Promise<Delivery> The delivery information about the sent message.
     */
    send(msg, tag, format) {
        return new Promise((resolve, reject) => {
            log.sender("[%s] Sender '%s' on amqp session '%s', credit: %d available: %d", this.connection.id, this.name, this.session.id, this.credit, this.session.outgoing.available());
            if (this.sendable()) {
                const timer = setTimeout(() => {
                    this.deliveryDispositionMap.delete(delivery.id);
                    const message = `Sender '${this.name}' on amqp session ` +
                        `'${this.session.id}', with address '${this.address}' was not able to send the ` +
                        `message with delivery id ${delivery.id} right now, due to operation timeout.`;
                    log.error("[%s] %s", this.connection.id, message);
                    return reject(new errorDefinitions_1.OperationTimeoutError(message));
                }, this.sendTimeoutInSeconds * 1000);
                const delivery = this._link.send(msg, tag, format);
                this.deliveryDispositionMap.set(delivery.id, {
                    resolve: resolve,
                    reject: reject,
                    timer: timer
                });
            }
            else {
                // Please send the message after some time.
                const msg = `Sender "${this.name}" on amqp session "${this.session.id}", with address ` +
                    `${this.address} cannot send the message right now as it does not have ` +
                    `enough credit. Please try later.`;
                log.error("[%s] %s", this.connection.id, msg);
                reject(new errorDefinitions_1.InsufficientCreditError(msg));
            }
        });
    }
}
exports.AwaitableSender = AwaitableSender;

},{"rhea":"w9Vx","./log":"d1sB","./sender":"vnLO","./errorDefinitions":"vVcP"}],"MQRf":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const log = require("./log");
const receiver_1 = require("./receiver");
const sender_1 = require("./sender");
const rhea_1 = require("rhea");
const utils_1 = require("./util/utils");
const entity_1 = require("./entity");
const errorDefinitions_1 = require("./errorDefinitions");
const awaitableSender_1 = require("./awaitableSender");
/**
 * @internal
 */
var SenderType;
(function (SenderType) {
    SenderType["sender"] = "sender";
    SenderType["AwaitableSender"] = "AwaitableSender";
})(SenderType || (SenderType = {}));
/**
 * Describes the session that wraps the rhea session.
 * @class Session
 */
class Session extends entity_1.Entity {
    constructor(connection, session) {
        super();
        this._connection = connection;
        this._session = session;
        this._initializeEventListeners();
    }
    /**
     * @property {Connection} connection The underlying AMQP connection.
     * @readonly
     */
    get connection() {
        return this._connection;
    }
    get outgoing() {
        return this._session.outgoing;
    }
    get error() {
        return this._session.error;
    }
    /**
     * Returns the unique identifier for the session in the format:
     * "local_<number>-remote_<number>-<connection-id>" or an empty string if the local channel or
     * remote channel are not yet defined.
     */
    get id() {
        let result = "";
        const session = this._session;
        if (session.local) {
            result += `local-${session.local.channel}_`;
        }
        if (session.remote) {
            result += `remote-${session.remote.channel}_`;
        }
        if (result) {
            result += `${this._connection.id}`;
        }
        return result;
    }
    /**
     * Determines whether the session and the underlying connection is open.
     * @returns {boolean} result `true` - is open; `false` otherwise.
     */
    isOpen() {
        let result = false;
        if (this._connection.isOpen() && this._session.is_open()) {
            result = true;
        }
        return result;
    }
    /**
     * Determines whether the close from the peer is a response to a locally initiated close request.
     * @returns {boolean} `true` if close was locally initiated, `false` otherwise.
     */
    isClosed() {
        return this._session.is_closed();
    }
    /**
     * Determines whether both local and remote endpoint for just the session itself are closed.
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isItselfClosed() {
        return this._session.is_itself_closed();
    }
    /**
     * Removes the underlying amqp session from the internal map in rhea.
     * Also removes all the event handlers added in the rhea-promise library on the session.
     */
    remove() {
        if (this._session) {
            // Remove our listeners and listeners from rhea's 'session' object.
            this.removeAllListeners();
            this._session.removeAllListeners();
            this._session.remove();
        }
    }
    begin() {
        if (this._session) {
            this._session.begin();
        }
    }
    /**
     * Closes the underlying amqp session in rhea if open. Also removes all the event
     * handlers added in the rhea-promise library on the session
     * @return {Promise<void>} Promise<void>
     * - **Resolves** the promise when rhea emits the "session_close" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "session_error" event while trying
     * to close an amqp session.
     */
    close() {
        this.removeAllListeners();
        return new Promise((resolve, reject) => {
            log.error("[%s] The amqp session '%s' is open ? -> %s", this.connection.id, this.id, this.isOpen());
            if (this.isOpen()) {
                let onError;
                let onClose;
                let onDisconnected;
                let waitTimer;
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    this.actionInitiated--;
                    this._session.removeListener(rhea_1.SessionEvents.sessionError, onError);
                    this._session.removeListener(rhea_1.SessionEvents.sessionClose, onClose);
                    this._session.connection.removeListener(rhea_1.ConnectionEvents.disconnected, onDisconnected);
                };
                onClose = (context) => {
                    removeListeners();
                    log.session("[%s] Resolving the promise as the amqp session '%s' has been closed.", this.connection.id, this.id);
                    return resolve();
                };
                onError = (context) => {
                    removeListeners();
                    log.error("[%s] Error occurred while closing amqp session '%s'.", this.connection.id, this.id, context.session.error);
                    reject(context.session.error);
                };
                onDisconnected = (context) => {
                    removeListeners();
                    const error = context.connection && context.connection.error
                        ? context.connection.error
                        : context.error;
                    log.error("[%s] Connection got disconnected while closing amqp session '%s': %O.", this.connection.id, this.id, error);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const msg = `Unable to close the amqp session ${this.id} due to operation timeout.`;
                    log.error("[%s] %s", this.connection.id, msg);
                    reject(new errorDefinitions_1.OperationTimeoutError(msg));
                };
                // listeners that we add for completing the operation are added directly to rhea's objects.
                this._session.once(rhea_1.SessionEvents.sessionClose, onClose);
                this._session.once(rhea_1.SessionEvents.sessionError, onError);
                this._session.connection.once(rhea_1.ConnectionEvents.disconnected, onDisconnected);
                log.session("[%s] Calling session.close() for amqp session '%s'.", this.connection.id, this.id);
                waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
                this._session.close();
                this.actionInitiated++;
            }
            else {
                return resolve();
            }
        });
    }
    /**
     * Creates an amqp receiver on this session.
     * @param session The amqp session object on which the receiver link needs to be established.
     * @param options Options that can be provided while creating an amqp receiver.
     * @return Promise<Receiver>
     * - **Resolves** the promise with the Receiver object when rhea emits the "receiver_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "receiver_close" event while trying
     * to create an amqp receiver or the operation timeout occurs.
     */
    createReceiver(options) {
        return new Promise((resolve, reject) => {
            if (options &&
                ((options.onMessage && !options.onError) || (options.onError && !options.onMessage))) {
                if (options.credit_window !== 0) {
                    // - If the 'onMessage' handler is not provided and the credit_window is not set to 0,
                    // then messages may be lost between the receiver link getting created and the message
                    // handler being attached.
                    // - It can be possible for a service to initially accept the link attach, which would
                    // cause the promise to resolve. However, moments later the service may send a detach
                    // due to some internal or configuration issue. If no error handler is attached, then
                    // the error may fall through.
                    // - Hence it is advised to either provide both 'onMessage' and 'onError' handlers, or
                    // please set the credit_window to `0`, if you want to provide only the 'onError' handler.
                    return reject(new Error("Either provide both 'onMessage' and 'onError' handlers, or pl" +
                        "ease set the credit_window to 0, if you want to provide only the 'onError' " +
                        "handler. This ensures no messages are lost between the receiver getting created " +
                        " and the 'onMessage' handler being added."));
                }
            }
            // Register session handlers for session_error and session_close if provided.
            // listeners provided by the user in the options object should be added
            // to our (rhea-promise) object.
            if (options && options.onSessionError) {
                this.on(rhea_1.SessionEvents.sessionError, options.onSessionError);
                log.session("[%s] Added event handler for event '%s' on rhea-promise 'session: %s', " +
                    "while creating the 'receiver'.", this.connection.id, rhea_1.SessionEvents.sessionError, this.id);
            }
            if (options && options.onSessionClose) {
                this.on(rhea_1.SessionEvents.sessionClose, options.onSessionClose);
                log.session("[%s] Added event handler for event '%s' on rhea-promise 'session: %s', " +
                    " while creating the 'receiver'.", this.connection.id, rhea_1.SessionEvents.sessionClose, this.id);
            }
            const rheaReceiver = this._session.attach_receiver(options);
            const receiver = new receiver_1.Receiver(this, rheaReceiver, options);
            receiver.actionInitiated++;
            let onOpen;
            let onClose;
            let onDisconnected;
            let waitTimer;
            if (options && options.onMessage) {
                receiver.on(rhea_1.ReceiverEvents.message, options.onMessage);
                log.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, rhea_1.ReceiverEvents.message);
            }
            if (options && options.onError) {
                receiver.on(rhea_1.ReceiverEvents.receiverError, options.onError);
                log.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, rhea_1.ReceiverEvents.receiverError);
            }
            if (options && options.onClose) {
                receiver.on(rhea_1.ReceiverEvents.receiverClose, options.onClose);
                log.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, rhea_1.ReceiverEvents.receiverClose);
            }
            if (options && options.onSettled) {
                receiver.on(rhea_1.ReceiverEvents.settled, options.onSettled);
                log.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, rhea_1.ReceiverEvents.settled);
            }
            const removeListeners = () => {
                clearTimeout(waitTimer);
                receiver.actionInitiated--;
                rheaReceiver.removeListener(rhea_1.ReceiverEvents.receiverOpen, onOpen);
                rheaReceiver.removeListener(rhea_1.ReceiverEvents.receiverClose, onClose);
                rheaReceiver.session.connection.removeListener(rhea_1.ConnectionEvents.disconnected, onDisconnected);
            };
            onOpen = (context) => {
                removeListeners();
                log.receiver("[%s] Resolving the promise with amqp receiver '%s' on amqp session '%s'.", this.connection.id, receiver.name, this.id);
                return resolve(receiver);
            };
            onClose = (context) => {
                removeListeners();
                log.error("[%s] Error occurred while creating the amqp receiver '%s' on amqp session " +
                    "'%s' over amqp connection: %O.", this.connection.id, receiver.name, this.id, context.receiver.error);
                return reject(context.receiver.error);
            };
            onDisconnected = (context) => {
                removeListeners();
                const error = context.connection && context.connection.error
                    ? context.connection.error
                    : context.error;
                log.error("[%s] Connection got disconnected while creating amqp receiver '%s' on amqp " +
                    "session '%s': %O.", this.connection.id, receiver.name, this.id, error);
                return reject(error);
            };
            const actionAfterTimeout = () => {
                removeListeners();
                const msg = `Unable to create the amqp receiver '${receiver.name}' on amqp ` +
                    `session '${this.id}' due to operation timeout.`;
                log.error("[%s] %s", this.connection.id, msg);
                return reject(new errorDefinitions_1.OperationTimeoutError(msg));
            };
            // listeners that we add for completing the operation are added directly to rhea's objects.
            rheaReceiver.once(rhea_1.ReceiverEvents.receiverOpen, onOpen);
            rheaReceiver.once(rhea_1.ReceiverEvents.receiverClose, onClose);
            rheaReceiver.session.connection.on(rhea_1.ConnectionEvents.disconnected, onDisconnected);
            waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
        });
    }
    /**
     * Creates an amqp sender on this session.
     * @param options Options that can be provided while creating an amqp sender.
     * @return Promise<Sender>
     * - **Resolves** the promise with the Sender object when rhea emits the "sender_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "sender_close" event while trying
     * to create an amqp sender or the operation timeout occurs.
     */
    createSender(options) {
        return this._createSender(SenderType.sender, options);
    }
    /**
     * Creates an awaitable amqp sender on this session.
     * @param options Options that can be provided while creating an async amqp sender.
     * - If `onError` and `onSessionError` handlers are not provided then the `AwaitableSender` will
     * clear the timer and reject the Promise for all the entries of inflight send operation in its
     * `deliveryDispositionMap`.
     * - If the user is handling the reconnection of sender link or the underlying connection in it's
     * app, then the `onError` and `onSessionError` handlers must be provided by the user and (s)he
     * shall be responsible of clearing the `deliveryDispotionMap` of inflight `send()` operation.
     *
     * @return Promise<AwaitableSender>
     * - **Resolves** the promise with the Sender object when rhea emits the "sender_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "sender_close" event while trying
     * to create an amqp sender or the operation timeout occurs.
     */
    createAwaitableSender(options) {
        return this._createSender(SenderType.AwaitableSender, options);
    }
    /**
     * Creates the Sender based on the provided type.
     * @internal
     * @param type The type of sender
     * @param options Options to be provided while creating the sender.
     */
    _createSender(type, options) {
        return new Promise((resolve, reject) => {
            // Register session handlers for session_error and session_close if provided.
            if (options && options.onSessionError) {
                this.on(rhea_1.SessionEvents.sessionError, options.onSessionError);
                log.session("[%s] Added event handler for event '%s' on rhea-promise 'session: %s', " +
                    "while creating the sender.", this.connection.id, rhea_1.SessionEvents.sessionError, this.id);
            }
            if (options && options.onSessionClose) {
                this.on(rhea_1.SessionEvents.sessionClose, options.onSessionClose);
                log.session("[%s] Added event handler for event '%s' on rhea-promise 'session: %s', " +
                    "while creating the sender.", this.connection.id, rhea_1.SessionEvents.sessionClose, this.id);
            }
            const rheaSender = this._session.attach_sender(options);
            let sender;
            if (type === SenderType.sender) {
                sender = new sender_1.Sender(this, rheaSender, options);
            }
            else {
                sender = new awaitableSender_1.AwaitableSender(this, rheaSender, options);
            }
            sender.actionInitiated++;
            let onSendable;
            let onClose;
            let onDisconnected;
            let waitTimer;
            // listeners provided by the user in the options object should be added
            // to our (rhea-promise) object.
            if (options) {
                if (options.onError) {
                    sender.on(rhea_1.SenderEvents.senderError, options.onError);
                }
                if (options.onClose) {
                    sender.on(rhea_1.SenderEvents.senderClose, options.onClose);
                }
                if (type === SenderType.sender) {
                    if (options.onAccepted) {
                        sender.on(rhea_1.SenderEvents.accepted, options.onAccepted);
                    }
                    if (options.onRejected) {
                        sender.on(rhea_1.SenderEvents.rejected, options.onRejected);
                    }
                    if (options.onReleased) {
                        sender.on(rhea_1.SenderEvents.released, options.onReleased);
                    }
                    if (options.onModified) {
                        sender.on(rhea_1.SenderEvents.modified, options.onModified);
                    }
                }
            }
            const removeListeners = () => {
                clearTimeout(waitTimer);
                sender.actionInitiated--;
                rheaSender.removeListener(rhea_1.SenderEvents.senderOpen, onSendable);
                rheaSender.removeListener(rhea_1.SenderEvents.senderClose, onClose);
                rheaSender.session.connection.removeListener(rhea_1.ConnectionEvents.disconnected, onDisconnected);
            };
            onSendable = (context) => {
                removeListeners();
                log.sender("[%s] Resolving the promise with amqp sender '%s' on amqp session '%s'.", this.connection.id, sender.name, this.id);
                return resolve(sender);
            };
            onClose = (context) => {
                removeListeners();
                log.error("[%s] Error occurred while creating the amqp sender '%s' on amqp session '%s' " +
                    "over amqp connection: %O.", this.connection.id, sender.name, this.id, context.sender.error);
                return reject(context.sender.error);
            };
            onDisconnected = (context) => {
                removeListeners();
                const error = context.connection && context.connection.error
                    ? context.connection.error
                    : context.error;
                log.error("[%s] Connection got disconnected while creating amqp sender '%s' on amqp " +
                    "session '%s': %O.", this.connection.id, sender.name, this.id, error);
                return reject(error);
            };
            const actionAfterTimeout = () => {
                removeListeners();
                const msg = `Unable to create the amqp sender '${sender.name}' on amqp session ` +
                    `'${this.id}' due to operation timeout.`;
                log.error("[%s] %s", this.connection.id, msg);
                return reject(new errorDefinitions_1.OperationTimeoutError(msg));
            };
            // listeners that we add for completing the operation are added directly to rhea's objects.
            rheaSender.once(rhea_1.SenderEvents.sendable, onSendable);
            rheaSender.once(rhea_1.SenderEvents.senderClose, onClose);
            rheaSender.session.connection.on(rhea_1.ConnectionEvents.disconnected, onDisconnected);
            waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
        });
    }
    /**
     * Adds event listeners for the possible events that can occur on the session object and
     * re-emits the same event back with the received arguments from rhea's event emitter.
     * @private
     * @returns {void} void
     */
    _initializeEventListeners() {
        for (const eventName in rhea_1.SessionEvents) {
            this._session.on(rhea_1.SessionEvents[eventName], (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: rhea_1.SessionEvents[eventName],
                    emitterType: "session",
                    connectionId: this.connection.id
                };
                utils_1.emitEvent(params);
            });
        }
        // Add event handlers for *_error and *_close events that can be propogated to the session
        // object, if they are not handled at their level. * denotes - Sender and Receiver.
        // Sender
        this._session.on(rhea_1.SenderEvents.senderError, (context) => {
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: rhea_1.SenderEvents.senderError,
                emitterType: "session",
                connectionId: this.connection.id
            };
            utils_1.emitEvent(params);
        });
        this._session.on(rhea_1.SenderEvents.senderClose, (context) => {
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: rhea_1.SenderEvents.senderClose,
                emitterType: "session",
                connectionId: this.connection.id
            };
            utils_1.emitEvent(params);
        });
        // Receiver
        this._session.on(rhea_1.ReceiverEvents.receiverError, (context) => {
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: rhea_1.ReceiverEvents.receiverError,
                emitterType: "session",
                connectionId: this.connection.id
            };
            utils_1.emitEvent(params);
        });
        this._session.on(rhea_1.ReceiverEvents.receiverClose, (context) => {
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: rhea_1.ReceiverEvents.receiverClose,
                emitterType: "session",
                connectionId: this.connection.id
            };
            utils_1.emitEvent(params);
        });
        if (typeof this._session.eventNames === "function") {
            log.eventHandler("[%s] rhea-promise 'session' object '%s' is listening for events: %o " +
                "emitted by rhea's 'session' object.", this.connection.id, this.id, this._session.eventNames());
        }
    }
}
exports.Session = Session;

},{"./log":"d1sB","./receiver":"Cr7S","./sender":"vnLO","rhea":"w9Vx","./util/utils":"w9fr","./entity":"G7IJ","./errorDefinitions":"vVcP","./awaitableSender":"Cwy0"}],"O6Cg":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const rhea_1 = require("rhea");
const events_1 = require("events");
const connection_1 = require("./connection");
/**
 * An AMQP container from which outgoing connections can be made and/or
 * to which incoming connections can be accepted.
 * @class Container
 */
class Container extends events_1.EventEmitter {
    constructor(options) {
        if (!options)
            options = {};
        super();
        if (options.createdInstance) {
            this._container = options.createdInstance;
            delete options.createdInstance;
        }
        else {
            this._container = rhea_1.create_container(options);
        }
        this.options = this._container.options;
    }
    get id() {
        return this._container.id;
    }
    get filter() {
        return this._container.filter;
    }
    get types() {
        return this._container.types;
    }
    get message() {
        return this._container.message;
    }
    get sasl() {
        return this._container.sasl;
    }
    get saslServerMechanisms() {
        return this._container.sasl_server_mechanisms;
    }
    createConnection(options) {
        const rheaConnection = this._container.create_connection(options);
        return new connection_1.Connection({ rheaConnection: rheaConnection, container: this });
    }
    connect(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.createConnection(options).open();
        });
    }
    listen(options) {
        return this._container.listen(options);
    }
    generateUUid() {
        return this._container.generate_uuid();
    }
    stringToUuid(uuidString) {
        return this._container.string_to_uuid(uuidString);
    }
    uuidToString(buffer) {
        return this._container.uuid_to_string(buffer);
    }
    websocketAccept(socket, options) {
        return this._container.websocket_accept(socket, options);
    }
    websocketConnect(impl) {
        return this._container.websocket_connect(impl);
    }
    static create(options) {
        return new Container(options);
    }
    static copyFromContainerInstance(instance) {
        return new Container({ createdInstance: instance });
    }
}
exports.Container = Container;

},{"tslib":"fCvn","rhea":"w9Vx","events":"wIHY","./connection":"XuC1"}],"XozP":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Describes the default operation timeout in seconds. Value: `60`.
 */
exports.defaultOperationTimeoutInSeconds = 60;

},{}],"XuC1":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const log = require("./log");
const session_1 = require("./session");
const container_1 = require("./container");
const constants_1 = require("./util/constants");
const utils_1 = require("./util/utils");
const rhea_1 = require("rhea");
const entity_1 = require("./entity");
const errorDefinitions_1 = require("./errorDefinitions");
// Determines whether the given object is a CreatedRheConnectionOptions object.
function isCreatedRheaConnectionOptions(obj) {
    return (obj && typeof obj.container === "object" && typeof obj.rheaConnection === "object");
}
/**
 * Descibes the AQMP Connection.
 * @class Connection
 */
class Connection extends entity_1.Entity {
    /**
     * Creates an instance of the Connection object.
     * @constructor
     * @param {Connection} _connection The connection object from rhea library.
     */
    constructor(options) {
        super();
        if (!options)
            options = {};
        if (options.operationTimeoutInSeconds == undefined) {
            options.operationTimeoutInSeconds = constants_1.defaultOperationTimeoutInSeconds;
        }
        if (isCreatedRheaConnectionOptions(options)) {
            this._connection = options.rheaConnection;
            this.container = options.container;
        }
        else {
            const connectionOptions = options;
            if (connectionOptions.webSocketOptions) {
                const ws = rhea_1.websocket_connect(connectionOptions.webSocketOptions.webSocket);
                connectionOptions.connection_details = ws(connectionOptions.webSocketOptions.url, connectionOptions.webSocketOptions.protocol, connectionOptions.webSocketOptions.options);
            }
            this._connection = rhea_1.create_connection(connectionOptions);
            this.container = container_1.Container.copyFromContainerInstance(this._connection.container);
        }
        this.options = this._connection.options;
        this.options.operationTimeoutInSeconds = options.operationTimeoutInSeconds;
        this._initializeEventListeners();
    }
    /**
     * @property {string} id Returns the connection id.
     * @readonly
     */
    get id() {
        return this._connection.options.id;
    }
    /**
     * @property {Dictionary<any> | undefined} [properties] Provides the connection properties.
     * @readonly
     */
    get properties() {
        return this._connection.properties;
    }
    /**
     * @property {number | undefined} [maxFrameSize] Provides the max frame size.
     * @readonly
     */
    get maxFrameSize() {
        return this._connection.max_frame_size;
    }
    /**
     * @property {number | undefined} [idleTimeout] Provides the idle timeout for the connection.
     * @readonly
     */
    get idleTimeout() {
        return this._connection.idle_time_out;
    }
    /**
     * @property {number | undefined} [channelMax] Provides the maximum number of channels supported.
     * @readonly
     */
    get channelMax() {
        return this._connection.channel_max;
    }
    /**
     * @property {AmqpError | Error | undefined} [error] Provides the last error that occurred on the
     * connection.
     */
    get error() {
        return this._connection.error;
    }
    /**
     * Removes the provided session from the internal map in rhea.
     * Also removes all the event handlers added in the rhea-promise library on the provided session.
     * @param {Session} session The session to be removed.
     */
    removeSession(session) {
        return session.remove();
    }
    /**
     * Creates a new amqp connection.
     * @return {Promise<Connection>} Promise<Connection>
     * - **Resolves** the promise with the Connection object when rhea emits the "connection_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "connection_close" event
     * while trying to establish an amqp connection.
     */
    open() {
        return new Promise((resolve, reject) => {
            if (!this.isOpen()) {
                let onOpen;
                let onClose;
                let waitTimer;
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    this.actionInitiated--;
                    this._connection.removeListener(rhea_1.ConnectionEvents.connectionOpen, onOpen);
                    this._connection.removeListener(rhea_1.ConnectionEvents.connectionClose, onClose);
                    this._connection.removeListener(rhea_1.ConnectionEvents.disconnected, onClose);
                };
                onOpen = (context) => {
                    removeListeners();
                    log.connection("[%s] Resolving the promise with amqp connection.", this.id);
                    return resolve(this);
                };
                onClose = (context) => {
                    removeListeners();
                    const err = context.error || context.connection.error || Error('Failed to connect');
                    log.error("[%s] Error occurred while establishing amqp connection: %O", this.id, err);
                    return reject(err);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const msg = `Unable to open the amqp connection "${this.id}" due to operation timeout.`;
                    log.error("[%s] %s", this.id, msg);
                    return reject(new Error(msg));
                };
                // listeners that we add for completing the operation are added directly to rhea's objects.
                this._connection.once(rhea_1.ConnectionEvents.connectionOpen, onOpen);
                this._connection.once(rhea_1.ConnectionEvents.connectionClose, onClose);
                this._connection.once(rhea_1.ConnectionEvents.disconnected, onClose);
                waitTimer = setTimeout(actionAfterTimeout, this.options.operationTimeoutInSeconds * 1000);
                log.connection("[%s] Trying to create a new amqp connection.", this.id);
                this._connection.connect();
                this.actionInitiated++;
            }
            else {
                return resolve(this);
            }
        });
    }
    /**
     * Closes the amqp connection.
     * @return {Promise<void>} Promise<void>
     * - **Resolves** the promise when rhea emits the "connection_close" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "connection_error" event while
     * trying to close an amqp connection.
     */
    close() {
        return new Promise((resolve, reject) => {
            log.error("[%s] The connection is open ? -> %s", this.id, this.isOpen());
            if (this.isOpen()) {
                let onClose;
                let onError;
                let onDisconnected;
                let waitTimer;
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    this.actionInitiated--;
                    this._connection.removeListener(rhea_1.ConnectionEvents.connectionError, onError);
                    this._connection.removeListener(rhea_1.ConnectionEvents.connectionClose, onClose);
                    this._connection.removeListener(rhea_1.ConnectionEvents.disconnected, onDisconnected);
                };
                onClose = (context) => {
                    removeListeners();
                    log.connection("[%s] Resolving the promise as the connection has been successfully closed.", this.id);
                    return resolve();
                };
                onError = (context) => {
                    removeListeners();
                    log.error("[%s] Error occurred while closing amqp connection: %O.", this.id, context.connection.error);
                    return reject(context.connection.error);
                };
                onDisconnected = (context) => {
                    removeListeners();
                    const error = context.connection && context.connection.error
                        ? context.connection.error
                        : context.error;
                    log.error("[%s] Connection got disconnected while closing itself: %O.", this.id, error);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const msg = `Unable to close the amqp connection "${this.id}" due to operation timeout.`;
                    log.error("[%s] %s", this.id, msg);
                    return reject(new Error(msg));
                };
                // listeners that we add for completing the operation are added directly to rhea's objects.
                this._connection.once(rhea_1.ConnectionEvents.connectionClose, onClose);
                this._connection.once(rhea_1.ConnectionEvents.connectionError, onError);
                this._connection.once(rhea_1.ConnectionEvents.disconnected, onDisconnected);
                waitTimer = setTimeout(actionAfterTimeout, this.options.operationTimeoutInSeconds * 1000);
                this._connection.close();
                this.actionInitiated++;
            }
            else {
                return resolve();
            }
        });
    }
    /**
     * Determines whether the connection is open.
     * @returns {boolean} result `true` - is open; `false` otherwise.
     */
    isOpen() {
        let result = false;
        if (this._connection && this._connection.is_open && this._connection.is_open()) {
            result = true;
        }
        return result;
    }
    /**
     * Clears all the amqp sessions from the internal map maintained in rhea. This does not remove any
     * of the event handlers added in the rhea-promise library. To clear such event handlers, either
     * call remove() or close() on each session
     */
    removeAllSessions() {
        if (this._connection) {
            this._connection.remove_all_sessions();
        }
    }
    /**
     * Determines whether the remote end of the connection is open.
     * @returns {boolean} result `true` - is open; `false` otherwise.
     */
    isRemoteOpen() {
        return this._connection.is_remote_open();
    }
    /**
     * Gets the connection error if present.
     * @returns {ConnectionError | undefined} ConnectionError | undefined
     */
    getError() {
        return this._connection.get_error();
    }
    /**
     * Gets the peer certificate if present.
     * @returns {PeerCertificate | undefined} PeerCertificate | undefined
     */
    getPeerCertificate() {
        return this._connection.get_peer_certificate();
    }
    /**
     * Gets the tls socket if present.
     * @returns {Socket | undefined} Socket | undefined
     */
    getTlsSocket() {
        return this._connection.get_tls_socket();
    }
    /**
     * Determines whether the close from the peer is a response to a locally initiated close request
     * for the connection.
     * @returns {boolean} `true` if close was locally initiated, `false` otherwise.
     */
    wasCloseInitiated() {
        return this._connection.is_closed();
    }
    /**
     * Creates an amqp session on the provided amqp connection.
     * @return {Promise<Session>} Promise<Session>
     * - **Resolves** the promise with the Session object when rhea emits the "session_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "session_close" event while
     * trying to create an amqp session.
     */
    createSession() {
        return new Promise((resolve, reject) => {
            const rheaSession = this._connection.create_session();
            const session = new session_1.Session(this, rheaSession);
            session.actionInitiated++;
            let onOpen;
            let onClose;
            let onDisconnected;
            let waitTimer;
            const removeListeners = () => {
                clearTimeout(waitTimer);
                session.actionInitiated--;
                rheaSession.removeListener(rhea_1.SessionEvents.sessionOpen, onOpen);
                rheaSession.removeListener(rhea_1.SessionEvents.sessionClose, onClose);
                rheaSession.connection.removeListener(rhea_1.ConnectionEvents.disconnected, onDisconnected);
            };
            onOpen = (context) => {
                removeListeners();
                log.session("[%s] Resolving the promise with amqp session '%s'.", this.id, session.id);
                return resolve(session);
            };
            onClose = (context) => {
                removeListeners();
                log.error("[%s] Error occurred while establishing a session over amqp connection: %O.", this.id, context.session.error);
                return reject(context.session.error);
            };
            onDisconnected = (context) => {
                removeListeners();
                const error = context.connection && context.connection.error
                    ? context.connection.error
                    : context.error;
                log.error("[%s] Connection got disconnected while creating amqp session '%s': %O.", this.id, session.id, error);
                return reject(error);
            };
            const actionAfterTimeout = () => {
                removeListeners();
                const msg = `Unable to create the amqp session due to operation timeout.`;
                log.error("[%s] %s", this.id, msg);
                return reject(new errorDefinitions_1.OperationTimeoutError(msg));
            };
            // listeners that we add for completing the operation are added directly to rhea's objects.
            rheaSession.once(rhea_1.SessionEvents.sessionOpen, onOpen);
            rheaSession.once(rhea_1.SessionEvents.sessionClose, onClose);
            rheaSession.connection.once(rhea_1.ConnectionEvents.disconnected, onDisconnected);
            log.session("[%s] Calling amqp session.begin().", this.id);
            waitTimer = setTimeout(actionAfterTimeout, this.options.operationTimeoutInSeconds * 1000);
            rheaSession.begin();
        });
    }
    /**
     * Creates an amqp sender link. It either uses the provided session or creates a new one.
     * @param {SenderOptionsWithSession} options Optional parameters to create a sender link.
     * @return {Promise<Sender>} Promise<Sender>.
     */
    createSender(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (options && options.session && options.session.createSender) {
                return options.session.createSender(options);
            }
            const session = yield this.createSession();
            return session.createSender(options);
        });
    }
    /**
     * Creates an awaitable amqp sender. It either uses the provided session or creates a new one.
     * @param options Optional parameters to create an awaitable sender link.
     * - If `onError` and `onSessionError` handlers are not provided then the `AwaitableSender` will
     * clear the timer and reject the Promise for all the entries of inflight send operation in its
     * `deliveryDispositionMap`.
     * - If the user is handling the reconnection of sender link or the underlying connection in it's
     * app, then the `onError` and `onSessionError` handlers must be provided by the user and (s)he
     * shall be responsible of clearing the `deliveryDispotionMap` of inflight `send()` operation.
     *
     * @return Promise<AwaitableSender>.
     */
    createAwaitableSender(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (options && options.session && options.session.createAwaitableSender) {
                return options.session.createAwaitableSender(options);
            }
            const session = yield this.createSession();
            return session.createAwaitableSender(options);
        });
    }
    /**
     * Creates an amqp receiver link. It either uses the provided session or creates a new one.
     * @param {ReceiverOptionsWithSession} options Optional parameters to create a receiver link.
     * @return {Promise<Receiver>} Promise<Receiver>.
     */
    createReceiver(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (options && options.session && options.session.createReceiver) {
                return options.session.createReceiver(options);
            }
            const session = yield this.createSession();
            return session.createReceiver(options);
        });
    }
    /**
     * Creates an amqp sender-receiver link. It either uses the provided session or creates a new one.
     * This method creates a sender-receiver link on the same session. It is useful for management
     * style operations where one may want to send a request and await for response.
     * @param {SenderOptions} senderOptions Parameters to create a sender.
     * @param {ReceiverOptions} receiverOptions Parameters to create a receiver.
     * @param {Session} [session] The optional session on which the sender and receiver links will be
     * created.
     * @return {Promise<ReqResLink>} Promise<ReqResLink>
     */
    createRequestResponseLink(senderOptions, receiverOptions, providedSession) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!senderOptions) {
                throw new Error(`Please provide sender options.`);
            }
            if (!receiverOptions) {
                throw new Error(`Please provide receiver options.`);
            }
            const session = providedSession || (yield this.createSession());
            const [sender, receiver] = yield Promise.all([
                session.createSender(senderOptions),
                session.createReceiver(receiverOptions)
            ]);
            log.connection("[%s] Successfully created the sender '%s' and receiver '%s' on the same " +
                "amqp session '%s'.", this.id, sender.name, receiver.name, session.id);
            return {
                session: session,
                sender: sender,
                receiver: receiver
            };
        });
    }
    /**
     * Adds event listeners for the possible events that can occur on the connection object and
     * re-emits the same event back with the received arguments from rhea's event emitter.
     * @private
     * @returns {void} void
     */
    _initializeEventListeners() {
        for (const eventName in rhea_1.ConnectionEvents) {
            this._connection.on(rhea_1.ConnectionEvents[eventName], (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: rhea_1.ConnectionEvents[eventName],
                    emitterType: "connection",
                    connectionId: this.id
                };
                if (eventName === rhea_1.ConnectionEvents.protocolError) {
                    log.connection("[%s] ProtocolError is: %O.", this.id, context);
                }
                utils_1.emitEvent(params);
            });
        }
        // Add event handlers for *_error and *_close events that can be propogated to the connection
        // object, if they are not handled at their level. * denotes - Sender, Receiver, Session
        // Sender
        this._connection.on(rhea_1.SenderEvents.senderError, (context) => {
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: rhea_1.SenderEvents.senderError,
                emitterType: "connection",
                connectionId: this.id
            };
            utils_1.emitEvent(params);
        });
        this._connection.on(rhea_1.SenderEvents.senderClose, (context) => {
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: rhea_1.SenderEvents.senderClose,
                emitterType: "connection",
                connectionId: this.id
            };
            utils_1.emitEvent(params);
        });
        // Receiver
        this._connection.on(rhea_1.ReceiverEvents.receiverError, (context) => {
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: rhea_1.ReceiverEvents.receiverError,
                emitterType: "connection",
                connectionId: this.id
            };
            utils_1.emitEvent(params);
        });
        this._connection.on(rhea_1.ReceiverEvents.receiverClose, (context) => {
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: rhea_1.ReceiverEvents.receiverClose,
                emitterType: "connection",
                connectionId: this.id
            };
            utils_1.emitEvent(params);
        });
        // Session
        this._connection.on(rhea_1.SessionEvents.sessionError, (context) => {
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: rhea_1.SessionEvents.sessionError,
                emitterType: "connection",
                connectionId: this.id
            };
            utils_1.emitEvent(params);
        });
        this._connection.on(rhea_1.SessionEvents.sessionClose, (context) => {
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: rhea_1.SessionEvents.sessionClose,
                emitterType: "connection",
                connectionId: this.id
            };
            utils_1.emitEvent(params);
        });
        if (typeof this._connection.eventNames === "function") {
            log.eventHandler("[%s] rhea-promise 'connection' object is listening for events: %o " +
                "emitted by rhea's 'connection' object.", this.id, this._connection.eventNames());
        }
    }
}
exports.Connection = Connection;

},{"tslib":"fCvn","./log":"d1sB","./session":"MQRf","./container":"O6Cg","./util/constants":"XozP","./util/utils":"w9fr","rhea":"w9Vx","./entity":"G7IJ","./errorDefinitions":"vVcP"}],"AAmz":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const connection_1 = require("./connection");
const session_1 = require("./session");
const link_1 = require("./link");
const log = require("./log");
var EventContext;
(function (EventContext) {
    /**
     * Translates rhea's EventContext into rhea-promise EventContext
     * @param rheaContext The received context from rhea's event emitter
     * @param emitter The rhea-promise equivalent object that is supposed emit the same event
     * @param eventName The name of the event for which the context will be translated
     *
     * @returns EventContext The translated EventContext.
     */
    function translate(rheaContext, emitter, eventName) {
        const connection = emitter instanceof connection_1.Connection
            ? emitter
            : emitter.connection;
        log.contextTranslator("[%s] Translating the context for event: '%s'.", connection.id, eventName);
        // initialize the result
        const result = Object.assign({ _context: rheaContext }, rheaContext);
        // set rhea-promise connection and container
        result.connection = connection;
        result.container = connection.container;
        // set rhea-promise session, sender/receiver.
        if (emitter instanceof link_1.Link) {
            result.session = emitter.session;
            if (emitter.type === link_1.LinkType.receiver && rheaContext.receiver) {
                result.receiver = emitter;
            }
            else if (emitter.type === link_1.LinkType.sender && rheaContext.sender) {
                result.sender = emitter;
            }
        }
        else if (emitter instanceof session_1.Session) {
            result.session = emitter;
        }
        return result;
    }
    EventContext.translate = translate;
})(EventContext = exports.EventContext || (exports.EventContext = {}));

},{"./connection":"XuC1","./session":"MQRf","./link":"b4Zd","./log":"d1sB"}],"fxSK":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
var rhea_1 = require("rhea");
exports.types = rhea_1.types;
exports.message = rhea_1.message;
exports.filter = rhea_1.filter;
exports.uuid_to_string = rhea_1.uuid_to_string;
exports.generate_uuid = rhea_1.generate_uuid;
exports.string_to_uuid = rhea_1.string_to_uuid;
exports.ReceiverEvents = rhea_1.ReceiverEvents;
exports.SenderEvents = rhea_1.SenderEvents;
exports.ConnectionEvents = rhea_1.ConnectionEvents;
exports.SessionEvents = rhea_1.SessionEvents;
exports.Typed = rhea_1.Typed;
var eventContext_1 = require("./eventContext");
exports.EventContext = eventContext_1.EventContext;
var container_1 = require("./container");
exports.Container = container_1.Container;
var connection_1 = require("./connection");
exports.Connection = connection_1.Connection;
var session_1 = require("./session");
exports.Session = session_1.Session;
var receiver_1 = require("./receiver");
exports.Receiver = receiver_1.Receiver;
var sender_1 = require("./sender");
exports.Sender = sender_1.Sender;
var awaitableSender_1 = require("./awaitableSender");
exports.AwaitableSender = awaitableSender_1.AwaitableSender;
var utils_1 = require("./util/utils");
exports.AmqpResponseStatusCode = utils_1.AmqpResponseStatusCode;
exports.isAmqpError = utils_1.isAmqpError;
exports.delay = utils_1.delay;
exports.messageHeader = utils_1.messageHeader;
exports.messageProperties = utils_1.messageProperties;
exports.parseConnectionString = utils_1.parseConnectionString;
var errorDefinitions_1 = require("./errorDefinitions");
exports.InsufficientCreditError = errorDefinitions_1.InsufficientCreditError;
exports.OperationTimeoutError = errorDefinitions_1.OperationTimeoutError;
exports.SendOperationFailedError = errorDefinitions_1.SendOperationFailedError;

},{"rhea":"w9Vx","./eventContext":"AAmz","./container":"O6Cg","./connection":"XuC1","./session":"MQRf","./receiver":"Cr7S","./sender":"vnLO","./awaitableSender":"Cwy0","./util/utils":"w9fr","./errorDefinitions":"vVcP"}],"yffp":[function(require,module,exports) {
var process = require("process");
'use strict';

var AsyncLock = function (opts) {
	opts = opts || {};

	this.Promise = opts.Promise || Promise;

	// format: {key : [fn, fn]}
	// queues[key] = null indicates no job running for key
	this.queues = Object.create(null);

	// lock is reentrant for same domain
	this.domainReentrant = opts.domainReentrant || false;
	if (this.domainReentrant) {
		if (typeof process === 'undefined' || typeof process.domain === 'undefined') {
			throw new Error(
				'Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, ' +
				'use a NodeJS version that still implements Domain, or install a browser polyfill.');
		}
		// domain of current running func {key : fn}
		this.domains = Object.create(null);
	}

	this.timeout = opts.timeout || AsyncLock.DEFAULT_TIMEOUT;
	if (opts.maxPending === Infinity || (Number.isInteger(opts.maxPending) && opts.maxPending >= 0)) {
		this.maxPending = opts.maxPending;
	} else {
		this.maxPending = AsyncLock.DEFAULT_MAX_PENDING;
	}
};

AsyncLock.DEFAULT_TIMEOUT = 0; //Never
AsyncLock.DEFAULT_MAX_PENDING = 1000;

/**
 * Acquire Locks
 *
 * @param {String|Array} key 	resource key or keys to lock
 * @param {function} fn 	async function
 * @param {function} cb 	callback function, otherwise will return a promise
 * @param {Object} opts 	options
 */
AsyncLock.prototype.acquire = function (key, fn, cb, opts) {
	if (Array.isArray(key)) {
		return this._acquireBatch(key, fn, cb, opts);
	}

	if (typeof (fn) !== 'function') {
		throw new Error('You must pass a function to execute');
	}

	// faux-deferred promise using new Promise() (as Promise.defer is deprecated)
	var deferredResolve = null;
	var deferredReject = null;
	var deferred = null;

	if (typeof (cb) !== 'function') {
		opts = cb;
		cb = null;

		// will return a promise
		deferred = new this.Promise(function(resolve, reject) {
			deferredResolve = resolve;
			deferredReject = reject;
		});
	}

	opts = opts || {};

	var resolved = false;
	var timer = null;
	var self = this;

	var done = function (locked, err, ret) {
		if (locked) {
			if (self.queues[key].length === 0) {
				delete self.queues[key];
			}
			if (self.domainReentrant) {
				delete self.domains[key];
			}
		}

		if (!resolved) {
			if (!deferred) {
				if (typeof (cb) === 'function') {
					cb(err, ret);
				}
			}
			else {
				//promise mode
				if (err) {
					deferredReject(err);
				}
				else {
					deferredResolve(ret);
				}
			}
			resolved = true;
		}

		if (locked) {
			//run next func
			if (!!self.queues[key] && self.queues[key].length > 0) {
				self.queues[key].shift()();
			}
		}
	};

	var exec = function (locked) {
		if (resolved) { // may due to timed out
			return done(locked);
		}

		if (timer) {
			clearTimeout(timer);
			timer = null;
		}

		if (self.domainReentrant && locked) {
			self.domains[key] = process.domain;
		}

		// Callback mode
		if (fn.length === 1) {
			var called = false;
			fn(function (err, ret) {
				if (!called) {
					called = true;
					done(locked, err, ret);
				}
			});
		}
		else {
			// Promise mode
			self._promiseTry(function () {
				return fn();
			})
			.then(function(ret){
				done(locked, undefined, ret);
			}, function(error){
				done(locked, error);
			});
		}
	};
	if (self.domainReentrant && !!process.domain) {
		exec = process.domain.bind(exec);
	}

	if (!self.queues[key]) {
		self.queues[key] = [];
		exec(true);
	}
	else if (self.domainReentrant && !!process.domain && process.domain === self.domains[key]) {
		// If code is in the same domain of current running task, run it directly
		// Since lock is re-enterable
		exec(false);
	}
	else if (self.queues[key].length >= self.maxPending) {
		done(false, new Error('Too much pending tasks'));
	}
	else {
		var taskFn = function () {
			exec(true);
		};
		if (opts.skipQueue) {
			self.queues[key].unshift(taskFn);
		} else {
			self.queues[key].push(taskFn);
		}

		var timeout = opts.timeout || self.timeout;
		if (timeout) {
			timer = setTimeout(function () {
				timer = null;
				done(false, new Error('async-lock timed out'));
			}, timeout);
		}
	}

	if (deferred) {
		return deferred;
	}
};

/*
 * Below is how this function works:
 *
 * Equivalent code:
 * self.acquire(key1, function(cb){
 *     self.acquire(key2, function(cb){
 *         self.acquire(key3, fn, cb);
 *     }, cb);
 * }, cb);
 *
 * Equivalent code:
 * var fn3 = getFn(key3, fn);
 * var fn2 = getFn(key2, fn3);
 * var fn1 = getFn(key1, fn2);
 * fn1(cb);
 */
AsyncLock.prototype._acquireBatch = function (keys, fn, cb, opts) {
	if (typeof (cb) !== 'function') {
		opts = cb;
		cb = null;
	}

	var self = this;
	var getFn = function (key, fn) {
		return function (cb) {
			self.acquire(key, fn, cb, opts);
		};
	};

	var fnx = fn;
	keys.reverse().forEach(function (key) {
		fnx = getFn(key, fnx);
	});

	if (typeof (cb) === 'function') {
		fnx(cb);
	}
	else {
		return new this.Promise(function (resolve, reject) {
			// check for promise mode in case keys is empty array
			if (fnx.length === 1) {
				fnx(function (err, ret) {
					if (err) {
						reject(err);
					}
					else {
						resolve(ret);
					}
				});
			} else {
				resolve(fnx());
			}
		});
	}
};

/*
 *	Whether there is any running or pending asyncFunc
 *
 *	@param {String} key
 */
AsyncLock.prototype.isBusy = function (key) {
	if (!key) {
		return Object.keys(this.queues).length > 0;
	}
	else {
		return !!this.queues[key];
	}
};

/**
 * Promise.try() implementation to become independent of Q-specific methods
 */
AsyncLock.prototype._promiseTry = function(fn) {
	try {
		return this.Promise.resolve(fn());
	} catch (e) {
		return this.Promise.reject(e);
	}
};

module.exports = AsyncLock;

},{"process":"g5IB"}],"WflA":[function(require,module,exports) {
'use strict';
module.exports = require('./lib');

},{"./lib":"yffp"}],"WIBX":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseConnectionString = parseConnectionString;
exports.getNewAsyncLock = getNewAsyncLock;
exports.delay = delay;
exports.randomNumberFromInterval = randomNumberFromInterval;
exports.executePromisesSequentially = executePromisesSequentially;
exports.isIotHubConnectionString = isIotHubConnectionString;
exports.isString = isString;
exports.isNumber = isNumber;
Object.defineProperty(exports, "AsyncLock", {
  enumerable: true,
  get: function () {
    return _asyncLock.default;
  }
});
exports.Timeout = exports.defaultLock = exports.isNode = void 0;

var _asyncLock = _interopRequireDefault(require("async-lock"));

var _abortController = require("@azure/abort-controller");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 *
 * A constant that indicates whether the environment is node.js or browser based.
 */
const isNode = !!process && !!process.version && !!process.versions && !!process.versions.node;
/**
 * Parses the connection string and returns an object of type T.
 *
 * Connection strings have the following syntax:
 *
 * ConnectionString ::= Part { ";" Part } [ ";" ] [ WhiteSpace ]
 * Part             ::= [ PartLiteral [ "=" PartLiteral ] ]
 * PartLiteral      ::= [ WhiteSpace ] Literal [ WhiteSpace ]
 * Literal          ::= ? any sequence of characters except ; or = or WhiteSpace ?
 * WhiteSpace       ::= ? all whitespace characters including \r and \n ?
 *
 * @param {string} connectionString The connection string to be parsed.
 * @returns {ParsedOutput<T>} ParsedOutput<T>.
 */

exports.isNode = isNode;

function parseConnectionString(connectionString) {
  const output = {};
  const parts = connectionString.trim().split(";");

  for (let part of parts) {
    part = part.trim();

    if (part === "") {
      // parts can be empty
      continue;
    }

    const splitIndex = part.indexOf("=");

    if (splitIndex === -1) {
      throw new Error("Connection string malformed: each part of the connection string must have an `=` assignment.");
    }

    const key = part.substring(0, splitIndex).trim();

    if (key === "") {
      throw new Error("Connection string malformed: missing key for assignment");
    }

    const value = part.substring(splitIndex + 1).trim();
    output[key] = value;
  }

  return output;
}
/**
 * @internal
 * @hidden
 *
 * Gets a new instance of the async lock with desired settings.
 * @param {AsyncLockOptions} [options] The async lock options.
 * @returns {AsyncLock} AsyncLock
 */


function getNewAsyncLock(options) {
  return new _asyncLock.default(options);
}
/**
 * @constant {AsyncLock} defaultLock The async lock instance with default settings.
 */


const defaultLock = new _asyncLock.default({
  maxPending: 10000
});
/**
 * @internal
 * @hidden
 *
 * Describes a Timeout class that can wait for the specified amount of time and then resolve/reject
 * the promise with the given value.
 * @class Timeout
 */

exports.defaultLock = defaultLock;

class Timeout {
  set(t, value) {
    return new Promise((resolve, reject) => {
      this.clear();
      const callback = value ? () => reject(new Error(`${value}`)) : resolve;
      this._timer = setTimeout(callback, t);
    });
  }

  clear() {
    if (this._timer) {
      clearTimeout(this._timer);
    }
  }

  wrap(promise, t, value) {
    const wrappedPromise = this._promiseFinally(promise, () => this.clear());

    const timer = this.set(t, value);
    return Promise.race([wrappedPromise, timer]);
  }

  _promiseFinally(promise, fn) {
    const success = result => {
      fn();
      return result;
    };

    const error = e => {
      fn();
      return Promise.reject(e);
    };

    return Promise.resolve(promise).then(success, error);
  }

  static set(t, value) {
    return new Timeout().set(t, value);
  }

  static wrap(promise, t, value) {
    return new Timeout().wrap(promise, t, value);
  }

}
/**
 * A wrapper for setTimeout that resolves a promise after t milliseconds.
 * @param {number} delayInMs - The number of milliseconds to be delayed.
 * @param {AbortSignalLike} abortSignal - The abortSignal associated with containing operation.
 * @param {string} abortErrorMsg - The abort error message associated with containing operation.
 * @param {T} value - The value to be resolved with after a timeout of t milliseconds.
 * @returns {Promise<T>} - Resolved promise
 */


exports.Timeout = Timeout;

function delay(delayInMs, abortSignal, abortErrorMsg, value) {
  return new Promise((resolve, reject) => {
    const rejectOnAbort = () => {
      return reject(new _abortController.AbortError(abortErrorMsg ? abortErrorMsg : `The delay was cancelled by the user.`));
    };

    const removeListeners = () => {
      if (abortSignal) {
        abortSignal.removeEventListener("abort", onAborted);
      }
    };

    const onAborted = () => {
      clearTimeout(timer);
      removeListeners();
      return rejectOnAbort();
    };

    if (abortSignal && abortSignal.aborted) {
      return rejectOnAbort();
    }

    const timer = setTimeout(() => {
      removeListeners();
      resolve(value);
    }, delayInMs);

    if (abortSignal) {
      abortSignal.addEventListener("abort", onAborted);
    }
  });
}
/**
 * @internal
 * @hidden
 *
 * Generates a random number between the given interval
 * @param {number} min Min number of the range (inclusive).
 * @param {number} max Max number of the range (inclusive).
 */


function randomNumberFromInterval(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
/**
 * @internal
 * @hidden
 *
 * Executes an array of promises sequentially. Inspiration of this method is here:
 * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!
 *
 * @param {Array} promiseFactories An array of promise factories(A function that return a promise)
 *
 * @param {any} [kickstart] Input to the first promise that is used to kickstart the promise chain.
 * If not provided then the promise chain starts with undefined.
 *
 * @return A chain of resolved or rejected promises
 */


function executePromisesSequentially(promiseFactories, kickstart) {
  let result = Promise.resolve(kickstart);
  promiseFactories.forEach(promiseFactory => {
    result = result.then(promiseFactory);
  });
  return result;
}
/**
 * @internal
 * @hidden
 *
 * Determines whether the given connection string is an iothub connection string.
 * @param {string} connectionString The connection string.
 * @return {boolean} boolean.
 */


function isIotHubConnectionString(connectionString) {
  connectionString = String(connectionString);
  let result = false;
  const model = parseConnectionString(connectionString);

  if (model && model.HostName && model.SharedAccessKey && model.SharedAccessKeyName) {
    result = true;
  }

  return result;
}
/**
 * @hidden
 * @internal
 */


function isString(s) {
  return typeof s === "string";
}
/**
 * @hidden
 * @internal
 */


function isNumber(n) {
  return typeof n === "number";
}
},{"async-lock":"WflA","@azure/abort-controller":"wyb9","process":"g5IB"}],"gSjS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMessagingError = isMessagingError;
exports.isSystemError = isSystemError;
exports.translate = translate;
exports.SystemErrorConditionMapper = exports.retryableErrors = exports.MessagingError = exports.ErrorNameConditionMapper = exports.ConditionErrorNameMapper = exports.ConditionStatusMapper = void 0;

var _rheaPromise = require("rhea-promise");

var _utils = require("../src/util/utils");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/* eslint-disable eqeqeq */

/**
 * Maps the conditions to the numeric AMQP Response status codes.
 * @enum {ConditionStatusMapper}
 * @internal
 * @hidden
 */
var ConditionStatusMapper;
exports.ConditionStatusMapper = ConditionStatusMapper;

(function (ConditionStatusMapper) {
  ConditionStatusMapper[ConditionStatusMapper["com.microsoft:timeout"] = 408] = "com.microsoft:timeout";
  ConditionStatusMapper[ConditionStatusMapper["amqp:not-found"] = 404] = "amqp:not-found";
  ConditionStatusMapper[ConditionStatusMapper["amqp:not-implemented"] = 501] = "amqp:not-implemented";
  ConditionStatusMapper[ConditionStatusMapper["com.microsoft:entity-already-exists"] = 409] = "com.microsoft:entity-already-exists";
  ConditionStatusMapper[ConditionStatusMapper["com.microsoft:message-lock-lost"] = 410] = "com.microsoft:message-lock-lost";
  ConditionStatusMapper[ConditionStatusMapper["com.microsoft:session-lock-lost"] = 410] = "com.microsoft:session-lock-lost";
  ConditionStatusMapper[ConditionStatusMapper["com.microsoft:no-matching-subscription"] = 500] = "com.microsoft:no-matching-subscription";
  ConditionStatusMapper[ConditionStatusMapper["amqp:link:message-size-exceeded"] = 403] = "amqp:link:message-size-exceeded";
  ConditionStatusMapper[ConditionStatusMapper["com.microsoft:server-busy"] = 503] = "com.microsoft:server-busy";
  ConditionStatusMapper[ConditionStatusMapper["com.microsoft:argument-error"] = 400] = "com.microsoft:argument-error";
  ConditionStatusMapper[ConditionStatusMapper["com.microsoft:argument-out-of-range"] = 400] = "com.microsoft:argument-out-of-range";
  ConditionStatusMapper[ConditionStatusMapper["com.microsoft:store-lock-lost"] = 410] = "com.microsoft:store-lock-lost";
  ConditionStatusMapper[ConditionStatusMapper["com.microsoft:session-cannot-be-locked"] = 410] = "com.microsoft:session-cannot-be-locked";
  ConditionStatusMapper[ConditionStatusMapper["com.microsoft:partition-not-owned"] = 410] = "com.microsoft:partition-not-owned";
  ConditionStatusMapper[ConditionStatusMapper["com.microsoft:entity-disabled"] = 400] = "com.microsoft:entity-disabled";
  ConditionStatusMapper[ConditionStatusMapper["com.microsoft:publisher-revoked"] = 401] = "com.microsoft:publisher-revoked";
  ConditionStatusMapper[ConditionStatusMapper["amqp:link:stolen"] = 410] = "amqp:link:stolen";
  ConditionStatusMapper[ConditionStatusMapper["amqp:not-allowed"] = 400] = "amqp:not-allowed";
  ConditionStatusMapper[ConditionStatusMapper["amqp:unauthorized-access"] = 401] = "amqp:unauthorized-access";
  ConditionStatusMapper[ConditionStatusMapper["amqp:resource-limit-exceeded"] = 403] = "amqp:resource-limit-exceeded";
})(ConditionStatusMapper || (exports.ConditionStatusMapper = ConditionStatusMapper = {}));
/**
 * Maps the amqp error conditions to the Error names.
 * @enum {ConditionErrorNameMapper}
 */


var ConditionErrorNameMapper;
exports.ConditionErrorNameMapper = ConditionErrorNameMapper;

(function (ConditionErrorNameMapper) {
  /**
   * Error is thrown when the address is already in use.
   */
  ConditionErrorNameMapper["com.microsoft:address-already-in-use"] = "AddressAlreadyInUseError";
  /**
   * Error is thrown when the store lock is lost.
   */

  ConditionErrorNameMapper["com.microsoft:store-lock-lost"] = "StoreLockLostError";
  /**
   * Error is thrown when a matching subscription is not found.
   */

  ConditionErrorNameMapper["com.microsoft:no-matching-subscription"] = "NoMatchingSubscriptionError";
  /**
   * Error is thrown when an attempt is made to access a partition that is not owned by the
   * requesting entity.
   */

  ConditionErrorNameMapper["com.microsoft:partition-not-owned"] = "PartitionNotOwnedError";
  /**
   * Error is thrown when access to publisher has been revoked.
   */

  ConditionErrorNameMapper["com.microsoft:publisher-revoked"] = "PublisherRevokedError";
  /**
   * Error is thrown when an attempt is made to create an entity that already exists.
   */

  ConditionErrorNameMapper["com.microsoft:entity-already-exists"] = "MessagingEntityAlreadyExistsError";
  /**
   * Error is thrown when trying to access/connect to a disabled messaging entity.
   */

  ConditionErrorNameMapper["com.microsoft:entity-disabled"] = "MessagingEntityDisabledError";
  /**
   * Error is thrown when the lock on the message is lost.
   */

  ConditionErrorNameMapper["com.microsoft:message-lock-lost"] = "MessageLockLostError";
  /**
   * Error is thrown when the lock on the Azure ServiceBus session is lost.
   */

  ConditionErrorNameMapper["com.microsoft:session-lock-lost"] = "SessionLockLostError";
  /**
   * Error is thrown when the Azure ServiceBus session cannot be locked.
   */

  ConditionErrorNameMapper["com.microsoft:session-cannot-be-locked"] = "SessionCannotBeLockedError";
  /**
   * Error is thrown when an internal server error occurred. You may have found a bug?
   */

  ConditionErrorNameMapper["amqp:internal-error"] = "InternalServerError";
  /**
   * Error for signaling general communication errors related to messaging operations.
   */

  ConditionErrorNameMapper["amqp:not-found"] = "ServiceCommunicationError";
  /**
   * Error is thrown when the message is not found.
   */

  ConditionErrorNameMapper["com.microsoft:message-not-found"] = "MessageNotFoundError";
  /**
   * Error is thrown when relay is not found.
   */

  ConditionErrorNameMapper["com.microsoft:relay-not-found"] = "RelayNotFoundError";
  /**
   * Error is thrown when a feature is not implemented yet but the placeholder is present.
   */

  ConditionErrorNameMapper["amqp:not-implemented"] = "NotImplementedError";
  /**
   * Error is thrown when an operation is attempted but is not allowed.
   */

  ConditionErrorNameMapper["amqp:not-allowed"] = "InvalidOperationError";
  /**
   * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
   * Quotas are reset periodically, this operation will have to wait until then.
   * The messaging entity has reached its maximum allowable size.
   * This can happen if the maximum number of receivers (which is 5) has already
   * been opened on a per-consumer group level.
   */

  ConditionErrorNameMapper["amqp:resource-limit-exceeded"] = "QuotaExceededError";
  /**
   * Error is thrown when the connection parameters are wrong and the server refused the connection.
   */

  ConditionErrorNameMapper["amqp:unauthorized-access"] = "UnauthorizedError";
  /**
   * Error is thrown when the connection parameters are wrong and the server refused the connection.
   */

  ConditionErrorNameMapper["com.microsoft:auth-failed"] = "UnauthorizedError";
  /**
   * Error is thrown when the service is unavailable. The operation should be retried.
   */

  ConditionErrorNameMapper["com.microsoft:timeout"] = "ServiceUnavailableError";
  /**
   * Error is thrown when no new messages are received for the specified time.
   */

  ConditionErrorNameMapper["com.microsoft:message-wait-timeout"] = "MessageWaitTimeout";
  /**
   * Error is thrown when an argument has a value that is out of the admissible range.
   */

  ConditionErrorNameMapper["com.microsoft:argument-out-of-range"] = "ArgumentOutOfRangeError";
  /**
   * Error is thrown when a condition that should have been met in order to execute an operation was not.
   */

  ConditionErrorNameMapper["amqp:precondition-failed"] = "PreconditionFailedError";
  /**
   * Error is thrown when a condition that should have been met in order to execute an operation was not.
   */

  ConditionErrorNameMapper["com.microsoft:precondition-failed"] = "PreconditionFailedError";
  /**
   * Error is thrown when data could not be decoded.
   */

  ConditionErrorNameMapper["amqp:decode-error"] = "DecodeError";
  /**
   * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
   */

  ConditionErrorNameMapper["amqp:invalid-field"] = "InvalidFieldError";
  /**
   * Error is thrown when the client attempted to work with a server entity to which it
   * has no access because another client is working with it.
   */

  ConditionErrorNameMapper["amqp:resource-locked"] = "ResourceLockedError";
  /**
   * Error is thrown when a server entity the client is working with has been deleted.
   */

  ConditionErrorNameMapper["amqp:resource-deleted"] = "ResourceDeletedError";
  /**
   * Error is thrown when the peer sent a frame that is not permitted in the current state.
   */

  ConditionErrorNameMapper["amqp:illegal-state"] = "IllegalStateError";
  /**
   * Error is thrown when the peer cannot send a frame because the smallest encoding of
   * the performative with the currently valid values would be too large to fit within
   * a frame of the agreed maximum frame size.
   */

  ConditionErrorNameMapper["amqp:frame-size-too-small"] = "FrameSizeTooSmallError";
  /**
   * Error is thrown when an operator intervened to detach for some reason.
   */

  ConditionErrorNameMapper["amqp:link:detach-forced"] = "DetachForcedError";
  /**
   * Error is thrown when the peer sent more message transfers than currently allowed on the link.
   */

  ConditionErrorNameMapper["amqp:link:transfer-limit-exceeded"] = "TransferLimitExceededError";
  /**
   * Error is thrown when the message sent is too large: the maximum size is 256Kb.
   */

  ConditionErrorNameMapper["amqp:link:message-size-exceeded"] = "MessageTooLargeError";
  /**
   * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
   */

  ConditionErrorNameMapper["amqp:link:redirect"] = "LinkRedirectError";
  /**
   * Error is thrown when two or more instances connect to the same partition
   * with different epoch values.
   */

  ConditionErrorNameMapper["amqp:link:stolen"] = "ReceiverDisconnectedError";
  /**
   * Error is thrown when the peer violated incoming window for the session.
   */

  ConditionErrorNameMapper["amqp:session:window-violation"] = "SessionWindowViolationError";
  /**
   * Error is thrown when input was received for a link that was detached with an error.
   */

  ConditionErrorNameMapper["amqp:session:errant-link"] = "ErrantLinkError";
  /**
   * Error is thrown when an attach was received using a handle that is already in use for an attached link.
   */

  ConditionErrorNameMapper["amqp:session:handle-in-use"] = "HandleInUseError";
  /**
   * Error is thrown when a frame (other than attach) was received referencing a handle which is not
   * currently in use of an attached link.
   */

  ConditionErrorNameMapper["amqp:session:unattached-handle"] = "UnattachedHandleError";
  /**
   * Error is thrown when an operator intervened to close the connection for some reason.
   */

  ConditionErrorNameMapper["amqp:connection:forced"] = "ConnectionForcedError";
  /**
   * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
   */

  ConditionErrorNameMapper["amqp:connection:framing-error"] = "FramingError";
  /**
   * Error is thrown when the container is no longer available on the current connection.
   */

  ConditionErrorNameMapper["amqp:connection:redirect"] = "ConnectionRedirectError";
  /**
   * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
   */

  ConditionErrorNameMapper["com.microsoft:server-busy"] = "ServerBusyError";
  /**
   * Error is thrown when an incorrect argument was received.
   */

  ConditionErrorNameMapper["com.microsoft:argument-error"] = "ArgumentError";
  /**
   * Error is thrown when server cancels the operation due to an internal issue.
   */

  ConditionErrorNameMapper["com.microsoft:operation-cancelled"] = "OperationCancelledError";
  /**
   * Error is thrown when the client sender does not have enough link credits to send the message.
   */

  ConditionErrorNameMapper["client.sender:not-enough-link-credit"] = "SenderBusyError";
  /**
   * Error is thrown when a low level system error is thrown by node.js.
   * {@link https://nodejs.org/dist/latest-v8.x/docs/api/all.html#errors_class_system_error}
   */

  ConditionErrorNameMapper["system:error"] = "SystemError";
})(ConditionErrorNameMapper || (exports.ConditionErrorNameMapper = ConditionErrorNameMapper = {}));
/**
 * Maps the Error names to the amqp error conditions.
 * @enum {ErrorNameConditionMapper}
 */


var ErrorNameConditionMapper;
exports.ErrorNameConditionMapper = ErrorNameConditionMapper;

(function (ErrorNameConditionMapper) {
  /**
   * Error is thrown when the address is already in use.
   */
  ErrorNameConditionMapper["AddressAlreadyInUseError"] = "com.microsoft:address-already-in-use";
  /**
   * Error is thrown when the store lock is lost.
   */

  ErrorNameConditionMapper["StoreLockLostError"] = "com.microsoft:store-lock-lost";
  /**
   * Error is thrown when a matching subscription is not found.
   */

  ErrorNameConditionMapper["NoMatchingSubscriptionError"] = "com.microsoft:no-matching-subscription";
  /**
   * Error is thrown when an attempt is made to access a partition that is not owned by the
   * requesting entity.
   */

  ErrorNameConditionMapper["PartitionNotOwnedError"] = "com.microsoft:partition-not-owned";
  /**
   * Error is thrown when access to publisher has been revoked.
   */

  ErrorNameConditionMapper["PublisherRevokedError"] = "com.microsoft:publisher-revoked";
  /**
   * Error is thrown when an attempt is made to create an entity that already exists.
   */

  ErrorNameConditionMapper["MessagingEntityAlreadyExistsError"] = "com.microsoft:entity-already-exists";
  /**
   * Error is thrown when trying to access/connect to a disabled messaging entity.
   */

  ErrorNameConditionMapper["MessagingEntityDisabledError"] = "com.microsoft:entity-disabled";
  /**
   * Error is thrown when the lock on the message is lost.
   */

  ErrorNameConditionMapper["MessageLockLostError"] = "com.microsoft:message-lock-lost";
  /**
   * Error is thrown when the lock on the Azure ServiceBus session is lost.
   */

  ErrorNameConditionMapper["SessionLockLostError"] = "com.microsoft:session-lock-lost";
  /**
   * Error is thrown when the Azure ServiceBus session cannot be locked.
   */

  ErrorNameConditionMapper["SessionCannotBeLockedError"] = "com.microsoft:session-cannot-be-locked";
  /**
   * Error is thrown when an internal server error occurred. You may have found a bug?
   */

  ErrorNameConditionMapper["InternalServerError"] = "amqp:internal-error";
  /**
   * Error for signaling general communication errors related to messaging operations.
   */

  ErrorNameConditionMapper["ServiceCommunicationError"] = "amqp:not-found";
  /**
   * Error is thrown when message is not found.
   */

  ErrorNameConditionMapper["MessageNotFoundError"] = "com.microsoft:message-not-found";
  /**
   * Error is thrown when relay is not found.
   */

  ErrorNameConditionMapper["RelayNotFoundError"] = "com.microsoft:relay-not-found";
  /**
   * Error is thrown when a feature is not implemented yet but the placeholder is present.
   */

  ErrorNameConditionMapper["NotImplementedError"] = "amqp:not-implemented";
  /**
   * Error is thrown when an operation is attempted but is not allowed.
   */

  ErrorNameConditionMapper["InvalidOperationError"] = "amqp:not-allowed";
  /**
   * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
   * Quotas are reset periodically, this operation will have to wait until then.
   * The messaging entity has reached its maximum allowable size.
   * This can happen if the maximum number of receivers (which is 5) has already
   * been opened on a per-consumer group level.
   */

  ErrorNameConditionMapper["QuotaExceededError"] = "amqp:resource-limit-exceeded";
  /**
   * Error is thrown when the connection parameters are wrong and the server refused the connection.
   */

  ErrorNameConditionMapper["UnauthorizedError"] = "amqp:unauthorized-access";
  /**
   * Error is thrown when the service is unavailable. The operation should be retried.
   */

  ErrorNameConditionMapper["ServiceUnavailableError"] = "com.microsoft:timeout";
  /**
   * Error is thrown when no new messages are received for the specified time.
   */

  ErrorNameConditionMapper["MessageWaitTimeout"] = "com.microsoft:message-wait-timeout";
  /**
   * Error is thrown when an argument has a value that is out of the admissible range.
   */

  ErrorNameConditionMapper["ArgumentOutOfRangeError"] = "com.microsoft:argument-out-of-range";
  /**
   * Error is thrown when a condition that should have been met in order to execute an operation was not.
   */

  ErrorNameConditionMapper["PreconditionFailedError"] = "amqp:precondition-failed";
  /**
   * Error is thrown when data could not be decoded.
   */

  ErrorNameConditionMapper["DecodeError"] = "amqp:decode-error";
  /**
   * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
   */

  ErrorNameConditionMapper["InvalidFieldError"] = "amqp:invalid-field";
  /**
   * Error is thrown when the client attempted to work with a server entity to which it
   * has no access because another client is working with it.
   */

  ErrorNameConditionMapper["ResourceLockedError"] = "amqp:resource-locked";
  /**
   * Error is thrown when a server entity the client is working with has been deleted.
   */

  ErrorNameConditionMapper["ResourceDeletedError"] = "amqp:resource-deleted";
  /**
   * Error is thrown when the peer sent a frame that is not permitted in the current state.
   */

  ErrorNameConditionMapper["IllegalStateError"] = "amqp:illegal-state";
  /**
   * Error is thrown when the peer cannot send a frame because the smallest encoding of
   * the performative with the currently valid values would be too large to fit within
   * a frame of the agreed maximum frame size.
   */

  ErrorNameConditionMapper["FrameSizeTooSmallError"] = "amqp:frame-size-too-small";
  /**
   * Error is thrown when an operator intervened to detach for some reason.
   */

  ErrorNameConditionMapper["DetachForcedError"] = "amqp:link:detach-forced";
  /**
   * Error is thrown when the peer sent more message transfers than currently allowed on the link.
   */

  ErrorNameConditionMapper["TransferLimitExceededError"] = "amqp:link:transfer-limit-exceeded";
  /**
   * Error is thrown when the message sent is too large: the maximum size is 256Kb.
   */

  ErrorNameConditionMapper["MessageTooLargeError"] = "amqp:link:message-size-exceeded";
  /**
   * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
   */

  ErrorNameConditionMapper["LinkRedirectError"] = "amqp:link:redirect";
  /**
   * Error is thrown when two or more instances connect to the same partition
   * with different epoch values.
   */

  ErrorNameConditionMapper["ReceiverDisconnectedError"] = "amqp:link:stolen";
  /**
   * Error is thrown when the peer violated incoming window for the session.
   */

  ErrorNameConditionMapper["SessionWindowViolationError"] = "amqp:session:window-violation";
  /**
   * Error is thrown when input was received for a link that was detached with an error.
   */

  ErrorNameConditionMapper["ErrantLinkError"] = "amqp:session:errant-link";
  /**
   * Error is thrown when an attach was received using a handle that is already in use for an attached link.
   */

  ErrorNameConditionMapper["HandleInUseError"] = "amqp:session:handle-in-use";
  /**
   * Error is thrown when a frame (other than attach) was received referencing a handle which is not
   * currently in use of an attached link.
   */

  ErrorNameConditionMapper["UnattachedHandleError"] = "amqp:session:unattached-handle";
  /**
   * Error is thrown when an operator intervened to close the connection for some reason.
   */

  ErrorNameConditionMapper["ConnectionForcedError"] = "amqp:connection:forced";
  /**
   * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
   */

  ErrorNameConditionMapper["FramingError"] = "amqp:connection:framing-error";
  /**
   * Error is thrown when the container is no longer available on the current connection.
   */

  ErrorNameConditionMapper["ConnectionRedirectError"] = "amqp:connection:redirect";
  /**
   * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
   */

  ErrorNameConditionMapper["ServerBusyError"] = "com.microsoft:server-busy";
  /**
   * Error is thrown when an incorrect argument was received.
   */

  ErrorNameConditionMapper["ArgumentError"] = "com.microsoft:argument-error";
  /**
   * Error is thrown when server cancels the operation due to an internal issue.
   */

  ErrorNameConditionMapper["OperationCancelledError"] = "com.microsoft:operation-cancelled";
  /**
   * Error is thrown when the client sender does not have enough link credits to send the message.
   */

  ErrorNameConditionMapper["SenderBusyError"] = "client.sender:not-enough-link-credit";
  /**
   * Error is thrown when a low level system error is thrown by node.js.
   * {@link https://nodejs.org/api/errors.html#errors_class_systemerror}
   */

  ErrorNameConditionMapper["SystemError"] = "system:error";
})(ErrorNameConditionMapper || (exports.ErrorNameConditionMapper = ErrorNameConditionMapper = {}));
/**
 * @internal
 * @hidden
 */


const systemErrorFieldsToCopy = ["address", "code", "errno", "info", "port", "stack", "syscall"];
/**
 * Determines if an error is a MessagingError.
 *
 * @param error An error that can either be an Error or a MessagingError.
 */

function isMessagingError(error) {
  return error.name === "MessagingError";
}
/**
 * Describes the base class for Messaging Error.
 * @class {MessagingError}
 * @extends Error
 */


class MessagingError extends Error {
  /**
   * @param {string} message The error message that provides more information about the error.
   * @param originalError An error whose properties will be copied to the MessagingError if the
   * property matches one found on the Node.js `SystemError`.
   */
  constructor(message, originalError) {
    super(message);
    /**
     * @property {string} name The error name. Default value: "MessagingError".
     */

    this.name = "MessagingError";
    /**
     *
     * @property {boolean} retryable Describes whether the error is retryable. Default: true.
     */

    this.retryable = true;

    if (!originalError) {
      return;
    } // copy properties from system error


    for (const propName of systemErrorFieldsToCopy) {
      if (originalError[propName] != undefined) {
        this[propName] = originalError[propName];
      }
    }
  }

}
/**
 * Provides a list of retryable AMQP errors.
 * "InternalServerError", "ServerBusyError", "ServiceUnavailableError", "OperationCancelledError",
 * "SenderBusyError", "MessagingError", "DetachForcedError", "ConnectionForcedError",
 * "TransferLimitExceededError"
 */


exports.MessagingError = MessagingError;
const retryableErrors = ["InternalServerError", "ServerBusyError", "ServiceUnavailableError", "OperationCancelledError", // OperationTimeoutError occurs when the service fails to respond within a given timeframe.
// Since reasons for such failures can be transient, this is treated as a retryable error.
"OperationTimeoutError", "SenderBusyError", "MessagingError", "DetachForcedError", "ConnectionForcedError", "TransferLimitExceededError", // InsufficientCreditError occurs when the number of credits available on Rhea link is insufficient.
// Since reasons for such shortage can be transient such as for pending delivery of messages, this is treated as a retryable error.
"InsufficientCreditError"];
/**
 * Maps some SystemErrors to amqp error conditions
 * @enum SystemErrorConditionMapper
 */

exports.retryableErrors = retryableErrors;
var SystemErrorConditionMapper;
exports.SystemErrorConditionMapper = SystemErrorConditionMapper;

(function (SystemErrorConditionMapper) {
  SystemErrorConditionMapper["ENOTFOUND"] = "amqp:not-found";
  SystemErrorConditionMapper["EBUSY"] = "com.microsoft:server-busy";
  SystemErrorConditionMapper["ECONNREFUSED"] = "amqp:connection:forced";
  SystemErrorConditionMapper["ETIMEDOUT"] = "com.microsoft:timeout";
  SystemErrorConditionMapper["ECONNRESET"] = "com.microsoft:timeout";
  SystemErrorConditionMapper["ENETDOWN"] = "com.microsoft:timeout";
  SystemErrorConditionMapper["EHOSTDOWN"] = "com.microsoft:timeout";
  SystemErrorConditionMapper["ENETRESET"] = "com.microsoft:timeout";
  SystemErrorConditionMapper["ENETUNREACH"] = "com.microsoft:timeout";
  SystemErrorConditionMapper["ENONET"] = "com.microsoft:timeout";
})(SystemErrorConditionMapper || (exports.SystemErrorConditionMapper = SystemErrorConditionMapper = {}));
/**
 * Checks whether the provided error is a node.js SystemError.
 * @param err An object that may contain error information.
 */


function isSystemError(err) {
  if (!err) {
    return false;
  }

  if (!(0, _utils.isString)(err.code) || !(0, _utils.isString)(err.syscall)) {
    return false;
  }

  if (!(0, _utils.isString)(err.errno) && !(0, _utils.isNumber)(err.errno)) {
    return false;
  }

  return true;
}
/**
 * @internal
 * @hidden
 * Since browser doesn't differentiate between the various kinds of service communication errors,
 * this utility is used to look at the error target to identify such category of errors.
 * For more information refer to - https://html.spec.whatwg.org/multipage/comms.html#feedback-from-the-protocol
 * @param err object that may contain error information
 */


function isBrowserWebsocketError(err) {
  let result = false;

  if (!_utils.isNode && window && err.type === "error" && err.target instanceof window.WebSocket) {
    result = true;
  }

  return result;
}
/**
 * @internal
 * @hidden
 */


const rheaPromiseErrors = [// OperationTimeoutError occurs when the service fails to respond within a given timeframe.
"OperationTimeoutError", // InsufficientCreditError occurs when the number of credits available on Rhea link is insufficient.
"InsufficientCreditError", // Defines the error that occurs when the Sender fails to send a message.
"SendOperationFailedError"];
/**
 * Translates the AMQP error received at the protocol layer or a SystemError into a MessagingError.
 * All other errors are returned unaltered.
 *
 * @param {AmqpError} err The amqp error that was received.
 * @returns {MessagingError} MessagingError object.
 */

function translate(err) {
  // Built-in errors like TypeError and RangeError should not be retryable as these indicate issues
  // with user input and not an issue with the Messaging process.
  if (err instanceof TypeError || err instanceof RangeError) {
    return err;
  }

  if (isAmqpError(err)) {
    // translate
    const condition = err.condition;
    const description = err.description;
    const error = new MessagingError(description);
    if (err.stack) error.stack = err.stack;
    error.info = err.info;

    if (condition) {
      error.code = ConditionErrorNameMapper[condition];
    }

    if (description && (description.includes("status-code: 404") || description.match(/The messaging entity .* could not be found.*/i) !== null)) {
      error.code = "MessagingEntityNotFoundError";
    }

    if (error.code && retryableErrors.indexOf(error.code) === -1) {
      // not found
      error.retryable = false;
    }

    return error;
  }

  if (err.name === "MessagingError") {
    // already translated
    return err;
  }

  if (isSystemError(err)) {
    // translate
    const condition = err.code;
    const description = err.message;
    const error = new MessagingError(description, err);
    let errorType = "SystemError";

    if (condition) {
      const amqpErrorCondition = SystemErrorConditionMapper[condition];
      errorType = ConditionErrorNameMapper[amqpErrorCondition];
    }

    if (retryableErrors.indexOf(errorType) === -1) {
      // not found
      error.retryable = false;
    }

    return error;
  }

  if (isBrowserWebsocketError(err)) {
    // Translate browser communication errors during opening handshake to generic ServiceCommunicationError
    const error = new MessagingError("Websocket connection failed.");
    error.code = ConditionErrorNameMapper[ErrorNameConditionMapper.ServiceCommunicationError];
    error.retryable = false;
    return error;
  } // Some errors come from rhea-promise and need to be converted to MessagingError.
  // A subset of these are also retryable.


  if (rheaPromiseErrors.indexOf(err.name) !== -1) {
    const error = new MessagingError(err.message, err);
    error.code = err.name;

    if (error.code && retryableErrors.indexOf(error.code) === -1) {
      // not found
      error.retryable = false;
    }

    return error;
  }

  return err;
}
/**
 * @internal
 * @hidden
 *
 * @param {*} error
 * @returns {error is AmqpError}
 */


function isAmqpError(error) {
  return (0, _rheaPromise.isAmqpError)(error);
}
},{"rhea-promise":"fxSK","../src/util/utils":"WIBX"}],"N8XP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.log = log;

var _tslib = require("tslib");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var logFunction = console.debug || console.log;

function log() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  logFunction.apply(void 0, (0, _tslib.__spread)(args));
}
},{"tslib":"CvJj"}],"vYWA":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = require("tslib");

var _log = require("./log");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/* eslint-disable no-invalid-this */
var debugEnvVariable = typeof process !== "undefined" && process.env && undefined || undefined;
var enabledString;
var enabledNamespaces = [];
var skippedNamespaces = [];
var debuggers = [];

if (debugEnvVariable) {
  enable(debugEnvVariable);
}

var debugObj = Object.assign(function (namespace) {
  return createDebugger(namespace);
}, {
  enable: enable,
  enabled: enabled,
  disable: disable,
  log: _log.log
});

function enable(namespaces) {
  var e_1, _a, e_2, _b;

  enabledString = namespaces;
  enabledNamespaces = [];
  skippedNamespaces = [];
  var wildcard = /\*/g;
  var namespaceList = namespaces.split(",").map(function (ns) {
    return ns.trim().replace(wildcard, ".*?");
  });

  try {
    for (var namespaceList_1 = (0, _tslib.__values)(namespaceList), namespaceList_1_1 = namespaceList_1.next(); !namespaceList_1_1.done; namespaceList_1_1 = namespaceList_1.next()) {
      var ns = namespaceList_1_1.value;

      if (ns.startsWith("-")) {
        skippedNamespaces.push(new RegExp("^" + ns.substr(1) + "$"));
      } else {
        enabledNamespaces.push(new RegExp("^" + ns + "$"));
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (namespaceList_1_1 && !namespaceList_1_1.done && (_a = namespaceList_1.return)) _a.call(namespaceList_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  try {
    for (var debuggers_1 = (0, _tslib.__values)(debuggers), debuggers_1_1 = debuggers_1.next(); !debuggers_1_1.done; debuggers_1_1 = debuggers_1.next()) {
      var instance = debuggers_1_1.value;
      instance.enabled = enabled(instance.namespace);
    }
  } catch (e_2_1) {
    e_2 = {
      error: e_2_1
    };
  } finally {
    try {
      if (debuggers_1_1 && !debuggers_1_1.done && (_b = debuggers_1.return)) _b.call(debuggers_1);
    } finally {
      if (e_2) throw e_2.error;
    }
  }
}

function enabled(namespace) {
  var e_3, _a, e_4, _b;

  if (namespace.endsWith("*")) {
    return true;
  }

  try {
    for (var skippedNamespaces_1 = (0, _tslib.__values)(skippedNamespaces), skippedNamespaces_1_1 = skippedNamespaces_1.next(); !skippedNamespaces_1_1.done; skippedNamespaces_1_1 = skippedNamespaces_1.next()) {
      var skipped = skippedNamespaces_1_1.value;

      if (skipped.test(namespace)) {
        return false;
      }
    }
  } catch (e_3_1) {
    e_3 = {
      error: e_3_1
    };
  } finally {
    try {
      if (skippedNamespaces_1_1 && !skippedNamespaces_1_1.done && (_a = skippedNamespaces_1.return)) _a.call(skippedNamespaces_1);
    } finally {
      if (e_3) throw e_3.error;
    }
  }

  try {
    for (var enabledNamespaces_1 = (0, _tslib.__values)(enabledNamespaces), enabledNamespaces_1_1 = enabledNamespaces_1.next(); !enabledNamespaces_1_1.done; enabledNamespaces_1_1 = enabledNamespaces_1.next()) {
      var enabledNamespace = enabledNamespaces_1_1.value;

      if (enabledNamespace.test(namespace)) {
        return true;
      }
    }
  } catch (e_4_1) {
    e_4 = {
      error: e_4_1
    };
  } finally {
    try {
      if (enabledNamespaces_1_1 && !enabledNamespaces_1_1.done && (_b = enabledNamespaces_1.return)) _b.call(enabledNamespaces_1);
    } finally {
      if (e_4) throw e_4.error;
    }
  }

  return false;
}

function disable() {
  var result = enabledString || "";
  enable("");
  return result;
}

function createDebugger(namespace) {
  var newDebugger = Object.assign(debug, {
    enabled: enabled(namespace),
    destroy: destroy,
    log: debugObj.log,
    namespace: namespace,
    extend: extend
  });

  function debug() {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    if (!newDebugger.enabled) {
      return;
    }

    if (args.length > 0) {
      args[0] = namespace + " " + args[0];
    }

    newDebugger.log.apply(newDebugger, (0, _tslib.__spread)(args));
  }

  debuggers.push(newDebugger);
  return newDebugger;
}

function destroy() {
  var index = debuggers.indexOf(this);

  if (index >= 0) {
    debuggers.splice(index, 1);
    return true;
  }

  return false;
}

function extend(namespace) {
  var newDebugger = createDebugger(this.namespace + ":" + namespace);
  newDebugger.log = this.log;
  return newDebugger;
}

var _default = debugObj;
exports.default = _default;
},{"tslib":"CvJj","./log":"N8XP","process":"sC8V"}],"JyPs":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setLogLevel = setLogLevel;
exports.getLogLevel = getLogLevel;
exports.createClientLogger = createClientLogger;
exports.AzureLogger = void 0;

var _tslib = require("tslib");

var _debug = _interopRequireDefault(require("./debug"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var registeredLoggers = new Set();
var logLevelFromEnv = typeof process !== "undefined" && process.env && undefined || undefined;
var azureLogLevel;
/**
 * The AzureLogger provides a mechanism for overriding where logs are output to.
 * By default, logs are sent to stderr.
 * Override the `log` method to redirect logs to another location.
 */

var AzureLogger = (0, _debug.default)("azure");
exports.AzureLogger = AzureLogger;

AzureLogger.log = function () {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  _debug.default.log.apply(_debug.default, (0, _tslib.__spread)(args));
};

var AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];

if (logLevelFromEnv) {
  // avoid calling setLogLevel because we don't want a mis-set environment variable to crash
  if (isAzureLogLevel(logLevelFromEnv)) {
    setLogLevel(logLevelFromEnv);
  } else {
    console.error("AZURE_LOG_LEVEL set to unknown log level '" + logLevelFromEnv + "'; logging is not enabled. Acceptable values: " + AZURE_LOG_LEVELS.join(", ") + ".");
  }
}
/**
 * Immediately enables logging at the specified log level.
 * @param level - The log level to enable for logging.
 * Options from most verbose to least verbose are:
 * - verbose
 * - info
 * - warning
 * - error
 */


function setLogLevel(level) {
  var e_1, _a;

  if (level && !isAzureLogLevel(level)) {
    throw new Error("Unknown log level '" + level + "'. Acceptable values: " + AZURE_LOG_LEVELS.join(","));
  }

  azureLogLevel = level;
  var enabledNamespaces = [];

  try {
    for (var registeredLoggers_1 = (0, _tslib.__values)(registeredLoggers), registeredLoggers_1_1 = registeredLoggers_1.next(); !registeredLoggers_1_1.done; registeredLoggers_1_1 = registeredLoggers_1.next()) {
      var logger = registeredLoggers_1_1.value;

      if (shouldEnable(logger)) {
        enabledNamespaces.push(logger.namespace);
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (registeredLoggers_1_1 && !registeredLoggers_1_1.done && (_a = registeredLoggers_1.return)) _a.call(registeredLoggers_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  _debug.default.enable(enabledNamespaces.join(","));
}
/**
 * Retrieves the currently specified log level.
 */


function getLogLevel() {
  return azureLogLevel;
}

var levelMap = {
  verbose: 400,
  info: 300,
  warning: 200,
  error: 100
};
/**
 * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.
 * @param namespace - The name of the SDK package.
 * @hidden
 */

function createClientLogger(namespace) {
  var clientRootLogger = AzureLogger.extend(namespace);
  patchLogMethod(AzureLogger, clientRootLogger);
  return {
    error: createLogger(clientRootLogger, "error"),
    warning: createLogger(clientRootLogger, "warning"),
    info: createLogger(clientRootLogger, "info"),
    verbose: createLogger(clientRootLogger, "verbose")
  };
}

function patchLogMethod(parent, child) {
  child.log = function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    parent.log.apply(parent, (0, _tslib.__spread)(args));
  };
}

function createLogger(parent, level) {
  var logger = Object.assign(parent.extend(level), {
    level: level
  });
  patchLogMethod(parent, logger);

  if (shouldEnable(logger)) {
    var enabledNamespaces = _debug.default.disable();

    _debug.default.enable(enabledNamespaces + "," + logger.namespace);
  }

  registeredLoggers.add(logger);
  return logger;
}

function shouldEnable(logger) {
  if (azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]) {
    return true;
  } else {
    return false;
  }
}

function isAzureLogLevel(logLevel) {
  return AZURE_LOG_LEVELS.includes(logLevel);
}
},{"tslib":"CvJj","./debug":"vYWA","process":"sC8V"}],"MjfT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logErrorStackTrace = logErrorStackTrace;
exports.logger = void 0;

var _logger = require("@azure/logger");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * The @azure/logger configuration for this package.
 * This will output logs using the `azure:event-hubs` namespace prefix.
 */
const logger = (0, _logger.createClientLogger)("core-amqp");
/**
 * Logs the error's stack trace to "verbose" if a stack trace is available.
 * @param error Error containing a stack trace.
 * @hidden
 */

exports.logger = logger;

function logErrorStackTrace(error) {
  if (error && error.stack) {
    logger.verbose(error.stack);
  }
}
},{"@azure/logger":"JyPs"}],"DyaW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onMessageReceived = onMessageReceived;
exports.getCodeDescriptionAndError = exports.RequestResponseLink = void 0;

var _tslib = require("tslib");

var _abortController = require("@azure/abort-controller");

var _constants = require("./util/constants");

var _rheaPromise = require("rhea-promise");

var _errors = require("./errors");

var _log = require("./log");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Describes an amqp request(sender)-response(receiver) link that is created over an amqp session.
 * @class RequestResponseLink
 */
class RequestResponseLink {
  /**
   * @constructor
   * @param {Session} session The amqp session.
   * @param {Sender} sender The amqp sender link.
   * @param {Receiver} receiver The amqp receiver link.
   */
  constructor(session, sender, receiver) {
    this.session = session;
    this.sender = sender;
    this.receiver = receiver;
    /**
     * @property {Map<string, Promise<any>>} _responsesMap Maintains a map of responses that
     * are being actively returned. It acts as a store for correlating the responses received for
     * the send requests.
     */

    this._responsesMap = new Map();
    this.session = session;
    this.sender = sender;
    this.receiver = receiver;
    this.receiver.on(_rheaPromise.ReceiverEvents.message, context => {
      onMessageReceived(context, this.connection.id, this._responsesMap);
    });
  }
  /**
   * Provides the underlying amqp connection object.
   * @returns {Connection} Connection.
   */


  get connection() {
    return this.session.connection;
  }
  /**
   * Indicates whether the session and the sender and receiver links are all open or closed.
   * @returns {boolean} boolean - `true` - `open`, `false` - `closed`.
   */


  isOpen() {
    return this.session.isOpen() && this.sender.isOpen() && this.receiver.isOpen();
  }
  /**
   * Sends the given request message and returns the received response. If the operation is not
   * completed in the provided timeout in milliseconds `default: 60000`, then `OperationTimeoutError` is thrown.
   *
   * @param {RheaMessage} request The AMQP (request) message.
   * @param {SendRequestOptions} [options] Options that can be provided while sending a request.
   * @returns {Promise<Message>} Promise<Message> The AMQP (response) message.
   */


  sendRequest(request, options = {}) {
    const timeoutInMs = options.timeoutInMs || _constants.Constants.defaultOperationTimeoutInMs;
    const aborter = options.abortSignal; // If message_id is not already set on the request, set it to a unique value
    // This helps in determining the right response for current request among multiple incoming messages

    if (!request.message_id) {
      request.message_id = (0, _rheaPromise.generate_uuid)();
    }

    return new Promise((resolve, reject) => {
      const rejectOnAbort = () => {
        this._responsesMap.delete(request.message_id);

        const address = this.receiver.address || "address";
        const requestName = options.requestName;
        const desc = `[${this.connection.id}] The request "${requestName}" ` + `to "${address}" has been cancelled by the user.`; // Cancellation is a user-intended action, so log to info instead of warning.

        _log.logger.info(desc);

        const error = new _abortController.AbortError(`The ${requestName ? requestName + " " : ""}operation has been cancelled by the user.`);
        reject(error);
      };

      const onAbort = () => {
        // safe to clear the timeout if it hasn't already occurred.
        clearTimeout(timer);
        aborter.removeEventListener("abort", onAbort);
        rejectOnAbort();
      };

      if (aborter) {
        // the aborter may have been triggered between request attempts
        // so check if it was triggered and reject if needed.
        if (aborter.aborted) {
          return rejectOnAbort();
        }

        aborter.addEventListener("abort", onAbort);
      }

      const timer = setTimeout(() => {
        this._responsesMap.delete(request.message_id);

        if (aborter) {
          aborter.removeEventListener("abort", onAbort);
        }

        const address = this.receiver.address || "address";
        const desc = `The request with message_id "${request.message_id}" to "${address}" ` + `endpoint timed out. Please try again later.`;
        const e = {
          name: "OperationTimeoutError",
          message: desc
        };
        return reject((0, _errors.translate)(e));
      }, timeoutInMs);

      this._responsesMap.set(request.message_id, {
        resolve: resolve,
        reject: reject,
        cleanupBeforeResolveOrReject: () => {
          if (aborter) aborter.removeEventListener("abort", onAbort);
          clearTimeout(timer);
        }
      });

      _log.logger.verbose("[%s] %s request sent: %O", this.connection.id, request.to || "$management", request);

      this.sender.send(request);
    });
  }
  /**
   * Closes the sender, receiver link and the underlying session.
   * @returns {Promise<void>} Promise<void>
   */


  close() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      yield this.sender.close({
        closeSession: false
      });
      yield this.receiver.close({
        closeSession: false
      });
      yield this.session.close();
    });
  }
  /**
   * Removes the sender, receiver link and it's underlying session.
   * @returns {void} void
   */


  remove() {
    this.sender.remove();
    this.receiver.remove();
    this.session.remove();
  }
  /**
   * Creates an amqp request/response link.
   *
   * @param {Connection} connection The amqp connection.
   * @param {SenderOptions} senderOptions Options that must be provided to create the sender link.
   * @param {ReceiverOptions} receiverOptions Options that must be provided to create the receiver link.
   * @returns {Promise<RequestResponseLink>} Promise<RequestResponseLink>
   */


  static create(connection, senderOptions, receiverOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const session = yield connection.createSession();
      const sender = yield session.createSender(senderOptions);
      const receiver = yield session.createReceiver(receiverOptions);

      _log.logger.verbose("[%s] Successfully created the sender and receiver links on the same session.", connection.id);

      return new RequestResponseLink(session, sender, receiver);
    });
  }

}
/**
 * @internal
 * @hidden
 *
 * Handle different variations of property names in responses emitted by EventHubs and ServiceBus.
 *
 * @param {*} props
 * @returns {NormalizedInfo}
 */


exports.RequestResponseLink = RequestResponseLink;

const getCodeDescriptionAndError = props => {
  if (!props) props = {};
  return {
    statusCode: props[_constants.Constants.statusCode] || props.statusCode,
    statusDescription: props[_constants.Constants.statusDescription] || props.statusDescription,
    errorCondition: props[_constants.Constants.errorCondition] || props.errorCondition
  };
};
/**
 * This is used as the onMessage handler for the "message" event on the receiver.
 *
 * (This is inspired from the message settlement sequence in service-bus SDK which
 * relies on a single listener for settled event for all the messages.)
 * The sequence is as follows:
 * 1. User calls `await RequestResponseLink.sendRequest()`
 * 2. This creates a `Promise` that gets stored in the _responsesMap
 * 3. When the service acknowledges the response, this method gets called for that request.
 * 4. We resolve() the promise from the _responsesMap with the message.
 * 5. User's code after the sendRequest continues.
 *
 * @internal
 * @hidden
 */


exports.getCodeDescriptionAndError = getCodeDescriptionAndError;

function onMessageReceived(context, connectionId, responsesMap) {
  const message = context.message;

  if (!message) {
    _log.logger.verbose(`[${connectionId}] "message" property on the EventContext is "undefined" which is unexpected, ` + `returning from the "onMessageReceived" handler without resolving or rejecting the promise ` + `upon encountering the message event.`);

    return;
  }

  const responseCorrelationId = message.correlation_id;

  if (!responsesMap.has(responseCorrelationId)) {
    _log.logger.verbose(`[${connectionId}] correlationId "${responseCorrelationId}" property on the response does not match with ` + `any of the "request-id"s in the map, returning from the "onMessageReceived" handler without resolving ` + `or rejecting the promise upon encountering the message event.`);

    return;
  }

  const promise = responsesMap.get(responseCorrelationId);
  promise.cleanupBeforeResolveOrReject();
  const deleteResult = responsesMap.delete(responseCorrelationId);

  _log.logger.verbose(`[${connectionId}] Successfully deleted the response with id ${responseCorrelationId} from the map. ` + `Delete result - ${deleteResult}`);

  const info = getCodeDescriptionAndError(message.application_properties);
  let error;

  if (!info.statusCode) {
    error = new Error(`[${connectionId}] No statusCode in the "application_properties" in the returned response with correlation-id: ${responseCorrelationId}`);
  }

  if (info.statusCode > 199 && info.statusCode < 300) {
    _log.logger.verbose(`[${connectionId}] Resolving the response with correlation-id: ${responseCorrelationId}`);

    return promise.resolve(message);
  }

  if (!error) {
    const condition = info.errorCondition || _errors.ConditionStatusMapper[info.statusCode] || "amqp:internal-error";
    error = (0, _errors.translate)({
      condition: condition,
      description: info.statusDescription
    });

    _log.logger.warning(`${error === null || error === void 0 ? void 0 : error.name}: ${error === null || error === void 0 ? void 0 : error.message}`);
  }

  (0, _log.logErrorStackTrace)(error);
  return promise.reject(error);
}
},{"tslib":"CvJj","@azure/abort-controller":"wyb9","./util/constants":"oklo","rhea-promise":"fxSK","./errors":"gSjS","./log":"MjfT"}],"azJF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkNetworkConnection = checkNetworkConnection;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Checks whether a network connection is detected.
 * @hidden
 * @internal
 */
function checkNetworkConnection() {
  return Promise.resolve(window.navigator.onLine);
}
},{}],"mE9i":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.retry = retry;
exports.RetryOperationType = exports.RetryMode = void 0;

var _tslib = require("tslib");

var _errors = require("./errors");

var _utils = require("./util/utils");

var _log = require("./log");

var _constants = require("./util/constants");

var _checkNetworkConnection = require("./util/checkNetworkConnection");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/* eslint-disable eqeqeq */

/**
 * Determines whether the object is a Delivery object.
 * @hidden
 */
function isDelivery(obj) {
  let result = false;

  if (obj && typeof obj.id === "number" && typeof obj.settled === "boolean" && typeof obj.remote_settled === "boolean" && typeof obj.format === "number") {
    result = true;
  }

  return result;
}
/**
 * Describes the Retry Mode type
 * @enum RetryMode
 */


var RetryMode;
exports.RetryMode = RetryMode;

(function (RetryMode) {
  RetryMode[RetryMode["Exponential"] = 0] = "Exponential";
  RetryMode[RetryMode["Fixed"] = 1] = "Fixed";
})(RetryMode || (exports.RetryMode = RetryMode = {}));
/**
 * Describes the retry operation type.
 * @enum RetryOperationType
 */


var RetryOperationType;
exports.RetryOperationType = RetryOperationType;

(function (RetryOperationType) {
  RetryOperationType["cbsAuth"] = "cbsAuth";
  RetryOperationType["connection"] = "connection";
  RetryOperationType["management"] = "management";
  RetryOperationType["receiverLink"] = "receiverLink";
  RetryOperationType["senderLink"] = "senderLink";
  RetryOperationType["sendMessage"] = "sendMessage";
  RetryOperationType["receiveMessage"] = "receiveMessage";
  RetryOperationType["session"] = "session";
})(RetryOperationType || (exports.RetryOperationType = RetryOperationType = {}));
/**
 * Validates the retry config.
 * @hidden
 */


function validateRetryConfig(config) {
  if (!config.operation) {
    throw new TypeError("Missing 'operation' in retry configuration");
  }

  if (!config.connectionId) {
    throw new TypeError("Missing 'connectionId' in retry configuration");
  }

  if (!config.operationType) {
    throw new TypeError("Missing 'operationType' in retry configuration");
  }
}
/**
 * Every operation is attempted at least once. Additional attempts are made if the previous attempt failed
 * with a retryable error. The number of additional attempts is governed by the `maxRetries` property provided
 * on the `RetryConfig` argument.
 *
 * If `mode` option is set to `Fixed`, then the retries are made on the
 * given operation for a specified number of times, with a fixed delay in between each retry each time.
 *
 * If `mode` option is set to `Exponential`, then the delay between retries is adjusted to increase
 * exponentially with each attempt using back-off factor of power 2.
 *
 * @param {RetryConfig<T>} config Parameters to configure retry operation
 *
 * @return {Promise<T>} Promise<T>.
 */


function retry(config) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
    validateRetryConfig(config);

    if (!config.retryOptions) {
      config.retryOptions = {};
    }

    if (config.retryOptions.maxRetries == undefined || config.retryOptions.maxRetries < 0) {
      config.retryOptions.maxRetries = _constants.Constants.defaultMaxRetries;
    }

    if (config.retryOptions.retryDelayInMs == undefined || config.retryOptions.retryDelayInMs < 0) {
      config.retryOptions.retryDelayInMs = _constants.Constants.defaultDelayBetweenOperationRetriesInMs;
    }

    if (config.retryOptions.maxRetryDelayInMs == undefined || config.retryOptions.maxRetryDelayInMs < 0) {
      config.retryOptions.maxRetryDelayInMs = _constants.Constants.defaultMaxDelayForExponentialRetryInMs;
    }

    if (config.retryOptions.mode == undefined) {
      config.retryOptions.mode = RetryMode.Fixed;
    }

    let lastError;
    let result;
    let success = false;
    const totalNumberOfAttempts = config.retryOptions.maxRetries + 1;

    for (let i = 1; i <= totalNumberOfAttempts; i++) {
      _log.logger.verbose("[%s] Attempt number for '%s': %d.", config.connectionId, config.operationType, i);

      try {
        result = yield config.operation();
        success = true;

        _log.logger.verbose("[%s] Success for '%s', after attempt number: %d.", config.connectionId, config.operationType, i);

        if (result && !isDelivery(result)) {
          _log.logger.verbose("[%s] Success result for '%s': %O", config.connectionId, config.operationType, result);
        }

        break;
      } catch (_err) {
        let err = _err;

        if (!err.translated) {
          err = (0, _errors.translate)(err);
        }

        if (!err.retryable && err.name === "ServiceCommunicationError" && config.connectionHost) {
          const isConnected = yield (0, _checkNetworkConnection.checkNetworkConnection)(config.connectionHost);

          if (!isConnected) {
            err.name = "ConnectionLostError";
            err.retryable = true;
          }
        }

        lastError = err;

        _log.logger.verbose("[%s] Error occurred for '%s' in attempt number %d: %O", config.connectionId, config.operationType, i, err);

        let targetDelayInMs = config.retryOptions.retryDelayInMs;

        if (config.retryOptions.mode === RetryMode.Exponential) {
          let incrementDelta = Math.pow(2, i) - 1;
          const boundedRandDelta = config.retryOptions.retryDelayInMs * 0.8 + Math.floor(Math.random() * (config.retryOptions.retryDelayInMs * 1.2 - config.retryOptions.retryDelayInMs * 0.8));
          incrementDelta *= boundedRandDelta;
          targetDelayInMs = Math.min(incrementDelta, config.retryOptions.maxRetryDelayInMs);
        }

        if (lastError && lastError.retryable && totalNumberOfAttempts > i) {
          _log.logger.verbose("[%s] Sleeping for %d milliseconds for '%s'.", config.connectionId, targetDelayInMs, config.operationType);

          yield (0, _utils.delay)(targetDelayInMs, config.abortSignal, `The retry operation has been cancelled by the user.`);
          continue;
        } else {
          break;
        }
      }
    }

    if (success) {
      return result;
    } else {
      throw lastError;
    }
  });
}
},{"tslib":"CvJj","./errors":"gSjS","./util/utils":"WIBX","./log":"MjfT","./util/constants":"oklo","./util/checkNetworkConnection":"azJF"}],"ypo9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TokenType = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Describes the type of supported tokens.
 * @enum TokenType
 */
var TokenType;
exports.TokenType = TokenType;

(function (TokenType) {
  /**
   * The "jwt" token type. Used with AADTokenCredential.
   */
  TokenType["CbsTokenTypeJwt"] = "jwt";
  /**
   * The sas token type. Used with SharedKeyCredential.
   */

  TokenType["CbsTokenTypeSas"] = "servicebus.windows.net:sastoken";
})(TokenType || (exports.TokenType = TokenType = {}));
},{}],"Yq5H":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSharedAccessSignature = isSharedAccessSignature;
exports.ConnectionConfig = void 0;

var _utils = require("../util/utils");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Describes the ConnectionConfig module
 * @module ConnectionConfig
 */
const ConnectionConfig = {
  /**
   * Creates the connection config.
   * @param {string} connectionString - The connection string for a given service like
   * EventHub/ServiceBus.
   * @param {string} [path]           - The name/path of the entity (hub name) to which the
   * connection needs to happen. This will override the EntityPath in the connectionString
   * if present.
   * @returns {ConnectionConfig} ConnectionConfig
   */
  create(connectionString, path) {
    connectionString = String(connectionString);
    const parsedCS = (0, _utils.parseConnectionString)(connectionString);

    if (!parsedCS.Endpoint) {
      throw new TypeError("Missing Endpoint in Connection String.");
    }

    if (!parsedCS.Endpoint.endsWith("/")) parsedCS.Endpoint += "/";
    const result = {
      connectionString: connectionString,
      endpoint: parsedCS.Endpoint,
      host: parsedCS && parsedCS.Endpoint ? (parsedCS.Endpoint.match(".*://([^/]*)") || [])[1] : "",
      sharedAccessKeyName: parsedCS.SharedAccessKeyName,
      sharedAccessKey: parsedCS.SharedAccessKey
    };

    if (path || parsedCS.EntityPath) {
      result.entityPath = path || parsedCS.EntityPath;
    }

    return result;
  },

  /**
   * Validates the properties of connection config.
   * @param {ConnectionConfig} config The connection config to be validated.
   * @returns {void} void
   */
  validate(config, options) {
    if (!options) options = {};

    if (!config) {
      throw new TypeError("Missing configuration");
    }

    if (!config.endpoint) {
      throw new TypeError("Missing 'endpoint' in configuration");
    }

    config.endpoint = String(config.endpoint);

    if (!config.host) {
      throw new TypeError("Missing 'host' in configuration");
    }

    config.host = String(config.host);

    if (options.isEntityPathRequired && !config.entityPath) {
      throw new TypeError("Missing 'entityPath' in configuration");
    }

    if (config.entityPath != undefined) {
      config.entityPath = String(config.entityPath);
    }

    if (!isSharedAccessSignature(config.connectionString)) {
      if (!config.sharedAccessKeyName) {
        throw new TypeError("Missing 'sharedAccessKeyName' in configuration");
      }

      config.sharedAccessKeyName = String(config.sharedAccessKeyName);

      if (!config.sharedAccessKey) {
        throw new TypeError("Missing 'sharedAccessKey' in configuration");
      }

      config.sharedAccessKey = String(config.sharedAccessKey);
    }
  }

};
/**
 * @internal
 * @hidden
 */

exports.ConnectionConfig = ConnectionConfig;

function isSharedAccessSignature(connectionString) {
  return connectionString.match(/;{0,1}SharedAccessSignature=SharedAccessSignature /) != null;
}
},{"../util/utils":"WIBX"}],"PiV1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CbsClient = void 0;

var _tslib = require("tslib");

var _rheaPromise = require("rhea-promise");

var _constants = require("./util/constants");

var _log = require("./log");

var _errors = require("./errors");

var _utils = require("./util/utils");

var _requestResponseLink = require("./requestResponseLink");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @class CbsClient
 * Describes the EventHub/ServiceBus Cbs client that talks to the $cbs endpoint over AMQP connection.
 */
class CbsClient {
  /**
   * @constructor
   * @param {Connection} connection The AMQP connection.
   * @param {string} connectionLock A unique string (usually a guid) per connection.
   */
  constructor(connection, connectionLock) {
    /**
     * @property {string} endpoint CBS endpoint - "$cbs"
     */
    this.endpoint = _constants.Constants.cbsEndpoint;
    /**
     * @property {string} replyTo CBS replyTo - The receiver link name that the service should reply to.
     */

    this.replyTo = `${_constants.Constants.cbsReplyTo}-${(0, _rheaPromise.generate_uuid)()}`;
    /**
     * @property {string} cbsLock The unique lock name per $cbs session per connection that is used to
     * acquire the lock for establishing a cbs session if one does not exist for an amqp connection.
     */

    this.cbsLock = `${_constants.Constants.negotiateCbsKey}-${(0, _rheaPromise.generate_uuid)()}`;
    this.connection = connection;
    this.connectionLock = connectionLock;
  }
  /**
   * Creates a singleton instance of the CBS session if it hasn't been initialized previously on
   * the given connection.
   * @returns {Promise<void>} Promise<void>.
   */


  init() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      try {
        // Acquire the lock and establish an amqp connection if it does not exist.
        if (!this.connection.isOpen()) {
          _log.logger.verbose("The CBS client is trying to establish an AMQP connection.");

          yield _utils.defaultLock.acquire(this.connectionLock, () => {
            return this.connection.open();
          });
        }

        if (!this._isCbsSenderReceiverLinkOpen()) {
          const rxOpt = {
            source: {
              address: this.endpoint
            },
            name: this.replyTo,
            onSessionError: context => {
              const id = context.connection.options.id;
              const ehError = (0, _errors.translate)(context.session.error);

              _log.logger.verbose("[%s] An error occurred on the session for request/response links " + "for $cbs: %O", id, ehError);
            }
          };
          const srOpt = {
            target: {
              address: this.endpoint
            }
          };

          _log.logger.verbose("[%s] Creating sender/receiver links on a session for $cbs endpoint.", this.connection.id);

          this._cbsSenderReceiverLink = yield _requestResponseLink.RequestResponseLink.create(this.connection, srOpt, rxOpt);

          this._cbsSenderReceiverLink.sender.on(_rheaPromise.SenderEvents.senderError, context => {
            const id = context.connection.options.id;
            const ehError = (0, _errors.translate)(context.sender.error);

            _log.logger.verbose("[%s] An error occurred on the cbs sender link.. %O", id, ehError);
          });

          this._cbsSenderReceiverLink.receiver.on(_rheaPromise.ReceiverEvents.receiverError, context => {
            const id = context.connection.options.id;
            const ehError = (0, _errors.translate)(context.receiver.error);

            _log.logger.verbose("[%s] An error occurred on the cbs receiver link.. %O", id, ehError);
          });

          _log.logger.verbose("[%s] Successfully created the cbs sender '%s' and receiver '%s' " + "links over cbs session.", this.connection.id, this._cbsSenderReceiverLink.sender.name, this._cbsSenderReceiverLink.receiver.name);
        } else {
          _log.logger.verbose("[%s] CBS session is already present. Reusing the cbs sender '%s' " + "and receiver '%s' links over cbs session.", this.connection.id, this._cbsSenderReceiverLink.sender.name, this._cbsSenderReceiverLink.receiver.name);
        }
      } catch (err) {
        const translatedError = (0, _errors.translate)(err);

        _log.logger.warning("[%s] An error occurred while establishing the cbs links: %s", this.connection.id, `${translatedError === null || translatedError === void 0 ? void 0 : translatedError.name}: ${translatedError === null || translatedError === void 0 ? void 0 : translatedError.message}`);

        (0, _log.logErrorStackTrace)(translatedError);
        throw translatedError;
      }
    });
  }
  /**
   * Negotiates the CBS claim with the EventHub/ServiceBus Service.
   * @param {string} audience The entity token audience for which the token is requested in one
   * of the following forms:
   *
   * - **ServiceBus**
   *    - **Sender**
   *        - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
   *        - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
   *
   *    - **Receiver**
   *         - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
   *         - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
   *
   *    - **ManagementClient**
   *         - `"sb://<your-namespace>.servicebus.windows.net/<queue-name>/$management"`.
   *         - `"sb://<your-namespace>.servicebus.windows.net/<topic-name>/$management"`.
   *
   * - **EventHubs**
   *     - **Sender**
   *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>"`
   *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>"`.
   *
   *     - **Receiver**
   *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>"`.
   *
   *     - **ManagementClient**
   *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/$management"`.
   * @param {string} token The token that needs to be sent in the put-token request.
   * @return {Promise<any>} Returns a Promise that resolves when $cbs authentication is successful
   * and rejects when an error occurs during $cbs authentication.
   */


  negotiateClaim(audience, token, tokenType) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      try {
        const request = {
          body: token,
          message_id: (0, _rheaPromise.generate_uuid)(),
          reply_to: this.replyTo,
          to: this.endpoint,
          application_properties: {
            operation: _constants.Constants.operationPutToken,
            name: audience,
            type: tokenType
          }
        };
        const responseMessage = yield this._cbsSenderReceiverLink.sendRequest(request);

        _log.logger.verbose("[%s] The CBS response is: %O", this.connection.id, responseMessage);

        return this._fromRheaMessageResponse(responseMessage);
      } catch (err) {
        _log.logger.warning("[%s] An error occurred while negotiating the cbs claim: %s", this.connection.id, `${err === null || err === void 0 ? void 0 : err.name}: ${err === null || err === void 0 ? void 0 : err.message}`);

        (0, _log.logErrorStackTrace)(err);
        throw err;
      }
    });
  }
  /**
   * Closes the AMQP cbs session to the EventHub/ServiceBus for this client,
   * returning a promise that will be resolved when disconnection is completed.
   * @return {Promise<void>}
   */


  close() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      try {
        if (this._isCbsSenderReceiverLinkOpen()) {
          const cbsLink = this._cbsSenderReceiverLink;
          this._cbsSenderReceiverLink = undefined;
          yield cbsLink.close();

          _log.logger.verbose("[%s] Successfully closed the cbs session.", this.connection.id);
        }
      } catch (err) {
        const msg = `An error occurred while closing the cbs link: ${err.stack || JSON.stringify(err)}.`;

        _log.logger.verbose("[%s] %s", this.connection.id, msg);

        throw new Error(msg);
      }
    });
  }
  /**
   * Removes the AMQP cbs session to the EventHub/ServiceBus for this client,
   * @returns {void} void
   */


  remove() {
    try {
      if (this._cbsSenderReceiverLink) {
        const cbsLink = this._cbsSenderReceiverLink;
        this._cbsSenderReceiverLink = undefined;
        cbsLink.remove();

        _log.logger.verbose("[%s] Successfully removed the cbs session.", this.connection.id);
      }
    } catch (err) {
      const msg = `An error occurred while removing the cbs link: ${err.stack || JSON.stringify(err)}.`;

      _log.logger.verbose("[%s] %s", this.connection.id, msg);

      throw new Error(msg);
    }
  }
  /**
   * Indicates whether the cbs sender receiver link is open or closed.
   * @return {boolean} `true` open, `false` closed.
   */


  _isCbsSenderReceiverLinkOpen() {
    return this._cbsSenderReceiverLink && this._cbsSenderReceiverLink.isOpen();
  }

  _fromRheaMessageResponse(msg) {
    const cbsResponse = {
      correlationId: msg.correlation_id,
      statusCode: msg.application_properties ? msg.application_properties["status-code"] : "",
      statusDescription: msg.application_properties ? msg.application_properties["status-description"] : ""
    };

    _log.logger.verbose("[%s] The deserialized CBS response is: %o", this.connection.id, cbsResponse);

    return cbsResponse;
  }

}

exports.CbsClient = CbsClient;
},{"tslib":"CvJj","rhea-promise":"fxSK","./util/constants":"oklo","./log":"MjfT","./errors":"gSjS","./util/utils":"WIBX","./requestResponseLink":"DyaW"}],"PHFr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AmqpMessageHeader = void 0;

var _log = require("./log");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/* eslint-disable eqeqeq */

/**
 * Describes the operations that can be performed on the message header.
 * @module MessageHeader
 */
const AmqpMessageHeader = {
  /**
   * Converts MessageHeader to RheaMessageHeader.
   *
   * @param {MessageHeader} props Message header.
   * @returns {RheaMessageHeader} RheaMessageHeader
   */
  toRheaMessageHeader(props) {
    const amqpHeader = {};

    if (props.deliveryCount != undefined) {
      amqpHeader.delivery_count = props.deliveryCount;
    }

    if (props.durable != undefined) amqpHeader.durable = props.durable;

    if (props.firstAcquirer != undefined) {
      amqpHeader.first_acquirer = props.firstAcquirer;
    }

    if (props.priority != undefined) {
      amqpHeader.priority = props.priority;
    }

    if (props.timeToLive != undefined) {
      amqpHeader.ttl = props.timeToLive;
    }

    _log.logger.verbose("To RheaMessageHeader: %O", amqpHeader);

    return amqpHeader;
  },

  /**
   * Converts RheaMessageHeader to MessageHeader.
   *
   * @param {RheaMessageHeader} props Amqp Message Header
   * @returns {AmqpMessageHeader} MessageHeader.
   */
  fromRheaMessageHeader(props) {
    const msgHeader = {};

    if (props.delivery_count != undefined) {
      msgHeader.deliveryCount = props.delivery_count;
    }

    if (props.durable != undefined) {
      msgHeader.durable = props.durable;
    }

    if (props.first_acquirer != undefined) {
      msgHeader.firstAcquirer = props.first_acquirer;
    }

    if (props.priority != undefined) {
      msgHeader.priority = props.priority;
    }

    if (props.ttl != undefined) {
      msgHeader.timeToLive = props.ttl;
    }

    _log.logger.verbose("From RheaMessageHeader: %O", msgHeader);

    return msgHeader;
  }

};
exports.AmqpMessageHeader = AmqpMessageHeader;
},{"./log":"MjfT"}],"XShq":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AmqpMessageProperties = void 0;

var _log = require("./log");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/* eslint-disable eqeqeq */

/**
 * Describes the operations that can be performed on the amqp message properties.
 * @module AmqpMessageProperties
 */
const AmqpMessageProperties = {
  /**
   * Converts MessageProperties to RheaMessageProperties.
   * @param {MessageProperties} props Message properties.
   * @returns {RheaMessageProperties} RheaMessageProperties.
   */
  toRheaMessageProperties(props) {
    const amqpProperties = {};

    if (props.absoluteExpiryTime != undefined) {
      amqpProperties.absolute_expiry_time = props.absoluteExpiryTime;
    }

    if (props.contentEncoding != undefined) {
      amqpProperties.content_encoding = props.contentEncoding;
    }

    if (props.contentType != undefined) {
      amqpProperties.content_type = props.contentType;
    }

    if (props.correlationId != undefined) {
      amqpProperties.correlation_id = props.correlationId;
    }

    if (props.creationTime != undefined) {
      amqpProperties.creation_time = props.creationTime;
    }

    if (props.groupId != undefined) {
      amqpProperties.group_id = props.groupId;
    }

    if (props.groupSequence != undefined) {
      amqpProperties.group_sequence = props.groupSequence;
    }

    if (props.messageId != undefined) {
      amqpProperties.message_id = props.messageId;
    }

    if (props.replyTo != undefined) {
      amqpProperties.reply_to = props.replyTo;
    }

    if (props.replyToGroupId != undefined) {
      amqpProperties.reply_to_group_id = props.replyToGroupId;
    }

    if (props.subject != undefined) {
      amqpProperties.subject = props.subject;
    }

    if (props.to != undefined) {
      amqpProperties.to = props.to;
    } // if (props.userId != undefined) {
    //   amqpProperties.user_id = props.userId;
    // }


    _log.logger.verbose("To RheaMessageProperties: %O", amqpProperties);

    return amqpProperties;
  },

  /**
   * Converts RheaMessageProperties to MessageProperties.
   * @param {RheaMessageProperties} props Amqp message properties.
   * @returns {AmqpMessageProperties} MessageProperties.
   */
  fromRheaMessageProperties(props) {
    const msgProperties = {};

    if (props.absolute_expiry_time != undefined) {
      msgProperties.absoluteExpiryTime = props.absolute_expiry_time;
    }

    if (props.content_encoding != undefined) {
      msgProperties.contentEncoding = props.content_encoding;
    }

    if (props.content_type != undefined) {
      msgProperties.contentType = props.content_type;
    }

    if (props.correlation_id != undefined) {
      msgProperties.correlationId = props.correlation_id;
    }

    if (props.creation_time != undefined) {
      msgProperties.creationTime = props.creation_time;
    }

    if (props.group_id != undefined) {
      msgProperties.groupId = props.group_id;
    }

    if (props.group_sequence != undefined) {
      msgProperties.groupSequence = props.group_sequence;
    }

    if (props.message_id != undefined) {
      msgProperties.messageId = props.message_id;
    }

    if (props.reply_to != undefined) {
      msgProperties.replyTo = props.reply_to;
    }

    if (props.reply_to_group_id != undefined) {
      msgProperties.replyToGroupId = props.reply_to_group_id;
    }

    if (props.subject != undefined) {
      msgProperties.subject = props.subject;
    }

    if (props.to != undefined) {
      msgProperties.to = props.to;
    } // if (props.user_id != undefined) {
    //   msgProperties.userId = props.user_id;
    // }


    _log.logger.verbose("From RheaMessageProperties: %O", msgProperties);

    return msgProperties;
  }

};
exports.AmqpMessageProperties = AmqpMessageProperties;
},{"./log":"MjfT"}],"Bz72":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPlatformInfo = getPlatformInfo;
exports.getFrameworkInfo = getFrameworkInfo;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Returns information about the platform this function is being run on.
 * @hidden
 * @internal
 */
function getPlatformInfo() {
  return `(javascript-Browser-${getReleaseInfo()})`;
}
/**
 * Returns information about Node.js this function is being run on.
 * @hidden
 * @internal
 */


function getFrameworkInfo() {
  return `Browser/${getReleaseInfo()}`;
}
/**
 * @internal
 * @hidden
 *
 * @returns {string}
 */


function getReleaseInfo() {
  if (typeof self === "undefined") {
    return "";
  }

  const navigator = self.navigator;
  return navigator.appVersion;
}
},{}],"uOjg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConnectionContextBase = void 0;

var _rheaPromise = require("rhea-promise");

var _cbs = require("./cbs");

var _connectionConfig = require("./connectionConfig/connectionConfig");

var _constants = require("./util/constants");

var _runtimeInfo = require("./util/runtimeInfo");

var _utils = require("./util/utils");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const ConnectionContextBase = {
  /**
   * Creates the base connection context.
   * @param {CreateConnectionContextBaseParameters} parameters Parameters to be provided to create
   * the base connection context.
   */
  create(parameters) {
    _connectionConfig.ConnectionConfig.validate(parameters.config, {
      isEntityPathRequired: parameters.isEntityPathRequired || false
    });

    const userAgent = parameters.connectionProperties.userAgent;

    if (userAgent.length > _constants.Constants.maxUserAgentLength) {
      throw new Error(`The user-agent string cannot be more than ${_constants.Constants.maxUserAgentLength} characters in length.` + `The given user-agent string is: ${userAgent} with length: ${userAgent.length}`);
    }

    const connectionOptions = {
      transport: _constants.Constants.TLS,
      host: parameters.config.host,
      hostname: parameters.config.host,
      username: parameters.config.sharedAccessKeyName,
      port: 5671,
      reconnect: false,
      properties: {
        product: parameters.connectionProperties.product,
        version: parameters.connectionProperties.version,
        "user-agent": userAgent,
        platform: (0, _runtimeInfo.getPlatformInfo)(),
        framework: (0, _runtimeInfo.getFrameworkInfo)()
      },
      idle_time_out: _constants.Constants.defaultConnectionIdleTimeoutInMs,
      operationTimeoutInSeconds: parameters.operationTimeoutInMs ? parameters.operationTimeoutInMs / 1000 : undefined
    };

    if (parameters.config.webSocket || !_utils.isNode && typeof window !== "undefined" && window.WebSocket) {
      const socket = parameters.config.webSocket || window.WebSocket;
      const host = parameters.config.host;
      const endpoint = parameters.config.webSocketEndpointPath || "";
      const socketOptions = parameters.config.webSocketConstructorOptions || {};
      connectionOptions.webSocketOptions = {
        webSocket: socket,
        url: `wss://${host}:443/${endpoint}`,
        protocol: ["AMQPWSB10"],
        options: socketOptions
      };
    }

    const connection = new _rheaPromise.Connection(connectionOptions);
    const connectionLock = `${_constants.Constants.establishConnection}-${(0, _rheaPromise.generate_uuid)()}`;
    const connectionContextBase = {
      wasConnectionCloseCalled: false,
      connectionLock: connectionLock,
      negotiateClaimLock: `${_constants.Constants.negotiateClaim}-${(0, _rheaPromise.generate_uuid)()}`,
      connection: connection,
      connectionId: connection.id,
      cbsSession: new _cbs.CbsClient(connection, connectionLock),
      config: parameters.config,

      refreshConnection() {
        const connection = new _rheaPromise.Connection(connectionOptions);
        const connectionLock = `${_constants.Constants.establishConnection}-${(0, _rheaPromise.generate_uuid)()}`;
        this.wasConnectionCloseCalled = false;
        this.connectionLock = connectionLock;
        this.negotiateClaimLock = `${_constants.Constants.negotiateClaim} - ${(0, _rheaPromise.generate_uuid)()}`;
        this.connection = connection;
        this.connectionId = connection.id;
        this.cbsSession = new _cbs.CbsClient(connection, connectionLock);
      }

    };
    return connectionContextBase;
  }

};
exports.ConnectionContextBase = ConnectionContextBase;
},{"rhea-promise":"fxSK","./cbs":"PiV1","./connectionConfig/connectionConfig":"Yq5H","./util/constants":"oklo","./util/runtimeInfo":"Bz72","./util/utils":"WIBX"}],"zXZQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AmqpAnnotatedMessage = void 0;

var _messageHeader = require("./messageHeader");

var _messageProperties = require("./messageProperties");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/* eslint-disable eqeqeq */

/**
 * Describes the operations that can be performed on(or to get) the AmqpAnnotatedMessage.
 */
const AmqpAnnotatedMessage = {
  /**
   * Takes RheaMessage(`Message` type from "rhea") and returns it in the AmqpAnnotatedMessage format.
   *
   * @param {RheaMessage} msg
   */
  fromRheaMessage(msg) {
    return {
      header: _messageHeader.AmqpMessageHeader.fromRheaMessageHeader(msg),
      footer: msg.footer,
      messageAnnotations: msg.message_annotations,
      deliveryAnnotations: msg.delivery_annotations,
      applicationProperties: msg.application_properties,
      properties: _messageProperties.AmqpMessageProperties.fromRheaMessageProperties(msg),
      body: msg.body
    };
  }

};
exports.AmqpAnnotatedMessage = AmqpAnnotatedMessage;
},{"./messageHeader":"PHFr","./messageProperties":"XShq"}],"n95d":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "RequestResponseLink", {
  enumerable: true,
  get: function () {
    return _requestResponseLink.RequestResponseLink;
  }
});
Object.defineProperty(exports, "retry", {
  enumerable: true,
  get: function () {
    return _retry.retry;
  }
});
Object.defineProperty(exports, "RetryOperationType", {
  enumerable: true,
  get: function () {
    return _retry.RetryOperationType;
  }
});
Object.defineProperty(exports, "RetryMode", {
  enumerable: true,
  get: function () {
    return _retry.RetryMode;
  }
});
Object.defineProperty(exports, "TokenType", {
  enumerable: true,
  get: function () {
    return _token.TokenType;
  }
});
Object.defineProperty(exports, "ConnectionConfig", {
  enumerable: true,
  get: function () {
    return _connectionConfig.ConnectionConfig;
  }
});
Object.defineProperty(exports, "CbsClient", {
  enumerable: true,
  get: function () {
    return _cbs.CbsClient;
  }
});
Object.defineProperty(exports, "Constants", {
  enumerable: true,
  get: function () {
    return _constants.Constants;
  }
});
Object.defineProperty(exports, "AmqpMessageHeader", {
  enumerable: true,
  get: function () {
    return _messageHeader.AmqpMessageHeader;
  }
});
Object.defineProperty(exports, "AmqpMessageProperties", {
  enumerable: true,
  get: function () {
    return _messageProperties.AmqpMessageProperties;
  }
});
Object.defineProperty(exports, "ConnectionContextBase", {
  enumerable: true,
  get: function () {
    return _ConnectionContextBase.ConnectionContextBase;
  }
});
Object.defineProperty(exports, "MessagingError", {
  enumerable: true,
  get: function () {
    return _errors.MessagingError;
  }
});
Object.defineProperty(exports, "isMessagingError", {
  enumerable: true,
  get: function () {
    return _errors.isMessagingError;
  }
});
Object.defineProperty(exports, "ErrorNameConditionMapper", {
  enumerable: true,
  get: function () {
    return _errors.ErrorNameConditionMapper;
  }
});
Object.defineProperty(exports, "ConditionErrorNameMapper", {
  enumerable: true,
  get: function () {
    return _errors.ConditionErrorNameMapper;
  }
});
Object.defineProperty(exports, "translate", {
  enumerable: true,
  get: function () {
    return _errors.translate;
  }
});
Object.defineProperty(exports, "retryableErrors", {
  enumerable: true,
  get: function () {
    return _errors.retryableErrors;
  }
});
Object.defineProperty(exports, "isSystemError", {
  enumerable: true,
  get: function () {
    return _errors.isSystemError;
  }
});
Object.defineProperty(exports, "SystemErrorConditionMapper", {
  enumerable: true,
  get: function () {
    return _errors.SystemErrorConditionMapper;
  }
});
Object.defineProperty(exports, "delay", {
  enumerable: true,
  get: function () {
    return _utils.delay;
  }
});
Object.defineProperty(exports, "parseConnectionString", {
  enumerable: true,
  get: function () {
    return _utils.parseConnectionString;
  }
});
Object.defineProperty(exports, "defaultLock", {
  enumerable: true,
  get: function () {
    return _utils.defaultLock;
  }
});
Object.defineProperty(exports, "AsyncLock", {
  enumerable: true,
  get: function () {
    return _utils.AsyncLock;
  }
});
Object.defineProperty(exports, "AmqpAnnotatedMessage", {
  enumerable: true,
  get: function () {
    return _amqpAnnotatedMessage.AmqpAnnotatedMessage;
  }
});
Object.defineProperty(exports, "logger", {
  enumerable: true,
  get: function () {
    return _log.logger;
  }
});

var _requestResponseLink = require("./requestResponseLink");

var _retry = require("./retry");

var _token = require("./auth/token");

var _connectionConfig = require("./connectionConfig/connectionConfig");

var _cbs = require("./cbs");

var _constants = require("./util/constants");

var _messageHeader = require("./messageHeader");

var _messageProperties = require("./messageProperties");

var _ConnectionContextBase = require("./ConnectionContextBase");

var _errors = require("./errors");

var _utils = require("./util/utils");

var _amqpAnnotatedMessage = require("./amqpAnnotatedMessage");

var _log = require("./log");
},{"./requestResponseLink":"DyaW","./retry":"mE9i","./auth/token":"ypo9","./connectionConfig/connectionConfig":"Yq5H","./cbs":"PiV1","./util/constants":"oklo","./messageHeader":"PHFr","./messageProperties":"XShq","./ConnectionContextBase":"uOjg","./errors":"gSjS","./util/utils":"WIBX","./amqpAnnotatedMessage":"zXZQ","./log":"MjfT"}],"Odc4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AzureKeyCredential = void 0;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * A static-key-based credential that supports updating
 * the underlying key value.
 */
var AzureKeyCredential =
/** @class */
function () {
  /**
   * Create an instance of an AzureKeyCredential for use
   * with a service client.
   *
   * @param key - The initial value of the key to use in authentication
   */
  function AzureKeyCredential(key) {
    if (!key) {
      throw new Error("key must be a non-empty string");
    }

    this._key = key;
  }

  Object.defineProperty(AzureKeyCredential.prototype, "key", {
    /**
     * The value of the key to be used in authentication
     */
    get: function () {
      return this._key;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Change the value of the key.
   *
   * Updates will take effect upon the next request after
   * updating the key value.
   *
   * @param newKey - The new key value to be used
   */

  AzureKeyCredential.prototype.update = function (newKey) {
    this._key = newKey;
  };

  return AzureKeyCredential;
}();

exports.AzureKeyCredential = AzureKeyCredential;
},{}],"Dpo0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isTokenCredential = isTokenCredential;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Tests an object to determine whether it implements TokenCredential.
 *
 * @param credential - The assumed TokenCredential to be tested.
 */
function isTokenCredential(credential) {
  // Check for an object with a 'getToken' function and possibly with
  // a 'signRequest' function.  We do this check to make sure that
  // a ServiceClientCredentials implementor (like TokenClientCredentials
  // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if
  // it doesn't actually implement TokenCredential also.
  var castCredential = credential;
  return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === undefined || castCredential.getToken.length > 0);
}
},{}],"Ujm9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AzureKeyCredential", {
  enumerable: true,
  get: function () {
    return _azureKeyCredential.AzureKeyCredential;
  }
});
Object.defineProperty(exports, "isTokenCredential", {
  enumerable: true,
  get: function () {
    return _tokenCredential.isTokenCredential;
  }
});

var _azureKeyCredential = require("./azureKeyCredential");

var _tokenCredential = require("./tokenCredential");
},{"./azureKeyCredential":"Odc4","./tokenCredential":"Dpo0"}],"wA5d":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isHttpHeadersLike = isHttpHeadersLike;
exports.HttpHeaders = void 0;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * A collection of HttpHeaders that can be sent with a HTTP request.
 */
function getHeaderKey(headerName) {
  return headerName.toLowerCase();
}

function isHttpHeadersLike(object) {
  if (object && typeof object === "object") {
    var castObject = object;

    if (typeof castObject.rawHeaders === "function" && typeof castObject.clone === "function" && typeof castObject.get === "function" && typeof castObject.set === "function" && typeof castObject.contains === "function" && typeof castObject.remove === "function" && typeof castObject.headersArray === "function" && typeof castObject.headerValues === "function" && typeof castObject.headerNames === "function" && typeof castObject.toJson === "function") {
      return true;
    }
  }

  return false;
}
/**
 * A collection of HTTP header key/value pairs.
 */


var HttpHeaders =
/** @class */
function () {
  function HttpHeaders(rawHeaders) {
    this._headersMap = {};

    if (rawHeaders) {
      for (var headerName in rawHeaders) {
        this.set(headerName, rawHeaders[headerName]);
      }
    }
  }
  /**
   * Set a header in this collection with the provided name and value. The name is
   * case-insensitive.
   * @param headerName - The name of the header to set. This value is case-insensitive.
   * @param headerValue - The value of the header to set.
   */


  HttpHeaders.prototype.set = function (headerName, headerValue) {
    this._headersMap[getHeaderKey(headerName)] = {
      name: headerName,
      value: headerValue.toString()
    };
  };
  /**
   * Get the header value for the provided header name, or undefined if no header exists in this
   * collection with the provided name.
   * @param headerName - The name of the header.
   */


  HttpHeaders.prototype.get = function (headerName) {
    var header = this._headersMap[getHeaderKey(headerName)];

    return !header ? undefined : header.value;
  };
  /**
   * Get whether or not this header collection contains a header entry for the provided header name.
   */


  HttpHeaders.prototype.contains = function (headerName) {
    return !!this._headersMap[getHeaderKey(headerName)];
  };
  /**
   * Remove the header with the provided headerName. Return whether or not the header existed and
   * was removed.
   * @param headerName - The name of the header to remove.
   */


  HttpHeaders.prototype.remove = function (headerName) {
    var result = this.contains(headerName);
    delete this._headersMap[getHeaderKey(headerName)];
    return result;
  };
  /**
   * Get the headers that are contained this collection as an object.
   */


  HttpHeaders.prototype.rawHeaders = function () {
    var result = {};

    for (var headerKey in this._headersMap) {
      var header = this._headersMap[headerKey];
      result[header.name.toLowerCase()] = header.value;
    }

    return result;
  };
  /**
   * Get the headers that are contained in this collection as an array.
   */


  HttpHeaders.prototype.headersArray = function () {
    var headers = [];

    for (var headerKey in this._headersMap) {
      headers.push(this._headersMap[headerKey]);
    }

    return headers;
  };
  /**
   * Get the header names that are contained in this collection.
   */


  HttpHeaders.prototype.headerNames = function () {
    var headerNames = [];
    var headers = this.headersArray();

    for (var i = 0; i < headers.length; ++i) {
      headerNames.push(headers[i].name);
    }

    return headerNames;
  };
  /**
   * Get the header values that are contained in this collection.
   */


  HttpHeaders.prototype.headerValues = function () {
    var headerValues = [];
    var headers = this.headersArray();

    for (var i = 0; i < headers.length; ++i) {
      headerValues.push(headers[i].value);
    }

    return headerValues;
  };
  /**
   * Get the JSON object representation of this HTTP header collection.
   */


  HttpHeaders.prototype.toJson = function () {
    return this.rawHeaders();
  };
  /**
   * Get the string representation of this HTTP header collection.
   */


  HttpHeaders.prototype.toString = function () {
    return JSON.stringify(this.toJson());
  };
  /**
   * Create a deep clone/copy of this HttpHeaders collection.
   */


  HttpHeaders.prototype.clone = function () {
    return new HttpHeaders(this.rawHeaders());
  };

  return HttpHeaders;
}();

exports.HttpHeaders = HttpHeaders;
},{}],"WMCt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeString = encodeString;
exports.encodeByteArray = encodeByteArray;
exports.decodeString = decodeString;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Encodes a string in base64 format.
 * @param value - The string to encode
 */
function encodeString(value) {
  return btoa(value);
}
/**
 * Encodes a byte array in base64 format.
 * @param value - The Uint8Aray to encode
 */


function encodeByteArray(value) {
  var str = "";

  for (var i = 0; i < value.length; i++) {
    str += String.fromCharCode(value[i]);
  }

  return btoa(str);
}
/**
 * Decodes a base64 string into a byte array.
 * @param value - The base64 string to decode
 */


function decodeString(value) {
  var byteString = atob(value);
  var arr = new Uint8Array(byteString.length);

  for (var i = 0; i < byteString.length; i++) {
    arr[i] = byteString.charCodeAt(i);
  }

  return arr;
}
},{}],"gKk3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
},{}],"Wq06":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;
},{}],"p9l8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
},{"./regex.js":"Wq06"}],"vDjk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;
},{"./validate.js":"p9l8"}],"qgnI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports.default = _default;
},{"./rng.js":"gKk3","./stringify.js":"vDjk"}],"rtKa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  var v;
  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;
},{"./validate.js":"p9l8"}],"Y6ie":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
},{"./stringify.js":"vDjk","./parse.js":"rtKa"}],"bGV3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';

  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 0xff;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));

  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
},{}],"vJdu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
},{"./v35.js":"Y6ie","./md5.js":"bGV3"}],"K7Zs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  var rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports.default = _default;
},{"./rng.js":"gKk3","./stringify.js":"vDjk"}],"MvYZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
},{}],"K2oB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
},{"./v35.js":"Y6ie","./sha1.js":"MvYZ"}],"loGb":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;
},{}],"GRom":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports.default = _default;
},{"./validate.js":"p9l8"}],"UeUD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./v1.js":"qgnI","./v3.js":"vJdu","./v4.js":"K7Zs","./v5.js":"K2oB","./nil.js":"loGb","./version.js":"GRom","./validate.js":"p9l8","./stringify.js":"vDjk","./parse.js":"rtKa"}],"o95E":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Constants = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var Constants = {
  /**
   * The core-http version
   */
  coreHttpVersion: "1.2.3",

  /**
   * Specifies HTTP.
   */
  HTTP: "http:",

  /**
   * Specifies HTTPS.
   */
  HTTPS: "https:",

  /**
   * Specifies HTTP Proxy.
   */
  HTTP_PROXY: "HTTP_PROXY",

  /**
   * Specifies HTTPS Proxy.
   */
  HTTPS_PROXY: "HTTPS_PROXY",

  /**
   * Specifies NO Proxy.
   */
  NO_PROXY: "NO_PROXY",

  /**
   * Specifies ALL Proxy.
   */
  ALL_PROXY: "ALL_PROXY",
  HttpConstants: {
    /**
     * Http Verbs
     */
    HttpVerbs: {
      PUT: "PUT",
      GET: "GET",
      DELETE: "DELETE",
      POST: "POST",
      MERGE: "MERGE",
      HEAD: "HEAD",
      PATCH: "PATCH"
    },
    StatusCodes: {
      TooManyRequests: 429
    }
  },

  /**
   * Defines constants for use with HTTP headers.
   */
  HeaderConstants: {
    /**
     * The Authorization header.
     */
    AUTHORIZATION: "authorization",
    AUTHORIZATION_SCHEME: "Bearer",

    /**
     * The Retry-After response-header field can be used with a 503 (Service
     * Unavailable) or 349 (Too Many Requests) responses to indicate how long
     * the service is expected to be unavailable to the requesting client.
     */
    RETRY_AFTER: "Retry-After",

    /**
     * The UserAgent header.
     */
    USER_AGENT: "User-Agent"
  }
};
exports.Constants = Constants;
},{}],"KdvI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.XML_CHARKEY = exports.XML_ATTRKEY = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Default key used to access the XML attributes.
 */
var XML_ATTRKEY = "$";
/**
 * Default key used to access the XML value content.
 */

exports.XML_ATTRKEY = XML_ATTRKEY;
var XML_CHARKEY = "_";
exports.XML_CHARKEY = XML_CHARKEY;
},{}],"DVp2":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.urlIsHTTPS = urlIsHTTPS;
exports.encodeUri = encodeUri;
exports.stripResponse = stripResponse;
exports.stripRequest = stripRequest;
exports.isValidUuid = isValidUuid;
exports.generateUuid = generateUuid;
exports.executePromisesSequentially = executePromisesSequentially;
exports.delay = delay;
exports.promiseToCallback = promiseToCallback;
exports.promiseToServiceCallback = promiseToServiceCallback;
exports.prepareXMLRootList = prepareXMLRootList;
exports.applyMixins = applyMixins;
exports.isDuration = isDuration;
exports.replaceAll = replaceAll;
exports.isPrimitiveType = isPrimitiveType;
exports.getEnvironmentValue = getEnvironmentValue;
exports.isNode = void 0;

var _uuid = require("uuid");

var _constants = require("./constants");

var _serializer = require("./serializer.common");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
/**
 * A constant that indicates whether the environment is node.js or browser based.
 */

var isNode = typeof process !== "undefined" && !!process.version && !!process.versions && !!process.versions.node;
/**
 * Checks if a parsed URL is HTTPS
 *
 * @param urlToCheck - The url to check
 * @returns True if the URL is HTTPS; false otherwise.
 */

exports.isNode = isNode;

function urlIsHTTPS(urlToCheck) {
  return urlToCheck.protocol.toLowerCase() === _constants.Constants.HTTPS;
}
/**
 * Encodes an URI.
 *
 * @param uri - The URI to be encoded.
 * @returns The encoded URI.
 */


function encodeUri(uri) {
  return encodeURIComponent(uri).replace(/!/g, "%21").replace(/"/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
}
/**
 * Returns a stripped version of the Http Response which only contains body,
 * headers and the status.
 *
 * @param response - The Http Response
 * @returns The stripped version of Http Response.
 */


function stripResponse(response) {
  var strippedResponse = {};
  strippedResponse.body = response.bodyAsText;
  strippedResponse.headers = response.headers;
  strippedResponse.status = response.status;
  return strippedResponse;
}
/**
 * Returns a stripped version of the Http Request that does not contain the
 * Authorization header.
 *
 * @param request - The Http Request object
 * @returns The stripped version of Http Request.
 */


function stripRequest(request) {
  var strippedRequest = request.clone();

  if (strippedRequest.headers) {
    strippedRequest.headers.remove("authorization");
  }

  return strippedRequest;
}
/**
 * Validates the given uuid as a string
 *
 * @param uuid - The uuid as a string that needs to be validated
 * @returns True if the uuid is valid; false otherwise.
 */


function isValidUuid(uuid) {
  return validUuidRegex.test(uuid);
}
/**
 * Generated UUID
 *
 * @returns RFC4122 v4 UUID.
 */


function generateUuid() {
  return (0, _uuid.v4)();
}
/**
 * Executes an array of promises sequentially. Inspiration of this method is here:
 * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!
 *
 * @param promiseFactories - An array of promise factories(A function that return a promise)
 * @param kickstart - Input to the first promise that is used to kickstart the promise chain.
 * If not provided then the promise chain starts with undefined.
 * @returns A chain of resolved or rejected promises
 */


function executePromisesSequentially(promiseFactories, kickstart) {
  var result = Promise.resolve(kickstart);
  promiseFactories.forEach(function (promiseFactory) {
    result = result.then(promiseFactory);
  });
  return result;
}
/**
 * A wrapper for setTimeout that resolves a promise after t milliseconds.
 * @param t - The number of milliseconds to be delayed.
 * @param value - The value to be resolved with after a timeout of t milliseconds.
 * @returns Resolved promise
 */


function delay(t, value) {
  return new Promise(function (resolve) {
    return setTimeout(function () {
      return resolve(value);
    }, t);
  });
}
/**
 * Converts a Promise to a callback.
 * @param promise - The Promise to be converted to a callback
 * @returns A function that takes the callback `(cb: Function) => void`
 * @deprecated generated code should instead depend on responseToBody
 */
// eslint-disable-next-line @typescript-eslint/ban-types


function promiseToCallback(promise) {
  if (typeof promise.then !== "function") {
    throw new Error("The provided input is not a Promise.");
  } // eslint-disable-next-line @typescript-eslint/ban-types


  return function (cb) {
    promise.then(function (data) {
      // eslint-disable-next-line promise/no-callback-in-promise
      return cb(undefined, data);
    }).catch(function (err) {
      // eslint-disable-next-line promise/no-callback-in-promise
      cb(err);
    });
  };
}
/**
 * Converts a Promise to a service callback.
 * @param promise - The Promise of HttpOperationResponse to be converted to a service callback
 * @returns A function that takes the service callback (cb: ServiceCallback<T>): void
 */


function promiseToServiceCallback(promise) {
  if (typeof promise.then !== "function") {
    throw new Error("The provided input is not a Promise.");
  }

  return function (cb) {
    promise.then(function (data) {
      return process.nextTick(cb, undefined, data.parsedBody, data.request, data);
    }).catch(function (err) {
      process.nextTick(cb, err);
    });
  };
}

function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
  var _a, _b, _c;

  if (!Array.isArray(obj)) {
    obj = [obj];
  }

  if (!xmlNamespaceKey || !xmlNamespace) {
    return _a = {}, _a[elementName] = obj, _a;
  }

  var result = (_b = {}, _b[elementName] = obj, _b);
  result[_serializer.XML_ATTRKEY] = (_c = {}, _c[xmlNamespaceKey] = xmlNamespace, _c);
  return result;
}
/**
 * Applies the properties on the prototype of sourceCtors to the prototype of targetCtor
 * @param targetCtor - The target object on which the properties need to be applied.
 * @param sourceCtors - An array of source objects from which the properties need to be taken.
 */


function applyMixins(targetCtorParam, sourceCtors) {
  var castTargetCtorParam = targetCtorParam;
  sourceCtors.forEach(function (sourceCtor) {
    Object.getOwnPropertyNames(sourceCtor.prototype).forEach(function (name) {
      castTargetCtorParam.prototype[name] = sourceCtor.prototype[name];
    });
  });
}

var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
/**
 * Indicates whether the given string is in ISO 8601 format.
 * @param value - The value to be validated for ISO 8601 duration format.
 * @returns `true` if valid, `false` otherwise.
 */

function isDuration(value) {
  return validateISODuration.test(value);
}
/**
 * Replace all of the instances of searchValue in value with the provided replaceValue.
 * @param value - The value to search and replace in.
 * @param searchValue - The value to search for in the value argument.
 * @param replaceValue - The value to replace searchValue with in the value argument.
 * @returns The value where each instance of searchValue was replaced with replacedValue.
 */


function replaceAll(value, searchValue, replaceValue) {
  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
}
/**
 * Determines whether the given entity is a basic/primitive type
 * (string, number, boolean, null, undefined).
 * @param value - Any entity
 * @returns true is it is primitive type, false otherwise.
 */


function isPrimitiveType(value) {
  return typeof value !== "object" && typeof value !== "function" || value === null;
}

function getEnvironmentValue(name) {
  if (process.env[name]) {
    return process.env[name];
  } else if (process.env[name.toLowerCase()]) {
    return process.env[name.toLowerCase()];
  }

  return undefined;
}
},{"uuid":"UeUD","./constants":"o95E","./serializer.common":"KdvI","process":"g5IB"}],"HiIJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serializeObject = serializeObject;
exports.MapperType = exports.Serializer = void 0;

var _tslib = require("tslib");

var base64 = _interopRequireWildcard(require("./util/base64"));

var utils = _interopRequireWildcard(require("./util/utils"));

var _serializer = require("./util/serializer.common");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/* eslint-disable eqeqeq */
var Serializer =
/** @class */
function () {
  function Serializer(modelMappers, isXML) {
    if (modelMappers === void 0) {
      modelMappers = {};
    }

    this.modelMappers = modelMappers;
    this.isXML = isXML;
  }

  Serializer.prototype.validateConstraints = function (mapper, value, objectName) {
    var failValidation = function (constraintName, constraintValue) {
      throw new Error("\"" + objectName + "\" with value \"" + value + "\" should satisfy the constraint \"" + constraintName + "\": " + constraintValue + ".");
    };

    if (mapper.constraints && value != undefined) {
      var valueAsNumber = value;
      var _a = mapper.constraints,
          ExclusiveMaximum = _a.ExclusiveMaximum,
          ExclusiveMinimum = _a.ExclusiveMinimum,
          InclusiveMaximum = _a.InclusiveMaximum,
          InclusiveMinimum = _a.InclusiveMinimum,
          MaxItems = _a.MaxItems,
          MaxLength = _a.MaxLength,
          MinItems = _a.MinItems,
          MinLength = _a.MinLength,
          MultipleOf = _a.MultipleOf,
          Pattern = _a.Pattern,
          UniqueItems = _a.UniqueItems;

      if (ExclusiveMaximum != undefined && valueAsNumber >= ExclusiveMaximum) {
        failValidation("ExclusiveMaximum", ExclusiveMaximum);
      }

      if (ExclusiveMinimum != undefined && valueAsNumber <= ExclusiveMinimum) {
        failValidation("ExclusiveMinimum", ExclusiveMinimum);
      }

      if (InclusiveMaximum != undefined && valueAsNumber > InclusiveMaximum) {
        failValidation("InclusiveMaximum", InclusiveMaximum);
      }

      if (InclusiveMinimum != undefined && valueAsNumber < InclusiveMinimum) {
        failValidation("InclusiveMinimum", InclusiveMinimum);
      }

      var valueAsArray = value;

      if (MaxItems != undefined && valueAsArray.length > MaxItems) {
        failValidation("MaxItems", MaxItems);
      }

      if (MaxLength != undefined && valueAsArray.length > MaxLength) {
        failValidation("MaxLength", MaxLength);
      }

      if (MinItems != undefined && valueAsArray.length < MinItems) {
        failValidation("MinItems", MinItems);
      }

      if (MinLength != undefined && valueAsArray.length < MinLength) {
        failValidation("MinLength", MinLength);
      }

      if (MultipleOf != undefined && valueAsNumber % MultipleOf !== 0) {
        failValidation("MultipleOf", MultipleOf);
      }

      if (Pattern) {
        var pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;

        if (typeof value !== "string" || value.match(pattern) === null) {
          failValidation("Pattern", Pattern);
        }
      }

      if (UniqueItems && valueAsArray.some(function (item, i, ar) {
        return ar.indexOf(item) !== i;
      })) {
        failValidation("UniqueItems", UniqueItems);
      }
    }
  };
  /**
   * Serialize the given object based on its metadata defined in the mapper
   *
   * @param mapper - The mapper which defines the metadata of the serializable object
   * @param object - A valid Javascript object to be serialized
   * @param objectName - Name of the serialized object
   * @param options - additional options to deserialization
   * @returns A valid serialized Javascript object
   */


  Serializer.prototype.serialize = function (mapper, object, objectName, options) {
    var _a, _b, _c;

    if (options === void 0) {
      options = {};
    }

    var updatedOptions = {
      rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "",
      includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
      xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : _serializer.XML_CHARKEY
    };
    var payload = {};
    var mapperType = mapper.type.name;

    if (!objectName) {
      objectName = mapper.serializedName;
    }

    if (mapperType.match(/^Sequence$/i) !== null) {
      payload = [];
    }

    if (mapper.isConstant) {
      object = mapper.defaultValue;
    } // This table of allowed values should help explain
    // the mapper.required and mapper.nullable properties.
    // X means "neither undefined or null are allowed".
    //           || required
    //           || true      | false
    //  nullable || ==========================
    //      true || null      | undefined/null
    //     false || X         | undefined
    // undefined || X         | undefined/null


    var required = mapper.required,
        nullable = mapper.nullable;

    if (required && nullable && object === undefined) {
      throw new Error(objectName + " cannot be undefined.");
    }

    if (required && !nullable && object == undefined) {
      throw new Error(objectName + " cannot be null or undefined.");
    }

    if (!required && nullable === false && object === null) {
      throw new Error(objectName + " cannot be null.");
    }

    if (object == undefined) {
      payload = object;
    } else {
      // Validate Constraints if any
      this.validateConstraints(mapper, object, objectName);

      if (mapperType.match(/^any$/i) !== null) {
        payload = object;
      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
        payload = serializeBasicTypes(mapperType, objectName, object);
      } else if (mapperType.match(/^Enum$/i) !== null) {
        var enumMapper = mapper;
        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
      } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
        payload = serializeDateTypes(mapperType, object, objectName);
      } else if (mapperType.match(/^ByteArray$/i) !== null) {
        payload = serializeByteArrayType(objectName, object);
      } else if (mapperType.match(/^Base64Url$/i) !== null) {
        payload = serializeBase64UrlType(objectName, object);
      } else if (mapperType.match(/^Sequence$/i) !== null) {
        payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
      } else if (mapperType.match(/^Dictionary$/i) !== null) {
        payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
      } else if (mapperType.match(/^Composite$/i) !== null) {
        payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
      }
    }

    return payload;
  };
  /**
   * Deserialize the given object based on its metadata defined in the mapper
   *
   * @param mapper - The mapper which defines the metadata of the serializable object
   * @param responseBody - A valid Javascript entity to be deserialized
   * @param objectName - Name of the deserialized object
   * @param options - Controls behavior of XML parser and builder.
   * @returns A valid deserialized Javascript object
   */


  Serializer.prototype.deserialize = function (mapper, responseBody, objectName, options) {
    var _a, _b, _c;

    if (options === void 0) {
      options = {};
    }

    var updatedOptions = {
      rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "",
      includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
      xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : _serializer.XML_CHARKEY
    };

    if (responseBody == undefined) {
      if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish
        // between the list being empty versus being missing,
        // so let's do the more user-friendly thing and return an empty list.
        responseBody = [];
      } // specifically check for undefined as default value can be a falsey value `0, "", false, null`


      if (mapper.defaultValue !== undefined) {
        responseBody = mapper.defaultValue;
      }

      return responseBody;
    }

    var payload;
    var mapperType = mapper.type.name;

    if (!objectName) {
      objectName = mapper.serializedName;
    }

    if (mapperType.match(/^Composite$/i) !== null) {
      payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
    } else {
      if (this.isXML) {
        var xmlCharKey = updatedOptions.xmlCharKey;
        var castResponseBody = responseBody;
        /**
         * If the mapper specifies this as a non-composite type value but the responseBody contains
         * both header ("$" i.e., XML_ATTRKEY) and body ("#" i.e., XML_CHARKEY) properties,
         * then just reduce the responseBody value to the body ("#" i.e., XML_CHARKEY) property.
         */

        if (castResponseBody[_serializer.XML_ATTRKEY] != undefined && castResponseBody[xmlCharKey] != undefined) {
          responseBody = castResponseBody[xmlCharKey];
        }
      }

      if (mapperType.match(/^Number$/i) !== null) {
        payload = parseFloat(responseBody);

        if (isNaN(payload)) {
          payload = responseBody;
        }
      } else if (mapperType.match(/^Boolean$/i) !== null) {
        if (responseBody === "true") {
          payload = true;
        } else if (responseBody === "false") {
          payload = false;
        } else {
          payload = responseBody;
        }
      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
        payload = responseBody;
      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
        payload = new Date(responseBody);
      } else if (mapperType.match(/^UnixTime$/i) !== null) {
        payload = unixTimeToDate(responseBody);
      } else if (mapperType.match(/^ByteArray$/i) !== null) {
        payload = base64.decodeString(responseBody);
      } else if (mapperType.match(/^Base64Url$/i) !== null) {
        payload = base64UrlToByteArray(responseBody);
      } else if (mapperType.match(/^Sequence$/i) !== null) {
        payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
      } else if (mapperType.match(/^Dictionary$/i) !== null) {
        payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
      }
    }

    if (mapper.isConstant) {
      payload = mapper.defaultValue;
    }

    return payload;
  };

  return Serializer;
}();

exports.Serializer = Serializer;

function trimEnd(str, ch) {
  var len = str.length;

  while (len - 1 >= 0 && str[len - 1] === ch) {
    --len;
  }

  return str.substr(0, len);
}

function bufferToBase64Url(buffer) {
  if (!buffer) {
    return undefined;
  }

  if (!(buffer instanceof Uint8Array)) {
    throw new Error("Please provide an input of type Uint8Array for converting to Base64Url.");
  } // Uint8Array to Base64.


  var str = base64.encodeByteArray(buffer); // Base64 to Base64Url.

  return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
}

function base64UrlToByteArray(str) {
  if (!str) {
    return undefined;
  }

  if (str && typeof str.valueOf() !== "string") {
    throw new Error("Please provide an input of type string for converting to Uint8Array");
  } // Base64Url to Base64.


  str = str.replace(/-/g, "+").replace(/_/g, "/"); // Base64 to Uint8Array.

  return base64.decodeString(str);
}

function splitSerializeName(prop) {
  var classes = [];
  var partialclass = "";

  if (prop) {
    var subwords = prop.split(".");

    for (var _i = 0, subwords_1 = subwords; _i < subwords_1.length; _i++) {
      var item = subwords_1[_i];

      if (item.charAt(item.length - 1) === "\\") {
        partialclass += item.substr(0, item.length - 1) + ".";
      } else {
        partialclass += item;
        classes.push(partialclass);
        partialclass = "";
      }
    }
  }

  return classes;
}

function dateToUnixTime(d) {
  if (!d) {
    return undefined;
  }

  if (typeof d.valueOf() === "string") {
    d = new Date(d);
  }

  return Math.floor(d.getTime() / 1000);
}

function unixTimeToDate(n) {
  if (!n) {
    return undefined;
  }

  return new Date(n * 1000);
}

function serializeBasicTypes(typeName, objectName, value) {
  if (value !== null && value !== undefined) {
    if (typeName.match(/^Number$/i) !== null) {
      if (typeof value !== "number") {
        throw new Error(objectName + " with value " + value + " must be of type number.");
      }
    } else if (typeName.match(/^String$/i) !== null) {
      if (typeof value.valueOf() !== "string") {
        throw new Error(objectName + " with value \"" + value + "\" must be of type string.");
      }
    } else if (typeName.match(/^Uuid$/i) !== null) {
      if (!(typeof value.valueOf() === "string" && utils.isValidUuid(value))) {
        throw new Error(objectName + " with value \"" + value + "\" must be of type string and a valid uuid.");
      }
    } else if (typeName.match(/^Boolean$/i) !== null) {
      if (typeof value !== "boolean") {
        throw new Error(objectName + " with value " + value + " must be of type boolean.");
      }
    } else if (typeName.match(/^Stream$/i) !== null) {
      var objectType = typeof value;

      if (objectType !== "string" && objectType !== "function" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob)) {
        throw new Error(objectName + " must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.");
      }
    }
  }

  return value;
}

function serializeEnumType(objectName, allowedValues, value) {
  if (!allowedValues) {
    throw new Error("Please provide a set of allowedValues to validate " + objectName + " as an Enum Type.");
  }

  var isPresent = allowedValues.some(function (item) {
    if (typeof item.valueOf() === "string") {
      return item.toLowerCase() === value.toLowerCase();
    }

    return item === value;
  });

  if (!isPresent) {
    throw new Error(value + " is not a valid value for " + objectName + ". The valid values are: " + JSON.stringify(allowedValues) + ".");
  }

  return value;
}

function serializeByteArrayType(objectName, value) {
  var returnValue = "";

  if (value != undefined) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(objectName + " must be of type Uint8Array.");
    }

    returnValue = base64.encodeByteArray(value);
  }

  return returnValue;
}

function serializeBase64UrlType(objectName, value) {
  var returnValue = "";

  if (value != undefined) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(objectName + " must be of type Uint8Array.");
    }

    returnValue = bufferToBase64Url(value) || "";
  }

  return returnValue;
}

function serializeDateTypes(typeName, value, objectName) {
  if (value != undefined) {
    if (typeName.match(/^Date$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(objectName + " must be an instanceof Date or a string in ISO8601 format.");
      }

      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
    } else if (typeName.match(/^DateTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(objectName + " must be an instanceof Date or a string in ISO8601 format.");
      }

      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(objectName + " must be an instanceof Date or a string in RFC-1123 format.");
      }

      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
    } else if (typeName.match(/^UnixTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(objectName + " must be an instanceof Date or a string in RFC-1123/ISO8601 format " + "for it to be serialized in UnixTime/Epoch format.");
      }

      value = dateToUnixTime(value);
    } else if (typeName.match(/^TimeSpan$/i) !== null) {
      if (!utils.isDuration(value)) {
        throw new Error(objectName + " must be a string in ISO 8601 format. Instead was \"" + value + "\".");
      }
    }
  }

  return value;
}

function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
  var _a, _b;

  if (!Array.isArray(object)) {
    throw new Error(objectName + " must be of type Array.");
  }

  var elementType = mapper.type.element;

  if (!elementType || typeof elementType !== "object") {
    throw new Error("element\" metadata for an Array must be defined in the " + ("mapper and it must of type \"object\" in " + objectName + "."));
  }

  var tempArray = [];

  for (var i = 0; i < object.length; i++) {
    var serializedValue = serializer.serialize(elementType, object[i], objectName, options);

    if (isXml && elementType.xmlNamespace) {
      var xmlnsKey = elementType.xmlNamespacePrefix ? "xmlns:" + elementType.xmlNamespacePrefix : "xmlns";

      if (elementType.type.name === "Composite") {
        tempArray[i] = (0, _tslib.__assign)({}, serializedValue);
        tempArray[i][_serializer.XML_ATTRKEY] = (_a = {}, _a[xmlnsKey] = elementType.xmlNamespace, _a);
      } else {
        tempArray[i] = {};
        tempArray[i][options.xmlCharKey] = serializedValue;
        tempArray[i][_serializer.XML_ATTRKEY] = (_b = {}, _b[xmlnsKey] = elementType.xmlNamespace, _b);
      }
    } else {
      tempArray[i] = serializedValue;
    }
  }

  return tempArray;
}

function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
  var _a;

  if (typeof object !== "object") {
    throw new Error(objectName + " must be of type object.");
  }

  var valueType = mapper.type.value;

  if (!valueType || typeof valueType !== "object") {
    throw new Error("\"value\" metadata for a Dictionary must be defined in the " + ("mapper and it must of type \"object\" in " + objectName + "."));
  }

  var tempDictionary = {};

  for (var _i = 0, _b = Object.keys(object); _i < _b.length; _i++) {
    var key = _b[_i];
    var serializedValue = serializer.serialize(valueType, object[key], objectName, options); // If the element needs an XML namespace we need to add it within the $ property

    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
  } // Add the namespace to the root element if needed


  if (isXml && mapper.xmlNamespace) {
    var xmlnsKey = mapper.xmlNamespacePrefix ? "xmlns:" + mapper.xmlNamespacePrefix : "xmlns";
    var result = tempDictionary;
    result[_serializer.XML_ATTRKEY] = (_a = {}, _a[xmlnsKey] = mapper.xmlNamespace, _a);
    return result;
  }

  return tempDictionary;
}
/**
 * Resolves the additionalProperties property from a referenced mapper
 * @param serializer - The serializer containing the entire set of mappers
 * @param mapper - The composite mapper to resolve
 * @param objectName - Name of the object being serialized
 */


function resolveAdditionalProperties(serializer, mapper, objectName) {
  var additionalProperties = mapper.type.additionalProperties;

  if (!additionalProperties && mapper.type.className) {
    var modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
    return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;
  }

  return additionalProperties;
}
/**
 * Finds the mapper referenced by className
 * @param serializer - The serializer containing the entire set of mappers
 * @param mapper - The composite mapper to resolve
 * @param objectName - Name of the object being serialized
 */


function resolveReferencedMapper(serializer, mapper, objectName) {
  var className = mapper.type.className;

  if (!className) {
    throw new Error("Class name for model \"" + objectName + "\" is not provided in the mapper \"" + JSON.stringify(mapper, undefined, 2) + "\".");
  }

  return serializer.modelMappers[className];
}
/**
 * Resolves a composite mapper's modelProperties.
 * @param serializer - The serializer containing the entire set of mappers
 * @param mapper - The composite mapper to resolve
 */


function resolveModelProperties(serializer, mapper, objectName) {
  var modelProps = mapper.type.modelProperties;

  if (!modelProps) {
    var modelMapper = resolveReferencedMapper(serializer, mapper, objectName);

    if (!modelMapper) {
      throw new Error("mapper() cannot be null or undefined for model \"" + mapper.type.className + "\".");
    }

    modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;

    if (!modelProps) {
      throw new Error("modelProperties cannot be null or undefined in the " + ("mapper \"" + JSON.stringify(modelMapper) + "\" of type \"" + mapper.type.className + "\" for object \"" + objectName + "\"."));
    }
  }

  return modelProps;
}

function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
  var _a, _b;

  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
    mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
  }

  if (object != undefined) {
    var payload = {};
    var modelProps = resolveModelProperties(serializer, mapper, objectName);

    for (var _i = 0, _c = Object.keys(modelProps); _i < _c.length; _i++) {
      var key = _c[_i];
      var propertyMapper = modelProps[key];

      if (propertyMapper.readOnly) {
        continue;
      }

      var propName = void 0;
      var parentObject = payload;

      if (serializer.isXML) {
        if (propertyMapper.xmlIsWrapped) {
          propName = propertyMapper.xmlName;
        } else {
          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
        }
      } else {
        var paths = splitSerializeName(propertyMapper.serializedName);
        propName = paths.pop();

        for (var _d = 0, paths_1 = paths; _d < paths_1.length; _d++) {
          var pathName = paths_1[_d];
          var childObject = parentObject[pathName];

          if (childObject == undefined && (object[key] != undefined || propertyMapper.defaultValue !== undefined)) {
            parentObject[pathName] = {};
          }

          parentObject = parentObject[pathName];
        }
      }

      if (parentObject != undefined) {
        if (isXml && mapper.xmlNamespace) {
          var xmlnsKey = mapper.xmlNamespacePrefix ? "xmlns:" + mapper.xmlNamespacePrefix : "xmlns";
          parentObject[_serializer.XML_ATTRKEY] = (0, _tslib.__assign)((0, _tslib.__assign)({}, parentObject[_serializer.XML_ATTRKEY]), (_a = {}, _a[xmlnsKey] = mapper.xmlNamespace, _a));
        }

        var propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
        var toSerialize = object[key];
        var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);

        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && toSerialize == undefined) {
          toSerialize = mapper.serializedName;
        }

        var serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);

        if (serializedValue !== undefined && propName != undefined) {
          var value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);

          if (isXml && propertyMapper.xmlIsAttribute) {
            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.
            // This keeps things simple while preventing name collision
            // with names in user documents.
            parentObject[_serializer.XML_ATTRKEY] = parentObject[_serializer.XML_ATTRKEY] || {};
            parentObject[_serializer.XML_ATTRKEY][propName] = serializedValue;
          } else if (isXml && propertyMapper.xmlIsWrapped) {
            parentObject[propName] = (_b = {}, _b[propertyMapper.xmlElementName] = value, _b);
          } else {
            parentObject[propName] = value;
          }
        }
      }
    }

    var additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);

    if (additionalPropertiesMapper) {
      var propNames = Object.keys(modelProps);

      var _loop_1 = function (clientPropName) {
        var isAdditionalProperty = propNames.every(function (pn) {
          return pn !== clientPropName;
        });

        if (isAdditionalProperty) {
          payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
        }
      };

      for (var clientPropName in object) {
        _loop_1(clientPropName);
      }
    }

    return payload;
  }

  return object;
}

function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
  var _a;

  if (!isXml || !propertyMapper.xmlNamespace) {
    return serializedValue;
  }

  var xmlnsKey = propertyMapper.xmlNamespacePrefix ? "xmlns:" + propertyMapper.xmlNamespacePrefix : "xmlns";
  var xmlNamespace = (_a = {}, _a[xmlnsKey] = propertyMapper.xmlNamespace, _a);

  if (["Composite"].includes(propertyMapper.type.name)) {
    if (serializedValue[_serializer.XML_ATTRKEY]) {
      return serializedValue;
    } else {
      var result_1 = (0, _tslib.__assign)({}, serializedValue);
      result_1[_serializer.XML_ATTRKEY] = xmlNamespace;
      return result_1;
    }
  }

  var result = {};
  result[options.xmlCharKey] = serializedValue;
  result[_serializer.XML_ATTRKEY] = xmlNamespace;
  return result;
}

function isSpecialXmlProperty(propertyName, options) {
  return [_serializer.XML_ATTRKEY, options.xmlCharKey].includes(propertyName);
}

function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
  var _a;

  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
    mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
  }

  var modelProps = resolveModelProperties(serializer, mapper, objectName);
  var instance = {};
  var handledPropertyNames = [];

  for (var _i = 0, _b = Object.keys(modelProps); _i < _b.length; _i++) {
    var key = _b[_i];
    var propertyMapper = modelProps[key];
    var paths = splitSerializeName(modelProps[key].serializedName);
    handledPropertyNames.push(paths[0]);
    var serializedName = propertyMapper.serializedName,
        xmlName = propertyMapper.xmlName,
        xmlElementName = propertyMapper.xmlElementName;
    var propertyObjectName = objectName;

    if (serializedName !== "" && serializedName !== undefined) {
      propertyObjectName = objectName + "." + serializedName;
    }

    var headerCollectionPrefix = propertyMapper.headerCollectionPrefix;

    if (headerCollectionPrefix) {
      var dictionary = {};

      for (var _c = 0, _d = Object.keys(responseBody); _c < _d.length; _c++) {
        var headerKey = _d[_c];

        if (headerKey.startsWith(headerCollectionPrefix)) {
          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
        }

        handledPropertyNames.push(headerKey);
      }

      instance[key] = dictionary;
    } else if (serializer.isXML) {
      if (propertyMapper.xmlIsAttribute && responseBody[_serializer.XML_ATTRKEY]) {
        instance[key] = serializer.deserialize(propertyMapper, responseBody[_serializer.XML_ATTRKEY][xmlName], propertyObjectName, options);
      } else {
        var propertyName = xmlElementName || xmlName || serializedName;

        if (propertyMapper.xmlIsWrapped) {
          /* a list of <xmlElementName> wrapped by <xmlName>
            For the xml example below
              <Cors>
                <CorsRule>...</CorsRule>
                <CorsRule>...</CorsRule>
              </Cors>
            the responseBody has
              {
                Cors: {
                  CorsRule: [{...}, {...}]
                }
              }
            xmlName is "Cors" and xmlElementName is"CorsRule".
          */
          var wrapped = responseBody[xmlName];
          var elementList = (_a = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _a !== void 0 ? _a : [];
          instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
        } else {
          var property = responseBody[propertyName];
          instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
        }
      }
    } else {
      // deserialize the property if it is present in the provided responseBody instance
      var propertyInstance = void 0;
      var res = responseBody; // traversing the object step by step.

      for (var _e = 0, paths_2 = paths; _e < paths_2.length; _e++) {
        var item = paths_2[_e];
        if (!res) break;
        res = res[item];
      }

      propertyInstance = res;
      var polymorphicDiscriminator = mapper.type.polymorphicDiscriminator; // checking that the model property name (key)(ex: "fishtype") and the
      // clientName of the polymorphicDiscriminator {metadata} (ex: "fishtype")
      // instead of the serializedName of the polymorphicDiscriminator (ex: "fish.type")
      // is a better approach. The generator is not consistent with escaping '\.' in the
      // serializedName of the property (ex: "fish\.type") that is marked as polymorphic discriminator
      // and the serializedName of the metadata polymorphicDiscriminator (ex: "fish.type"). However,
      // the clientName transformation of the polymorphicDiscriminator (ex: "fishtype") and
      // the transformation of model property name (ex: "fishtype") is done consistently.
      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.

      if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && propertyInstance == undefined) {
        propertyInstance = mapper.serializedName;
      }

      var serializedValue = void 0; // paging

      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
        propertyInstance = responseBody[key];
        instance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {
        serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
        instance[key] = serializedValue;
      }
    }
  }

  var additionalPropertiesMapper = mapper.type.additionalProperties;

  if (additionalPropertiesMapper) {
    var isAdditionalProperty = function (responsePropName) {
      for (var clientPropName in modelProps) {
        var paths = splitSerializeName(modelProps[clientPropName].serializedName);

        if (paths[0] === responsePropName) {
          return false;
        }
      }

      return true;
    };

    for (var responsePropName in responseBody) {
      if (isAdditionalProperty(responsePropName)) {
        instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
      }
    }
  } else if (responseBody) {
    for (var _f = 0, _g = Object.keys(responseBody); _f < _g.length; _f++) {
      var key = _g[_f];

      if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) {
        instance[key] = responseBody[key];
      }
    }
  }

  return instance;
}

function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
  var value = mapper.type.value;

  if (!value || typeof value !== "object") {
    throw new Error("\"value\" metadata for a Dictionary must be defined in the " + ("mapper and it must of type \"object\" in " + objectName));
  }

  if (responseBody) {
    var tempDictionary = {};

    for (var _i = 0, _a = Object.keys(responseBody); _i < _a.length; _i++) {
      var key = _a[_i];
      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
    }

    return tempDictionary;
  }

  return responseBody;
}

function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
  var element = mapper.type.element;

  if (!element || typeof element !== "object") {
    throw new Error("element\" metadata for an Array must be defined in the " + ("mapper and it must of type \"object\" in " + objectName));
  }

  if (responseBody) {
    if (!Array.isArray(responseBody)) {
      // xml2js will interpret a single element array as just the element, so force it to be an array
      responseBody = [responseBody];
    }

    var tempArray = [];

    for (var i = 0; i < responseBody.length; i++) {
      tempArray[i] = serializer.deserialize(element, responseBody[i], objectName + "[" + i + "]", options);
    }

    return tempArray;
  }

  return responseBody;
}

function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
  var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);

  if (polymorphicDiscriminator) {
    var discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];

    if (discriminatorName != undefined) {
      var discriminatorValue = object[discriminatorName];

      if (discriminatorValue != undefined) {
        var typeName = mapper.type.uberParent || mapper.type.className;
        var indexDiscriminator = discriminatorValue === typeName ? discriminatorValue : typeName + "." + discriminatorValue;
        var polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];

        if (polymorphicMapper) {
          mapper = polymorphicMapper;
        }
      }
    }
  }

  return mapper;
}

function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);
}

function getPolymorphicDiscriminatorSafely(serializer, typeName) {
  return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;
} // TODO: why is this here?


function serializeObject(toSerialize) {
  var castToSerialize = toSerialize;
  if (toSerialize == undefined) return undefined;

  if (toSerialize instanceof Uint8Array) {
    toSerialize = base64.encodeByteArray(toSerialize);
    return toSerialize;
  } else if (toSerialize instanceof Date) {
    return toSerialize.toISOString();
  } else if (Array.isArray(toSerialize)) {
    var array = [];

    for (var i = 0; i < toSerialize.length; i++) {
      array.push(serializeObject(toSerialize[i]));
    }

    return array;
  } else if (typeof toSerialize === "object") {
    var dictionary = {};

    for (var property in toSerialize) {
      dictionary[property] = serializeObject(castToSerialize[property]);
    }

    return dictionary;
  }

  return toSerialize;
}
/**
 * Utility function to create a K:V from a list of strings
 */


function strEnum(o) {
  var result = {};

  for (var _i = 0, o_1 = o; _i < o_1.length; _i++) {
    var key = o_1[_i];
    result[key] = key;
  }

  return result;
} // eslint-disable-next-line @typescript-eslint/no-redeclare


var MapperType = strEnum(["Base64Url", "Boolean", "ByteArray", "Composite", "Date", "DateTime", "DateTimeRfc1123", "Dictionary", "Enum", "Number", "Object", "Sequence", "String", "Stream", "TimeSpan", "UnixTime"]);
exports.MapperType = MapperType;
},{"tslib":"CvJj","./util/base64":"WMCt","./util/utils":"DVp2","./util/serializer.common":"KdvI"}],"xjLS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWebResourceLike = isWebResourceLike;
exports.WebResource = void 0;

var _httpHeaders = require("./httpHeaders");

var _serializer = require("./serializer");

var _utils = require("./util/utils");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function isWebResourceLike(object) {
  if (object && typeof object === "object") {
    var castObject = object;

    if (typeof castObject.url === "string" && typeof castObject.method === "string" && typeof castObject.headers === "object" && (0, _httpHeaders.isHttpHeadersLike)(castObject.headers) && typeof castObject.validateRequestProperties === "function" && typeof castObject.prepare === "function" && typeof castObject.clone === "function") {
      return true;
    }
  }

  return false;
}
/**
 * Creates a new WebResource object.
 *
 * This class provides an abstraction over a REST call by being library / implementation agnostic and wrapping the necessary
 * properties to initiate a request.
 */


var WebResource =
/** @class */
function () {
  function WebResource(url, method, body, query, headers, streamResponseBody, withCredentials, abortSignal, timeout, onUploadProgress, onDownloadProgress, proxySettings, keepAlive, decompressResponse, streamResponseStatusCodes) {
    this.streamResponseBody = streamResponseBody;
    this.streamResponseStatusCodes = streamResponseStatusCodes;
    this.url = url || "";
    this.method = method || "GET";
    this.headers = (0, _httpHeaders.isHttpHeadersLike)(headers) ? headers : new _httpHeaders.HttpHeaders(headers);
    this.body = body;
    this.query = query;
    this.formData = undefined;
    this.withCredentials = withCredentials || false;
    this.abortSignal = abortSignal;
    this.timeout = timeout || 0;
    this.onUploadProgress = onUploadProgress;
    this.onDownloadProgress = onDownloadProgress;
    this.proxySettings = proxySettings;
    this.keepAlive = keepAlive;
    this.decompressResponse = decompressResponse;
    this.requestId = this.headers.get("x-ms-client-request-id") || (0, _utils.generateUuid)();
  }
  /**
   * Validates that the required properties such as method, url, headers["Content-Type"],
   * headers["accept-language"] are defined. It will throw an error if one of the above
   * mentioned properties are not defined.
   */


  WebResource.prototype.validateRequestProperties = function () {
    if (!this.method) {
      throw new Error("WebResource.method is required.");
    }

    if (!this.url) {
      throw new Error("WebResource.url is required.");
    }
  };
  /**
   * Prepares the request.
   * @param options - Options to provide for preparing the request.
   * @returns Returns the prepared WebResource (HTTP Request) object that needs to be given to the request pipeline.
   */


  WebResource.prototype.prepare = function (options) {
    if (!options) {
      throw new Error("options object is required");
    }

    if (options.method === undefined || options.method === null || typeof options.method.valueOf() !== "string") {
      throw new Error("options.method must be a string.");
    }

    if (options.url && options.pathTemplate) {
      throw new Error("options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them.");
    }

    if ((options.pathTemplate === undefined || options.pathTemplate === null || typeof options.pathTemplate.valueOf() !== "string") && (options.url === undefined || options.url === null || typeof options.url.valueOf() !== "string")) {
      throw new Error("Please provide exactly one of options.pathTemplate or options.url.");
    } // set the url if it is provided.


    if (options.url) {
      if (typeof options.url !== "string") {
        throw new Error('options.url must be of type "string".');
      }

      this.url = options.url;
    } // set the method


    if (options.method) {
      var validMethods = ["GET", "PUT", "HEAD", "DELETE", "OPTIONS", "POST", "PATCH", "TRACE"];

      if (validMethods.indexOf(options.method.toUpperCase()) === -1) {
        throw new Error('The provided method "' + options.method + '" is invalid. Supported HTTP methods are: ' + JSON.stringify(validMethods));
      }
    }

    this.method = options.method.toUpperCase(); // construct the url if path template is provided

    if (options.pathTemplate) {
      var pathTemplate_1 = options.pathTemplate,
          pathParameters_1 = options.pathParameters;

      if (typeof pathTemplate_1 !== "string") {
        throw new Error('options.pathTemplate must be of type "string".');
      }

      if (!options.baseUrl) {
        options.baseUrl = "https://management.azure.com";
      }

      var baseUrl = options.baseUrl;
      var url_1 = baseUrl + (baseUrl.endsWith("/") ? "" : "/") + (pathTemplate_1.startsWith("/") ? pathTemplate_1.slice(1) : pathTemplate_1);
      var segments = url_1.match(/({[\w-]*\s*[\w-]*})/gi);

      if (segments && segments.length) {
        if (!pathParameters_1) {
          throw new Error("pathTemplate: " + pathTemplate_1 + " has been provided. Hence, options.pathParameters must also be provided.");
        }

        segments.forEach(function (item) {
          var pathParamName = item.slice(1, -1);
          var pathParam = pathParameters_1[pathParamName];

          if (pathParam === null || pathParam === undefined || !(typeof pathParam === "string" || typeof pathParam === "object")) {
            var stringifiedPathParameters = JSON.stringify(pathParameters_1, undefined, 2);
            throw new Error("pathTemplate: " + pathTemplate_1 + " contains the path parameter " + pathParamName + (" however, it is not present in parameters: " + stringifiedPathParameters + ".") + ("The value of the path parameter can either be a \"string\" of the form { " + pathParamName + ": \"some sample value\" } or ") + ("it can be an \"object\" of the form { \"" + pathParamName + "\": { value: \"some sample value\", skipUrlEncoding: true } }."));
          }

          if (typeof pathParam.valueOf() === "string") {
            url_1 = url_1.replace(item, encodeURIComponent(pathParam));
          }

          if (typeof pathParam.valueOf() === "object") {
            if (!pathParam.value) {
              throw new Error("options.pathParameters[" + pathParamName + "] is of type \"object\" but it does not contain a \"value\" property.");
            }

            if (pathParam.skipUrlEncoding) {
              url_1 = url_1.replace(item, pathParam.value);
            } else {
              url_1 = url_1.replace(item, encodeURIComponent(pathParam.value));
            }
          }
        });
      }

      this.url = url_1;
    } // append query parameters to the url if they are provided. They can be provided with pathTemplate or url option.


    if (options.queryParameters) {
      var queryParameters = options.queryParameters;

      if (typeof queryParameters !== "object") {
        throw new Error("options.queryParameters must be of type object. It should be a JSON object " + "of \"query-parameter-name\" as the key and the \"query-parameter-value\" as the value. " + "The \"query-parameter-value\" may be fo type \"string\" or an \"object\" of the form { value: \"query-parameter-value\", skipUrlEncoding: true }.");
      } // append question mark if it is not present in the url


      if (this.url && this.url.indexOf("?") === -1) {
        this.url += "?";
      } // construct queryString


      var queryParams = []; // We need to populate this.query as a dictionary if the request is being used for Sway's validateRequest().

      this.query = {};

      for (var queryParamName in queryParameters) {
        var queryParam = queryParameters[queryParamName];

        if (queryParam) {
          if (typeof queryParam === "string") {
            queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam));
            this.query[queryParamName] = encodeURIComponent(queryParam);
          } else if (typeof queryParam === "object") {
            if (!queryParam.value) {
              throw new Error("options.queryParameters[" + queryParamName + "] is of type \"object\" but it does not contain a \"value\" property.");
            }

            if (queryParam.skipUrlEncoding) {
              queryParams.push(queryParamName + "=" + queryParam.value);
              this.query[queryParamName] = queryParam.value;
            } else {
              queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam.value));
              this.query[queryParamName] = encodeURIComponent(queryParam.value);
            }
          }
        }
      } // end-of-for
      // append the queryString


      this.url += queryParams.join("&");
    } // add headers to the request if they are provided


    if (options.headers) {
      var headers = options.headers;

      for (var _i = 0, _a = Object.keys(options.headers); _i < _a.length; _i++) {
        var headerName = _a[_i];
        this.headers.set(headerName, headers[headerName]);
      }
    } // ensure accept-language is set correctly


    if (!this.headers.get("accept-language")) {
      this.headers.set("accept-language", "en-US");
    } // ensure the request-id is set correctly


    if (!this.headers.get("x-ms-client-request-id") && !options.disableClientRequestId) {
      this.headers.set("x-ms-client-request-id", this.requestId);
    } // default


    if (!this.headers.get("Content-Type")) {
      this.headers.set("Content-Type", "application/json; charset=utf-8");
    } // set the request body. request.js automatically sets the Content-Length request header, so we need not set it explicitly


    this.body = options.body;

    if (options.body !== undefined && options.body !== null) {
      // body as a stream special case. set the body as-is and check for some special request headers specific to sending a stream.
      if (options.bodyIsStream) {
        if (!this.headers.get("Transfer-Encoding")) {
          this.headers.set("Transfer-Encoding", "chunked");
        }

        if (this.headers.get("Content-Type") !== "application/octet-stream") {
          this.headers.set("Content-Type", "application/octet-stream");
        }
      } else {
        if (options.serializationMapper) {
          this.body = new _serializer.Serializer(options.mappers).serialize(options.serializationMapper, options.body, "requestBody");
        }

        if (!options.disableJsonStringifyOnBody) {
          this.body = JSON.stringify(options.body);
        }
      }
    }

    if (options.spanOptions) {
      this.spanOptions = options.spanOptions;
    }

    this.abortSignal = options.abortSignal;
    this.onDownloadProgress = options.onDownloadProgress;
    this.onUploadProgress = options.onUploadProgress;
    return this;
  };
  /**
   * Clone this WebResource HTTP request object.
   * @returns The clone of this WebResource HTTP request object.
   */


  WebResource.prototype.clone = function () {
    var result = new WebResource(this.url, this.method, this.body, this.query, this.headers && this.headers.clone(), this.streamResponseBody, this.withCredentials, this.abortSignal, this.timeout, this.onUploadProgress, this.onDownloadProgress, this.proxySettings, this.keepAlive, this.decompressResponse, this.streamResponseStatusCodes);

    if (this.formData) {
      result.formData = this.formData;
    }

    if (this.operationSpec) {
      result.operationSpec = this.operationSpec;
    }

    if (this.shouldDeserialize) {
      result.shouldDeserialize = this.shouldDeserialize;
    }

    if (this.operationResponseGetter) {
      result.operationResponseGetter = this.operationResponseGetter;
    }

    return result;
  };

  return WebResource;
}();

exports.WebResource = WebResource;
},{"./httpHeaders":"wA5d","./serializer":"HiIJ","./util/utils":"DVp2"}],"EqDk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.custom = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var custom = {};
exports.custom = custom;
},{}],"fcMK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.URL = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var url = URL;
exports.URL = url;
},{}],"bBTP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAlphaNumericCharacter = isAlphaNumericCharacter;
Object.defineProperty(exports, "URL", {
  enumerable: true,
  get: function () {
    return _url.URL;
  }
});
exports.URLTokenizer = exports.URLToken = exports.URLBuilder = exports.URLQuery = void 0;

var _utils = require("./util/utils");

var _url = require("./util/url");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * A class that handles the query portion of a URLBuilder.
 */
var URLQuery =
/** @class */
function () {
  function URLQuery() {
    this._rawQuery = {};
  }
  /**
   * Get whether or not there any query parameters in this URLQuery.
   */


  URLQuery.prototype.any = function () {
    return Object.keys(this._rawQuery).length > 0;
  };
  /**
   * Get the keys of the query string.
   */


  URLQuery.prototype.keys = function () {
    return Object.keys(this._rawQuery);
  };
  /**
   * Set a query parameter with the provided name and value. If the parameterValue is undefined or
   * empty, then this will attempt to remove an existing query parameter with the provided
   * parameterName.
   */


  URLQuery.prototype.set = function (parameterName, parameterValue) {
    var caseParameterValue = parameterValue;

    if (parameterName) {
      if (caseParameterValue !== undefined && caseParameterValue !== null) {
        var newValue = Array.isArray(caseParameterValue) ? caseParameterValue : caseParameterValue.toString();
        this._rawQuery[parameterName] = newValue;
      } else {
        delete this._rawQuery[parameterName];
      }
    }
  };
  /**
   * Get the value of the query parameter with the provided name. If no parameter exists with the
   * provided parameter name, then undefined will be returned.
   */


  URLQuery.prototype.get = function (parameterName) {
    return parameterName ? this._rawQuery[parameterName] : undefined;
  };
  /**
   * Get the string representation of this query. The return value will not start with a "?".
   */


  URLQuery.prototype.toString = function () {
    var result = "";

    for (var parameterName in this._rawQuery) {
      if (result) {
        result += "&";
      }

      var parameterValue = this._rawQuery[parameterName];

      if (Array.isArray(parameterValue)) {
        var parameterStrings = [];

        for (var _i = 0, parameterValue_1 = parameterValue; _i < parameterValue_1.length; _i++) {
          var parameterValueElement = parameterValue_1[_i];
          parameterStrings.push(parameterName + "=" + parameterValueElement);
        }

        result += parameterStrings.join("&");
      } else {
        result += parameterName + "=" + parameterValue;
      }
    }

    return result;
  };
  /**
   * Parse a URLQuery from the provided text.
   */


  URLQuery.parse = function (text) {
    var result = new URLQuery();

    if (text) {
      if (text.startsWith("?")) {
        text = text.substring(1);
      }

      var currentState = "ParameterName";
      var parameterName = "";
      var parameterValue = "";

      for (var i = 0; i < text.length; ++i) {
        var currentCharacter = text[i];

        switch (currentState) {
          case "ParameterName":
            switch (currentCharacter) {
              case "=":
                currentState = "ParameterValue";
                break;

              case "&":
                parameterName = "";
                parameterValue = "";
                break;

              default:
                parameterName += currentCharacter;
                break;
            }

            break;

          case "ParameterValue":
            switch (currentCharacter) {
              case "&":
                result.set(parameterName, parameterValue);
                parameterName = "";
                parameterValue = "";
                currentState = "ParameterName";
                break;

              default:
                parameterValue += currentCharacter;
                break;
            }

            break;

          default:
            throw new Error("Unrecognized URLQuery parse state: " + currentState);
        }
      }

      if (currentState === "ParameterValue") {
        result.set(parameterName, parameterValue);
      }
    }

    return result;
  };

  return URLQuery;
}();

exports.URLQuery = URLQuery;

/**
 * A class that handles creating, modifying, and parsing URLs.
 */
var URLBuilder =
/** @class */
function () {
  function URLBuilder() {}
  /**
   * Set the scheme/protocol for this URL. If the provided scheme contains other parts of a URL
   * (such as a host, port, path, or query), those parts will be added to this URL as well.
   */


  URLBuilder.prototype.setScheme = function (scheme) {
    if (!scheme) {
      this._scheme = undefined;
    } else {
      this.set(scheme, "SCHEME");
    }
  };
  /**
   * Get the scheme that has been set in this URL.
   */


  URLBuilder.prototype.getScheme = function () {
    return this._scheme;
  };
  /**
   * Set the host for this URL. If the provided host contains other parts of a URL (such as a
   * port, path, or query), those parts will be added to this URL as well.
   */


  URLBuilder.prototype.setHost = function (host) {
    if (!host) {
      this._host = undefined;
    } else {
      this.set(host, "SCHEME_OR_HOST");
    }
  };
  /**
   * Get the host that has been set in this URL.
   */


  URLBuilder.prototype.getHost = function () {
    return this._host;
  };
  /**
   * Set the port for this URL. If the provided port contains other parts of a URL (such as a
   * path or query), those parts will be added to this URL as well.
   */


  URLBuilder.prototype.setPort = function (port) {
    if (port === undefined || port === null || port === "") {
      this._port = undefined;
    } else {
      this.set(port.toString(), "PORT");
    }
  };
  /**
   * Get the port that has been set in this URL.
   */


  URLBuilder.prototype.getPort = function () {
    return this._port;
  };
  /**
   * Set the path for this URL. If the provided path contains a query, then it will be added to
   * this URL as well.
   */


  URLBuilder.prototype.setPath = function (path) {
    if (!path) {
      this._path = undefined;
    } else {
      var schemeIndex = path.indexOf("://");

      if (schemeIndex !== -1) {
        var schemeStart = path.lastIndexOf("/", schemeIndex); // Make sure to only grab the URL part of the path before setting the state back to SCHEME
        // this will handle cases such as "/a/b/c/https://microsoft.com" => "https://microsoft.com"

        this.set(schemeStart === -1 ? path : path.substr(schemeStart + 1), "SCHEME");
      } else {
        this.set(path, "PATH");
      }
    }
  };
  /**
   * Append the provided path to this URL's existing path. If the provided path contains a query,
   * then it will be added to this URL as well.
   */


  URLBuilder.prototype.appendPath = function (path) {
    if (path) {
      var currentPath = this.getPath();

      if (currentPath) {
        if (!currentPath.endsWith("/")) {
          currentPath += "/";
        }

        if (path.startsWith("/")) {
          path = path.substring(1);
        }

        path = currentPath + path;
      }

      this.set(path, "PATH");
    }
  };
  /**
   * Get the path that has been set in this URL.
   */


  URLBuilder.prototype.getPath = function () {
    return this._path;
  };
  /**
   * Set the query in this URL.
   */


  URLBuilder.prototype.setQuery = function (query) {
    if (!query) {
      this._query = undefined;
    } else {
      this._query = URLQuery.parse(query);
    }
  };
  /**
   * Set a query parameter with the provided name and value in this URL's query. If the provided
   * query parameter value is undefined or empty, then the query parameter will be removed if it
   * existed.
   */


  URLBuilder.prototype.setQueryParameter = function (queryParameterName, queryParameterValue) {
    if (queryParameterName) {
      if (!this._query) {
        this._query = new URLQuery();
      }

      this._query.set(queryParameterName, queryParameterValue);
    }
  };
  /**
   * Get the value of the query parameter with the provided query parameter name. If no query
   * parameter exists with the provided name, then undefined will be returned.
   */


  URLBuilder.prototype.getQueryParameterValue = function (queryParameterName) {
    return this._query ? this._query.get(queryParameterName) : undefined;
  };
  /**
   * Get the query in this URL.
   */


  URLBuilder.prototype.getQuery = function () {
    return this._query ? this._query.toString() : undefined;
  };
  /**
   * Set the parts of this URL by parsing the provided text using the provided startState.
   */


  URLBuilder.prototype.set = function (text, startState) {
    var tokenizer = new URLTokenizer(text, startState);

    while (tokenizer.next()) {
      var token = tokenizer.current();
      var tokenPath = void 0;

      if (token) {
        switch (token.type) {
          case "SCHEME":
            this._scheme = token.text || undefined;
            break;

          case "HOST":
            this._host = token.text || undefined;
            break;

          case "PORT":
            this._port = token.text || undefined;
            break;

          case "PATH":
            tokenPath = token.text || undefined;

            if (!this._path || this._path === "/" || tokenPath !== "/") {
              this._path = tokenPath;
            }

            break;

          case "QUERY":
            this._query = URLQuery.parse(token.text);
            break;

          default:
            throw new Error("Unrecognized URLTokenType: " + token.type);
        }
      }
    }
  };

  URLBuilder.prototype.toString = function () {
    var result = "";

    if (this._scheme) {
      result += this._scheme + "://";
    }

    if (this._host) {
      result += this._host;
    }

    if (this._port) {
      result += ":" + this._port;
    }

    if (this._path) {
      if (!this._path.startsWith("/")) {
        result += "/";
      }

      result += this._path;
    }

    if (this._query && this._query.any()) {
      result += "?" + this._query.toString();
    }

    return result;
  };
  /**
   * If the provided searchValue is found in this URLBuilder, then replace it with the provided
   * replaceValue.
   */


  URLBuilder.prototype.replaceAll = function (searchValue, replaceValue) {
    if (searchValue) {
      this.setScheme((0, _utils.replaceAll)(this.getScheme(), searchValue, replaceValue));
      this.setHost((0, _utils.replaceAll)(this.getHost(), searchValue, replaceValue));
      this.setPort((0, _utils.replaceAll)(this.getPort(), searchValue, replaceValue));
      this.setPath((0, _utils.replaceAll)(this.getPath(), searchValue, replaceValue));
      this.setQuery((0, _utils.replaceAll)(this.getQuery(), searchValue, replaceValue));
    }
  };

  URLBuilder.parse = function (text) {
    var result = new URLBuilder();
    result.set(text, "SCHEME_OR_HOST");
    return result;
  };

  return URLBuilder;
}();

exports.URLBuilder = URLBuilder;

var URLToken =
/** @class */
function () {
  function URLToken(text, type) {
    this.text = text;
    this.type = type;
  }

  URLToken.scheme = function (text) {
    return new URLToken(text, "SCHEME");
  };

  URLToken.host = function (text) {
    return new URLToken(text, "HOST");
  };

  URLToken.port = function (text) {
    return new URLToken(text, "PORT");
  };

  URLToken.path = function (text) {
    return new URLToken(text, "PATH");
  };

  URLToken.query = function (text) {
    return new URLToken(text, "QUERY");
  };

  return URLToken;
}();

exports.URLToken = URLToken;

/**
 * Get whether or not the provided character (single character string) is an alphanumeric (letter or
 * digit) character.
 */
function isAlphaNumericCharacter(character) {
  var characterCode = character.charCodeAt(0);
  return 48
  /* '0' */
  <= characterCode && characterCode <= 57 ||
  /* '9' */
  65
  /* 'A' */
  <= characterCode && characterCode <= 90
  /* 'Z' */
  || 97
  /* 'a' */
  <= characterCode && characterCode <= 122
  /* 'z' */
  ;
}
/**
 * A class that tokenizes URL strings.
 */


var URLTokenizer =
/** @class */
function () {
  function URLTokenizer(_text, state) {
    this._text = _text;
    this._textLength = _text ? _text.length : 0;
    this._currentState = state !== undefined && state !== null ? state : "SCHEME_OR_HOST";
    this._currentIndex = 0;
  }
  /**
   * Get the current URLToken this URLTokenizer is pointing at, or undefined if the URLTokenizer
   * hasn't started or has finished tokenizing.
   */


  URLTokenizer.prototype.current = function () {
    return this._currentToken;
  };
  /**
   * Advance to the next URLToken and return whether or not a URLToken was found.
   */


  URLTokenizer.prototype.next = function () {
    if (!hasCurrentCharacter(this)) {
      this._currentToken = undefined;
    } else {
      switch (this._currentState) {
        case "SCHEME":
          nextScheme(this);
          break;

        case "SCHEME_OR_HOST":
          nextSchemeOrHost(this);
          break;

        case "HOST":
          nextHost(this);
          break;

        case "PORT":
          nextPort(this);
          break;

        case "PATH":
          nextPath(this);
          break;

        case "QUERY":
          nextQuery(this);
          break;

        default:
          throw new Error("Unrecognized URLTokenizerState: " + this._currentState);
      }
    }

    return !!this._currentToken;
  };

  return URLTokenizer;
}();

exports.URLTokenizer = URLTokenizer;

/**
 * Read the remaining characters from this Tokenizer's character stream.
 */
function readRemaining(tokenizer) {
  var result = "";

  if (tokenizer._currentIndex < tokenizer._textLength) {
    result = tokenizer._text.substring(tokenizer._currentIndex);
    tokenizer._currentIndex = tokenizer._textLength;
  }

  return result;
}
/**
 * Whether or not this URLTokenizer has a current character.
 */


function hasCurrentCharacter(tokenizer) {
  return tokenizer._currentIndex < tokenizer._textLength;
}
/**
 * Get the character in the text string at the current index.
 */


function getCurrentCharacter(tokenizer) {
  return tokenizer._text[tokenizer._currentIndex];
}
/**
 * Advance to the character in text that is "step" characters ahead. If no step value is provided,
 * then step will default to 1.
 */


function nextCharacter(tokenizer, step) {
  if (hasCurrentCharacter(tokenizer)) {
    if (!step) {
      step = 1;
    }

    tokenizer._currentIndex += step;
  }
}
/**
 * Starting with the current character, peek "charactersToPeek" number of characters ahead in this
 * Tokenizer's stream of characters.
 */


function peekCharacters(tokenizer, charactersToPeek) {
  var endIndex = tokenizer._currentIndex + charactersToPeek;

  if (tokenizer._textLength < endIndex) {
    endIndex = tokenizer._textLength;
  }

  return tokenizer._text.substring(tokenizer._currentIndex, endIndex);
}
/**
 * Read characters from this Tokenizer until the end of the stream or until the provided condition
 * is false when provided the current character.
 */


function readWhile(tokenizer, condition) {
  var result = "";

  while (hasCurrentCharacter(tokenizer)) {
    var currentCharacter = getCurrentCharacter(tokenizer);

    if (!condition(currentCharacter)) {
      break;
    } else {
      result += currentCharacter;
      nextCharacter(tokenizer);
    }
  }

  return result;
}
/**
 * Read characters from this Tokenizer until a non-alphanumeric character or the end of the
 * character stream is reached.
 */


function readWhileLetterOrDigit(tokenizer) {
  return readWhile(tokenizer, function (character) {
    return isAlphaNumericCharacter(character);
  });
}
/**
 * Read characters from this Tokenizer until one of the provided terminating characters is read or
 * the end of the character stream is reached.
 */


function readUntilCharacter(tokenizer) {
  var terminatingCharacters = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    terminatingCharacters[_i - 1] = arguments[_i];
  }

  return readWhile(tokenizer, function (character) {
    return terminatingCharacters.indexOf(character) === -1;
  });
}

function nextScheme(tokenizer) {
  var scheme = readWhileLetterOrDigit(tokenizer);
  tokenizer._currentToken = URLToken.scheme(scheme);

  if (!hasCurrentCharacter(tokenizer)) {
    tokenizer._currentState = "DONE";
  } else {
    tokenizer._currentState = "HOST";
  }
}

function nextSchemeOrHost(tokenizer) {
  var schemeOrHost = readUntilCharacter(tokenizer, ":", "/", "?");

  if (!hasCurrentCharacter(tokenizer)) {
    tokenizer._currentToken = URLToken.host(schemeOrHost);
    tokenizer._currentState = "DONE";
  } else if (getCurrentCharacter(tokenizer) === ":") {
    if (peekCharacters(tokenizer, 3) === "://") {
      tokenizer._currentToken = URLToken.scheme(schemeOrHost);
      tokenizer._currentState = "HOST";
    } else {
      tokenizer._currentToken = URLToken.host(schemeOrHost);
      tokenizer._currentState = "PORT";
    }
  } else {
    tokenizer._currentToken = URLToken.host(schemeOrHost);

    if (getCurrentCharacter(tokenizer) === "/") {
      tokenizer._currentState = "PATH";
    } else {
      tokenizer._currentState = "QUERY";
    }
  }
}

function nextHost(tokenizer) {
  if (peekCharacters(tokenizer, 3) === "://") {
    nextCharacter(tokenizer, 3);
  }

  var host = readUntilCharacter(tokenizer, ":", "/", "?");
  tokenizer._currentToken = URLToken.host(host);

  if (!hasCurrentCharacter(tokenizer)) {
    tokenizer._currentState = "DONE";
  } else if (getCurrentCharacter(tokenizer) === ":") {
    tokenizer._currentState = "PORT";
  } else if (getCurrentCharacter(tokenizer) === "/") {
    tokenizer._currentState = "PATH";
  } else {
    tokenizer._currentState = "QUERY";
  }
}

function nextPort(tokenizer) {
  if (getCurrentCharacter(tokenizer) === ":") {
    nextCharacter(tokenizer);
  }

  var port = readUntilCharacter(tokenizer, "/", "?");
  tokenizer._currentToken = URLToken.port(port);

  if (!hasCurrentCharacter(tokenizer)) {
    tokenizer._currentState = "DONE";
  } else if (getCurrentCharacter(tokenizer) === "/") {
    tokenizer._currentState = "PATH";
  } else {
    tokenizer._currentState = "QUERY";
  }
}

function nextPath(tokenizer) {
  var path = readUntilCharacter(tokenizer, "?");
  tokenizer._currentToken = URLToken.path(path);

  if (!hasCurrentCharacter(tokenizer)) {
    tokenizer._currentState = "DONE";
  } else {
    tokenizer._currentState = "QUERY";
  }
}

function nextQuery(tokenizer) {
  if (getCurrentCharacter(tokenizer) === "?") {
    nextCharacter(tokenizer);
  }

  var query = readRemaining(tokenizer);
  tokenizer._currentToken = URLToken.query(query);
  tokenizer._currentState = "DONE";
}
},{"./util/utils":"DVp2","./util/url":"fcMK"}],"HVdY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sanitizer = void 0;

var _tslib = require("tslib");

var _url = require("../url");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var RedactedString = "REDACTED";
var defaultAllowedHeaderNames = ["x-ms-client-request-id", "x-ms-return-client-request-id", "x-ms-useragent", "x-ms-correlation-request-id", "x-ms-request-id", "client-request-id", "ms-cv", "return-client-request-id", "traceparent", "Access-Control-Allow-Credentials", "Access-Control-Allow-Headers", "Access-Control-Allow-Methods", "Access-Control-Allow-Origin", "Access-Control-Expose-Headers", "Access-Control-Max-Age", "Access-Control-Request-Headers", "Access-Control-Request-Method", "Origin", "Accept", "Cache-Control", "Connection", "Content-Length", "Content-Type", "Date", "ETag", "Expires", "If-Match", "If-Modified-Since", "If-None-Match", "If-Unmodified-Since", "Last-Modified", "Pragma", "Request-Id", "Retry-After", "Server", "Transfer-Encoding", "User-Agent"];
var defaultAllowedQueryParameters = ["api-version"];

var Sanitizer =
/** @class */
function () {
  function Sanitizer(_a) {
    var _b = _a === void 0 ? {} : _a,
        _c = _b.allowedHeaderNames,
        allowedHeaderNames = _c === void 0 ? [] : _c,
        _d = _b.allowedQueryParameters,
        allowedQueryParameters = _d === void 0 ? [] : _d;

    allowedHeaderNames = Array.isArray(allowedHeaderNames) ? defaultAllowedHeaderNames.concat(allowedHeaderNames) : defaultAllowedHeaderNames;
    allowedQueryParameters = Array.isArray(allowedQueryParameters) ? defaultAllowedQueryParameters.concat(allowedQueryParameters) : defaultAllowedQueryParameters;
    this.allowedHeaderNames = new Set(allowedHeaderNames.map(function (n) {
      return n.toLowerCase();
    }));
    this.allowedQueryParameters = new Set(allowedQueryParameters.map(function (p) {
      return p.toLowerCase();
    }));
  }

  Sanitizer.prototype.sanitize = function (obj) {
    return JSON.stringify(obj, this.replacer.bind(this), 2);
  };

  Sanitizer.prototype.replacer = function (key, value) {
    // Ensure Errors include their interesting non-enumerable members
    if (value instanceof Error) {
      return (0, _tslib.__assign)((0, _tslib.__assign)({}, value), {
        name: value.name,
        message: value.message
      });
    }

    if (key === "_headersMap") {
      return this.sanitizeHeaders(key, value);
    } else if (key === "url") {
      return this.sanitizeUrl(value);
    } else if (key === "query") {
      return this.sanitizeQuery(value);
    } else if (key === "body") {
      // Don't log the request body
      return undefined;
    } else if (key === "response") {
      // Don't log response again
      return undefined;
    } else if (key === "operationSpec") {
      // When using sendOperationRequest, the request carries a massive
      // field with the autorest spec. No need to log it.
      return undefined;
    }

    return value;
  };

  Sanitizer.prototype.sanitizeHeaders = function (_, value) {
    return this.sanitizeObject(value, this.allowedHeaderNames, function (v, k) {
      return v[k].value;
    });
  };

  Sanitizer.prototype.sanitizeQuery = function (value) {
    return this.sanitizeObject(value, this.allowedQueryParameters, function (v, k) {
      return v[k];
    });
  };

  Sanitizer.prototype.sanitizeObject = function (value, allowedKeys, accessor) {
    if (typeof value !== "object" || value === null) {
      return value;
    }

    var sanitized = {};

    for (var _i = 0, _a = Object.keys(value); _i < _a.length; _i++) {
      var k = _a[_i];

      if (allowedKeys.has(k.toLowerCase())) {
        sanitized[k] = accessor(value, k);
      } else {
        sanitized[k] = RedactedString;
      }
    }

    return sanitized;
  };

  Sanitizer.prototype.sanitizeUrl = function (value) {
    if (typeof value !== "string" || value === null) {
      return value;
    }

    var urlBuilder = _url.URLBuilder.parse(value);

    var queryString = urlBuilder.getQuery();

    if (!queryString) {
      return value;
    }

    var query = _url.URLQuery.parse(queryString);

    for (var _i = 0, _a = query.keys(); _i < _a.length; _i++) {
      var k = _a[_i];

      if (!this.allowedQueryParameters.has(k.toLowerCase())) {
        query.set(k, RedactedString);
      }
    }

    urlBuilder.setQuery(query.toString());
    return urlBuilder.toString();
  };

  return Sanitizer;
}();

exports.Sanitizer = Sanitizer;
},{"tslib":"CvJj","../url":"bBTP"}],"VBBg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RestError = void 0;

var _tslib = require("tslib");

var _inspect = require("./util/inspect");

var _sanitizer = require("./util/sanitizer");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var errorSanitizer = new _sanitizer.Sanitizer();

var RestError =
/** @class */
function (_super) {
  (0, _tslib.__extends)(RestError, _super);

  function RestError(message, code, statusCode, request, response) {
    var _this = _super.call(this, message) || this;

    _this.name = "RestError";
    _this.code = code;
    _this.statusCode = statusCode;
    _this.request = request;
    _this.response = response;
    Object.setPrototypeOf(_this, RestError.prototype);
    return _this;
  }
  /**
   * Logging method for util.inspect in Node
   */


  RestError.prototype[_inspect.custom] = function () {
    return "RestError: " + this.message + " \n " + errorSanitizer.sanitize(this);
  };

  RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
  RestError.PARSE_ERROR = "PARSE_ERROR";
  return RestError;
}(Error);

exports.RestError = RestError;
},{"tslib":"CvJj","./util/inspect":"EqDk","./util/sanitizer":"HVdY"}],"d8In":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseHeaders = parseHeaders;
exports.XhrHttpClient = void 0;

var _abortController = require("@azure/abort-controller");

var _httpHeaders = require("./httpHeaders");

var _restError = require("./restError");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.
 */
var XhrHttpClient =
/** @class */
function () {
  function XhrHttpClient() {}

  XhrHttpClient.prototype.sendRequest = function (request) {
    var _a;

    var xhr = new XMLHttpRequest();

    if (request.proxySettings) {
      throw new Error("HTTP proxy is not supported in browser environment");
    }

    var abortSignal = request.abortSignal;

    if (abortSignal) {
      if (abortSignal.aborted) {
        return Promise.reject(new _abortController.AbortError("The operation was aborted."));
      }

      var listener_1 = function () {
        xhr.abort();
      };

      abortSignal.addEventListener("abort", listener_1);
      xhr.addEventListener("readystatechange", function () {
        if (xhr.readyState === XMLHttpRequest.DONE) {
          abortSignal.removeEventListener("abort", listener_1);
        }
      });
    }

    addProgressListener(xhr.upload, request.onUploadProgress);
    addProgressListener(xhr, request.onDownloadProgress);

    if (request.formData) {
      var formData = request.formData;
      var requestForm_1 = new FormData();

      var appendFormValue = function (key, value) {
        if (value && Object.prototype.hasOwnProperty.call(value, "value") && Object.prototype.hasOwnProperty.call(value, "options")) {
          requestForm_1.append(key, value.value, value.options);
        } else {
          requestForm_1.append(key, value);
        }
      };

      for (var _i = 0, _b = Object.keys(formData); _i < _b.length; _i++) {
        var formKey = _b[_i];
        var formValue = formData[formKey];

        if (Array.isArray(formValue)) {
          for (var j = 0; j < formValue.length; j++) {
            appendFormValue(formKey, formValue[j]);
          }
        } else {
          appendFormValue(formKey, formValue);
        }
      }

      request.body = requestForm_1;
      request.formData = undefined;
      var contentType = request.headers.get("Content-Type");

      if (contentType && contentType.indexOf("multipart/form-data") !== -1) {
        // browser will automatically apply a suitable content-type header
        request.headers.remove("Content-Type");
      }
    }

    xhr.open(request.method, request.url);
    xhr.timeout = request.timeout;
    xhr.withCredentials = request.withCredentials;

    for (var _c = 0, _d = request.headers.headersArray(); _c < _d.length; _c++) {
      var header = _d[_c];
      xhr.setRequestHeader(header.name, header.value);
    }

    xhr.responseType = ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.size) || request.streamResponseBody ? "blob" : "text"; // tslint:disable-next-line:no-null-keyword

    xhr.send(request.body === undefined ? null : request.body);

    if (xhr.responseType === "blob") {
      return new Promise(function (resolve, reject) {
        handleBlobResponse(xhr, request, resolve, reject);
        rejectOnTerminalEvent(request, xhr, reject);
      });
    } else {
      return new Promise(function (resolve, reject) {
        xhr.addEventListener("load", function () {
          return resolve({
            request: request,
            status: xhr.status,
            headers: parseHeaders(xhr),
            bodyAsText: xhr.responseText
          });
        });
        rejectOnTerminalEvent(request, xhr, reject);
      });
    }
  };

  return XhrHttpClient;
}();

exports.XhrHttpClient = XhrHttpClient;

function handleBlobResponse(xhr, request, res, rej) {
  xhr.addEventListener("readystatechange", function () {
    var _a; // Resolve as soon as headers are loaded


    if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
      if (request.streamResponseBody || ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(xhr.status))) {
        var blobBody = new Promise(function (resolve, reject) {
          xhr.addEventListener("load", function () {
            resolve(xhr.response);
          });
          rejectOnTerminalEvent(request, xhr, reject);
        });
        res({
          request: request,
          status: xhr.status,
          headers: parseHeaders(xhr),
          blobBody: blobBody
        });
      } else {
        xhr.addEventListener("load", function () {
          // xhr.response is of Blob type if the request is sent with xhr.responseType === "blob"
          // but the status code is not one of the stream response status codes,
          // so treat it as text and convert from Blob to text
          if (xhr.response) {
            // Blob.text() is not supported in IE so using FileReader instead
            var reader_1 = new FileReader();

            reader_1.onload = function (e) {
              var _a;

              var text = (_a = e.target) === null || _a === void 0 ? void 0 : _a.result;
              res({
                request: request,
                status: xhr.status,
                headers: parseHeaders(xhr),
                bodyAsText: text
              });
            };

            reader_1.onerror = function (_e) {
              rej(reader_1.error);
            };

            reader_1.readAsText(xhr.response, "UTF-8");
          } else {
            res({
              request: request,
              status: xhr.status,
              headers: parseHeaders(xhr)
            });
          }
        });
      }
    }
  });
}

function addProgressListener(xhr, listener) {
  if (listener) {
    xhr.addEventListener("progress", function (rawEvent) {
      return listener({
        loadedBytes: rawEvent.loaded
      });
    });
  }
} // exported locally for testing


function parseHeaders(xhr) {
  var responseHeaders = new _httpHeaders.HttpHeaders();
  var headerLines = xhr.getAllResponseHeaders().trim().split(/[\r\n]+/);

  for (var _i = 0, headerLines_1 = headerLines; _i < headerLines_1.length; _i++) {
    var line = headerLines_1[_i];
    var index = line.indexOf(":");
    var headerName = line.slice(0, index);
    var headerValue = line.slice(index + 2);
    responseHeaders.set(headerName, headerValue);
  }

  return responseHeaders;
}

function rejectOnTerminalEvent(request, xhr, reject) {
  xhr.addEventListener("error", function () {
    return reject(new _restError.RestError("Failed to send request to " + request.url, _restError.RestError.REQUEST_SEND_ERROR, undefined, request));
  });
  var abortError = new _abortController.AbortError("The operation was aborted.");
  xhr.addEventListener("abort", function () {
    return reject(abortError);
  });
  xhr.addEventListener("timeout", function () {
    return reject(abortError);
  });
}
},{"@azure/abort-controller":"wyb9","./httpHeaders":"wA5d","./restError":"VBBg"}],"CT7P":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "DefaultHttpClient", {
  enumerable: true,
  get: function () {
    return _xhrHttpClient.XhrHttpClient;
  }
});

var _xhrHttpClient = require("./xhrHttpClient");
},{"./xhrHttpClient":"d8In"}],"q4NL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HttpPipelineLogLevel = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * The different levels of logs that can be used with the HttpPipelineLogger.
 */
var HttpPipelineLogLevel;
exports.HttpPipelineLogLevel = HttpPipelineLogLevel;

(function (HttpPipelineLogLevel) {
  /**
   * A log level that indicates that no logs will be logged.
   */
  HttpPipelineLogLevel[HttpPipelineLogLevel["OFF"] = 0] = "OFF";
  /**
   * An error log.
   */

  HttpPipelineLogLevel[HttpPipelineLogLevel["ERROR"] = 1] = "ERROR";
  /**
   * A warning log.
   */

  HttpPipelineLogLevel[HttpPipelineLogLevel["WARNING"] = 2] = "WARNING";
  /**
   * An information log.
   */

  HttpPipelineLogLevel[HttpPipelineLogLevel["INFO"] = 3] = "INFO";
})(HttpPipelineLogLevel || (exports.HttpPipelineLogLevel = HttpPipelineLogLevel = {}));
},{}],"I7lc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.operationOptionsToRequestOptionsBase = operationOptionsToRequestOptionsBase;

var _tslib = require("tslib");

/**
 * Converts an OperationOptions to a RequestOptionsBase
 *
 * @param opts - OperationOptions object to convert to RequestOptionsBase
 */
function operationOptionsToRequestOptionsBase(opts) {
  var requestOptions = opts.requestOptions,
      tracingOptions = opts.tracingOptions,
      additionalOptions = (0, _tslib.__rest)(opts, ["requestOptions", "tracingOptions"]);
  var result = additionalOptions;

  if (requestOptions) {
    result = (0, _tslib.__assign)((0, _tslib.__assign)({}, result), requestOptions);
  }

  if (tracingOptions) {
    result.spanOptions = tracingOptions.spanOptions;
  }

  return result;
}
},{"tslib":"CvJj"}],"ggtJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RequestPolicyOptions = exports.BaseRequestPolicy = void 0;

var _httpPipelineLogLevel = require("../httpPipelineLogLevel");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var BaseRequestPolicy =
/** @class */
function () {
  function BaseRequestPolicy(_nextPolicy, _options) {
    this._nextPolicy = _nextPolicy;
    this._options = _options;
  }
  /**
   * Get whether or not a log with the provided log level should be logged.
   * @param logLevel - The log level of the log that will be logged.
   * @returns Whether or not a log with the provided log level should be logged.
   */


  BaseRequestPolicy.prototype.shouldLog = function (logLevel) {
    return this._options.shouldLog(logLevel);
  };
  /**
   * Attempt to log the provided message to the provided logger. If no logger was provided or if
   * the log level does not meat the logger's threshold, then nothing will be logged.
   * @param logLevel - The log level of this log.
   * @param message - The message of this log.
   */


  BaseRequestPolicy.prototype.log = function (logLevel, message) {
    this._options.log(logLevel, message);
  };

  return BaseRequestPolicy;
}();

exports.BaseRequestPolicy = BaseRequestPolicy;

/**
 * Optional properties that can be used when creating a RequestPolicy.
 */
var RequestPolicyOptions =
/** @class */
function () {
  function RequestPolicyOptions(_logger) {
    this._logger = _logger;
  }
  /**
   * Get whether or not a log with the provided log level should be logged.
   * @param logLevel - The log level of the log that will be logged.
   * @returns Whether or not a log with the provided log level should be logged.
   */


  RequestPolicyOptions.prototype.shouldLog = function (logLevel) {
    return !!this._logger && logLevel !== _httpPipelineLogLevel.HttpPipelineLogLevel.OFF && logLevel <= this._logger.minimumLogLevel;
  };
  /**
   * Attempt to log the provided message to the provided logger. If no logger was provided or if
   * the log level does not meet the logger's threshold, then nothing will be logged.
   * @param logLevel - The log level of this log.
   * @param message - The message of this log.
   */


  RequestPolicyOptions.prototype.log = function (logLevel, message) {
    if (this._logger && this.shouldLog(logLevel)) {
      this._logger.log(logLevel, message);
    }
  };

  return RequestPolicyOptions;
}();

exports.RequestPolicyOptions = RequestPolicyOptions;
},{"../httpPipelineLogLevel":"q4NL"}],"D5PC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logger = void 0;

var _logger = require("@azure/logger");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var logger = (0, _logger.createClientLogger)("core-http");
exports.logger = logger;
},{"@azure/logger":"JyPs"}],"DhOT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logPolicy = logPolicy;
exports.LogPolicy = void 0;

var _tslib = require("tslib");

var _requestPolicy = require("./requestPolicy");

var _log = require("../log");

var _sanitizer = require("../util/sanitizer");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function logPolicy(loggingOptions) {
  if (loggingOptions === void 0) {
    loggingOptions = {};
  }

  return {
    create: function (nextPolicy, options) {
      return new LogPolicy(nextPolicy, options, loggingOptions);
    }
  };
}

var LogPolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(LogPolicy, _super);

  function LogPolicy(nextPolicy, options, _a) {
    var _b = _a === void 0 ? {} : _a,
        _c = _b.logger,
        logger = _c === void 0 ? _log.logger.info : _c,
        _d = _b.allowedHeaderNames,
        allowedHeaderNames = _d === void 0 ? [] : _d,
        _e = _b.allowedQueryParameters,
        allowedQueryParameters = _e === void 0 ? [] : _e;

    var _this = _super.call(this, nextPolicy, options) || this;

    _this.logger = logger;
    _this.sanitizer = new _sanitizer.Sanitizer({
      allowedHeaderNames: allowedHeaderNames,
      allowedQueryParameters: allowedQueryParameters
    });
    return _this;
  }

  Object.defineProperty(LogPolicy.prototype, "allowedHeaderNames", {
    /**
     * Header names whose values will be logged when logging is enabled. Defaults to
     * Date, traceparent, x-ms-client-request-id, and x-ms-request id.  Any headers
     * specified in this field will be added to that list.  Any other values will
     * be written to logs as "REDACTED".
     * @deprecated Pass these into the constructor instead.
     */
    get: function () {
      return this.sanitizer.allowedHeaderNames;
    },

    /**
     * Header names whose values will be logged when logging is enabled. Defaults to
     * Date, traceparent, x-ms-client-request-id, and x-ms-request id.  Any headers
     * specified in this field will be added to that list.  Any other values will
     * be written to logs as "REDACTED".
     * @deprecated Pass these into the constructor instead.
     */
    set: function (allowedHeaderNames) {
      this.sanitizer.allowedHeaderNames = allowedHeaderNames;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LogPolicy.prototype, "allowedQueryParameters", {
    /**
     * Query string names whose values will be logged when logging is enabled. By default no
     * query string values are logged.
     * @deprecated Pass these into the constructor instead.
     */
    get: function () {
      return this.sanitizer.allowedQueryParameters;
    },

    /**
     * Query string names whose values will be logged when logging is enabled. By default no
     * query string values are logged.
     * @deprecated Pass these into the constructor instead.
     */
    set: function (allowedQueryParameters) {
      this.sanitizer.allowedQueryParameters = allowedQueryParameters;
    },
    enumerable: false,
    configurable: true
  });

  LogPolicy.prototype.sendRequest = function (request) {
    var _this = this;

    if (!this.logger.enabled) return this._nextPolicy.sendRequest(request);
    this.logRequest(request);
    return this._nextPolicy.sendRequest(request).then(function (response) {
      return _this.logResponse(response);
    });
  };

  LogPolicy.prototype.logRequest = function (request) {
    this.logger("Request: " + this.sanitizer.sanitize(request));
  };

  LogPolicy.prototype.logResponse = function (response) {
    this.logger("Response status code: " + response.status);
    this.logger("Headers: " + this.sanitizer.sanitize(response.headers));
    return response;
  };

  return LogPolicy;
}(_requestPolicy.BaseRequestPolicy);

exports.LogPolicy = LogPolicy;
},{"tslib":"CvJj","./requestPolicy":"ggtJ","../log":"D5PC","../util/sanitizer":"HVdY"}],"wpZP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPathStringFromParameter = getPathStringFromParameter;
exports.getPathStringFromParameterPath = getPathStringFromParameterPath;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Get the path to this parameter's value as a dotted string (a.b.c).
 * @param parameter - The parameter to get the path string for.
 * @returns The path to this parameter's value as a dotted string.
 */
function getPathStringFromParameter(parameter) {
  return getPathStringFromParameterPath(parameter.parameterPath, parameter.mapper);
}

function getPathStringFromParameterPath(parameterPath, mapper) {
  var result;

  if (typeof parameterPath === "string") {
    result = parameterPath;
  } else if (Array.isArray(parameterPath)) {
    result = parameterPath.join(".");
  } else {
    result = mapper.serializedName;
  }

  return result;
}
},{}],"Lysf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStreamResponseStatusCodes = getStreamResponseStatusCodes;

var _serializer = require("./serializer");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Gets the list of status codes for streaming responses.
 * @internal @hidden
 */
function getStreamResponseStatusCodes(operationSpec) {
  var result = new Set();

  for (var statusCode in operationSpec.responses) {
    var operationResponse = operationSpec.responses[statusCode];

    if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === _serializer.MapperType.Stream) {
      result.add(Number(statusCode));
    }
  }

  return result;
}
},{"./serializer":"HiIJ"}],"oKNo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseXML = parseXML;
exports.stringifyXML = stringifyXML;

var _serializer = require("./serializer.common");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// tslint:disable-next-line:no-null-keyword
var doc = document.implementation.createDocument(null, null, null);
var parser = new DOMParser();

function parseXML(str, opts) {
  var _a, _b, _c;

  if (opts === void 0) {
    opts = {};
  }

  try {
    var updatedOptions = {
      rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : "",
      includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,
      xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : _serializer.XML_CHARKEY
    };
    var dom = parser.parseFromString(str, "application/xml");
    throwIfError(dom);
    var obj = void 0;

    if (updatedOptions.includeRoot) {
      obj = domToObject(dom, updatedOptions);
    } else {
      obj = domToObject(dom.childNodes[0], updatedOptions);
    }

    return Promise.resolve(obj);
  } catch (err) {
    return Promise.reject(err);
  }
}

var errorNS;

function getErrorNamespace() {
  var _a;

  if (errorNS === undefined) {
    try {
      errorNS = (_a = parser.parseFromString("INVALID", "text/xml").getElementsByTagName("parsererror")[0].namespaceURI) !== null && _a !== void 0 ? _a : "";
    } catch (ignored) {
      // Most browsers will return a document containing <parsererror>, but IE will throw.
      errorNS = "";
    }
  }

  return errorNS;
}

function throwIfError(dom) {
  var parserErrors = dom.getElementsByTagName("parsererror");

  if (parserErrors.length > 0 && getErrorNamespace()) {
    for (var i = 0; i < parserErrors.length; i++) {
      if (parserErrors[i].namespaceURI === errorNS) {
        throw new Error(parserErrors[i].innerHTML);
      }
    }
  }
}

function isElement(node) {
  return !!node.attributes;
}
/**
 * Get the Element-typed version of the provided Node if the provided node is an element with
 * attributes. If it isn't, then undefined is returned.
 */


function asElementWithAttributes(node) {
  return isElement(node) && node.hasAttributes() ? node : undefined;
}

function domToObject(node, options) {
  var result = {};
  var childNodeCount = node.childNodes.length;
  var firstChildNode = node.childNodes[0];
  var onlyChildTextValue = firstChildNode && childNodeCount === 1 && firstChildNode.nodeType === Node.TEXT_NODE && firstChildNode.nodeValue || undefined;
  var elementWithAttributes = asElementWithAttributes(node);

  if (elementWithAttributes) {
    result[_serializer.XML_ATTRKEY] = {};

    for (var i = 0; i < elementWithAttributes.attributes.length; i++) {
      var attr = elementWithAttributes.attributes[i];
      result[_serializer.XML_ATTRKEY][attr.nodeName] = attr.nodeValue;
    }

    if (onlyChildTextValue) {
      result[options.xmlCharKey] = onlyChildTextValue;
    }
  } else if (childNodeCount === 0) {
    result = "";
  } else if (onlyChildTextValue) {
    result = onlyChildTextValue;
  }

  if (!onlyChildTextValue) {
    for (var i = 0; i < childNodeCount; i++) {
      var child = node.childNodes[i]; // Ignore leading/trailing whitespace nodes

      if (child.nodeType !== Node.TEXT_NODE) {
        var childObject = domToObject(child, options);

        if (!result[child.nodeName]) {
          result[child.nodeName] = childObject;
        } else if (Array.isArray(result[child.nodeName])) {
          result[child.nodeName].push(childObject);
        } else {
          result[child.nodeName] = [result[child.nodeName], childObject];
        }
      }
    }
  }

  return result;
}

var serializer = new XMLSerializer();

function stringifyXML(content, opts) {
  var _a, _b, _c;

  if (opts === void 0) {
    opts = {};
  }

  var updatedOptions = {
    rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : "root",
    includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,
    xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : _serializer.XML_CHARKEY
  };
  var dom = buildNode(content, updatedOptions.rootName, updatedOptions)[0];
  return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + serializer.serializeToString(dom);
}

function buildAttributes(attrs) {
  var result = [];

  for (var _i = 0, _a = Object.keys(attrs); _i < _a.length; _i++) {
    var key = _a[_i];
    var attr = doc.createAttribute(key);
    attr.value = attrs[key].toString();
    result.push(attr);
  }

  return result;
}

function buildNode(obj, elementName, options) {
  if (obj === undefined || obj === null || typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean") {
    var elem = doc.createElement(elementName);
    elem.textContent = obj === undefined || obj === null ? "" : obj.toString();
    return [elem];
  } else if (Array.isArray(obj)) {
    var result = [];

    for (var _i = 0, obj_1 = obj; _i < obj_1.length; _i++) {
      var arrayElem = obj_1[_i];

      for (var _a = 0, _b = buildNode(arrayElem, elementName, options); _a < _b.length; _a++) {
        var child = _b[_a];
        result.push(child);
      }
    }

    return result;
  } else if (typeof obj === "object") {
    var elem = doc.createElement(elementName);

    for (var _c = 0, _d = Object.keys(obj); _c < _d.length; _c++) {
      var key = _d[_c];

      if (key === _serializer.XML_ATTRKEY) {
        for (var _e = 0, _f = buildAttributes(obj[key]); _e < _f.length; _e++) {
          var attr = _f[_e];
          elem.attributes.setNamedItem(attr);
        }
      } else if (key === options.xmlCharKey) {
        elem.textContent = obj[key].toString();
      } else {
        for (var _g = 0, _h = buildNode(obj[key], key, options); _g < _h.length; _g++) {
          var child = _h[_g];
          elem.appendChild(child);
        }
      }
    }

    return [elem];
  } else {
    throw new Error("Illegal value passed to buildObject: " + obj);
  }
}
},{"./serializer.common":"KdvI"}],"dsuK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deserializationPolicy = deserializationPolicy;
exports.deserializeResponseBody = deserializeResponseBody;
exports.DeserializationPolicy = exports.DefaultDeserializationOptions = exports.defaultXmlContentTypes = exports.defaultJsonContentTypes = void 0;

var _tslib = require("tslib");

var _restError = require("../restError");

var _serializer = require("../serializer");

var _xml = require("../util/xml");

var _requestPolicy = require("./requestPolicy");

var _serializer2 = require("../util/serializer.common");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Create a new serialization RequestPolicyCreator that will serialized HTTP request bodies as they
 * pass through the HTTP pipeline.
 */
function deserializationPolicy(deserializationContentTypes, parsingOptions) {
  return {
    create: function (nextPolicy, options) {
      return new DeserializationPolicy(nextPolicy, options, deserializationContentTypes, parsingOptions);
    }
  };
}

var defaultJsonContentTypes = ["application/json", "text/json"];
exports.defaultJsonContentTypes = defaultJsonContentTypes;
var defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
exports.defaultXmlContentTypes = defaultXmlContentTypes;
var DefaultDeserializationOptions = {
  expectedContentTypes: {
    json: defaultJsonContentTypes,
    xml: defaultXmlContentTypes
  }
};
/**
 * A RequestPolicy that will deserialize HTTP response bodies and headers as they pass through the
 * HTTP pipeline.
 */

exports.DefaultDeserializationOptions = DefaultDeserializationOptions;

var DeserializationPolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(DeserializationPolicy, _super);

  function DeserializationPolicy(nextPolicy, requestPolicyOptions, deserializationContentTypes, parsingOptions) {
    if (parsingOptions === void 0) {
      parsingOptions = {};
    }

    var _a;

    var _this = _super.call(this, nextPolicy, requestPolicyOptions) || this;

    _this.jsonContentTypes = deserializationContentTypes && deserializationContentTypes.json || defaultJsonContentTypes;
    _this.xmlContentTypes = deserializationContentTypes && deserializationContentTypes.xml || defaultXmlContentTypes;
    _this.xmlCharKey = (_a = parsingOptions.xmlCharKey) !== null && _a !== void 0 ? _a : _serializer2.XML_CHARKEY;
    return _this;
  }

  DeserializationPolicy.prototype.sendRequest = function (request) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _this = this;

      return (0, _tslib.__generator)(this, function (_a) {
        return [2
        /*return*/
        , this._nextPolicy.sendRequest(request).then(function (response) {
          return deserializeResponseBody(_this.jsonContentTypes, _this.xmlContentTypes, response, {
            xmlCharKey: _this.xmlCharKey
          });
        })];
      });
    });
  };

  return DeserializationPolicy;
}(_requestPolicy.BaseRequestPolicy);

exports.DeserializationPolicy = DeserializationPolicy;

function getOperationResponse(parsedResponse) {
  var result;
  var request = parsedResponse.request;
  var operationSpec = request.operationSpec;

  if (operationSpec) {
    var operationResponseGetter = request.operationResponseGetter;

    if (!operationResponseGetter) {
      result = operationSpec.responses[parsedResponse.status];
    } else {
      result = operationResponseGetter(operationSpec, parsedResponse);
    }
  }

  return result;
}

function shouldDeserializeResponse(parsedResponse) {
  var shouldDeserialize = parsedResponse.request.shouldDeserialize;
  var result;

  if (shouldDeserialize === undefined) {
    result = true;
  } else if (typeof shouldDeserialize === "boolean") {
    result = shouldDeserialize;
  } else {
    result = shouldDeserialize(parsedResponse);
  }

  return result;
}

function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options) {
  var _a, _b, _c;

  if (options === void 0) {
    options = {};
  }

  var updatedOptions = {
    rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "",
    includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
    xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : _serializer2.XML_CHARKEY
  };
  return parse(jsonContentTypes, xmlContentTypes, response, updatedOptions).then(function (parsedResponse) {
    if (!shouldDeserializeResponse(parsedResponse)) {
      return parsedResponse;
    }

    var operationSpec = parsedResponse.request.operationSpec;

    if (!operationSpec || !operationSpec.responses) {
      return parsedResponse;
    }

    var responseSpec = getOperationResponse(parsedResponse);

    var _a = handleErrorResponse(parsedResponse, operationSpec, responseSpec),
        error = _a.error,
        shouldReturnResponse = _a.shouldReturnResponse;

    if (error) {
      throw error;
    } else if (shouldReturnResponse) {
      return parsedResponse;
    } // An operation response spec does exist for current status code, so
    // use it to deserialize the response.


    if (responseSpec) {
      if (responseSpec.bodyMapper) {
        var valueToDeserialize = parsedResponse.parsedBody;

        if (operationSpec.isXML && responseSpec.bodyMapper.type.name === _serializer.MapperType.Sequence) {
          valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
        }

        try {
          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
        } catch (innerError) {
          var restError = new _restError.RestError("Error " + innerError + " occurred in deserializing the responseBody - " + parsedResponse.bodyAsText, undefined, parsedResponse.status, parsedResponse.request, parsedResponse);
          throw restError;
        }
      } else if (operationSpec.httpMethod === "HEAD") {
        // head methods never have a body, but we return a boolean to indicate presence/absence of the resource
        parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
      }

      if (responseSpec.headersMapper) {
        parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.rawHeaders(), "operationRes.parsedHeaders", options);
      }
    }

    return parsedResponse;
  });
}

function isOperationSpecEmpty(operationSpec) {
  var expectedStatusCodes = Object.keys(operationSpec.responses);
  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
}

function handleErrorResponse(parsedResponse, operationSpec, responseSpec) {
  var _a;

  var isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
  var isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;

  if (isExpectedStatusCode) {
    if (responseSpec) {
      if (!responseSpec.isError) {
        return {
          error: null,
          shouldReturnResponse: false
        };
      }
    } else {
      return {
        error: null,
        shouldReturnResponse: false
      };
    }
  }

  var errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
  var streaming = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status)) || parsedResponse.request.streamResponseBody;
  var initialErrorMessage = streaming ? "Unexpected status code: " + parsedResponse.status : parsedResponse.bodyAsText;
  var error = new _restError.RestError(initialErrorMessage, undefined, parsedResponse.status, parsedResponse.request, parsedResponse); // If the item failed but there's no error spec or default spec to deserialize the error,
  // we should fail so we just throw the parsed response

  if (!errorResponseSpec) {
    throw error;
  }

  var defaultBodyMapper = errorResponseSpec.bodyMapper;
  var defaultHeadersMapper = errorResponseSpec.headersMapper;

  try {
    // If error response has a body, try to deserialize it using default body mapper.
    // Then try to extract error code & message from it
    if (parsedResponse.parsedBody) {
      var parsedBody = parsedResponse.parsedBody;
      var parsedError = void 0;

      if (defaultBodyMapper) {
        var valueToDeserialize = parsedBody;

        if (operationSpec.isXML && defaultBodyMapper.type.name === _serializer.MapperType.Sequence) {
          valueToDeserialize = typeof parsedBody === "object" ? parsedBody[defaultBodyMapper.xmlElementName] : [];
        }

        parsedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody");
      }

      var internalError = parsedBody.error || parsedError || parsedBody;
      error.code = internalError.code;

      if (internalError.message) {
        error.message = internalError.message;
      }

      if (defaultBodyMapper) {
        error.response.parsedBody = parsedError;
      }
    } // If error response has headers, try to deserialize it using default header mapper


    if (parsedResponse.headers && defaultHeadersMapper) {
      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.rawHeaders(), "operationRes.parsedHeaders");
    }
  } catch (defaultError) {
    error.message = "Error \"" + defaultError.message + "\" occurred in deserializing the responseBody - \"" + parsedResponse.bodyAsText + "\" for the default response.";
  }

  return {
    error: error,
    shouldReturnResponse: false
  };
}

function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts) {
  var _a;

  var errorHandler = function (err) {
    var msg = "Error \"" + err + "\" occurred while parsing the response body - " + operationResponse.bodyAsText + ".";
    var errCode = err.code || _restError.RestError.PARSE_ERROR;
    var e = new _restError.RestError(msg, errCode, operationResponse.status, operationResponse.request, operationResponse);
    return Promise.reject(e);
  };

  var streaming = ((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) || operationResponse.request.streamResponseBody;

  if (!streaming && operationResponse.bodyAsText) {
    var text_1 = operationResponse.bodyAsText;
    var contentType = operationResponse.headers.get("Content-Type") || "";
    var contentComponents = !contentType ? [] : contentType.split(";").map(function (component) {
      return component.toLowerCase();
    });

    if (contentComponents.length === 0 || contentComponents.some(function (component) {
      return jsonContentTypes.indexOf(component) !== -1;
    })) {
      return new Promise(function (resolve) {
        operationResponse.parsedBody = JSON.parse(text_1);
        resolve(operationResponse);
      }).catch(errorHandler);
    } else if (contentComponents.some(function (component) {
      return xmlContentTypes.indexOf(component) !== -1;
    })) {
      return (0, _xml.parseXML)(text_1, opts).then(function (body) {
        operationResponse.parsedBody = body;
        return operationResponse;
      }).catch(errorHandler);
    }
  }

  return Promise.resolve(operationResponse);
}
},{"tslib":"CvJj","../restError":"VBBg","../serializer":"HiIJ","../util/xml":"oKNo","./requestPolicy":"ggtJ","../util/serializer.common":"KdvI"}],"BT2Z":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNumber = isNumber;
exports.shouldRetry = shouldRetry;
exports.updateRetryData = updateRetryData;
exports.DEFAULT_CLIENT_MIN_RETRY_INTERVAL = exports.DEFAULT_CLIENT_MAX_RETRY_INTERVAL = exports.DEFAULT_CLIENT_RETRY_INTERVAL = exports.DEFAULT_CLIENT_RETRY_COUNT = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var DEFAULT_CLIENT_RETRY_COUNT = 3; // intervals are in ms

exports.DEFAULT_CLIENT_RETRY_COUNT = DEFAULT_CLIENT_RETRY_COUNT;
var DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;
exports.DEFAULT_CLIENT_RETRY_INTERVAL = DEFAULT_CLIENT_RETRY_INTERVAL;
var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;
exports.DEFAULT_CLIENT_MAX_RETRY_INTERVAL = DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
var DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;
exports.DEFAULT_CLIENT_MIN_RETRY_INTERVAL = DEFAULT_CLIENT_MIN_RETRY_INTERVAL;

function isNumber(n) {
  return typeof n === "number";
}
/**
 * @internal
 * Determines if the operation should be retried.
 *
 * @param retryLimit - Specifies the max number of retries.
 * @param predicate - Initial chekck on whether to retry based on given responses or errors
 * @param retryData -  The retry data.
 * @returns True if the operation qualifies for a retry; false otherwise.
 */


function shouldRetry(retryLimit, predicate, retryData, response, error) {
  if (!predicate(response, error)) {
    return false;
  }

  return retryData.retryCount < retryLimit;
}
/**
 * @internal
 * Updates the retry data for the next attempt.
 *
 * @param retryOptions - specifies retry interval, and its lower bound and upper bound.
 * @param retryData -  The retry data.
 * @param err - The operation"s error, if any.
 */


function updateRetryData(retryOptions, retryData, err) {
  if (retryData === void 0) {
    retryData = {
      retryCount: 0,
      retryInterval: 0
    };
  }

  if (err) {
    if (retryData.error) {
      err.innerError = retryData.error;
    }

    retryData.error = err;
  } // Adjust retry count


  retryData.retryCount++; // Adjust retry interval

  var incrementDelta = Math.pow(2, retryData.retryCount - 1) - 1;
  var boundedRandDelta = retryOptions.retryInterval * 0.8 + Math.floor(Math.random() * (retryOptions.retryInterval * 0.4));
  incrementDelta *= boundedRandDelta;
  retryData.retryInterval = Math.min(retryOptions.minRetryInterval + incrementDelta, retryOptions.maxRetryInterval);
  return retryData;
}
},{}],"At7c":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exponentialRetryPolicy = exponentialRetryPolicy;
exports.ExponentialRetryPolicy = exports.DefaultRetryOptions = exports.RetryMode = void 0;

var _tslib = require("tslib");

var utils = _interopRequireWildcard(require("../util/utils"));

var _requestPolicy = require("./requestPolicy");

var _exponentialBackoffStrategy = require("../util/exponentialBackoffStrategy");

var _restError = require("../restError");

var _log = require("../log");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function exponentialRetryPolicy(retryCount, retryInterval, maxRetryInterval) {
  return {
    create: function (nextPolicy, options) {
      return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval);
    }
  };
}
/**
 * Describes the Retry Mode type. Currently supporting only Exponential.
 */


var RetryMode;
exports.RetryMode = RetryMode;

(function (RetryMode) {
  RetryMode[RetryMode["Exponential"] = 0] = "Exponential";
})(RetryMode || (exports.RetryMode = RetryMode = {}));

var DefaultRetryOptions = {
  maxRetries: _exponentialBackoffStrategy.DEFAULT_CLIENT_RETRY_COUNT,
  retryDelayInMs: _exponentialBackoffStrategy.DEFAULT_CLIENT_RETRY_INTERVAL,
  maxRetryDelayInMs: _exponentialBackoffStrategy.DEFAULT_CLIENT_MAX_RETRY_INTERVAL
};
/**
 * Instantiates a new "ExponentialRetryPolicyFilter" instance.
 */

exports.DefaultRetryOptions = DefaultRetryOptions;

var ExponentialRetryPolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(ExponentialRetryPolicy, _super);
  /**
   * @param nextPolicy - The next RequestPolicy in the pipeline chain.
   * @param options - The options for this RequestPolicy.
   * @param retryCount - The client retry count.
   * @param retryInterval - The client retry interval, in milliseconds.
   * @param minRetryInterval - The minimum retry interval, in milliseconds.
   * @param maxRetryInterval - The maximum retry interval, in milliseconds.
   */

  function ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval) {
    var _this = _super.call(this, nextPolicy, options) || this;

    _this.retryCount = (0, _exponentialBackoffStrategy.isNumber)(retryCount) ? retryCount : _exponentialBackoffStrategy.DEFAULT_CLIENT_RETRY_COUNT;
    _this.retryInterval = (0, _exponentialBackoffStrategy.isNumber)(retryInterval) ? retryInterval : _exponentialBackoffStrategy.DEFAULT_CLIENT_RETRY_INTERVAL;
    _this.maxRetryInterval = (0, _exponentialBackoffStrategy.isNumber)(maxRetryInterval) ? maxRetryInterval : _exponentialBackoffStrategy.DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
    return _this;
  }

  ExponentialRetryPolicy.prototype.sendRequest = function (request) {
    var _this = this;

    return this._nextPolicy.sendRequest(request.clone()).then(function (response) {
      return retry(_this, request, response);
    }).catch(function (error) {
      return retry(_this, request, error.response, undefined, error);
    });
  };

  return ExponentialRetryPolicy;
}(_requestPolicy.BaseRequestPolicy);

exports.ExponentialRetryPolicy = ExponentialRetryPolicy;

function retry(policy, request, response, retryData, requestError) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    function shouldPolicyRetry(responseParam) {
      var statusCode = responseParam === null || responseParam === void 0 ? void 0 : responseParam.status;

      if (statusCode === undefined || statusCode < 500 && statusCode !== 408 || statusCode === 501 || statusCode === 505) {
        return false;
      }

      return true;
    }

    var isAborted, res, err_1, err;
    return (0, _tslib.__generator)(this, function (_a) {
      switch (_a.label) {
        case 0:
          retryData = (0, _exponentialBackoffStrategy.updateRetryData)({
            retryInterval: policy.retryInterval,
            minRetryInterval: 0,
            maxRetryInterval: policy.maxRetryInterval
          }, retryData, requestError);
          isAborted = request.abortSignal && request.abortSignal.aborted;
          if (!(!isAborted && (0, _exponentialBackoffStrategy.shouldRetry)(policy.retryCount, shouldPolicyRetry, retryData, response))) return [3
          /*break*/
          , 6];

          _log.logger.info("Retrying request in " + retryData.retryInterval);

          _a.label = 1;

        case 1:
          _a.trys.push([1, 4,, 5]);

          return [4
          /*yield*/
          , utils.delay(retryData.retryInterval)];

        case 2:
          _a.sent();

          return [4
          /*yield*/
          , policy._nextPolicy.sendRequest(request.clone())];

        case 3:
          res = _a.sent();
          return [2
          /*return*/
          , retry(policy, request, res, retryData)];

        case 4:
          err_1 = _a.sent();
          return [2
          /*return*/
          , retry(policy, request, response, retryData, err_1)];

        case 5:
          return [3
          /*break*/
          , 7];

        case 6:
          if (isAborted || requestError || !response) {
            err = retryData.error || new _restError.RestError("Failed to send the request.", _restError.RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);
            throw err;
          } else {
            return [2
            /*return*/
            , response];
          }

          _a.label = 7;

        case 7:
          return [2
          /*return*/
          ];
      }
    });
  });
}
},{"tslib":"CvJj","../util/utils":"DVp2","./requestPolicy":"ggtJ","../util/exponentialBackoffStrategy":"BT2Z","../restError":"VBBg","../log":"D5PC"}],"pXAS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateClientRequestIdPolicy = generateClientRequestIdPolicy;
exports.GenerateClientRequestIdPolicy = void 0;

var _tslib = require("tslib");

var _requestPolicy = require("./requestPolicy");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function generateClientRequestIdPolicy(requestIdHeaderName) {
  if (requestIdHeaderName === void 0) {
    requestIdHeaderName = "x-ms-client-request-id";
  }

  return {
    create: function (nextPolicy, options) {
      return new GenerateClientRequestIdPolicy(nextPolicy, options, requestIdHeaderName);
    }
  };
}

var GenerateClientRequestIdPolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(GenerateClientRequestIdPolicy, _super);

  function GenerateClientRequestIdPolicy(nextPolicy, options, _requestIdHeaderName) {
    var _this = _super.call(this, nextPolicy, options) || this;

    _this._requestIdHeaderName = _requestIdHeaderName;
    return _this;
  }

  GenerateClientRequestIdPolicy.prototype.sendRequest = function (request) {
    if (!request.headers.contains(this._requestIdHeaderName)) {
      request.headers.set(this._requestIdHeaderName, request.requestId);
    }

    return this._nextPolicy.sendRequest(request);
  };

  return GenerateClientRequestIdPolicy;
}(_requestPolicy.BaseRequestPolicy);

exports.GenerateClientRequestIdPolicy = GenerateClientRequestIdPolicy;
},{"tslib":"CvJj","./requestPolicy":"ggtJ"}],"MZ57":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultUserAgentKey = getDefaultUserAgentKey;
exports.getPlatformSpecificData = getPlatformSpecificData;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function getDefaultUserAgentKey() {
  return "x-ms-useragent";
}

function getPlatformSpecificData() {
  var navigator = window.navigator;
  var osInfo = {
    key: "OS",
    value: (navigator.oscpu || navigator.platform).replace(" ", "")
  };
  return [osInfo];
}
},{}],"rhWY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultUserAgentValue = getDefaultUserAgentValue;
exports.userAgentPolicy = userAgentPolicy;
exports.UserAgentPolicy = exports.getDefaultUserAgentHeaderName = void 0;

var _tslib = require("tslib");

var _httpHeaders = require("../httpHeaders");

var _constants = require("../util/constants");

var _msRestUserAgentPolicy = require("./msRestUserAgentPolicy");

var _requestPolicy = require("./requestPolicy");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function getRuntimeInfo() {
  var msRestRuntime = {
    key: "core-http",
    value: _constants.Constants.coreHttpVersion
  };
  return [msRestRuntime];
}

function getUserAgentString(telemetryInfo, keySeparator, valueSeparator) {
  if (keySeparator === void 0) {
    keySeparator = " ";
  }

  if (valueSeparator === void 0) {
    valueSeparator = "/";
  }

  return telemetryInfo.map(function (info) {
    var value = info.value ? "" + valueSeparator + info.value : "";
    return "" + info.key + value;
  }).join(keySeparator);
}

var getDefaultUserAgentHeaderName = _msRestUserAgentPolicy.getDefaultUserAgentKey;
exports.getDefaultUserAgentHeaderName = getDefaultUserAgentHeaderName;

function getDefaultUserAgentValue() {
  var runtimeInfo = getRuntimeInfo();
  var platformSpecificData = (0, _msRestUserAgentPolicy.getPlatformSpecificData)();
  var userAgent = getUserAgentString(runtimeInfo.concat(platformSpecificData));
  return userAgent;
}

function userAgentPolicy(userAgentData) {
  var key = !userAgentData || userAgentData.key === undefined || userAgentData.key === null ? (0, _msRestUserAgentPolicy.getDefaultUserAgentKey)() : userAgentData.key;
  var value = !userAgentData || userAgentData.value === undefined || userAgentData.value === null ? getDefaultUserAgentValue() : userAgentData.value;
  return {
    create: function (nextPolicy, options) {
      return new UserAgentPolicy(nextPolicy, options, key, value);
    }
  };
}

var UserAgentPolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(UserAgentPolicy, _super);

  function UserAgentPolicy(_nextPolicy, _options, headerKey, headerValue) {
    var _this = _super.call(this, _nextPolicy, _options) || this;

    _this._nextPolicy = _nextPolicy;
    _this._options = _options;
    _this.headerKey = headerKey;
    _this.headerValue = headerValue;
    return _this;
  }

  UserAgentPolicy.prototype.sendRequest = function (request) {
    this.addUserAgentHeader(request);
    return this._nextPolicy.sendRequest(request);
  };

  UserAgentPolicy.prototype.addUserAgentHeader = function (request) {
    if (!request.headers) {
      request.headers = new _httpHeaders.HttpHeaders();
    }

    if (!request.headers.get(this.headerKey) && this.headerValue) {
      request.headers.set(this.headerKey, this.headerValue);
    }
  };

  return UserAgentPolicy;
}(_requestPolicy.BaseRequestPolicy);

exports.UserAgentPolicy = UserAgentPolicy;
},{"tslib":"CvJj","../httpHeaders":"wA5d","../util/constants":"o95E","./msRestUserAgentPolicy":"MZ57","./requestPolicy":"ggtJ"}],"IlDT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.redirectPolicy = redirectPolicy;
exports.RedirectPolicy = exports.DefaultRedirectOptions = void 0;

var _tslib = require("tslib");

var _url = require("../url");

var _requestPolicy = require("./requestPolicy");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Methods that are allowed to follow redirects 301 and 302
 */
var allowedRedirect = ["GET", "HEAD"];
var DefaultRedirectOptions = {
  handleRedirects: true,
  maxRetries: 20
};
exports.DefaultRedirectOptions = DefaultRedirectOptions;

function redirectPolicy(maximumRetries) {
  if (maximumRetries === void 0) {
    maximumRetries = 20;
  }

  return {
    create: function (nextPolicy, options) {
      return new RedirectPolicy(nextPolicy, options, maximumRetries);
    }
  };
}

var RedirectPolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(RedirectPolicy, _super);

  function RedirectPolicy(nextPolicy, options, maxRetries) {
    if (maxRetries === void 0) {
      maxRetries = 20;
    }

    var _this = _super.call(this, nextPolicy, options) || this;

    _this.maxRetries = maxRetries;
    return _this;
  }

  RedirectPolicy.prototype.sendRequest = function (request) {
    var _this = this;

    return this._nextPolicy.sendRequest(request).then(function (response) {
      return handleRedirect(_this, response, 0);
    });
  };

  return RedirectPolicy;
}(_requestPolicy.BaseRequestPolicy);

exports.RedirectPolicy = RedirectPolicy;

function handleRedirect(policy, response, currentRetries) {
  var request = response.request,
      status = response.status;
  var locationHeader = response.headers.get("location");

  if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && (!policy.maxRetries || currentRetries < policy.maxRetries)) {
    var builder = _url.URLBuilder.parse(request.url);

    builder.setPath(locationHeader);
    request.url = builder.toString(); // POST request with Status code 303 should be converted into a
    // redirected GET request if the redirect url is present in the location header

    if (status === 303) {
      request.method = "GET";
      delete request.body;
    }

    return policy._nextPolicy.sendRequest(request).then(function (res) {
      return handleRedirect(policy, res, currentRetries + 1);
    });
  }

  return Promise.resolve(response);
}
},{"tslib":"CvJj","../url":"bBTP","./requestPolicy":"ggtJ"}],"gZxS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rpRegistrationPolicy = rpRegistrationPolicy;
exports.RPRegistrationPolicy = void 0;

var _tslib = require("tslib");

var utils = _interopRequireWildcard(require("../util/utils"));

var _requestPolicy = require("./requestPolicy");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function rpRegistrationPolicy(retryTimeout) {
  if (retryTimeout === void 0) {
    retryTimeout = 30;
  }

  return {
    create: function (nextPolicy, options) {
      return new RPRegistrationPolicy(nextPolicy, options, retryTimeout);
    }
  };
}

var RPRegistrationPolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(RPRegistrationPolicy, _super);

  function RPRegistrationPolicy(nextPolicy, options, _retryTimeout) {
    if (_retryTimeout === void 0) {
      _retryTimeout = 30;
    }

    var _this = _super.call(this, nextPolicy, options) || this;

    _this._retryTimeout = _retryTimeout;
    return _this;
  }

  RPRegistrationPolicy.prototype.sendRequest = function (request) {
    var _this = this;

    return this._nextPolicy.sendRequest(request.clone()).then(function (response) {
      return registerIfNeeded(_this, request, response);
    });
  };

  return RPRegistrationPolicy;
}(_requestPolicy.BaseRequestPolicy);

exports.RPRegistrationPolicy = RPRegistrationPolicy;

function registerIfNeeded(policy, request, response) {
  if (response.status === 409) {
    var rpName = checkRPNotRegisteredError(response.bodyAsText);

    if (rpName) {
      var urlPrefix = extractSubscriptionUrl(request.url);
      return registerRP(policy, urlPrefix, rpName, request) // Autoregistration of ${provider} failed for some reason. We will not return this error
      // instead will return the initial response with 409 status code back to the user.
      // do nothing here as we are returning the original response at the end of this method.
      .catch(function () {
        return false;
      }).then(function (registrationStatus) {
        if (registrationStatus) {
          // Retry the original request. We have to change the x-ms-client-request-id
          // otherwise Azure endpoint will return the initial 409 (cached) response.
          request.headers.set("x-ms-client-request-id", utils.generateUuid());
          return policy._nextPolicy.sendRequest(request.clone());
        }

        return response;
      });
    }
  }

  return Promise.resolve(response);
}
/**
 * Reuses the headers of the original request and url (if specified).
 * @param originalRequest - The original request
 * @param reuseUrlToo - Should the url from the original request be reused as well. Default false.
 * @returns A new request object with desired headers.
 */


function getRequestEssentials(originalRequest, reuseUrlToo) {
  if (reuseUrlToo === void 0) {
    reuseUrlToo = false;
  }

  var reqOptions = originalRequest.clone();

  if (reuseUrlToo) {
    reqOptions.url = originalRequest.url;
  } // We have to change the x-ms-client-request-id otherwise Azure endpoint
  // will return the initial 409 (cached) response.


  reqOptions.headers.set("x-ms-client-request-id", utils.generateUuid()); // Set content-type to application/json

  reqOptions.headers.set("Content-Type", "application/json; charset=utf-8");
  return reqOptions;
}
/**
 * Validates the error code and message associated with 409 response status code. If it matches to that of
 * RP not registered then it returns the name of the RP else returns undefined.
 * @param body - The response body received after making the original request.
 * @returns The name of the RP if condition is satisfied else undefined.
 */


function checkRPNotRegisteredError(body) {
  var result, responseBody;

  if (body) {
    try {
      responseBody = JSON.parse(body);
    } catch (err) {// do nothing;
    }

    if (responseBody && responseBody.error && responseBody.error.message && responseBody.error.code && responseBody.error.code === "MissingSubscriptionRegistration") {
      var matchRes = responseBody.error.message.match(/.*'(.*)'/i);

      if (matchRes) {
        result = matchRes.pop();
      }
    }
  }

  return result;
}
/**
 * Extracts the first part of the URL, just after subscription:
 * https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/
 * @param url - The original request url
 * @returns The url prefix as explained above.
 */


function extractSubscriptionUrl(url) {
  var result;
  var matchRes = url.match(/.*\/subscriptions\/[a-f0-9-]+\//gi);

  if (matchRes && matchRes[0]) {
    result = matchRes[0];
  } else {
    throw new Error("Unable to extract subscriptionId from the given url - " + url + ".");
  }

  return result;
}
/**
 * Registers the given provider.
 * @param policy - The RPRegistrationPolicy this function is being called against.
 * @param urlPrefix - https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/
 * @param provider - The provider name to be registered.
 * @param originalRequest - The original request sent by the user that returned a 409 response
 * with a message that the provider is not registered.
 * @param callback - The callback that handles the RP registration
 */


function registerRP(policy, urlPrefix, provider, originalRequest) {
  var postUrl = urlPrefix + "providers/" + provider + "/register?api-version=2016-02-01";
  var getUrl = urlPrefix + "providers/" + provider + "?api-version=2016-02-01";
  var reqOptions = getRequestEssentials(originalRequest);
  reqOptions.method = "POST";
  reqOptions.url = postUrl;
  return policy._nextPolicy.sendRequest(reqOptions).then(function (response) {
    if (response.status !== 200) {
      throw new Error("Autoregistration of " + provider + " failed. Please try registering manually.");
    }

    return getRegistrationStatus(policy, getUrl, originalRequest);
  });
}
/**
 * Polls the registration status of the provider that was registered. Polling happens at an interval of 30 seconds.
 * Polling will happen till the registrationState property of the response body is "Registered".
 * @param policy - The RPRegistrationPolicy this function is being called against.
 * @param url - The request url for polling
 * @param originalRequest - The original request sent by the user that returned a 409 response
 * with a message that the provider is not registered.
 * @returns True if RP Registration is successful.
 */


function getRegistrationStatus(policy, url, originalRequest) {
  var reqOptions = getRequestEssentials(originalRequest);
  reqOptions.url = url;
  reqOptions.method = "GET";
  return policy._nextPolicy.sendRequest(reqOptions).then(function (res) {
    var obj = res.parsedBody;

    if (res.parsedBody && obj.registrationState && obj.registrationState === "Registered") {
      return true;
    } else {
      return utils.delay(policy._retryTimeout * 1000).then(function () {
        return getRegistrationStatus(policy, url, originalRequest);
      });
    }
  });
}
},{"tslib":"CvJj","../util/utils":"DVp2","./requestPolicy":"ggtJ"}],"WW12":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExpiringAccessTokenCache = exports.TokenRefreshBufferMs = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Defines the default token refresh buffer duration.
 */
var TokenRefreshBufferMs = 2 * 60 * 1000; // 2 Minutes

/**
 * Provides an {@link AccessTokenCache} implementation which clears
 * the cached {@link AccessToken}'s after the expiresOnTimestamp has
 * passed.
 */

exports.TokenRefreshBufferMs = TokenRefreshBufferMs;

var ExpiringAccessTokenCache =
/** @class */
function () {
  /**
   * Constructs an instance of {@link ExpiringAccessTokenCache} with
   * an optional expiration buffer time.
   */
  function ExpiringAccessTokenCache(tokenRefreshBufferMs) {
    if (tokenRefreshBufferMs === void 0) {
      tokenRefreshBufferMs = TokenRefreshBufferMs;
    }

    this.cachedToken = undefined;
    this.tokenRefreshBufferMs = tokenRefreshBufferMs;
  }

  ExpiringAccessTokenCache.prototype.setCachedToken = function (accessToken) {
    this.cachedToken = accessToken;
  };

  ExpiringAccessTokenCache.prototype.getCachedToken = function () {
    if (this.cachedToken && Date.now() + this.tokenRefreshBufferMs >= this.cachedToken.expiresOnTimestamp) {
      this.cachedToken = undefined;
    }

    return this.cachedToken;
  };

  return ExpiringAccessTokenCache;
}();

exports.ExpiringAccessTokenCache = ExpiringAccessTokenCache;
},{}],"CqC4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AccessTokenRefresher = void 0;

var _tslib = require("tslib");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Helps the core-http token authentication policies with requesting a new token if we're not currently waiting for a new token.
 */
var AccessTokenRefresher =
/** @class */
function () {
  function AccessTokenRefresher(credential, scopes, requiredMillisecondsBeforeNewRefresh) {
    if (requiredMillisecondsBeforeNewRefresh === void 0) {
      requiredMillisecondsBeforeNewRefresh = 30000;
    }

    this.credential = credential;
    this.scopes = scopes;
    this.requiredMillisecondsBeforeNewRefresh = requiredMillisecondsBeforeNewRefresh;
    this.lastCalled = 0;
  }
  /**
   * Returns true if the required milliseconds(defaulted to 30000) have been passed signifying
   * that we are ready for a new refresh.
   */


  AccessTokenRefresher.prototype.isReady = function () {
    // We're only ready for a new refresh if the required milliseconds have passed.
    return !this.lastCalled || Date.now() - this.lastCalled > this.requiredMillisecondsBeforeNewRefresh;
  };
  /**
   * Stores the time in which it is called,
   * then requests a new token,
   * then sets this.promise to undefined,
   * then returns the token.
   */


  AccessTokenRefresher.prototype.getToken = function (options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var token;
      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            this.lastCalled = Date.now();
            return [4
            /*yield*/
            , this.credential.getToken(this.scopes, options)];

          case 1:
            token = _a.sent();
            this.promise = undefined;
            return [2
            /*return*/
            , token || undefined];
        }
      });
    });
  };
  /**
   * Requests a new token if we're not currently waiting for a new token.
   * Returns null if the required time between each call hasn't been reached.
   */


  AccessTokenRefresher.prototype.refresh = function (options) {
    if (!this.promise) {
      this.promise = this.getToken(options);
    }

    return this.promise;
  };

  return AccessTokenRefresher;
}();

exports.AccessTokenRefresher = AccessTokenRefresher;
},{"tslib":"CvJj"}],"lKdS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy;
exports.BearerTokenAuthenticationPolicy = void 0;

var _tslib = require("tslib");

var _requestPolicy = require("../policies/requestPolicy");

var _constants = require("../util/constants");

var _httpHeaders = require("../httpHeaders");

var _accessTokenCache = require("../credentials/accessTokenCache");

var _accessTokenRefresher = require("../credentials/accessTokenRefresher");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * The automated token refresh will only start to happen at the
 * expiration date minus the value of timeBetweenRefreshAttemptsInMs,
 * which is by default 30 seconds.
 */
var timeBetweenRefreshAttemptsInMs = 30000;
/**
 * Creates a new BearerTokenAuthenticationPolicy factory.
 *
 * @param credential - The TokenCredential implementation that can supply the bearer token.
 * @param scopes - The scopes for which the bearer token applies.
 */

function bearerTokenAuthenticationPolicy(credential, scopes) {
  var tokenCache = new _accessTokenCache.ExpiringAccessTokenCache();
  var tokenRefresher = new _accessTokenRefresher.AccessTokenRefresher(credential, scopes, timeBetweenRefreshAttemptsInMs);
  return {
    create: function (nextPolicy, options) {
      return new BearerTokenAuthenticationPolicy(nextPolicy, options, tokenCache, tokenRefresher);
    }
  };
}
/**
 *
 * Provides a RequestPolicy that can request a token from a TokenCredential
 * implementation and then apply it to the Authorization header of a request
 * as a Bearer token.
 *
 */


var BearerTokenAuthenticationPolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(BearerTokenAuthenticationPolicy, _super);
  /**
   * Creates a new BearerTokenAuthenticationPolicy object.
   *
   * @param nextPolicy - The next RequestPolicy in the request pipeline.
   * @param options - Options for this RequestPolicy.
   * @param credential - The TokenCredential implementation that can supply the bearer token.
   * @param scopes - The scopes for which the bearer token applies.
   * @param tokenCache - The cache for the most recent AccessToken returned from the TokenCredential.
   */

  function BearerTokenAuthenticationPolicy(nextPolicy, options, tokenCache, tokenRefresher) {
    var _this = _super.call(this, nextPolicy, options) || this;

    _this.tokenCache = tokenCache;
    _this.tokenRefresher = tokenRefresher;
    return _this;
  }
  /**
   * Applies the Bearer token to the request through the Authorization header.
   */


  BearerTokenAuthenticationPolicy.prototype.sendRequest = function (webResource) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var token;
      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (!webResource.headers) webResource.headers = new _httpHeaders.HttpHeaders();
            return [4
            /*yield*/
            , this.getToken({
              abortSignal: webResource.abortSignal,
              tracingOptions: {
                spanOptions: webResource.spanOptions
              }
            })];

          case 1:
            token = _a.sent();
            webResource.headers.set(_constants.Constants.HeaderConstants.AUTHORIZATION, "Bearer " + token);
            return [2
            /*return*/
            , this._nextPolicy.sendRequest(webResource)];
        }
      });
    });
  };
  /**
   * Attempts a token update if any other time related conditionals have been reached based on the tokenRefresher class.
   */


  BearerTokenAuthenticationPolicy.prototype.updateTokenIfNeeded = function (options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var accessToken;
      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (!this.tokenRefresher.isReady()) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , this.tokenRefresher.refresh(options)];

          case 1:
            accessToken = _a.sent();
            this.tokenCache.setCachedToken(accessToken);
            _a.label = 2;

          case 2:
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  BearerTokenAuthenticationPolicy.prototype.getToken = function (options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var accessToken;
      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            accessToken = this.tokenCache.getCachedToken();
            if (!(accessToken === undefined)) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , this.tokenRefresher.refresh(options)];

          case 1:
            // Waiting for the next refresh only if the cache is unable to retrieve the access token,
            // which means that it has expired, or it has never been set.
            accessToken = _a.sent();
            this.tokenCache.setCachedToken(accessToken);
            return [3
            /*break*/
            , 3];

          case 2:
            // If we still have a cached access token,
            // And any other time related conditionals have been reached based on the tokenRefresher class,
            // then attempt to refresh without waiting.
            this.updateTokenIfNeeded(options);
            _a.label = 3;

          case 3:
            return [2
            /*return*/
            , accessToken ? accessToken.token : undefined];
        }
      });
    });
  };

  return BearerTokenAuthenticationPolicy;
}(_requestPolicy.BaseRequestPolicy);

exports.BearerTokenAuthenticationPolicy = BearerTokenAuthenticationPolicy;
},{"tslib":"CvJj","../policies/requestPolicy":"ggtJ","../util/constants":"o95E","../httpHeaders":"wA5d","../credentials/accessTokenCache":"WW12","../credentials/accessTokenRefresher":"CqC4"}],"hlpJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.systemErrorRetryPolicy = systemErrorRetryPolicy;
exports.SystemErrorRetryPolicy = void 0;

var _tslib = require("tslib");

var utils = _interopRequireWildcard(require("../util/utils"));

var _requestPolicy = require("./requestPolicy");

var _exponentialBackoffStrategy = require("../util/exponentialBackoffStrategy");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
  return {
    create: function (nextPolicy, options) {
      return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);
    }
  };
}
/**
 * @param retryCount - The client retry count.
 * @param retryInterval - The client retry interval, in milliseconds.
 * @param minRetryInterval - The minimum retry interval, in milliseconds.
 * @param maxRetryInterval - The maximum retry interval, in milliseconds.
 */


var SystemErrorRetryPolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(SystemErrorRetryPolicy, _super);

  function SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
    var _this = _super.call(this, nextPolicy, options) || this;

    _this.retryCount = (0, _exponentialBackoffStrategy.isNumber)(retryCount) ? retryCount : _exponentialBackoffStrategy.DEFAULT_CLIENT_RETRY_COUNT;
    _this.retryInterval = (0, _exponentialBackoffStrategy.isNumber)(retryInterval) ? retryInterval : _exponentialBackoffStrategy.DEFAULT_CLIENT_RETRY_INTERVAL;
    _this.minRetryInterval = (0, _exponentialBackoffStrategy.isNumber)(minRetryInterval) ? minRetryInterval : _exponentialBackoffStrategy.DEFAULT_CLIENT_MIN_RETRY_INTERVAL;
    _this.maxRetryInterval = (0, _exponentialBackoffStrategy.isNumber)(maxRetryInterval) ? maxRetryInterval : _exponentialBackoffStrategy.DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
    return _this;
  }

  SystemErrorRetryPolicy.prototype.sendRequest = function (request) {
    var _this = this;

    return this._nextPolicy.sendRequest(request.clone()).catch(function (error) {
      return retry(_this, request, error.response, error);
    });
  };

  return SystemErrorRetryPolicy;
}(_requestPolicy.BaseRequestPolicy);

exports.SystemErrorRetryPolicy = SystemErrorRetryPolicy;

function retry(policy, request, operationResponse, err, retryData) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    function shouldPolicyRetry(_response, error) {
      if (error && error.code && (error.code === "ETIMEDOUT" || error.code === "ESOCKETTIMEDOUT" || error.code === "ECONNREFUSED" || error.code === "ECONNRESET" || error.code === "ENOENT")) {
        return true;
      }

      return false;
    }

    var nestedErr_1;
    return (0, _tslib.__generator)(this, function (_a) {
      switch (_a.label) {
        case 0:
          retryData = (0, _exponentialBackoffStrategy.updateRetryData)(policy, retryData, err);
          if (!(0, _exponentialBackoffStrategy.shouldRetry)(policy.retryCount, shouldPolicyRetry, retryData, operationResponse, err)) return [3
          /*break*/
          , 5];
          _a.label = 1;

        case 1:
          _a.trys.push([1, 3,, 4]);

          return [4
          /*yield*/
          , utils.delay(retryData.retryInterval)];

        case 2:
          _a.sent();

          return [2
          /*return*/
          , policy._nextPolicy.sendRequest(request.clone())];

        case 3:
          nestedErr_1 = _a.sent();
          return [2
          /*return*/
          , retry(policy, request, operationResponse, nestedErr_1, retryData)];

        case 4:
          return [3
          /*break*/
          , 6];

        case 5:
          if (err) {
            // If the operation failed in the end, return all errors instead of just the last one
            return [2
            /*return*/
            , Promise.reject(retryData.error)];
          }

          return [2
          /*return*/
          , operationResponse];

        case 6:
          return [2
          /*return*/
          ];
      }
    });
  });
}
},{"tslib":"CvJj","../util/utils":"DVp2","./requestPolicy":"ggtJ","../util/exponentialBackoffStrategy":"BT2Z"}],"T2Lt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QueryCollectionFormat = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * The format that will be used to join an array of values together for a query parameter value.
 */
var QueryCollectionFormat;
exports.QueryCollectionFormat = QueryCollectionFormat;

(function (QueryCollectionFormat) {
  QueryCollectionFormat["Csv"] = ",";
  QueryCollectionFormat["Ssv"] = " ";
  QueryCollectionFormat["Tsv"] = "\t";
  QueryCollectionFormat["Pipes"] = "|";
  QueryCollectionFormat["Multi"] = "Multi";
})(QueryCollectionFormat || (exports.QueryCollectionFormat = QueryCollectionFormat = {}));
},{}],"Rd7P":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultProxySettings = getDefaultProxySettings;
exports.proxyPolicy = proxyPolicy;
exports.ProxyPolicy = void 0;

var _tslib = require("tslib");

var _requestPolicy = require("./requestPolicy");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var proxyNotSupportedInBrowser = new Error("ProxyPolicy is not supported in browser environment");

function getDefaultProxySettings(_proxyUrl) {
  return undefined;
}

function proxyPolicy(_proxySettings) {
  return {
    create: function (_nextPolicy, _options) {
      throw proxyNotSupportedInBrowser;
    }
  };
}

var ProxyPolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(ProxyPolicy, _super);

  function ProxyPolicy(nextPolicy, options) {
    var _this = _super.call(this, nextPolicy, options) || this;

    throw proxyNotSupportedInBrowser;
    return _this;
  }

  ProxyPolicy.prototype.sendRequest = function (_request) {
    throw proxyNotSupportedInBrowser;
  };

  return ProxyPolicy;
}(_requestPolicy.BaseRequestPolicy);

exports.ProxyPolicy = ProxyPolicy;
},{"tslib":"CvJj","./requestPolicy":"ggtJ"}],"kEMe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.throttlingRetryPolicy = throttlingRetryPolicy;
exports.ThrottlingRetryPolicy = void 0;

var _tslib = require("tslib");

var _requestPolicy = require("./requestPolicy");

var _constants = require("../util/constants");

var _utils = require("../util/utils");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var StatusCodes = _constants.Constants.HttpConstants.StatusCodes;

function throttlingRetryPolicy() {
  return {
    create: function (nextPolicy, options) {
      return new ThrottlingRetryPolicy(nextPolicy, options);
    }
  };
}
/**
 * To learn more, please refer to
 * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,
 * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and
 * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors
 */


var ThrottlingRetryPolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(ThrottlingRetryPolicy, _super);

  function ThrottlingRetryPolicy(nextPolicy, options, _handleResponse) {
    var _this = _super.call(this, nextPolicy, options) || this;

    _this._handleResponse = _handleResponse || _this._defaultResponseHandler;
    return _this;
  }

  ThrottlingRetryPolicy.prototype.sendRequest = function (httpRequest) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _this = this;

      return (0, _tslib.__generator)(this, function (_a) {
        return [2
        /*return*/
        , this._nextPolicy.sendRequest(httpRequest.clone()).then(function (response) {
          if (response.status !== StatusCodes.TooManyRequests) {
            return response;
          } else {
            return _this._handleResponse(httpRequest, response);
          }
        })];
      });
    });
  };

  ThrottlingRetryPolicy.prototype._defaultResponseHandler = function (httpRequest, httpResponse) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var retryAfterHeader, delayInMs;

      var _this = this;

      return (0, _tslib.__generator)(this, function (_a) {
        retryAfterHeader = httpResponse.headers.get(_constants.Constants.HeaderConstants.RETRY_AFTER);

        if (retryAfterHeader) {
          delayInMs = ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);

          if (delayInMs) {
            return [2
            /*return*/
            , (0, _utils.delay)(delayInMs).then(function (_) {
              return _this._nextPolicy.sendRequest(httpRequest);
            })];
          }
        }

        return [2
        /*return*/
        , httpResponse];
      });
    });
  };

  ThrottlingRetryPolicy.parseRetryAfterHeader = function (headerValue) {
    var retryAfterInSeconds = Number(headerValue);

    if (Number.isNaN(retryAfterInSeconds)) {
      return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);
    } else {
      return retryAfterInSeconds * 1000;
    }
  };

  ThrottlingRetryPolicy.parseDateRetryAfterHeader = function (headerValue) {
    try {
      var now = Date.now();
      var date = Date.parse(headerValue);
      var diff = date - now;
      return Number.isNaN(diff) ? undefined : diff;
    } catch (error) {
      return undefined;
    }
  };

  return ThrottlingRetryPolicy;
}(_requestPolicy.BaseRequestPolicy);

exports.ThrottlingRetryPolicy = ThrottlingRetryPolicy;
},{"tslib":"CvJj","./requestPolicy":"ggtJ","../util/constants":"o95E","../util/utils":"DVp2"}],"ZJzR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.signingPolicy = signingPolicy;
exports.SigningPolicy = void 0;

var _tslib = require("tslib");

var _requestPolicy = require("./requestPolicy");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function signingPolicy(authenticationProvider) {
  return {
    create: function (nextPolicy, options) {
      return new SigningPolicy(nextPolicy, options, authenticationProvider);
    }
  };
}

var SigningPolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(SigningPolicy, _super);

  function SigningPolicy(nextPolicy, options, authenticationProvider) {
    var _this = _super.call(this, nextPolicy, options) || this;

    _this.authenticationProvider = authenticationProvider;
    return _this;
  }

  SigningPolicy.prototype.signRequest = function (request) {
    return this.authenticationProvider.signRequest(request);
  };

  SigningPolicy.prototype.sendRequest = function (request) {
    var _this = this;

    return this.signRequest(request).then(function (nextRequest) {
      return _this._nextPolicy.sendRequest(nextRequest);
    });
  };

  return SigningPolicy;
}(_requestPolicy.BaseRequestPolicy);

exports.SigningPolicy = SigningPolicy;
},{"tslib":"CvJj","./requestPolicy":"ggtJ"}],"V02X":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.keepAlivePolicy = keepAlivePolicy;
exports.KeepAlivePolicy = exports.DefaultKeepAliveOptions = void 0;

var _tslib = require("tslib");

var _requestPolicy = require("./requestPolicy");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var DefaultKeepAliveOptions = {
  enable: true
};
exports.DefaultKeepAliveOptions = DefaultKeepAliveOptions;

function keepAlivePolicy(keepAliveOptions) {
  return {
    create: function (nextPolicy, options) {
      return new KeepAlivePolicy(nextPolicy, options, keepAliveOptions || DefaultKeepAliveOptions);
    }
  };
}
/**
 * KeepAlivePolicy is a policy used to control keep alive settings for every request.
 */


var KeepAlivePolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(KeepAlivePolicy, _super);
  /**
   * Creates an instance of KeepAlivePolicy.
   *
   * @param nextPolicy -
   * @param options -
   * @param keepAliveOptions -
   */

  function KeepAlivePolicy(nextPolicy, options, keepAliveOptions) {
    var _this = _super.call(this, nextPolicy, options) || this;

    _this.keepAliveOptions = keepAliveOptions;
    return _this;
  }
  /**
   * Sends out request.
   *
   * @param request -
   * @returns
   */


  KeepAlivePolicy.prototype.sendRequest = function (request) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      return (0, _tslib.__generator)(this, function (_a) {
        request.keepAlive = this.keepAliveOptions.enable;
        return [2
        /*return*/
        , this._nextPolicy.sendRequest(request)];
      });
    });
  };

  return KeepAlivePolicy;
}(_requestPolicy.BaseRequestPolicy);

exports.KeepAlivePolicy = KeepAlivePolicy;
},{"tslib":"CvJj","./requestPolicy":"ggtJ"}],"Y5SG":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"Icr5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"mtqD":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultGetter = void 0;
/**
 * Default getter which just does a simple property access. Returns
 * undefined if the key is not set.
 *
 * @param carrier
 * @param key
 */

function defaultGetter(carrier, key) {
  return carrier[key];
}

exports.defaultGetter = defaultGetter;
},{}],"SwHY":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NOOP_HTTP_TEXT_PROPAGATOR = exports.NoopHttpTextPropagator = void 0;
/**
 * No-op implementations of {@link HttpTextPropagator}.
 */

var NoopHttpTextPropagator =
/** @class */
function () {
  function NoopHttpTextPropagator() {}
  /** Noop inject function does nothing */


  NoopHttpTextPropagator.prototype.inject = function (context, carrier, setter) {};
  /** Noop extract function does nothing and returns the input context */


  NoopHttpTextPropagator.prototype.extract = function (context, carrier, getter) {
    return context;
  };

  return NoopHttpTextPropagator;
}();

exports.NoopHttpTextPropagator = NoopHttpTextPropagator;
exports.NOOP_HTTP_TEXT_PROPAGATOR = new NoopHttpTextPropagator();
},{}],"sZnr":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultSetter = void 0;
/**
 * Default setter which sets value via direct property access
 *
 * @param carrier
 * @param key
 */

function defaultSetter(carrier, key, value) {
  carrier[key] = value;
}

exports.defaultSetter = defaultSetter;
},{}],"aVeZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EntryTtl = void 0;
/**
 * EntryTtl is an integer that represents number of hops an entry can propagate.
 *
 * For now, ONLY special values (0 and -1) are supported.
 */

var EntryTtl;

(function (EntryTtl) {
  /**
   * NO_PROPAGATION is considered to have local context and is used within the
   * process it created.
   */
  EntryTtl[EntryTtl["NO_PROPAGATION"] = 0] = "NO_PROPAGATION";
  /** UNLIMITED_PROPAGATION can propagate unlimited hops. */

  EntryTtl[EntryTtl["UNLIMITED_PROPAGATION"] = -1] = "UNLIMITED_PROPAGATION";
})(EntryTtl = exports.EntryTtl || (exports.EntryTtl = {}));
},{}],"POuM":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ValueType = void 0;
/** The Type of value. It describes how the data is reported. */

var ValueType;

(function (ValueType) {
  ValueType[ValueType["INT"] = 0] = "INT";
  ValueType[ValueType["DOUBLE"] = 1] = "DOUBLE";
})(ValueType = exports.ValueType || (exports.ValueType = {}));
},{}],"dMTv":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __extends = this && this.__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NOOP_BATCH_OBSERVER_METRIC = exports.NOOP_SUM_OBSERVER_METRIC = exports.NOOP_UP_DOWN_SUM_OBSERVER_METRIC = exports.NOOP_VALUE_OBSERVER_METRIC = exports.NOOP_BOUND_BASE_OBSERVER = exports.NOOP_VALUE_RECORDER_METRIC = exports.NOOP_BOUND_VALUE_RECORDER = exports.NOOP_COUNTER_METRIC = exports.NOOP_BOUND_COUNTER = exports.NOOP_METER = exports.NoopBoundBaseObserver = exports.NoopBoundValueRecorder = exports.NoopBoundCounter = exports.NoopBatchObserverMetric = exports.NoopBaseObserverMetric = exports.NoopValueRecorderMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = void 0;
/**
 * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses
 * constant NoopMetrics for all of its methods.
 */

var NoopMeter =
/** @class */
function () {
  function NoopMeter() {}
  /**
   * Returns constant noop value recorder.
   * @param name the name of the metric.
   * @param [options] the metric options.
   */


  NoopMeter.prototype.createValueRecorder = function (name, options) {
    return exports.NOOP_VALUE_RECORDER_METRIC;
  };
  /**
   * Returns a constant noop counter.
   * @param name the name of the metric.
   * @param [options] the metric options.
   */


  NoopMeter.prototype.createCounter = function (name, options) {
    return exports.NOOP_COUNTER_METRIC;
  };
  /**
   * Returns a constant noop UpDownCounter.
   * @param name the name of the metric.
   * @param [options] the metric options.
   */


  NoopMeter.prototype.createUpDownCounter = function (name, options) {
    return exports.NOOP_COUNTER_METRIC;
  };
  /**
   * Returns constant noop value observer.
   * @param name the name of the metric.
   * @param [options] the metric options.
   * @param [callback] the value observer callback
   */


  NoopMeter.prototype.createValueObserver = function (name, options, callback) {
    return exports.NOOP_VALUE_OBSERVER_METRIC;
  };
  /**
   * Returns constant noop batch observer.
   * @param name the name of the metric.
   * @param callback the batch observer callback
   */


  NoopMeter.prototype.createBatchObserver = function (name, callback) {
    return exports.NOOP_BATCH_OBSERVER_METRIC;
  };

  return NoopMeter;
}();

exports.NoopMeter = NoopMeter;

var NoopMetric =
/** @class */
function () {
  function NoopMetric(instrument) {
    this._instrument = instrument;
  }
  /**
   * Returns a Bound Instrument associated with specified Labels.
   * It is recommended to keep a reference to the Bound Instrument instead of
   * always calling this method for every operations.
   * @param labels key-values pairs that are associated with a specific metric
   *     that you want to record.
   */


  NoopMetric.prototype.bind = function (labels) {
    return this._instrument;
  };
  /**
   * Removes the Binding from the metric, if it is present.
   * @param labels key-values pairs that are associated with a specific metric.
   */


  NoopMetric.prototype.unbind = function (labels) {
    return;
  };
  /**
   * Clears all timeseries from the Metric.
   */


  NoopMetric.prototype.clear = function () {
    return;
  };

  return NoopMetric;
}();

exports.NoopMetric = NoopMetric;

var NoopCounterMetric =
/** @class */
function (_super) {
  __extends(NoopCounterMetric, _super);

  function NoopCounterMetric() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  NoopCounterMetric.prototype.add = function (value, labels) {
    this.bind(labels).add(value);
  };

  return NoopCounterMetric;
}(NoopMetric);

exports.NoopCounterMetric = NoopCounterMetric;

var NoopValueRecorderMetric =
/** @class */
function (_super) {
  __extends(NoopValueRecorderMetric, _super);

  function NoopValueRecorderMetric() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  NoopValueRecorderMetric.prototype.record = function (value, labels, correlationContext, spanContext) {
    if (typeof correlationContext === 'undefined') {
      this.bind(labels).record(value);
    } else if (typeof spanContext === 'undefined') {
      this.bind(labels).record(value, correlationContext);
    } else {
      this.bind(labels).record(value, correlationContext, spanContext);
    }
  };

  return NoopValueRecorderMetric;
}(NoopMetric);

exports.NoopValueRecorderMetric = NoopValueRecorderMetric;

var NoopBaseObserverMetric =
/** @class */
function (_super) {
  __extends(NoopBaseObserverMetric, _super);

  function NoopBaseObserverMetric() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  NoopBaseObserverMetric.prototype.observation = function () {
    return {
      observer: this,
      value: 0
    };
  };

  return NoopBaseObserverMetric;
}(NoopMetric);

exports.NoopBaseObserverMetric = NoopBaseObserverMetric;

var NoopBatchObserverMetric =
/** @class */
function (_super) {
  __extends(NoopBatchObserverMetric, _super);

  function NoopBatchObserverMetric() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return NoopBatchObserverMetric;
}(NoopMetric);

exports.NoopBatchObserverMetric = NoopBatchObserverMetric;

var NoopBoundCounter =
/** @class */
function () {
  function NoopBoundCounter() {}

  NoopBoundCounter.prototype.add = function (value) {
    return;
  };

  return NoopBoundCounter;
}();

exports.NoopBoundCounter = NoopBoundCounter;

var NoopBoundValueRecorder =
/** @class */
function () {
  function NoopBoundValueRecorder() {}

  NoopBoundValueRecorder.prototype.record = function (value, correlationContext, spanContext) {
    return;
  };

  return NoopBoundValueRecorder;
}();

exports.NoopBoundValueRecorder = NoopBoundValueRecorder;

var NoopBoundBaseObserver =
/** @class */
function () {
  function NoopBoundBaseObserver() {}

  NoopBoundBaseObserver.prototype.update = function (value) {};

  return NoopBoundBaseObserver;
}();

exports.NoopBoundBaseObserver = NoopBoundBaseObserver;
exports.NOOP_METER = new NoopMeter();
exports.NOOP_BOUND_COUNTER = new NoopBoundCounter();
exports.NOOP_COUNTER_METRIC = new NoopCounterMetric(exports.NOOP_BOUND_COUNTER);
exports.NOOP_BOUND_VALUE_RECORDER = new NoopBoundValueRecorder();
exports.NOOP_VALUE_RECORDER_METRIC = new NoopValueRecorderMetric(exports.NOOP_BOUND_VALUE_RECORDER);
exports.NOOP_BOUND_BASE_OBSERVER = new NoopBoundBaseObserver();
exports.NOOP_VALUE_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);
exports.NOOP_UP_DOWN_SUM_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);
exports.NOOP_SUM_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);
exports.NOOP_BATCH_OBSERVER_METRIC = new NoopBatchObserverMetric();
},{}],"XBYZ":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = void 0;

var NoopMeter_1 = require("./NoopMeter");
/**
 * An implementation of the {@link MeterProvider} which returns an impotent Meter
 * for all calls to `getMeter`
 */


var NoopMeterProvider =
/** @class */
function () {
  function NoopMeterProvider() {}

  NoopMeterProvider.prototype.getMeter = function (_name, _version) {
    return NoopMeter_1.NOOP_METER;
  };

  return NoopMeterProvider;
}();

exports.NoopMeterProvider = NoopMeterProvider;
exports.NOOP_METER_PROVIDER = new NoopMeterProvider();
},{"./NoopMeter":"dMTv"}],"Fi3i":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TraceFlags = void 0;
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var TraceFlags;

(function (TraceFlags) {
  /** Represents no flag set. */
  TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
  /** Bit to represent whether trace is sampled in trace flags. */

  TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
},{}],"zLsY":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NOOP_SPAN = exports.NoopSpan = exports.INVALID_SPAN_ID = exports.INVALID_TRACE_ID = void 0;

var trace_flags_1 = require("./trace_flags");

exports.INVALID_TRACE_ID = '0';
exports.INVALID_SPAN_ID = '0';
var INVALID_SPAN_CONTEXT = {
  traceId: exports.INVALID_TRACE_ID,
  spanId: exports.INVALID_SPAN_ID,
  traceFlags: trace_flags_1.TraceFlags.NONE
};
/**
 * The NoopSpan is the default {@link Span} that is used when no Span
 * implementation is available. All operations are no-op including context
 * propagation.
 */

var NoopSpan =
/** @class */
function () {
  function NoopSpan(_spanContext) {
    if (_spanContext === void 0) {
      _spanContext = INVALID_SPAN_CONTEXT;
    }

    this._spanContext = _spanContext;
  } // Returns a SpanContext.


  NoopSpan.prototype.context = function () {
    return this._spanContext;
  }; // By default does nothing


  NoopSpan.prototype.setAttribute = function (key, value) {
    return this;
  }; // By default does nothing


  NoopSpan.prototype.setAttributes = function (attributes) {
    return this;
  }; // By default does nothing


  NoopSpan.prototype.addEvent = function (name, attributes) {
    return this;
  }; // By default does nothing


  NoopSpan.prototype.setStatus = function (status) {
    return this;
  }; // By default does nothing


  NoopSpan.prototype.updateName = function (name) {
    return this;
  }; // By default does nothing


  NoopSpan.prototype.end = function (endTime) {}; // isRecording always returns false for noopSpan.


  NoopSpan.prototype.isRecording = function () {
    return false;
  };

  return NoopSpan;
}();

exports.NoopSpan = NoopSpan;
exports.NOOP_SPAN = new NoopSpan();
},{"./trace_flags":"Fi3i"}],"Ch5C":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NOOP_TRACER = exports.NoopTracer = void 0;

var NoopSpan_1 = require("./NoopSpan");
/**
 * No-op implementations of {@link Tracer}.
 */


var NoopTracer =
/** @class */
function () {
  function NoopTracer() {}

  NoopTracer.prototype.getCurrentSpan = function () {
    return NoopSpan_1.NOOP_SPAN;
  }; // startSpan starts a noop span.


  NoopTracer.prototype.startSpan = function (name, options) {
    return NoopSpan_1.NOOP_SPAN;
  };

  NoopTracer.prototype.withSpan = function (span, fn) {
    return fn();
  };

  NoopTracer.prototype.bind = function (target, span) {
    return target;
  };

  return NoopTracer;
}();

exports.NoopTracer = NoopTracer;
exports.NOOP_TRACER = new NoopTracer();
},{"./NoopSpan":"zLsY"}],"Fp6n":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NOOP_TRACER_PROVIDER = exports.NoopTracerProvider = void 0;

var NoopTracer_1 = require("./NoopTracer");
/**
 * An implementation of the {@link TracerProvider} which returns an impotent
 * Tracer for all calls to `getTracer`.
 *
 * All operations are no-op.
 */


var NoopTracerProvider =
/** @class */
function () {
  function NoopTracerProvider() {}

  NoopTracerProvider.prototype.getTracer = function (_name, _version) {
    return NoopTracer_1.NOOP_TRACER;
  };

  return NoopTracerProvider;
}();

exports.NoopTracerProvider = NoopTracerProvider;
exports.NOOP_TRACER_PROVIDER = new NoopTracerProvider();
},{"./NoopTracer":"Ch5C"}],"kzZB":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SamplingDecision = void 0;
/**
 * A sampling decision that determines how a {@link Span} will be recorded
 * and collected.
 */

var SamplingDecision;

(function (SamplingDecision) {
  /**
   * `Span.isRecording() === false`, span will not be recorded and all events
   * and attributes will be dropped.
   */
  SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
  /**
   * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
   * MUST NOT be set.
   */

  SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
  /**
   * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
   * MUST be set.
   */

  SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
},{}],"PRuY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpanKind = void 0;
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var SpanKind;

(function (SpanKind) {
  /** Default value. Indicates that the span is used internally. */
  SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
  /**
   * Indicates that the span covers server-side handling of an RPC or other
   * remote request.
   */

  SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
  /**
   * Indicates that the span covers the client-side wrapper around an RPC or
   * other remote request.
   */

  SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
  /**
   * Indicates that the span describes producer sending a message to a
   * broker. Unlike client and server, there is no direct critical path latency
   * relationship between producer and consumer spans.
   */

  SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
  /**
   * Indicates that the span describes consumer receiving a message from a
   * broker. Unlike client and server, there is no direct critical path latency
   * relationship between producer and consumer spans.
   */

  SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
},{}],"dd5e":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CanonicalCode = void 0;
/**
 * An enumeration of canonical status codes.
 */

var CanonicalCode;

(function (CanonicalCode) {
  /**
   * Not an error; returned on success
   */
  CanonicalCode[CanonicalCode["OK"] = 0] = "OK";
  /**
   * The operation was cancelled (typically by the caller).
   */

  CanonicalCode[CanonicalCode["CANCELLED"] = 1] = "CANCELLED";
  /**
   * Unknown error.  An example of where this error may be returned is
   * if a status value received from another address space belongs to
   * an error-space that is not known in this address space.  Also
   * errors raised by APIs that do not return enough error information
   * may be converted to this error.
   */

  CanonicalCode[CanonicalCode["UNKNOWN"] = 2] = "UNKNOWN";
  /**
   * Client specified an invalid argument.  Note that this differs
   * from FAILED_PRECONDITION.  INVALID_ARGUMENT indicates arguments
   * that are problematic regardless of the state of the system
   * (e.g., a malformed file name).
   */

  CanonicalCode[CanonicalCode["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
  /**
   * Deadline expired before operation could complete.  For operations
   * that change the state of the system, this error may be returned
   * even if the operation has completed successfully.  For example, a
   * successful response from a server could have been delayed long
   * enough for the deadline to expire.
   */

  CanonicalCode[CanonicalCode["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
  /**
   * Some requested entity (e.g., file or directory) was not found.
   */

  CanonicalCode[CanonicalCode["NOT_FOUND"] = 5] = "NOT_FOUND";
  /**
   * Some entity that we attempted to create (e.g., file or directory)
   * already exists.
   */

  CanonicalCode[CanonicalCode["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
  /**
   * The caller does not have permission to execute the specified
   * operation.  PERMISSION_DENIED must not be used for rejections
   * caused by exhausting some resource (use RESOURCE_EXHAUSTED
   * instead for those errors).  PERMISSION_DENIED must not be
   * used if the caller can not be identified (use UNAUTHENTICATED
   * instead for those errors).
   */

  CanonicalCode[CanonicalCode["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
  /**
   * Some resource has been exhausted, perhaps a per-user quota, or
   * perhaps the entire file system is out of space.
   */

  CanonicalCode[CanonicalCode["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
  /**
   * Operation was rejected because the system is not in a state
   * required for the operation's execution.  For example, directory
   * to be deleted may be non-empty, an rmdir operation is applied to
   * a non-directory, etc.
   *
   * A litmus test that may help a service implementor in deciding
   * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
   *
   *  - Use UNAVAILABLE if the client can retry just the failing call.
   *  - Use ABORTED if the client should retry at a higher-level
   *    (e.g., restarting a read-modify-write sequence).
   *  - Use FAILED_PRECONDITION if the client should not retry until
   *    the system state has been explicitly fixed.  E.g., if an "rmdir"
   *    fails because the directory is non-empty, FAILED_PRECONDITION
   *    should be returned since the client should not retry unless
   *    they have first fixed up the directory by deleting files from it.
   *  - Use FAILED_PRECONDITION if the client performs conditional
   *    REST Get/Update/Delete on a resource and the resource on the
   *    server does not match the condition. E.g., conflicting
   *    read-modify-write on the same resource.
   */

  CanonicalCode[CanonicalCode["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
  /**
   * The operation was aborted, typically due to a concurrency issue
   * like sequencer check failures, transaction aborts, etc.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION,
   * ABORTED, and UNAVAILABLE.
   */

  CanonicalCode[CanonicalCode["ABORTED"] = 10] = "ABORTED";
  /**
   * Operation was attempted past the valid range.  E.g., seeking or
   * reading past end of file.
   *
   * Unlike INVALID_ARGUMENT, this error indicates a problem that may
   * be fixed if the system state changes. For example, a 32-bit file
   * system will generate INVALID_ARGUMENT if asked to read at an
   * offset that is not in the range [0,2^32-1], but it will generate
   * OUT_OF_RANGE if asked to read from an offset past the current
   * file size.
   *
   * There is a fair bit of overlap between FAILED_PRECONDITION and
   * OUT_OF_RANGE.  We recommend using OUT_OF_RANGE (the more specific
   * error) when it applies so that callers who are iterating through
   * a space can easily look for an OUT_OF_RANGE error to detect when
   * they are done.
   */

  CanonicalCode[CanonicalCode["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
  /**
   * Operation is not implemented or not supported/enabled in this service.
   */

  CanonicalCode[CanonicalCode["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
  /**
   * Internal errors.  Means some invariants expected by underlying
   * system has been broken.  If you see one of these errors,
   * something is very broken.
   */

  CanonicalCode[CanonicalCode["INTERNAL"] = 13] = "INTERNAL";
  /**
   * The service is currently unavailable.  This is a most likely a
   * transient condition and may be corrected by retrying with
   * a backoff.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION,
   * ABORTED, and UNAVAILABLE.
   */

  CanonicalCode[CanonicalCode["UNAVAILABLE"] = 14] = "UNAVAILABLE";
  /**
   * Unrecoverable data loss or corruption.
   */

  CanonicalCode[CanonicalCode["DATA_LOSS"] = 15] = "DATA_LOSS";
  /**
   * The request does not have valid authentication credentials for the
   * operation.
   */

  CanonicalCode[CanonicalCode["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
})(CanonicalCode = exports.CanonicalCode || (exports.CanonicalCode = {}));
},{}],"qY2D":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Context = void 0;
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Context =
/** @class */
function () {
  /**
   * Construct a new context which inherits values from an optional parent context.
   *
   * @param parentContext a context from which to inherit values
   */
  function Context(parentContext) {
    this._currentContext = parentContext ? new Map(parentContext) : new Map();
  }
  /** Get a key to uniquely identify a context value */


  Context.createKey = function (description) {
    return Symbol(description);
  };
  /**
   * Get a value from the context.
   *
   * @param key key which identifies a context value
   */


  Context.prototype.getValue = function (key) {
    return this._currentContext.get(key);
  };
  /**
   * Create a new context which inherits from this context and has
   * the given key set to the given value.
   *
   * @param key context key for which to set the value
   * @param value value to set for the given key
   */


  Context.prototype.setValue = function (key, value) {
    var context = new Context(this._currentContext);

    context._currentContext.set(key, value);

    return context;
  };
  /**
   * Return a new context which inherits from this context but does
   * not contain a value for the given key.
   *
   * @param key context key for which to clear a value
   */


  Context.prototype.deleteValue = function (key) {
    var context = new Context(this._currentContext);

    context._currentContext.delete(key);

    return context;
  };
  /** The root context is used as the default parent context when there is no active context */


  Context.ROOT_CONTEXT = new Context();
  /**
   * This is another identifier to the root context which allows developers to easily search the
   * codebase for direct uses of context which need to be removed in later PRs.
   *
   * It's existence is temporary and it should be removed when all references are fixed.
   */

  Context.TODO = Context.ROOT_CONTEXT;
  return Context;
}();

exports.Context = Context;
},{}],"Krwc":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NoopContextManager = void 0;

var context_1 = require("./context");

var NoopContextManager =
/** @class */
function () {
  function NoopContextManager() {}

  NoopContextManager.prototype.active = function () {
    return context_1.Context.ROOT_CONTEXT;
  };

  NoopContextManager.prototype.with = function (context, fn) {
    return fn();
  };

  NoopContextManager.prototype.bind = function (target, context) {
    return target;
  };

  NoopContextManager.prototype.enable = function () {
    return this;
  };

  NoopContextManager.prototype.disable = function () {
    return this;
  };

  return NoopContextManager;
}();

exports.NoopContextManager = NoopContextManager;
},{"./context":"qY2D"}],"TuHz":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

__exportStar(require("./types"), exports);

__exportStar(require("./context"), exports);

__exportStar(require("./NoopContextManager"), exports);
},{"./types":"Y5SG","./context":"qY2D","./NoopContextManager":"Krwc"}],"OlV1":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._globalThis = void 0;
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef

exports._globalThis = typeof globalThis === 'object' ? globalThis : window;
},{}],"W2U1":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

__exportStar(require("./globalThis"), exports);
},{"./globalThis":"OlV1"}],"lpO7":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.API_BACKWARDS_COMPATIBILITY_VERSION = exports.makeGetter = exports._global = exports.GLOBAL_TRACE_API_KEY = exports.GLOBAL_PROPAGATION_API_KEY = exports.GLOBAL_METRICS_API_KEY = exports.GLOBAL_CONTEXT_MANAGER_API_KEY = void 0;

var platform_1 = require("../platform");

exports.GLOBAL_CONTEXT_MANAGER_API_KEY = Symbol.for('io.opentelemetry.js.api.context');
exports.GLOBAL_METRICS_API_KEY = Symbol.for('io.opentelemetry.js.api.metrics');
exports.GLOBAL_PROPAGATION_API_KEY = Symbol.for('io.opentelemetry.js.api.propagation');
exports.GLOBAL_TRACE_API_KEY = Symbol.for('io.opentelemetry.js.api.trace');
exports._global = platform_1._globalThis;
/**
 * Make a function which accepts a version integer and returns the instance of an API if the version
 * is compatible, or a fallback version (usually NOOP) if it is not.
 *
 * @param requiredVersion Backwards compatibility version which is required to return the instance
 * @param instance Instance which should be returned if the required version is compatible
 * @param fallback Fallback instance, usually NOOP, which will be returned if the required version is not compatible
 */

function makeGetter(requiredVersion, instance, fallback) {
  return function (version) {
    return version === requiredVersion ? instance : fallback;
  };
}

exports.makeGetter = makeGetter;
/**
 * A number which should be incremented each time a backwards incompatible
 * change is made to the API. This number is used when an API package
 * attempts to access the global API to ensure it is getting a compatible
 * version. If the global API is not compatible with the API package
 * attempting to get it, a NOOP API implementation will be returned.
 */

exports.API_BACKWARDS_COMPATIBILITY_VERSION = 0;
},{"../platform":"W2U1"}],"MIIU":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContextAPI = void 0;

var context_base_1 = require("@opentelemetry/context-base");

var global_utils_1 = require("./global-utils");

var NOOP_CONTEXT_MANAGER = new context_base_1.NoopContextManager();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Context API
 */

var ContextAPI =
/** @class */
function () {
  /** Empty private constructor prevents end users from constructing a new instance of the API */
  function ContextAPI() {}
  /** Get the singleton instance of the Context API */


  ContextAPI.getInstance = function () {
    if (!this._instance) {
      this._instance = new ContextAPI();
    }

    return this._instance;
  };
  /**
   * Set the current context manager. Returns the initialized context manager
   */


  ContextAPI.prototype.setGlobalContextManager = function (contextManager) {
    if (global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY]) {
      // global context manager has already been set
      return this._getContextManager();
    }

    global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, contextManager, NOOP_CONTEXT_MANAGER);
    return contextManager;
  };
  /**
   * Get the currently active context
   */


  ContextAPI.prototype.active = function () {
    return this._getContextManager().active();
  };
  /**
   * Execute a function with an active context
   *
   * @param context context to be active during function execution
   * @param fn function to execute in a context
   */


  ContextAPI.prototype.with = function (context, fn) {
    return this._getContextManager().with(context, fn);
  };
  /**
   * Bind a context to a target function or event emitter
   *
   * @param target function or event emitter to bind
   * @param context context to bind to the event emitter or function. Defaults to the currently active context
   */


  ContextAPI.prototype.bind = function (target, context) {
    if (context === void 0) {
      context = this.active();
    }

    return this._getContextManager().bind(target, context);
  };

  ContextAPI.prototype._getContextManager = function () {
    var _a, _b;

    return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NOOP_CONTEXT_MANAGER;
  };
  /** Disable and remove the global context manager */


  ContextAPI.prototype.disable = function () {
    this._getContextManager().disable();

    delete global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY];
  };

  return ContextAPI;
}();

exports.ContextAPI = ContextAPI;
},{"@opentelemetry/context-base":"TuHz","./global-utils":"lpO7"}],"ZKIZ":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TraceAPI = void 0;

var NoopTracerProvider_1 = require("../trace/NoopTracerProvider");

var global_utils_1 = require("./global-utils");
/**
 * Singleton object which represents the entry point to the OpenTelemetry Tracing API
 */


var TraceAPI =
/** @class */
function () {
  /** Empty private constructor prevents end users from constructing a new instance of the API */
  function TraceAPI() {}
  /** Get the singleton instance of the Trace API */


  TraceAPI.getInstance = function () {
    if (!this._instance) {
      this._instance = new TraceAPI();
    }

    return this._instance;
  };
  /**
   * Set the current global tracer. Returns the initialized global tracer provider
   */


  TraceAPI.prototype.setGlobalTracerProvider = function (provider) {
    if (global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY]) {
      // global tracer provider has already been set
      return this.getTracerProvider();
    }

    global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopTracerProvider_1.NOOP_TRACER_PROVIDER);
    return this.getTracerProvider();
  };
  /**
   * Returns the global tracer provider.
   */


  TraceAPI.prototype.getTracerProvider = function () {
    var _a, _b;

    return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NoopTracerProvider_1.NOOP_TRACER_PROVIDER;
  };
  /**
   * Returns a tracer from the global tracer provider.
   */


  TraceAPI.prototype.getTracer = function (name, version) {
    return this.getTracerProvider().getTracer(name, version);
  };
  /** Remove the global tracer provider */


  TraceAPI.prototype.disable = function () {
    delete global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY];
  };

  return TraceAPI;
}();

exports.TraceAPI = TraceAPI;
},{"../trace/NoopTracerProvider":"Fp6n","./global-utils":"lpO7"}],"wXod":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MetricsAPI = void 0;

var NoopMeterProvider_1 = require("../metrics/NoopMeterProvider");

var global_utils_1 = require("./global-utils");
/**
 * Singleton object which represents the entry point to the OpenTelemetry Metrics API
 */


var MetricsAPI =
/** @class */
function () {
  /** Empty private constructor prevents end users from constructing a new instance of the API */
  function MetricsAPI() {}
  /** Get the singleton instance of the Metrics API */


  MetricsAPI.getInstance = function () {
    if (!this._instance) {
      this._instance = new MetricsAPI();
    }

    return this._instance;
  };
  /**
   * Set the current global meter. Returns the initialized global meter provider.
   */


  MetricsAPI.prototype.setGlobalMeterProvider = function (provider) {
    if (global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY]) {
      // global meter provider has already been set
      return this.getMeterProvider();
    }

    global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopMeterProvider_1.NOOP_METER_PROVIDER);
    return provider;
  };
  /**
   * Returns the global meter provider.
   */


  MetricsAPI.prototype.getMeterProvider = function () {
    var _a, _b;

    return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NoopMeterProvider_1.NOOP_METER_PROVIDER;
  };
  /**
   * Returns a meter from the global meter provider.
   */


  MetricsAPI.prototype.getMeter = function (name, version) {
    return this.getMeterProvider().getMeter(name, version);
  };
  /** Remove the global meter provider */


  MetricsAPI.prototype.disable = function () {
    delete global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY];
  };

  return MetricsAPI;
}();

exports.MetricsAPI = MetricsAPI;
},{"../metrics/NoopMeterProvider":"XBYZ","./global-utils":"lpO7"}],"V4bS":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PropagationAPI = void 0;

var getter_1 = require("../context/propagation/getter");

var NoopHttpTextPropagator_1 = require("../context/propagation/NoopHttpTextPropagator");

var setter_1 = require("../context/propagation/setter");

var context_1 = require("./context");

var global_utils_1 = require("./global-utils");

var contextApi = context_1.ContextAPI.getInstance();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Propagation API
 */

var PropagationAPI =
/** @class */
function () {
  /** Empty private constructor prevents end users from constructing a new instance of the API */
  function PropagationAPI() {}
  /** Get the singleton instance of the Propagator API */


  PropagationAPI.getInstance = function () {
    if (!this._instance) {
      this._instance = new PropagationAPI();
    }

    return this._instance;
  };
  /**
   * Set the current propagator. Returns the initialized propagator
   */


  PropagationAPI.prototype.setGlobalPropagator = function (propagator) {
    if (global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY]) {
      // global propagator has already been set
      return this._getGlobalPropagator();
    }

    global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, propagator, NoopHttpTextPropagator_1.NOOP_HTTP_TEXT_PROPAGATOR);
    return propagator;
  };
  /**
   * Inject context into a carrier to be propagated inter-process
   *
   * @param carrier carrier to inject context into
   * @param setter Function used to set values on the carrier
   * @param context Context carrying tracing data to inject. Defaults to the currently active context.
   */


  PropagationAPI.prototype.inject = function (carrier, setter, context) {
    if (setter === void 0) {
      setter = setter_1.defaultSetter;
    }

    if (context === void 0) {
      context = contextApi.active();
    }

    return this._getGlobalPropagator().inject(context, carrier, setter);
  };
  /**
   * Extract context from a carrier
   *
   * @param carrier Carrier to extract context from
   * @param getter Function used to extract keys from a carrier
   * @param context Context which the newly created context will inherit from. Defaults to the currently active context.
   */


  PropagationAPI.prototype.extract = function (carrier, getter, context) {
    if (getter === void 0) {
      getter = getter_1.defaultGetter;
    }

    if (context === void 0) {
      context = contextApi.active();
    }

    return this._getGlobalPropagator().extract(context, carrier, getter);
  };
  /** Remove the global propagator */


  PropagationAPI.prototype.disable = function () {
    delete global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY];
  };

  PropagationAPI.prototype._getGlobalPropagator = function () {
    var _a, _b;

    return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NoopHttpTextPropagator_1.NOOP_HTTP_TEXT_PROPAGATOR;
  };

  return PropagationAPI;
}();

exports.PropagationAPI = PropagationAPI;
},{"../context/propagation/getter":"mtqD","../context/propagation/NoopHttpTextPropagator":"SwHY","../context/propagation/setter":"sZnr","./context":"MIIU","./global-utils":"lpO7"}],"fNAU":[function(require,module,exports) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.propagation = exports.metrics = exports.trace = exports.context = void 0;

__exportStar(require("./common/Logger"), exports);

__exportStar(require("./common/Time"), exports);

__exportStar(require("./context/propagation/getter"), exports);

__exportStar(require("./context/propagation/HttpTextPropagator"), exports);

__exportStar(require("./context/propagation/NoopHttpTextPropagator"), exports);

__exportStar(require("./context/propagation/setter"), exports);

__exportStar(require("./correlation_context/CorrelationContext"), exports);

__exportStar(require("./correlation_context/EntryValue"), exports);

__exportStar(require("./metrics/BatchObserverResult"), exports);

__exportStar(require("./metrics/BoundInstrument"), exports);

__exportStar(require("./metrics/Meter"), exports);

__exportStar(require("./metrics/MeterProvider"), exports);

__exportStar(require("./metrics/Metric"), exports);

__exportStar(require("./metrics/NoopMeter"), exports);

__exportStar(require("./metrics/NoopMeterProvider"), exports);

__exportStar(require("./metrics/Observation"), exports);

__exportStar(require("./metrics/ObserverResult"), exports);

__exportStar(require("./trace/attributes"), exports);

__exportStar(require("./trace/Event"), exports);

__exportStar(require("./trace/instrumentation/Plugin"), exports);

__exportStar(require("./trace/link_context"), exports);

__exportStar(require("./trace/link"), exports);

__exportStar(require("./trace/NoopSpan"), exports);

__exportStar(require("./trace/NoopTracer"), exports);

__exportStar(require("./trace/NoopTracerProvider"), exports);

__exportStar(require("./trace/Sampler"), exports);

__exportStar(require("./trace/SamplingResult"), exports);

__exportStar(require("./trace/span_context"), exports);

__exportStar(require("./trace/span_kind"), exports);

__exportStar(require("./trace/span"), exports);

__exportStar(require("./trace/SpanOptions"), exports);

__exportStar(require("./trace/status"), exports);

__exportStar(require("./trace/TimedEvent"), exports);

__exportStar(require("./trace/trace_flags"), exports);

__exportStar(require("./trace/trace_state"), exports);

__exportStar(require("./trace/tracer_provider"), exports);

__exportStar(require("./trace/tracer"), exports);

var context_base_1 = require("@opentelemetry/context-base");

Object.defineProperty(exports, "Context", {
  enumerable: true,
  get: function () {
    return context_base_1.Context;
  }
});

var context_1 = require("./api/context");
/** Entrypoint for context API */


exports.context = context_1.ContextAPI.getInstance();

var trace_1 = require("./api/trace");
/** Entrypoint for trace API */


exports.trace = trace_1.TraceAPI.getInstance();

var metrics_1 = require("./api/metrics");
/** Entrypoint for metrics API */


exports.metrics = metrics_1.MetricsAPI.getInstance();

var propagation_1 = require("./api/propagation");
/** Entrypoint for propagation API */


exports.propagation = propagation_1.PropagationAPI.getInstance();
exports.default = {
  trace: exports.trace,
  metrics: exports.metrics,
  context: exports.context,
  propagation: exports.propagation
};
},{"./common/Logger":"Y5SG","./common/Time":"Icr5","./context/propagation/getter":"mtqD","./context/propagation/HttpTextPropagator":"Y5SG","./context/propagation/NoopHttpTextPropagator":"SwHY","./context/propagation/setter":"sZnr","./correlation_context/CorrelationContext":"Y5SG","./correlation_context/EntryValue":"aVeZ","./metrics/BatchObserverResult":"Y5SG","./metrics/BoundInstrument":"Y5SG","./metrics/Meter":"Y5SG","./metrics/MeterProvider":"Y5SG","./metrics/Metric":"POuM","./metrics/NoopMeter":"dMTv","./metrics/NoopMeterProvider":"XBYZ","./metrics/Observation":"Y5SG","./metrics/ObserverResult":"Y5SG","./trace/attributes":"Icr5","./trace/Event":"Y5SG","./trace/instrumentation/Plugin":"Y5SG","./trace/link_context":"Y5SG","./trace/link":"Y5SG","./trace/NoopSpan":"zLsY","./trace/NoopTracer":"Ch5C","./trace/NoopTracerProvider":"Fp6n","./trace/Sampler":"Y5SG","./trace/SamplingResult":"kzZB","./trace/span_context":"Y5SG","./trace/span_kind":"PRuY","./trace/span":"Y5SG","./trace/SpanOptions":"Y5SG","./trace/status":"dd5e","./trace/TimedEvent":"Y5SG","./trace/trace_flags":"Fi3i","./trace/trace_state":"Icr5","./trace/tracer_provider":"Y5SG","./trace/tracer":"Y5SG","@opentelemetry/context-base":"TuHz","./api/context":"MIIU","./api/trace":"ZKIZ","./api/metrics":"wXod","./api/propagation":"V4bS"}],"M998":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NoOpSpan = void 0;

var _api = require("@opentelemetry/api");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * A no-op implementation of Span that can safely be used without side-effects.
 */
var NoOpSpan =
/** @class */
function () {
  function NoOpSpan() {}
  /**
   * Returns the SpanContext associated with this Span.
   */


  NoOpSpan.prototype.context = function () {
    return {
      spanId: "",
      traceId: "",
      traceFlags: _api.TraceFlags.NONE
    };
  };
  /**
   * Marks the end of Span execution.
   * @param _endTime The time to use as the Span's end time. Defaults to
   * the current time.
   */


  NoOpSpan.prototype.end = function (_endTime) {
    /* Noop */
  };
  /**
   * Sets an attribute on the Span
   * @param _key the attribute key
   * @param _value the attribute value
   */


  NoOpSpan.prototype.setAttribute = function (_key, _value) {
    return this;
  };
  /**
   * Sets attributes on the Span
   * @param _attributes the attributes to add
   */


  NoOpSpan.prototype.setAttributes = function (_attributes) {
    return this;
  };
  /**
   * Adds an event to the Span
   * @param _name The name of the event
   * @param _attributes The associated attributes to add for this event
   */


  NoOpSpan.prototype.addEvent = function (_name, _attributes) {
    return this;
  };
  /**
   * Sets a status on the span. Overrides the default of CanonicalCode.OK.
   * @param _status The status to set.
   */


  NoOpSpan.prototype.setStatus = function (_status) {
    return this;
  };
  /**
   * Updates the name of the Span
   * @param _name the new Span name
   */


  NoOpSpan.prototype.updateName = function (_name) {
    return this;
  };
  /**
   * Returns whether this span will be recorded
   */


  NoOpSpan.prototype.isRecording = function () {
    return false;
  };

  return NoOpSpan;
}();

exports.NoOpSpan = NoOpSpan;
},{"@opentelemetry/api":"fNAU"}],"tFNs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NoOpTracer = void 0;

var _noOpSpan = require("./noOpSpan");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * A no-op implementation of Tracer that can be used when tracing
 * is disabled.
 */
var NoOpTracer =
/** @class */
function () {
  function NoOpTracer() {}
  /**
   * Starts a new Span.
   * @param _name The name of the span.
   * @param _options The SpanOptions used during Span creation.
   */


  NoOpTracer.prototype.startSpan = function (_name, _options) {
    return new _noOpSpan.NoOpSpan();
  };
  /**
   * Returns the current Span from the current context, if available.
   */


  NoOpTracer.prototype.getCurrentSpan = function () {
    return new _noOpSpan.NoOpSpan();
  };
  /**
   * Executes the given function within the context provided by a Span.
   * @param _span The span that provides the context.
   * @param fn The function to be executed.
   */


  NoOpTracer.prototype.withSpan = function (_span, fn) {
    return fn();
  };
  /**
   * Bind a Span as the target's scope
   * @param target An object to bind the scope.
   * @param _span A specific Span to use. Otherwise, use the current one.
   */


  NoOpTracer.prototype.bind = function (target, _span) {
    return target;
  };

  return NoOpTracer;
}();

exports.NoOpTracer = NoOpTracer;
},{"./noOpSpan":"M998"}],"F6eq":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGlobalObject = getGlobalObject;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function getGlobalObject() {
  return self;
}
},{}],"QwY5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCache = getCache;

var _global = require("./global");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// V1 = OpenTelemetry 0.1
// V2 = OpenTelemetry 0.2
// V3 = OpenTelemetry 0.6.1
var GLOBAL_TRACER_VERSION = 3; // preview5 shipped with @azure/core-tracing.tracerCache
// and didn't have smart detection for collisions

var GLOBAL_TRACER_SYMBOL = Symbol.for("@azure/core-tracing.tracerCache2");
var cache;

function loadTracerCache() {
  var globalObj = (0, _global.getGlobalObject)();
  var existingCache = globalObj[GLOBAL_TRACER_SYMBOL];
  var setGlobalCache = true;

  if (existingCache) {
    if (existingCache.version === GLOBAL_TRACER_VERSION) {
      cache = existingCache;
    } else {
      setGlobalCache = false;

      if (existingCache.tracer) {
        throw new Error("Two incompatible versions of @azure/core-tracing have been loaded.\n          This library is " + GLOBAL_TRACER_VERSION + ", existing is " + existingCache.version + ".");
      }
    }
  }

  if (!cache) {
    cache = {
      tracer: undefined,
      version: GLOBAL_TRACER_VERSION
    };
  }

  if (setGlobalCache) {
    globalObj[GLOBAL_TRACER_SYMBOL] = cache;
  }
}

function getCache() {
  if (!cache) {
    loadTracerCache();
  }

  return cache;
}
},{"./global":"F6eq"}],"yFrR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setTracer = setTracer;
exports.getTracer = getTracer;

var _noOpTracer = require("./tracers/noop/noOpTracer");

var _cache = require("./utils/cache");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var defaultTracer;

function getDefaultTracer() {
  if (!defaultTracer) {
    defaultTracer = new _noOpTracer.NoOpTracer();
  }

  return defaultTracer;
}
/**
 * Sets the global tracer, enabling tracing for the Azure SDK.
 * @param tracer An OpenTelemetry Tracer instance.
 */


function setTracer(tracer) {
  var cache = (0, _cache.getCache)();
  cache.tracer = tracer;
}
/**
 * Retrieves the active tracer, or returns a
 * no-op implementation if one is not set.
 */


function getTracer() {
  var cache = (0, _cache.getCache)();

  if (!cache.tracer) {
    return getDefaultTracer();
  }

  return cache.tracer;
}
},{"./tracers/noop/noOpTracer":"tFNs","./utils/cache":"QwY5"}],"kV0q":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OpenCensusTraceStateWrapper = void 0;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @ignore
 * @internal
 */
var OpenCensusTraceStateWrapper =
/** @class */
function () {
  function OpenCensusTraceStateWrapper(state) {
    this._state = state;
  }

  OpenCensusTraceStateWrapper.prototype.get = function (_key) {
    throw new Error("Method not implemented.");
  };

  OpenCensusTraceStateWrapper.prototype.set = function (_key, _value) {
    throw new Error("Method not implemented.");
  };

  OpenCensusTraceStateWrapper.prototype.unset = function (_key) {
    throw new Error("Method not implemented");
  };

  OpenCensusTraceStateWrapper.prototype.serialize = function () {
    return this._state || "";
  };

  return OpenCensusTraceStateWrapper;
}();

exports.OpenCensusTraceStateWrapper = OpenCensusTraceStateWrapper;
},{}],"Ff0U":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OpenCensusSpanWrapper = void 0;

var _openCensusTraceStateWrapper = require("./openCensusTraceStateWrapper");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function isWrappedSpan(span) {
  return !!span && span.getWrappedSpan !== undefined;
}

function isTracer(tracerOrSpan) {
  return tracerOrSpan.getWrappedTracer !== undefined;
}
/**
 * An implementation of OpenTelemetry Span that wraps an OpenCensus Span.
 */


var OpenCensusSpanWrapper =
/** @class */
function () {
  function OpenCensusSpanWrapper(tracerOrSpan, name, options) {
    if (name === void 0) {
      name = "";
    }

    if (options === void 0) {
      options = {};
    }

    if (isTracer(tracerOrSpan)) {
      var parent = isWrappedSpan(options.parent) ? options.parent.getWrappedSpan() : undefined;
      this._span = tracerOrSpan.getWrappedTracer().startChildSpan({
        name: name,
        childOf: parent
      });

      this._span.start();

      if (options.links) {
        for (var _i = 0, _a = options.links; _i < _a.length; _i++) {
          var link = _a[_i]; // Since there is no way to set the link relationship, leave it as Unspecified.

          this._span.addLink(link.context.traceId, link.context.spanId, 0
          /* LinkType.UNSPECIFIED */
          , link.attributes);
        }
      }
    } else {
      this._span = tracerOrSpan;
    }
  }
  /**
   * The underlying OpenCensus Span
   */


  OpenCensusSpanWrapper.prototype.getWrappedSpan = function () {
    return this._span;
  };
  /**
   * Marks the end of Span execution.
   * @param endTime The time to use as the Span's end time. Defaults to
   * the current time.
   */


  OpenCensusSpanWrapper.prototype.end = function (_endTime) {
    this._span.end();
  };
  /**
   * Returns the SpanContext associated with this Span.
   */


  OpenCensusSpanWrapper.prototype.context = function () {
    var openCensusSpanContext = this._span.spanContext;
    return {
      spanId: openCensusSpanContext.spanId,
      traceId: openCensusSpanContext.traceId,
      traceFlags: openCensusSpanContext.options,
      traceState: new _openCensusTraceStateWrapper.OpenCensusTraceStateWrapper(openCensusSpanContext.traceState)
    };
  };
  /**
   * Sets an attribute on the Span
   * @param key the attribute key
   * @param value the attribute value
   */


  OpenCensusSpanWrapper.prototype.setAttribute = function (key, value) {
    this._span.addAttribute(key, value);

    return this;
  };
  /**
   * Sets attributes on the Span
   * @param attributes the attributes to add
   */


  OpenCensusSpanWrapper.prototype.setAttributes = function (attributes) {
    this._span.attributes = attributes;
    return this;
  };
  /**
   * Adds an event to the Span
   * @param name The name of the event
   * @param attributes The associated attributes to add for this event
   */


  OpenCensusSpanWrapper.prototype.addEvent = function (_name, _attributes) {
    throw new Error("Method not implemented.");
  };
  /**
   * Sets a status on the span. Overrides the default of CanonicalCode.OK.
   * @param status The status to set.
   */


  OpenCensusSpanWrapper.prototype.setStatus = function (status) {
    this._span.setStatus(status.code, status.message);

    return this;
  };
  /**
   * Updates the name of the Span
   * @param name the new Span name
   */


  OpenCensusSpanWrapper.prototype.updateName = function (name) {
    this._span.name = name;
    return this;
  };
  /**
   * Returns whether this span will be recorded
   */


  OpenCensusSpanWrapper.prototype.isRecording = function () {
    // NoRecordSpans have an empty traceId
    return !!this._span.traceId;
  };

  return OpenCensusSpanWrapper;
}();

exports.OpenCensusSpanWrapper = OpenCensusSpanWrapper;
},{"./openCensusTraceStateWrapper":"kV0q"}],"VHX1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OpenCensusTracerWrapper = void 0;

var _openCensusSpanWrapper = require("./openCensusSpanWrapper");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * An implementation of OpenTelemetry Tracer that wraps an OpenCensus Tracer.
 */
var OpenCensusTracerWrapper =
/** @class */
function () {
  /**
   * Create a new wrapper around a given OpenCensus Tracer.
   * @param tracer The OpenCensus Tracer to wrap.
   */
  function OpenCensusTracerWrapper(tracer) {
    this._tracer = tracer;
  }
  /**
   * The wrapped OpenCensus Tracer
   */


  OpenCensusTracerWrapper.prototype.getWrappedTracer = function () {
    return this._tracer;
  };
  /**
   * Starts a new Span.
   * @param name The name of the span.
   * @param options The SpanOptions used during Span creation.
   */


  OpenCensusTracerWrapper.prototype.startSpan = function (name, options) {
    return new _openCensusSpanWrapper.OpenCensusSpanWrapper(this, name, options);
  };
  /**
   * Returns the current Span from the current context, if available.
   */


  OpenCensusTracerWrapper.prototype.getCurrentSpan = function () {
    return undefined;
  };
  /**
   * Executes the given function within the context provided by a Span.
   * @param _span The span that provides the context.
   * @param _fn The function to be executed.
   */


  OpenCensusTracerWrapper.prototype.withSpan = function (_span, _fn) {
    throw new Error("Method not implemented.");
  };
  /**
   * Bind a Span as the target's scope
   * @param target An object to bind the scope.
   * @param _span A specific Span to use. Otherwise, use the current one.
   */


  OpenCensusTracerWrapper.prototype.bind = function (_target, _span) {
    throw new Error("Method not implemented.");
  };

  return OpenCensusTracerWrapper;
}();

exports.OpenCensusTracerWrapper = OpenCensusTracerWrapper;
},{"./openCensusSpanWrapper":"Ff0U"}],"awp2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TestSpan = void 0;

var _tslib = require("tslib");

var _api = require("@opentelemetry/api");

var _noOpSpan = require("../noop/noOpSpan");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * A mock span useful for testing.
 */
var TestSpan =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TestSpan, _super);
  /**
   * Starts a new Span.
   * @param parentTracer The tracer that created this Span
   * @param name The name of the span.
   * @param context The SpanContext this span belongs to
   * @param kind The SpanKind of this Span
   * @param parentSpanId The identifier of the parent Span
   * @param startTime The startTime of the event (defaults to now)
   */

  function TestSpan(parentTracer, name, context, kind, parentSpanId, startTime) {
    if (startTime === void 0) {
      startTime = Date.now();
    }

    var _this = _super.call(this) || this;

    _this._tracer = parentTracer;
    _this.name = name;
    _this.kind = kind;
    _this.startTime = startTime;
    _this.parentSpanId = parentSpanId;
    _this.status = {
      code: _api.CanonicalCode.OK
    };
    _this.endCalled = false;
    _this._context = context;
    _this.attributes = {};
    return _this;
  }
  /**
   * Returns the Tracer that created this Span
   */


  TestSpan.prototype.tracer = function () {
    return this._tracer;
  };
  /**
   * Returns the SpanContext associated with this Span.
   */


  TestSpan.prototype.context = function () {
    return this._context;
  };
  /**
   * Marks the end of Span execution.
   * @param _endTime The time to use as the Span's end time. Defaults to
   * the current time.
   */


  TestSpan.prototype.end = function (_endTime) {
    this.endCalled = true;
  };
  /**
   * Sets a status on the span. Overrides the default of CanonicalCode.OK.
   * @param status The status to set.
   */


  TestSpan.prototype.setStatus = function (status) {
    this.status = status;
    return this;
  };
  /**
   * Returns whether this span will be recorded
   */


  TestSpan.prototype.isRecording = function () {
    return true;
  };
  /**
   * Sets an attribute on the Span
   * @param key the attribute key
   * @param value the attribute value
   */


  TestSpan.prototype.setAttribute = function (key, value) {
    this.attributes[key] = value;
    return this;
  };
  /**
   * Sets attributes on the Span
   * @param attributes the attributes to add
   */


  TestSpan.prototype.setAttributes = function (attributes) {
    for (var _i = 0, _a = Object.keys(attributes); _i < _a.length; _i++) {
      var key = _a[_i];
      this.attributes[key] = attributes[key];
    }

    return this;
  };

  return TestSpan;
}(_noOpSpan.NoOpSpan);

exports.TestSpan = TestSpan;
},{"tslib":"CvJj","@opentelemetry/api":"fNAU","../noop/noOpSpan":"M998"}],"jwmF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TestTracer = void 0;

var _tslib = require("tslib");

var _testSpan = require("./testSpan");

var _noOpTracer = require("../noop/noOpTracer");

var _api = require("@opentelemetry/api");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * A mock tracer useful for testing
 */
var TestTracer =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TestTracer, _super);

  function TestTracer() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.traceIdCounter = 0;
    _this.spanIdCounter = 0;
    _this.rootSpans = [];
    _this.knownSpans = [];
    return _this;
  }

  TestTracer.prototype.getNextTraceId = function () {
    this.traceIdCounter++;
    return String(this.traceIdCounter);
  };

  TestTracer.prototype.getNextSpanId = function () {
    this.spanIdCounter++;
    return String(this.spanIdCounter);
  };
  /**
   * Returns all Spans that were created without a parent
   */


  TestTracer.prototype.getRootSpans = function () {
    return this.rootSpans;
  };
  /**
   * Returns all Spans this Tracer knows about
   */


  TestTracer.prototype.getKnownSpans = function () {
    return this.knownSpans;
  };
  /**
   * Returns all Spans where end() has not been called
   */


  TestTracer.prototype.getActiveSpans = function () {
    return this.knownSpans.filter(function (span) {
      return !span.endCalled;
    });
  };
  /**
   * Return all Spans for a particular trace, grouped by their
   * parent Span in a tree-like structure
   * @param traceId The traceId to return the graph for
   */


  TestTracer.prototype.getSpanGraph = function (traceId) {
    var traceSpans = this.knownSpans.filter(function (span) {
      return span.context().traceId === traceId;
    });
    var roots = [];
    var nodeMap = new Map();

    for (var _i = 0, traceSpans_1 = traceSpans; _i < traceSpans_1.length; _i++) {
      var span = traceSpans_1[_i];
      var spanId = span.context().spanId;
      var node = {
        name: span.name,
        children: []
      };
      nodeMap.set(spanId, node);

      if (span.parentSpanId) {
        var parent = nodeMap.get(span.parentSpanId);

        if (!parent) {
          throw new Error("Span with name " + node.name + " has an unknown parentSpan with id " + span.parentSpanId);
        }

        parent.children.push(node);
      } else {
        roots.push(node);
      }
    }

    return {
      roots: roots
    };
  };
  /**
   * Starts a new Span.
   * @param name The name of the span.
   * @param options The SpanOptions used during Span creation.
   */


  TestTracer.prototype.startSpan = function (name, options) {
    if (options === void 0) {
      options = {};
    }

    var parentContext = this._getParentContext(options);

    var traceId;
    var isRootSpan = false;

    if (parentContext && parentContext.traceId) {
      traceId = parentContext.traceId;
    } else {
      traceId = this.getNextTraceId();
      isRootSpan = true;
    }

    var context = {
      traceId: traceId,
      spanId: this.getNextSpanId(),
      traceFlags: _api.TraceFlags.NONE
    };
    var span = new _testSpan.TestSpan(this, name, context, options.kind || _api.SpanKind.INTERNAL, parentContext ? parentContext.spanId : undefined, options.startTime);
    this.knownSpans.push(span);

    if (isRootSpan) {
      this.rootSpans.push(span);
    }

    return span;
  };

  TestTracer.prototype._getParentContext = function (options) {
    var parent = options.parent;
    var result;

    if (parent) {
      if ("traceId" in parent) {
        result = parent;
      } else {
        result = parent.context();
      }
    }

    return result;
  };

  return TestTracer;
}(_noOpTracer.NoOpTracer);

exports.TestTracer = TestTracer;
},{"tslib":"CvJj","./testSpan":"awp2","../noop/noOpTracer":"tFNs","@opentelemetry/api":"fNAU"}],"BsZG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractSpanContextFromTraceParentHeader = extractSpanContextFromTraceParentHeader;
exports.getTraceParentHeader = getTraceParentHeader;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var VERSION = "00";
/**
 * Generates a `SpanContext` given a `traceparent` header value.
 * @param traceParent Serialized span context data as a `traceparent` header value.
 * @returns The `SpanContext` generated from the `traceparent` value.
 */

function extractSpanContextFromTraceParentHeader(traceParentHeader) {
  var parts = traceParentHeader.split("-");

  if (parts.length !== 4) {
    return;
  }

  var version = parts[0],
      traceId = parts[1],
      spanId = parts[2],
      traceOptions = parts[3];

  if (version !== VERSION) {
    return;
  }

  var traceFlags = parseInt(traceOptions, 16);
  var spanContext = {
    spanId: spanId,
    traceId: traceId,
    traceFlags: traceFlags
  };
  return spanContext;
}
/**
 * Generates a `traceparent` value given a span context.
 * @param spanContext Contains context for a specific span.
 * @returns The `spanContext` represented as a `traceparent` value.
 */


function getTraceParentHeader(spanContext) {
  var missingFields = [];

  if (!spanContext.traceId) {
    missingFields.push("traceId");
  }

  if (!spanContext.spanId) {
    missingFields.push("spanId");
  }

  if (missingFields.length) {
    return;
  }

  var flags = spanContext.traceFlags || 0
  /* NONE */
  ;
  var hexFlags = flags.toString(16);
  var traceFlags = hexFlags.length === 1 ? "0" + hexFlags : hexFlags; // https://www.w3.org/TR/trace-context/#traceparent-header-field-values

  return VERSION + "-" + spanContext.traceId + "-" + spanContext.spanId + "-" + traceFlags;
}
},{}],"xbTt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "getTracer", {
  enumerable: true,
  get: function () {
    return _tracerProxy.getTracer;
  }
});
Object.defineProperty(exports, "setTracer", {
  enumerable: true,
  get: function () {
    return _tracerProxy.setTracer;
  }
});
Object.defineProperty(exports, "NoOpSpan", {
  enumerable: true,
  get: function () {
    return _noOpSpan.NoOpSpan;
  }
});
Object.defineProperty(exports, "NoOpTracer", {
  enumerable: true,
  get: function () {
    return _noOpTracer.NoOpTracer;
  }
});
Object.defineProperty(exports, "OpenCensusSpanWrapper", {
  enumerable: true,
  get: function () {
    return _openCensusSpanWrapper.OpenCensusSpanWrapper;
  }
});
Object.defineProperty(exports, "OpenCensusTracerWrapper", {
  enumerable: true,
  get: function () {
    return _openCensusTracerWrapper.OpenCensusTracerWrapper;
  }
});
Object.defineProperty(exports, "TestTracer", {
  enumerable: true,
  get: function () {
    return _testTracer.TestTracer;
  }
});
Object.defineProperty(exports, "TestSpan", {
  enumerable: true,
  get: function () {
    return _testSpan.TestSpan;
  }
});
Object.defineProperty(exports, "extractSpanContextFromTraceParentHeader", {
  enumerable: true,
  get: function () {
    return _traceParentHeader.extractSpanContextFromTraceParentHeader;
  }
});
Object.defineProperty(exports, "getTraceParentHeader", {
  enumerable: true,
  get: function () {
    return _traceParentHeader.getTraceParentHeader;
  }
});

var _tracerProxy = require("./tracerProxy");

var _noOpSpan = require("./tracers/noop/noOpSpan");

var _noOpTracer = require("./tracers/noop/noOpTracer");

var _openCensusSpanWrapper = require("./tracers/opencensus/openCensusSpanWrapper");

var _openCensusTracerWrapper = require("./tracers/opencensus/openCensusTracerWrapper");

var _testTracer = require("./tracers/test/testTracer");

var _testSpan = require("./tracers/test/testSpan");

var _traceParentHeader = require("./utils/traceParentHeader");
},{"./tracerProxy":"yFrR","./tracers/noop/noOpSpan":"M998","./tracers/noop/noOpTracer":"tFNs","./tracers/opencensus/openCensusSpanWrapper":"Ff0U","./tracers/opencensus/openCensusTracerWrapper":"VHX1","./tracers/test/testTracer":"jwmF","./tracers/test/testSpan":"awp2","./utils/traceParentHeader":"BsZG"}],"Go6L":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tracingPolicy = tracingPolicy;
exports.TracingPolicy = void 0;

var _tslib = require("tslib");

var _coreTracing = require("@azure/core-tracing");

var _api = require("@opentelemetry/api");

var _requestPolicy = require("./requestPolicy");

var _url = require("../url");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function tracingPolicy(tracingOptions) {
  if (tracingOptions === void 0) {
    tracingOptions = {};
  }

  return {
    create: function (nextPolicy, options) {
      return new TracingPolicy(nextPolicy, options, tracingOptions);
    }
  };
}

var TracingPolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TracingPolicy, _super);

  function TracingPolicy(nextPolicy, options, tracingOptions) {
    var _this = _super.call(this, nextPolicy, options) || this;

    _this.userAgent = tracingOptions.userAgent;
    return _this;
  }

  TracingPolicy.prototype.sendRequest = function (request) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var tracer, spanOptions, path, span, spanContext, traceParentHeader, traceState, response, serviceRequestId, err_1;
      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (!request.spanOptions || !request.spanOptions.parent) {
              return [2
              /*return*/
              , this._nextPolicy.sendRequest(request)];
            }

            tracer = (0, _coreTracing.getTracer)();
            spanOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, request.spanOptions), {
              kind: _api.SpanKind.CLIENT
            });
            path = _url.URLBuilder.parse(request.url).getPath() || "/";
            span = tracer.startSpan(path, spanOptions);
            span.setAttributes({
              "http.method": request.method,
              "http.url": request.url,
              requestId: request.requestId
            });

            if (this.userAgent) {
              span.setAttribute("http.user_agent", this.userAgent);
            }

            _a.label = 1;

          case 1:
            _a.trys.push([1, 3,, 4]);

            spanContext = span.context();
            traceParentHeader = (0, _coreTracing.getTraceParentHeader)(spanContext);

            if (traceParentHeader) {
              request.headers.set("traceparent", traceParentHeader);
              traceState = spanContext.traceState && spanContext.traceState.serialize(); // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent

              if (traceState) {
                request.headers.set("tracestate", traceState);
              }
            }

            return [4
            /*yield*/
            , this._nextPolicy.sendRequest(request)];

          case 2:
            response = _a.sent();
            span.setAttribute("http.status_code", response.status);
            serviceRequestId = response.headers.get("x-ms-request-id");

            if (serviceRequestId) {
              span.setAttribute("serviceRequestId", serviceRequestId);
            }

            span.end();
            return [2
            /*return*/
            , response];

          case 3:
            err_1 = _a.sent();
            span.end();
            throw err_1;

          case 4:
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  return TracingPolicy;
}(_requestPolicy.BaseRequestPolicy);

exports.TracingPolicy = TracingPolicy;
},{"tslib":"CvJj","@azure/core-tracing":"xbTt","@opentelemetry/api":"fNAU","./requestPolicy":"ggtJ","../url":"bBTP"}],"M6Qy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.disableResponseDecompressionPolicy = disableResponseDecompressionPolicy;
exports.DisableResponseDecompressionPolicy = void 0;

var _tslib = require("tslib");

var _requestPolicy = require("./requestPolicy");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/*
 * NOTE: When moving this file, please update "browser" section in package.json
 */
var DisbleResponseDecompressionNotSupportedInBrowser = new Error("DisableResponseDecompressionPolicy is not supported in browser environment");
/**
 * {@link DisableResponseDecompressionPolicy} is not supported in browser and attempting
 * to use it will results in error being thrown.
 */

function disableResponseDecompressionPolicy() {
  return {
    create: function (_nextPolicy, _options) {
      throw DisbleResponseDecompressionNotSupportedInBrowser;
    }
  };
}

var DisableResponseDecompressionPolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(DisableResponseDecompressionPolicy, _super);

  function DisableResponseDecompressionPolicy(nextPolicy, options) {
    var _this = _super.call(this, nextPolicy, options) || this;

    throw DisbleResponseDecompressionNotSupportedInBrowser;
    return _this;
  }

  DisableResponseDecompressionPolicy.prototype.sendRequest = function (_request) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      return (0, _tslib.__generator)(this, function (_a) {
        throw DisbleResponseDecompressionNotSupportedInBrowser;
      });
    });
  };

  return DisableResponseDecompressionPolicy;
}(_requestPolicy.BaseRequestPolicy);

exports.DisableResponseDecompressionPolicy = DisableResponseDecompressionPolicy;
},{"tslib":"CvJj","./requestPolicy":"ggtJ"}],"hIxU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ndJsonPolicy = ndJsonPolicy;

var _tslib = require("tslib");

var _requestPolicy = require("./requestPolicy");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// BaseRequestPolicy has a protected constructor.

/* eslint-disable @typescript-eslint/no-useless-constructor */
function ndJsonPolicy() {
  return {
    create: function (nextPolicy, options) {
      return new NdJsonPolicy(nextPolicy, options);
    }
  };
}
/**
 * NdJsonPolicy that formats a JSON array as newline-delimited JSON
 */


var NdJsonPolicy =
/** @class */
function (_super) {
  (0, _tslib.__extends)(NdJsonPolicy, _super);
  /**
   * Creates an instance of KeepAlivePolicy.
   */

  function NdJsonPolicy(nextPolicy, options) {
    return _super.call(this, nextPolicy, options) || this;
  }
  /**
   * Sends a request.
   */


  NdJsonPolicy.prototype.sendRequest = function (request) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var body;
      return (0, _tslib.__generator)(this, function (_a) {
        // There currently isn't a good way to bypass the serializer
        if (typeof request.body === "string" && request.body.startsWith("[")) {
          body = JSON.parse(request.body);

          if (Array.isArray(body)) {
            request.body = body.map(function (item) {
              return JSON.stringify(item) + "\n";
            }).join("");
          }
        }

        return [2
        /*return*/
        , this._nextPolicy.sendRequest(request)];
      });
    });
  };

  return NdJsonPolicy;
}(_requestPolicy.BaseRequestPolicy);
},{"tslib":"CvJj","./requestPolicy":"ggtJ"}],"SKk4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCachedDefaultHttpClient = getCachedDefaultHttpClient;

var _defaultHttpClient = require("./defaultHttpClient");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var cachedHttpClient;

function getCachedDefaultHttpClient() {
  if (!cachedHttpClient) {
    cachedHttpClient = new _defaultHttpClient.DefaultHttpClient();
  }

  return cachedHttpClient;
}
},{"./defaultHttpClient":"CT7P"}],"GHYw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serializeRequestBody = serializeRequestBody;
exports.createPipelineFromOptions = createPipelineFromOptions;
exports.getPropertyParent = getPropertyParent;
exports.getOperationArgumentValueFromParameterPath = getOperationArgumentValueFromParameterPath;
exports.flattenResponse = flattenResponse;
exports.ServiceClient = void 0;

var _tslib = require("tslib");

var _coreAuth = require("@azure/core-auth");

var _logPolicy = require("./policies/logPolicy");

var _operationParameter = require("./operationParameter");

var _operationSpec = require("./operationSpec");

var _deserializationPolicy = require("./policies/deserializationPolicy");

var _exponentialRetryPolicy = require("./policies/exponentialRetryPolicy");

var _generateClientRequestIdPolicy = require("./policies/generateClientRequestIdPolicy");

var _userAgentPolicy = require("./policies/userAgentPolicy");

var _redirectPolicy = require("./policies/redirectPolicy");

var _requestPolicy = require("./policies/requestPolicy");

var _rpRegistrationPolicy = require("./policies/rpRegistrationPolicy");

var _bearerTokenAuthenticationPolicy = require("./policies/bearerTokenAuthenticationPolicy");

var _systemErrorRetryPolicy = require("./policies/systemErrorRetryPolicy");

var _queryCollectionFormat = require("./queryCollectionFormat");

var _serializer = require("./serializer");

var _url = require("./url");

var utils = _interopRequireWildcard(require("./util/utils"));

var _xml = require("./util/xml");

var _webResource = require("./webResource");

var _proxyPolicy = require("./policies/proxyPolicy");

var _throttlingRetryPolicy = require("./policies/throttlingRetryPolicy");

var _signingPolicy = require("./policies/signingPolicy");

var _log = require("./log");

var _keepAlivePolicy = require("./policies/keepAlivePolicy");

var _tracingPolicy = require("./policies/tracingPolicy");

var _disableResponseDecompressionPolicy = require("./policies/disableResponseDecompressionPolicy");

var _ndJsonPolicy = require("./policies/ndJsonPolicy");

var _serializer2 = require("./util/serializer.common");

var _httpClientCache = require("./httpClientCache");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * ServiceClient sends service requests and receives responses.
 */
var ServiceClient =
/** @class */
function () {
  /**
   * The ServiceClient constructor
   * @param credentials - The credentials used for authentication with the service.
   * @param options - The service client options that govern the behavior of the client.
   */
  function ServiceClient(credentials,
  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */
  options) {
    var _this = this;

    if (!options) {
      options = {};
    }

    this._withCredentials = options.withCredentials || false;
    this._httpClient = options.httpClient || (0, _httpClientCache.getCachedDefaultHttpClient)();
    this._requestPolicyOptions = new _requestPolicy.RequestPolicyOptions(options.httpPipelineLogger);
    var requestPolicyFactories;

    if (Array.isArray(options.requestPolicyFactories)) {
      _log.logger.info("ServiceClient: using custom request policies");

      requestPolicyFactories = options.requestPolicyFactories;
    } else {
      var authPolicyFactory = undefined;

      if ((0, _coreAuth.isTokenCredential)(credentials)) {
        _log.logger.info("ServiceClient: creating bearer token authentication policy from provided credentials"); // Create a wrapped RequestPolicyFactory here so that we can provide the
        // correct scope to the BearerTokenAuthenticationPolicy at the first time
        // one is requested.  This is needed because generated ServiceClient
        // implementations do not set baseUri until after ServiceClient's constructor
        // is finished, leaving baseUri empty at the time when it is needed to
        // build the correct scope name.


        var wrappedPolicyFactory = function () {
          var bearerTokenPolicyFactory = undefined; // eslint-disable-next-line @typescript-eslint/no-this-alias

          var serviceClient = _this;
          var serviceClientOptions = options;
          return {
            create: function (nextPolicy, createOptions) {
              var credentialScopes = getCredentialScopes(serviceClientOptions, serviceClient.baseUri);

              if (!credentialScopes) {
                throw new Error("When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy");
              }

              if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {
                bearerTokenPolicyFactory = (0, _bearerTokenAuthenticationPolicy.bearerTokenAuthenticationPolicy)(credentials, credentialScopes);
              }

              return bearerTokenPolicyFactory.create(nextPolicy, createOptions);
            }
          };
        };

        authPolicyFactory = wrappedPolicyFactory();
      } else if (credentials && typeof credentials.signRequest === "function") {
        _log.logger.info("ServiceClient: creating signing policy from provided credentials");

        authPolicyFactory = (0, _signingPolicy.signingPolicy)(credentials);
      } else if (credentials !== undefined && credentials !== null) {
        throw new Error("The credentials argument must implement the TokenCredential interface");
      }

      _log.logger.info("ServiceClient: using default request policies");

      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);

      if (options.requestPolicyFactories) {
        // options.requestPolicyFactories can also be a function that manipulates
        // the default requestPolicyFactories array
        var newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);

        if (newRequestPolicyFactories) {
          requestPolicyFactories = newRequestPolicyFactories;
        }
      }
    }

    this._requestPolicyFactories = requestPolicyFactories;
  }
  /**
   * Send the provided httpRequest.
   */


  ServiceClient.prototype.sendRequest = function (options) {
    if (options === null || options === undefined || typeof options !== "object") {
      throw new Error("options cannot be null or undefined and it must be of type object.");
    }

    var httpRequest;

    try {
      if ((0, _webResource.isWebResourceLike)(options)) {
        options.validateRequestProperties();
        httpRequest = options;
      } else {
        httpRequest = new _webResource.WebResource();
        httpRequest = httpRequest.prepare(options);
      }
    } catch (error) {
      return Promise.reject(error);
    }

    var httpPipeline = this._httpClient;

    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {
      for (var i = this._requestPolicyFactories.length - 1; i >= 0; --i) {
        httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);
      }
    }

    return httpPipeline.sendRequest(httpRequest);
  };
  /**
   * Send an HTTP request that is populated using the provided OperationSpec.
   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
   * @param operationSpec - The OperationSpec to use to populate the httpRequest.
   * @param callback - The callback to call when the response is received.
   */


  ServiceClient.prototype.sendOperationRequest = function (operationArguments, operationSpec, callback) {
    var _a;

    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var serializerOptions, httpRequest, result, baseUri, requestUrl, _i, _b, urlParameter, urlParameterValue, _c, _d, queryParameter, queryParameterValue, index, item, index, contentType, _e, _f, headerParameter, headerValue, headerCollectionPrefix, _g, _h, key, options, customHeaderName, rawResponse, sendRequestError, error_1, error_2, cb;

      return (0, _tslib.__generator)(this, function (_j) {
        switch (_j.label) {
          case 0:
            if (typeof operationArguments.options === "function") {
              callback = operationArguments.options;
              operationArguments.options = undefined;
            }

            serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;
            httpRequest = new _webResource.WebResource();
            _j.label = 1;

          case 1:
            _j.trys.push([1, 6,, 7]);

            baseUri = operationSpec.baseUrl || this.baseUri;

            if (!baseUri) {
              throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.");
            }

            httpRequest.method = operationSpec.httpMethod;
            httpRequest.operationSpec = operationSpec;
            requestUrl = _url.URLBuilder.parse(baseUri);

            if (operationSpec.path) {
              requestUrl.appendPath(operationSpec.path);
            }

            if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {
              for (_i = 0, _b = operationSpec.urlParameters; _i < _b.length; _i++) {
                urlParameter = _b[_i];
                urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer);
                urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, (0, _operationParameter.getPathStringFromParameter)(urlParameter), serializerOptions);

                if (!urlParameter.skipEncoding) {
                  urlParameterValue = encodeURIComponent(urlParameterValue);
                }

                requestUrl.replaceAll("{" + (urlParameter.mapper.serializedName || (0, _operationParameter.getPathStringFromParameter)(urlParameter)) + "}", urlParameterValue);
              }
            }

            if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {
              for (_c = 0, _d = operationSpec.queryParameters; _c < _d.length; _c++) {
                queryParameter = _d[_c];
                queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer);

                if (queryParameterValue !== undefined && queryParameterValue !== null) {
                  queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, (0, _operationParameter.getPathStringFromParameter)(queryParameter), serializerOptions);

                  if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null) {
                    if (queryParameter.collectionFormat === _queryCollectionFormat.QueryCollectionFormat.Multi) {
                      if (queryParameterValue.length === 0) {
                        // The collection is empty, no need to try serializing the current queryParam
                        continue;
                      } else {
                        for (index in queryParameterValue) {
                          item = queryParameterValue[index];
                          queryParameterValue[index] = item === undefined || item === null ? "" : item.toString();
                        }
                      }
                    } else if (queryParameter.collectionFormat === _queryCollectionFormat.QueryCollectionFormat.Ssv || queryParameter.collectionFormat === _queryCollectionFormat.QueryCollectionFormat.Tsv) {
                      queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);
                    }
                  }

                  if (!queryParameter.skipEncoding) {
                    if (Array.isArray(queryParameterValue)) {
                      for (index in queryParameterValue) {
                        if (queryParameterValue[index] !== undefined && queryParameterValue[index] !== null) {
                          queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);
                        }
                      }
                    } else {
                      queryParameterValue = encodeURIComponent(queryParameterValue);
                    }
                  }

                  if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null && queryParameter.collectionFormat !== _queryCollectionFormat.QueryCollectionFormat.Multi && queryParameter.collectionFormat !== _queryCollectionFormat.QueryCollectionFormat.Ssv && queryParameter.collectionFormat !== _queryCollectionFormat.QueryCollectionFormat.Tsv) {
                    queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);
                  }

                  requestUrl.setQueryParameter(queryParameter.mapper.serializedName || (0, _operationParameter.getPathStringFromParameter)(queryParameter), queryParameterValue);
                }
              }
            }

            httpRequest.url = requestUrl.toString();
            contentType = operationSpec.contentType || this.requestContentType;

            if (contentType && operationSpec.requestBody) {
              httpRequest.headers.set("Content-Type", contentType);
            }

            if (operationSpec.headerParameters) {
              for (_e = 0, _f = operationSpec.headerParameters; _e < _f.length; _e++) {
                headerParameter = _f[_e];
                headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer);

                if (headerValue !== undefined && headerValue !== null) {
                  headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, (0, _operationParameter.getPathStringFromParameter)(headerParameter), serializerOptions);
                  headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;

                  if (headerCollectionPrefix) {
                    for (_g = 0, _h = Object.keys(headerValue); _g < _h.length; _g++) {
                      key = _h[_g];
                      httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);
                    }
                  } else {
                    httpRequest.headers.set(headerParameter.mapper.serializedName || (0, _operationParameter.getPathStringFromParameter)(headerParameter), headerValue);
                  }
                }
              }
            }

            options = operationArguments.options;

            if (options) {
              if (options.customHeaders) {
                for (customHeaderName in options.customHeaders) {
                  httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);
                }
              }

              if (options.abortSignal) {
                httpRequest.abortSignal = options.abortSignal;
              }

              if (options.timeout) {
                httpRequest.timeout = options.timeout;
              }

              if (options.onUploadProgress) {
                httpRequest.onUploadProgress = options.onUploadProgress;
              }

              if (options.onDownloadProgress) {
                httpRequest.onDownloadProgress = options.onDownloadProgress;
              }

              if (options.spanOptions) {
                httpRequest.spanOptions = options.spanOptions;
              }

              if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {
                httpRequest.shouldDeserialize = options.shouldDeserialize;
              }
            }

            httpRequest.withCredentials = this._withCredentials;
            serializeRequestBody(this, httpRequest, operationArguments, operationSpec);

            if (httpRequest.streamResponseStatusCodes === undefined) {
              httpRequest.streamResponseStatusCodes = (0, _operationSpec.getStreamResponseStatusCodes)(operationSpec);
            }

            rawResponse = void 0;
            sendRequestError = void 0;
            _j.label = 2;

          case 2:
            _j.trys.push([2, 4,, 5]);

            return [4
            /*yield*/
            , this.sendRequest(httpRequest)];

          case 3:
            rawResponse = _j.sent();
            return [3
            /*break*/
            , 5];

          case 4:
            error_1 = _j.sent();
            sendRequestError = error_1;
            return [3
            /*break*/
            , 5];

          case 5:
            if (sendRequestError) {
              if (sendRequestError.response) {
                sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] || operationSpec.responses["default"]);
              }

              result = Promise.reject(sendRequestError);
            } else {
              result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]));
            }

            return [3
            /*break*/
            , 7];

          case 6:
            error_2 = _j.sent();
            result = Promise.reject(error_2);
            return [3
            /*break*/
            , 7];

          case 7:
            cb = callback;

            if (cb) {
              result.then(function (res) {
                return cb(null, res._response.parsedBody, res._response.request, res._response);
              }).catch(function (err) {
                return cb(err);
              });
            }

            return [2
            /*return*/
            , result];
        }
      });
    });
  };

  return ServiceClient;
}();

exports.ServiceClient = ServiceClient;

function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {
  var _a, _b, _c, _d, _e, _f;

  var serializerOptions = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions) !== null && _b !== void 0 ? _b : {};
  var updatedOptions = {
    rootName: (_c = serializerOptions.rootName) !== null && _c !== void 0 ? _c : "",
    includeRoot: (_d = serializerOptions.includeRoot) !== null && _d !== void 0 ? _d : false,
    xmlCharKey: (_e = serializerOptions.xmlCharKey) !== null && _e !== void 0 ? _e : _serializer2.XML_CHARKEY
  };
  var xmlCharKey = serializerOptions.xmlCharKey;

  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
    httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);
    var bodyMapper = operationSpec.requestBody.mapper;
    var required = bodyMapper.required,
        xmlName = bodyMapper.xmlName,
        xmlElementName = bodyMapper.xmlElementName,
        serializedName = bodyMapper.serializedName,
        xmlNamespace = bodyMapper.xmlNamespace,
        xmlNamespacePrefix = bodyMapper.xmlNamespacePrefix;
    var typeName = bodyMapper.type.name;

    try {
      if (httpRequest.body !== undefined && httpRequest.body !== null || required) {
        var requestBodyParameterPathString = (0, _operationParameter.getPathStringFromParameter)(operationSpec.requestBody);
        httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);
        var isStream = typeName === _serializer.MapperType.Stream;

        if (operationSpec.isXML) {
          var xmlnsKey = xmlNamespacePrefix ? "xmlns:" + xmlNamespacePrefix : "xmlns";
          var value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);

          if (typeName === _serializer.MapperType.Sequence) {
            httpRequest.body = (0, _xml.stringifyXML)(utils.prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {
              rootName: xmlName || serializedName,
              xmlCharKey: xmlCharKey
            });
          } else if (!isStream) {
            httpRequest.body = (0, _xml.stringifyXML)(value, {
              rootName: xmlName || serializedName,
              xmlCharKey: xmlCharKey
            });
          }
        } else if (typeName === _serializer.MapperType.String && (((_f = operationSpec.contentType) === null || _f === void 0 ? void 0 : _f.match("text/plain")) || operationSpec.mediaType === "text")) {
          // the String serializer has validated that request body is a string
          // so just send the string.
          return;
        } else if (!isStream) {
          httpRequest.body = JSON.stringify(httpRequest.body);
        }
      }
    } catch (error) {
      throw new Error("Error \"" + error.message + "\" occurred in serializing the payload - " + JSON.stringify(serializedName, undefined, "  ") + ".");
    }
  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
    httpRequest.formData = {};

    for (var _i = 0, _g = operationSpec.formDataParameters; _i < _g.length; _i++) {
      var formDataParameter = _g[_i];
      var formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);

      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {
        var formDataParameterPropertyName = formDataParameter.mapper.serializedName || (0, _operationParameter.getPathStringFromParameter)(formDataParameter);
        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, (0, _operationParameter.getPathStringFromParameter)(formDataParameter), updatedOptions);
      }
    }
  }
}
/**
 * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself
 */


function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
  var _a; // Composite and Sequence schemas already got their root namespace set during serialization
  // We just need to add xmlns to the other schema types


  if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
    var result = {};
    result[options.xmlCharKey] = serializedValue;
    result[_serializer2.XML_ATTRKEY] = (_a = {}, _a[xmlnsKey] = xmlNamespace, _a);
    return result;
  }

  return serializedValue;
}

function getValueOrFunctionResult(value, defaultValueCreator) {
  var result;

  if (typeof value === "string") {
    result = value;
  } else {
    result = defaultValueCreator();

    if (typeof value === "function") {
      result = value(result);
    }
  }

  return result;
}

function createDefaultRequestPolicyFactories(authPolicyFactory, options) {
  var factories = [];

  if (options.generateClientRequestIdHeader) {
    factories.push((0, _generateClientRequestIdPolicy.generateClientRequestIdPolicy)(options.clientRequestIdHeaderName));
  }

  if (authPolicyFactory) {
    factories.push(authPolicyFactory);
  }

  var userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, _userAgentPolicy.getDefaultUserAgentHeaderName);
  var userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, _userAgentPolicy.getDefaultUserAgentValue);

  if (userAgentHeaderName && userAgentHeaderValue) {
    factories.push((0, _userAgentPolicy.userAgentPolicy)({
      key: userAgentHeaderName,
      value: userAgentHeaderValue
    }));
  }

  factories.push((0, _redirectPolicy.redirectPolicy)());
  factories.push((0, _rpRegistrationPolicy.rpRegistrationPolicy)(options.rpRegistrationRetryTimeout));

  if (!options.noRetryPolicy) {
    factories.push((0, _exponentialRetryPolicy.exponentialRetryPolicy)());
    factories.push((0, _systemErrorRetryPolicy.systemErrorRetryPolicy)());
    factories.push((0, _throttlingRetryPolicy.throttlingRetryPolicy)());
  }

  factories.push((0, _deserializationPolicy.deserializationPolicy)(options.deserializationContentTypes));

  if (utils.isNode) {
    factories.push((0, _proxyPolicy.proxyPolicy)(options.proxySettings));
  }

  factories.push((0, _logPolicy.logPolicy)({
    logger: _log.logger.info
  }));
  return factories;
}

function createPipelineFromOptions(pipelineOptions, authPolicyFactory) {
  var requestPolicyFactories = [];

  if (pipelineOptions.sendStreamingJson) {
    requestPolicyFactories.push((0, _ndJsonPolicy.ndJsonPolicy)());
  }

  var userAgentValue = undefined;

  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {
    var userAgentInfo = [];
    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix); // Add the default user agent value if it isn't already specified
    // by the userAgentPrefix option.

    var defaultUserAgentInfo = (0, _userAgentPolicy.getDefaultUserAgentValue)();

    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {
      userAgentInfo.push(defaultUserAgentInfo);
    }

    userAgentValue = userAgentInfo.join(" ");
  }

  var keepAliveOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, _keepAlivePolicy.DefaultKeepAliveOptions), pipelineOptions.keepAliveOptions);
  var retryOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, _exponentialRetryPolicy.DefaultRetryOptions), pipelineOptions.retryOptions);
  var redirectOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, _redirectPolicy.DefaultRedirectOptions), pipelineOptions.redirectOptions);

  if (utils.isNode) {
    requestPolicyFactories.push((0, _proxyPolicy.proxyPolicy)(pipelineOptions.proxyOptions));
  }

  var deserializationOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, _deserializationPolicy.DefaultDeserializationOptions), pipelineOptions.deserializationOptions);
  var loggingOptions = (0, _tslib.__assign)({}, pipelineOptions.loggingOptions);
  requestPolicyFactories.push((0, _tracingPolicy.tracingPolicy)({
    userAgent: userAgentValue
  }), (0, _keepAlivePolicy.keepAlivePolicy)(keepAliveOptions), (0, _userAgentPolicy.userAgentPolicy)({
    value: userAgentValue
  }), (0, _generateClientRequestIdPolicy.generateClientRequestIdPolicy)(), (0, _deserializationPolicy.deserializationPolicy)(deserializationOptions.expectedContentTypes), (0, _throttlingRetryPolicy.throttlingRetryPolicy)(), (0, _systemErrorRetryPolicy.systemErrorRetryPolicy)(), (0, _exponentialRetryPolicy.exponentialRetryPolicy)(retryOptions.maxRetries, retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs));

  if (redirectOptions.handleRedirects) {
    requestPolicyFactories.push((0, _redirectPolicy.redirectPolicy)(redirectOptions.maxRetries));
  }

  if (authPolicyFactory) {
    requestPolicyFactories.push(authPolicyFactory);
  }

  requestPolicyFactories.push((0, _logPolicy.logPolicy)(loggingOptions));

  if (utils.isNode && pipelineOptions.decompressResponse === false) {
    requestPolicyFactories.push((0, _disableResponseDecompressionPolicy.disableResponseDecompressionPolicy)());
  }

  return {
    httpClient: pipelineOptions.httpClient,
    requestPolicyFactories: requestPolicyFactories
  };
}
/**
 * Get the property parent for the property at the provided path when starting with the provided
 * parent object.
 */


function getPropertyParent(parent, propertyPath) {
  if (parent && propertyPath) {
    var propertyPathLength = propertyPath.length;

    for (var i = 0; i < propertyPathLength - 1; ++i) {
      var propertyName = propertyPath[i];

      if (!parent[propertyName]) {
        parent[propertyName] = {};
      }

      parent = parent[propertyName];
    }
  }

  return parent;
}

function getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {
  return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);
}

function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {
  var _a;

  var value;

  if (typeof parameterPath === "string") {
    parameterPath = [parameterPath];
  }

  var serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;

  if (Array.isArray(parameterPath)) {
    if (parameterPath.length > 0) {
      if (parameterMapper.isConstant) {
        value = parameterMapper.defaultValue;
      } else {
        var propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);

        if (!propertySearchResult.propertyFound) {
          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);
        }

        var useDefaultValue = false;

        if (!propertySearchResult.propertyFound) {
          useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
        }

        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
      } // Serialize just for validation purposes.


      var parameterPathString = (0, _operationParameter.getPathStringFromParameterPath)(parameterPath, parameterMapper);
      serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);
    }
  } else {
    if (parameterMapper.required) {
      value = {};
    }

    for (var propertyName in parameterPath) {
      var propertyMapper = parameterMapper.type.modelProperties[propertyName];
      var propertyPath = parameterPath[propertyName];
      var propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer); // Serialize just for validation purposes.

      var propertyPathString = (0, _operationParameter.getPathStringFromParameterPath)(propertyPath, propertyMapper);
      serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);

      if (propertyValue !== undefined && propertyValue !== null) {
        if (!value) {
          value = {};
        }

        value[propertyName] = propertyValue;
      }
    }
  }

  return value;
}

function getPropertyFromParameterPath(parent, parameterPath) {
  var result = {
    propertyFound: false
  };
  var i = 0;

  for (; i < parameterPath.length; ++i) {
    var parameterPathPart = parameterPath[i]; // Make sure to check inherited properties too, so don't use hasOwnProperty().

    if (parent !== undefined && parent !== null && parameterPathPart in parent) {
      parent = parent[parameterPathPart];
    } else {
      break;
    }
  }

  if (i === parameterPath.length) {
    result.propertyValue = parent;
    result.propertyFound = true;
  }

  return result;
}

function flattenResponse(_response, responseSpec) {
  var parsedHeaders = _response.parsedHeaders;
  var bodyMapper = responseSpec && responseSpec.bodyMapper;

  var addOperationResponse = function (obj) {
    return Object.defineProperty(obj, "_response", {
      value: _response
    });
  };

  if (bodyMapper) {
    var typeName = bodyMapper.type.name;

    if (typeName === "Stream") {
      return addOperationResponse((0, _tslib.__assign)((0, _tslib.__assign)({}, parsedHeaders), {
        blobBody: _response.blobBody,
        readableStreamBody: _response.readableStreamBody
      }));
    }

    var modelProperties_1 = typeName === "Composite" && bodyMapper.type.modelProperties || {};
    var isPageableResponse = Object.keys(modelProperties_1).some(function (k) {
      return modelProperties_1[k].serializedName === "";
    });

    if (typeName === "Sequence" || isPageableResponse) {
      var arrayResponse = (0, _tslib.__spreadArrays)(_response.parsedBody || []);

      for (var _i = 0, _a = Object.keys(modelProperties_1); _i < _a.length; _i++) {
        var key = _a[_i];

        if (modelProperties_1[key].serializedName) {
          arrayResponse[key] = _response.parsedBody[key];
        }
      }

      if (parsedHeaders) {
        for (var _b = 0, _c = Object.keys(parsedHeaders); _b < _c.length; _b++) {
          var key = _c[_b];
          arrayResponse[key] = parsedHeaders[key];
        }
      }

      addOperationResponse(arrayResponse);
      return arrayResponse;
    }

    if (typeName === "Composite" || typeName === "Dictionary") {
      return addOperationResponse((0, _tslib.__assign)((0, _tslib.__assign)({}, parsedHeaders), _response.parsedBody));
    }
  }

  if (bodyMapper || _response.request.method === "HEAD" || utils.isPrimitiveType(_response.parsedBody)) {
    // primitive body types and HEAD booleans
    return addOperationResponse((0, _tslib.__assign)((0, _tslib.__assign)({}, parsedHeaders), {
      body: _response.parsedBody
    }));
  }

  return addOperationResponse((0, _tslib.__assign)((0, _tslib.__assign)({}, parsedHeaders), _response.parsedBody));
}

function getCredentialScopes(options, baseUri) {
  if (options === null || options === void 0 ? void 0 : options.credentialScopes) {
    var scopes = options.credentialScopes;
    return Array.isArray(scopes) ? scopes.map(function (scope) {
      return new _url.URL(scope).toString();
    }) : new _url.URL(scopes).toString();
  }

  if (baseUri) {
    return baseUri + "/.default";
  }

  return undefined;
}
},{"tslib":"CvJj","@azure/core-auth":"Ujm9","./policies/logPolicy":"DhOT","./operationParameter":"wpZP","./operationSpec":"Lysf","./policies/deserializationPolicy":"dsuK","./policies/exponentialRetryPolicy":"At7c","./policies/generateClientRequestIdPolicy":"pXAS","./policies/userAgentPolicy":"rhWY","./policies/redirectPolicy":"IlDT","./policies/requestPolicy":"ggtJ","./policies/rpRegistrationPolicy":"gZxS","./policies/bearerTokenAuthenticationPolicy":"lKdS","./policies/systemErrorRetryPolicy":"hlpJ","./queryCollectionFormat":"T2Lt","./serializer":"HiIJ","./url":"bBTP","./util/utils":"DVp2","./util/xml":"oKNo","./webResource":"xjLS","./policies/proxyPolicy":"Rd7P","./policies/throttlingRetryPolicy":"kEMe","./policies/signingPolicy":"ZJzR","./log":"D5PC","./policies/keepAlivePolicy":"V02X","./policies/tracingPolicy":"Go6L","./policies/disableResponseDecompressionPolicy":"M6Qy","./policies/ndJsonPolicy":"hIxU","./util/serializer.common":"KdvI","./httpClientCache":"SKk4"}],"QEkd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSpanFunction = createSpanFunction;

var _tslib = require("tslib");

var _api = require("@opentelemetry/api");

var _coreTracing = require("@azure/core-tracing");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Creates a function called createSpan to create spans using the global tracer.
 * @hidden
 * @param spanConfig - The name of the operation being performed.
 * @param tracingOptions - The options for the underlying http request.
 */
function createSpanFunction(_a) {
  var packagePrefix = _a.packagePrefix,
      namespace = _a.namespace;
  return function (operationName, operationOptions) {
    var tracer = (0, _coreTracing.getTracer)();
    var tracingOptions = operationOptions.tracingOptions || {};
    var spanOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, tracingOptions.spanOptions), {
      kind: _api.SpanKind.INTERNAL
    });
    var span = tracer.startSpan(packagePrefix + "." + operationName, spanOptions);
    span.setAttribute("az.namespace", namespace);
    var newSpanOptions = tracingOptions.spanOptions || {};

    if (span.isRecording()) {
      newSpanOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, tracingOptions.spanOptions), {
        parent: span.context(),
        attributes: (0, _tslib.__assign)((0, _tslib.__assign)({}, spanOptions.attributes), {
          "az.namespace": namespace
        })
      });
    }

    var newTracingOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, tracingOptions), {
      spanOptions: newSpanOptions
    });
    var newOperationOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, operationOptions), {
      tracingOptions: newTracingOptions
    });
    return {
      span: span,
      updatedOptions: newOperationOptions
    };
  };
}
},{"tslib":"CvJj","@opentelemetry/api":"fNAU","@azure/core-tracing":"xbTt"}],"nH4I":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BasicAuthenticationCredentials = void 0;

var _httpHeaders = require("../httpHeaders");

var base64 = _interopRequireWildcard(require("../util/base64"));

var _constants = require("../util/constants");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var HeaderConstants = _constants.Constants.HeaderConstants;
var DEFAULT_AUTHORIZATION_SCHEME = "Basic";

var BasicAuthenticationCredentials =
/** @class */
function () {
  /**
   * Creates a new BasicAuthenticationCredentials object.
   *
   * @param userName - User name.
   * @param password - Password.
   * @param authorizationScheme - The authorization scheme.
   */
  function BasicAuthenticationCredentials(userName, password, authorizationScheme) {
    if (authorizationScheme === void 0) {
      authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME;
    }

    this.authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME;

    if (userName === null || userName === undefined || typeof userName.valueOf() !== "string") {
      throw new Error("userName cannot be null or undefined and must be of type string.");
    }

    if (password === null || password === undefined || typeof password.valueOf() !== "string") {
      throw new Error("password cannot be null or undefined and must be of type string.");
    }

    this.userName = userName;
    this.password = password;
    this.authorizationScheme = authorizationScheme;
  }
  /**
   * Signs a request with the Authentication header.
   *
   * @param webResource - The WebResourceLike to be signed.
   * @returns The signed request object.
   */


  BasicAuthenticationCredentials.prototype.signRequest = function (webResource) {
    var credentials = this.userName + ":" + this.password;
    var encodedCredentials = this.authorizationScheme + " " + base64.encodeString(credentials);
    if (!webResource.headers) webResource.headers = new _httpHeaders.HttpHeaders();
    webResource.headers.set(HeaderConstants.AUTHORIZATION, encodedCredentials);
    return Promise.resolve(webResource);
  };

  return BasicAuthenticationCredentials;
}();

exports.BasicAuthenticationCredentials = BasicAuthenticationCredentials;
},{"../httpHeaders":"wA5d","../util/base64":"WMCt","../util/constants":"o95E"}],"qOA9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ApiKeyCredentials = void 0;

var _httpHeaders = require("../httpHeaders");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Authenticates to a service using an API key.
 */
var ApiKeyCredentials =
/** @class */
function () {
  /**
   * @param options - Specifies the options to be provided for auth. Either header or query needs to be provided.
   */
  function ApiKeyCredentials(options) {
    if (!options || options && !options.inHeader && !options.inQuery) {
      throw new Error("options cannot be null or undefined. Either \"inHeader\" or \"inQuery\" property of the options object needs to be provided.");
    }

    this.inHeader = options.inHeader;
    this.inQuery = options.inQuery;
  }
  /**
   * Signs a request with the values provided in the inHeader and inQuery parameter.
   *
   * @param webResource - The WebResourceLike to be signed.
   * @returns The signed request object.
   */


  ApiKeyCredentials.prototype.signRequest = function (webResource) {
    if (!webResource) {
      return Promise.reject(new Error("webResource cannot be null or undefined and must be of type \"object\"."));
    }

    if (this.inHeader) {
      if (!webResource.headers) {
        webResource.headers = new _httpHeaders.HttpHeaders();
      }

      for (var headerName in this.inHeader) {
        webResource.headers.set(headerName, this.inHeader[headerName]);
      }
    }

    if (this.inQuery) {
      if (!webResource.url) {
        return Promise.reject(new Error("url cannot be null in the request object."));
      }

      if (webResource.url.indexOf("?") < 0) {
        webResource.url += "?";
      }

      for (var key in this.inQuery) {
        if (!webResource.url.endsWith("?")) {
          webResource.url += "&";
        }

        webResource.url += key + "=" + this.inQuery[key];
      }
    }

    return Promise.resolve(webResource);
  };

  return ApiKeyCredentials;
}();

exports.ApiKeyCredentials = ApiKeyCredentials;
},{"../httpHeaders":"wA5d"}],"vNrv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TopicCredentials = void 0;

var _tslib = require("tslib");

var _apiKeyCredentials = require("./apiKeyCredentials");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var TopicCredentials =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TopicCredentials, _super);
  /**
   * Creates a new EventGrid TopicCredentials object.
   *
   * @param topicKey - The EventGrid topic key
   */

  function TopicCredentials(topicKey) {
    var _this = this;

    if (!topicKey || topicKey && typeof topicKey !== "string") {
      throw new Error("topicKey cannot be null or undefined and must be of type string.");
    }

    var options = {
      inHeader: {
        "aeg-sas-key": topicKey
      }
    };
    _this = _super.call(this, options) || this;
    return _this;
  }

  return TopicCredentials;
}(_apiKeyCredentials.ApiKeyCredentials);

exports.TopicCredentials = TopicCredentials;
},{"tslib":"CvJj","./apiKeyCredentials":"qOA9"}],"rj0o":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "WebResource", {
  enumerable: true,
  get: function () {
    return _webResource.WebResource;
  }
});
Object.defineProperty(exports, "DefaultHttpClient", {
  enumerable: true,
  get: function () {
    return _defaultHttpClient.DefaultHttpClient;
  }
});
Object.defineProperty(exports, "HttpHeaders", {
  enumerable: true,
  get: function () {
    return _httpHeaders.HttpHeaders;
  }
});
Object.defineProperty(exports, "HttpPipelineLogLevel", {
  enumerable: true,
  get: function () {
    return _httpPipelineLogLevel.HttpPipelineLogLevel;
  }
});
Object.defineProperty(exports, "RestError", {
  enumerable: true,
  get: function () {
    return _restError.RestError;
  }
});
Object.defineProperty(exports, "operationOptionsToRequestOptionsBase", {
  enumerable: true,
  get: function () {
    return _operationOptions.operationOptionsToRequestOptionsBase;
  }
});
Object.defineProperty(exports, "ServiceClient", {
  enumerable: true,
  get: function () {
    return _serviceClient.ServiceClient;
  }
});
Object.defineProperty(exports, "flattenResponse", {
  enumerable: true,
  get: function () {
    return _serviceClient.flattenResponse;
  }
});
Object.defineProperty(exports, "createPipelineFromOptions", {
  enumerable: true,
  get: function () {
    return _serviceClient.createPipelineFromOptions;
  }
});
Object.defineProperty(exports, "createSpanFunction", {
  enumerable: true,
  get: function () {
    return _createSpan.createSpanFunction;
  }
});
Object.defineProperty(exports, "QueryCollectionFormat", {
  enumerable: true,
  get: function () {
    return _queryCollectionFormat.QueryCollectionFormat;
  }
});
Object.defineProperty(exports, "Constants", {
  enumerable: true,
  get: function () {
    return _constants.Constants;
  }
});
Object.defineProperty(exports, "bearerTokenAuthenticationPolicy", {
  enumerable: true,
  get: function () {
    return _bearerTokenAuthenticationPolicy.bearerTokenAuthenticationPolicy;
  }
});
Object.defineProperty(exports, "logPolicy", {
  enumerable: true,
  get: function () {
    return _logPolicy.logPolicy;
  }
});
Object.defineProperty(exports, "BaseRequestPolicy", {
  enumerable: true,
  get: function () {
    return _requestPolicy.BaseRequestPolicy;
  }
});
Object.defineProperty(exports, "RequestPolicyOptions", {
  enumerable: true,
  get: function () {
    return _requestPolicy.RequestPolicyOptions;
  }
});
Object.defineProperty(exports, "generateClientRequestIdPolicy", {
  enumerable: true,
  get: function () {
    return _generateClientRequestIdPolicy.generateClientRequestIdPolicy;
  }
});
Object.defineProperty(exports, "exponentialRetryPolicy", {
  enumerable: true,
  get: function () {
    return _exponentialRetryPolicy.exponentialRetryPolicy;
  }
});
Object.defineProperty(exports, "RetryMode", {
  enumerable: true,
  get: function () {
    return _exponentialRetryPolicy.RetryMode;
  }
});
Object.defineProperty(exports, "systemErrorRetryPolicy", {
  enumerable: true,
  get: function () {
    return _systemErrorRetryPolicy.systemErrorRetryPolicy;
  }
});
Object.defineProperty(exports, "throttlingRetryPolicy", {
  enumerable: true,
  get: function () {
    return _throttlingRetryPolicy.throttlingRetryPolicy;
  }
});
Object.defineProperty(exports, "getDefaultProxySettings", {
  enumerable: true,
  get: function () {
    return _proxyPolicy.getDefaultProxySettings;
  }
});
Object.defineProperty(exports, "proxyPolicy", {
  enumerable: true,
  get: function () {
    return _proxyPolicy.proxyPolicy;
  }
});
Object.defineProperty(exports, "redirectPolicy", {
  enumerable: true,
  get: function () {
    return _redirectPolicy.redirectPolicy;
  }
});
Object.defineProperty(exports, "keepAlivePolicy", {
  enumerable: true,
  get: function () {
    return _keepAlivePolicy.keepAlivePolicy;
  }
});
Object.defineProperty(exports, "disableResponseDecompressionPolicy", {
  enumerable: true,
  get: function () {
    return _disableResponseDecompressionPolicy.disableResponseDecompressionPolicy;
  }
});
Object.defineProperty(exports, "signingPolicy", {
  enumerable: true,
  get: function () {
    return _signingPolicy.signingPolicy;
  }
});
Object.defineProperty(exports, "userAgentPolicy", {
  enumerable: true,
  get: function () {
    return _userAgentPolicy.userAgentPolicy;
  }
});
Object.defineProperty(exports, "getDefaultUserAgentValue", {
  enumerable: true,
  get: function () {
    return _userAgentPolicy.getDefaultUserAgentValue;
  }
});
Object.defineProperty(exports, "deserializationPolicy", {
  enumerable: true,
  get: function () {
    return _deserializationPolicy.deserializationPolicy;
  }
});
Object.defineProperty(exports, "deserializeResponseBody", {
  enumerable: true,
  get: function () {
    return _deserializationPolicy.deserializeResponseBody;
  }
});
Object.defineProperty(exports, "tracingPolicy", {
  enumerable: true,
  get: function () {
    return _tracingPolicy.tracingPolicy;
  }
});
Object.defineProperty(exports, "MapperType", {
  enumerable: true,
  get: function () {
    return _serializer.MapperType;
  }
});
Object.defineProperty(exports, "Serializer", {
  enumerable: true,
  get: function () {
    return _serializer.Serializer;
  }
});
Object.defineProperty(exports, "serializeObject", {
  enumerable: true,
  get: function () {
    return _serializer.serializeObject;
  }
});
Object.defineProperty(exports, "stripRequest", {
  enumerable: true,
  get: function () {
    return _utils.stripRequest;
  }
});
Object.defineProperty(exports, "stripResponse", {
  enumerable: true,
  get: function () {
    return _utils.stripResponse;
  }
});
Object.defineProperty(exports, "delay", {
  enumerable: true,
  get: function () {
    return _utils.delay;
  }
});
Object.defineProperty(exports, "executePromisesSequentially", {
  enumerable: true,
  get: function () {
    return _utils.executePromisesSequentially;
  }
});
Object.defineProperty(exports, "generateUuid", {
  enumerable: true,
  get: function () {
    return _utils.generateUuid;
  }
});
Object.defineProperty(exports, "encodeUri", {
  enumerable: true,
  get: function () {
    return _utils.encodeUri;
  }
});
Object.defineProperty(exports, "promiseToCallback", {
  enumerable: true,
  get: function () {
    return _utils.promiseToCallback;
  }
});
Object.defineProperty(exports, "promiseToServiceCallback", {
  enumerable: true,
  get: function () {
    return _utils.promiseToServiceCallback;
  }
});
Object.defineProperty(exports, "isValidUuid", {
  enumerable: true,
  get: function () {
    return _utils.isValidUuid;
  }
});
Object.defineProperty(exports, "applyMixins", {
  enumerable: true,
  get: function () {
    return _utils.applyMixins;
  }
});
Object.defineProperty(exports, "isNode", {
  enumerable: true,
  get: function () {
    return _utils.isNode;
  }
});
Object.defineProperty(exports, "isDuration", {
  enumerable: true,
  get: function () {
    return _utils.isDuration;
  }
});
Object.defineProperty(exports, "URLBuilder", {
  enumerable: true,
  get: function () {
    return _url.URLBuilder;
  }
});
Object.defineProperty(exports, "URLQuery", {
  enumerable: true,
  get: function () {
    return _url.URLQuery;
  }
});
Object.defineProperty(exports, "isTokenCredential", {
  enumerable: true,
  get: function () {
    return _coreAuth.isTokenCredential;
  }
});
Object.defineProperty(exports, "ExpiringAccessTokenCache", {
  enumerable: true,
  get: function () {
    return _accessTokenCache.ExpiringAccessTokenCache;
  }
});
Object.defineProperty(exports, "AccessTokenRefresher", {
  enumerable: true,
  get: function () {
    return _accessTokenRefresher.AccessTokenRefresher;
  }
});
Object.defineProperty(exports, "BasicAuthenticationCredentials", {
  enumerable: true,
  get: function () {
    return _basicAuthenticationCredentials.BasicAuthenticationCredentials;
  }
});
Object.defineProperty(exports, "ApiKeyCredentials", {
  enumerable: true,
  get: function () {
    return _apiKeyCredentials.ApiKeyCredentials;
  }
});
Object.defineProperty(exports, "TopicCredentials", {
  enumerable: true,
  get: function () {
    return _topicCredentials.TopicCredentials;
  }
});
Object.defineProperty(exports, "parseXML", {
  enumerable: true,
  get: function () {
    return _xml.parseXML;
  }
});
Object.defineProperty(exports, "stringifyXML", {
  enumerable: true,
  get: function () {
    return _xml.stringifyXML;
  }
});
Object.defineProperty(exports, "XML_ATTRKEY", {
  enumerable: true,
  get: function () {
    return _serializer2.XML_ATTRKEY;
  }
});
Object.defineProperty(exports, "XML_CHARKEY", {
  enumerable: true,
  get: function () {
    return _serializer2.XML_CHARKEY;
  }
});

var _webResource = require("./webResource");

var _defaultHttpClient = require("./defaultHttpClient");

var _httpHeaders = require("./httpHeaders");

var _httpPipelineLogLevel = require("./httpPipelineLogLevel");

var _restError = require("./restError");

var _operationOptions = require("./operationOptions");

var _serviceClient = require("./serviceClient");

var _createSpan = require("./createSpan");

var _queryCollectionFormat = require("./queryCollectionFormat");

var _constants = require("./util/constants");

var _bearerTokenAuthenticationPolicy = require("./policies/bearerTokenAuthenticationPolicy");

var _logPolicy = require("./policies/logPolicy");

var _requestPolicy = require("./policies/requestPolicy");

var _generateClientRequestIdPolicy = require("./policies/generateClientRequestIdPolicy");

var _exponentialRetryPolicy = require("./policies/exponentialRetryPolicy");

var _systemErrorRetryPolicy = require("./policies/systemErrorRetryPolicy");

var _throttlingRetryPolicy = require("./policies/throttlingRetryPolicy");

var _proxyPolicy = require("./policies/proxyPolicy");

var _redirectPolicy = require("./policies/redirectPolicy");

var _keepAlivePolicy = require("./policies/keepAlivePolicy");

var _disableResponseDecompressionPolicy = require("./policies/disableResponseDecompressionPolicy");

var _signingPolicy = require("./policies/signingPolicy");

var _userAgentPolicy = require("./policies/userAgentPolicy");

var _deserializationPolicy = require("./policies/deserializationPolicy");

var _tracingPolicy = require("./policies/tracingPolicy");

var _serializer = require("./serializer");

var _utils = require("./util/utils");

var _url = require("./url");

var _coreAuth = require("@azure/core-auth");

var _accessTokenCache = require("./credentials/accessTokenCache");

var _accessTokenRefresher = require("./credentials/accessTokenRefresher");

var _basicAuthenticationCredentials = require("./credentials/basicAuthenticationCredentials");

var _apiKeyCredentials = require("./credentials/apiKeyCredentials");

var _topicCredentials = require("./credentials/topicCredentials");

var _xml = require("./util/xml");

var _serializer2 = require("./util/serializer.common");
},{"./webResource":"xjLS","./defaultHttpClient":"CT7P","./httpHeaders":"wA5d","./httpPipelineLogLevel":"q4NL","./restError":"VBBg","./operationOptions":"I7lc","./serviceClient":"GHYw","./createSpan":"QEkd","./queryCollectionFormat":"T2Lt","./util/constants":"o95E","./policies/bearerTokenAuthenticationPolicy":"lKdS","./policies/logPolicy":"DhOT","./policies/requestPolicy":"ggtJ","./policies/generateClientRequestIdPolicy":"pXAS","./policies/exponentialRetryPolicy":"At7c","./policies/systemErrorRetryPolicy":"hlpJ","./policies/throttlingRetryPolicy":"kEMe","./policies/proxyPolicy":"Rd7P","./policies/redirectPolicy":"IlDT","./policies/keepAlivePolicy":"V02X","./policies/disableResponseDecompressionPolicy":"M6Qy","./policies/signingPolicy":"ZJzR","./policies/userAgentPolicy":"rhWY","./policies/deserializationPolicy":"dsuK","./policies/tracingPolicy":"Go6L","./serializer":"HiIJ","./util/utils":"DVp2","./url":"bBTP","@azure/core-auth":"Ujm9","./credentials/accessTokenCache":"WW12","./credentials/accessTokenRefresher":"CqC4","./credentials/basicAuthenticationCredentials":"nH4I","./credentials/apiKeyCredentials":"qOA9","./credentials/topicCredentials":"vNrv","./util/xml":"oKNo","./util/serializer.common":"KdvI"}],"IupI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logErrorStackTrace = logErrorStackTrace;
exports.createServiceBusLogger = createServiceBusLogger;
exports.managementClientLogger = exports.messageLogger = exports.administrationLogger = exports.connectionLogger = exports.senderLogger = exports.receiverLogger = exports.logger = void 0;

var _logger2 = require("@azure/logger");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * The @azure/logger configuration for this package.
 * This will output logs using the `azure:service-bus` namespace prefix.
 * @internal
 * @hidden
 */
const logger = createServiceBusLogger("service-bus");
/**
 * Logging for ServiceBusReceivers of any type (session, non-session)
 * @internal
 * @hidden
 */

exports.logger = logger;
const receiverLogger = createServiceBusLogger("service-bus:receiver");
/**
 * Logging for ServiceBusSenders
 * @internal
 * @hidden
 */

exports.receiverLogger = receiverLogger;
const senderLogger = createServiceBusLogger("service-bus:sender");
/**
 * Logging for connection management
 * @internal
 * @hidden
 */

exports.senderLogger = senderLogger;
const connectionLogger = createServiceBusLogger("service-bus:connection");
/**
 * Logging for the ServiceBusAdministrationClient
 * @internal
 * @hidden
 */

exports.connectionLogger = connectionLogger;
const administrationLogger = createServiceBusLogger("service-bus:administration");
/**
 * Logging related to message encoding/decoding.
 * @internal
 * @hidden
 */

exports.administrationLogger = administrationLogger;
const messageLogger = createServiceBusLogger("service-bus:messages");
/**
 * Logging related to message encoding/decoding.
 * @internal
 * @hidden
 */

exports.messageLogger = messageLogger;
const managementClientLogger = createServiceBusLogger("service-bus:management");
/**
 * Logs the error's stack trace to "verbose" if a stack trace is available.
 * @param error Error containing a stack trace.
 * @internal
 * @hidden
 */

exports.managementClientLogger = managementClientLogger;

function logErrorStackTrace(_logger, error) {
  if (error && error.stack) {
    _logger.verbose(error.stack);
  }
}
/**
 * Creates an AzureLogger with any additional methods for standardized logging (for example, with errors)
 * @internal
 * @hidden
 */


function createServiceBusLogger(namespace) {
  const _logger = (0, _logger2.createClientLogger)(namespace);

  _logger["logError"] = (err, ...args) => {
    let l; // abort errors are user initiated so we don't have to treat them as warnings, like we
    // would with other errors.

    if (isError(err) && err.name === "AbortError") {
      l = _logger.info;
    } else {
      l = _logger.warning;
    } // tack on the error object so it also gets logged.


    args.push(":", err); // let the normal formatting work and include the error at the end.

    l(...args); // optionally log the stack trace if it's available but this always goes to verbose

    if (err && err.stack) {
      _logger.verbose(err.stack);
    }
  };

  return _logger;
}
/**
 * @internal
 * @hidden
 */


function isError(err) {
  return err != null && err.name != null;
}
},{"@azure/logger":"JyPs"}],"kjjy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HttpResponseCodes = exports.ATOM_METADATA_MARKER = exports.XML_VALUE_MARKER = exports.XML_METADATA_MARKER = exports.ODATA_ERROR_MESSAGE_VALUE = exports.ODATA_ERROR_MESSAGE = exports.CURRENT_API_VERSION = exports.API_VERSION_QUERY_KEY = exports.FORWARD_DEADLETTERED_MESSAGES_TO = exports.ENABLE_PARTITIONING = exports.SUPPORT_ORDERING = exports.ENABLE_BATCHED_OPERATIONS = exports.MAX_DELIVERY_COUNT = exports.DUPLICATE_DETECTION_HISTORY_TIME_WINDOW = exports.DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS = exports.DEAD_LETTERING_ON_MESSAGE_EXPIRATION = exports.REQUIRES_DUPLICATE_DETECTION = exports.REQUIRES_SESSION = exports.LOCK_DURATION = exports.DEFAULT_MESSAGE_TIME_TO_LIVE = exports.MAX_SIZE_IN_MEGABYTES = exports.USER_METADATA = exports.FORWARD_TO = exports.STATUS = exports.AUTO_DELETE_ON_IDLE = exports.DEFAULT_RULE_NAME = exports.COUNT_DETAILS = exports.SUBSCRIPTION_COUNT = exports.MESSAGE_COUNT = exports.SIZE_IN_BYTES = exports.FILTER_MESSAGES_BEFORE_PUBLISHING = exports.ENABLE_SUBSCRIPTION_PARTITIONING = exports.IS_EXPRESS = exports.ENABLE_EXPRESS = exports.ENTITY_AVAILABILITY_STATUS = exports.IS_ANONYMOUS_ACCESSIBLE = exports.AUTHORIZATION_RULES = exports.CREATED_AT = exports.UPDATED_AT = exports.ACCESSED_AT = exports.RULE_NAME = exports.SUBSCRIPTION_NAME = exports.TOPIC_NAME = exports.QUEUE_NAME = exports.max32BitNumber = exports.messageDispositionTimeout = exports.packageJsonInfo = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 */
const packageJsonInfo = {
  name: "@azure/service-bus",
  version: "7.0.3"
};
/**
 * @internal
 * @hidden
 */

exports.packageJsonInfo = packageJsonInfo;
const messageDispositionTimeout = 20000;
/**
 * @internal
 * @hidden
 */

exports.messageDispositionTimeout = messageDispositionTimeout;
const max32BitNumber = Math.pow(2, 31) - 1;
/**
 * Queue name identifier
 * @internal
 * @hidden
 */

exports.max32BitNumber = max32BitNumber;
const QUEUE_NAME = "QueueName";
/**
 * Topic name identifier
 * @internal
 * @hidden
 */

exports.QUEUE_NAME = QUEUE_NAME;
const TOPIC_NAME = "TopicName";
/**
 * Subscription name identifier
 * @internal
 * @hidden
 */

exports.TOPIC_NAME = TOPIC_NAME;
const SUBSCRIPTION_NAME = "SubscriptionName";
/**
 * Rule name identifier
 * @internal
 * @hidden
 */

exports.SUBSCRIPTION_NAME = SUBSCRIPTION_NAME;
const RULE_NAME = "RuleName";
/**
 * Accessed at field
 * @internal
 * @hidden
 */

exports.RULE_NAME = RULE_NAME;
const ACCESSED_AT = "AccessedAt";
/**
 * Updated at field
 * @internal
 * @hidden
 */

exports.ACCESSED_AT = ACCESSED_AT;
const UPDATED_AT = "UpdatedAt";
/**
 * Created at field
 * @internal
 * @hidden
 */

exports.UPDATED_AT = UPDATED_AT;
const CREATED_AT = "CreatedAt";
/**
 * Authorization rules on the entity
 * @internal
 * @hidden
 */

exports.CREATED_AT = CREATED_AT;
const AUTHORIZATION_RULES = "AuthorizationRules";
/**
 * Is Anonymous Accessible field
 * @internal
 * @hidden
 */

exports.AUTHORIZATION_RULES = AUTHORIZATION_RULES;
const IS_ANONYMOUS_ACCESSIBLE = "IsAnonymousAccessible";
/**
 * Entity Availability Status field
 * @internal
 * @hidden
 */

exports.IS_ANONYMOUS_ACCESSIBLE = IS_ANONYMOUS_ACCESSIBLE;
const ENTITY_AVAILABILITY_STATUS = "EntityAvailabilityStatus";
/**
 * Enable express option
 * @internal
 * @hidden
 */

exports.ENTITY_AVAILABILITY_STATUS = ENTITY_AVAILABILITY_STATUS;
const ENABLE_EXPRESS = "EnableExpress";
/**
 * Is express option
 * @internal
 * @hidden
 */

exports.ENABLE_EXPRESS = ENABLE_EXPRESS;
const IS_EXPRESS = "IsExpress";
/**
 * Enable Subscription Partitioning option
 * @internal
 * @hidden
 */

exports.IS_EXPRESS = IS_EXPRESS;
const ENABLE_SUBSCRIPTION_PARTITIONING = "EnableSubscriptionPartitioning";
/**
 * Filtering Messages Before Publishing option
 * @internal
 * @hidden
 */

exports.ENABLE_SUBSCRIPTION_PARTITIONING = ENABLE_SUBSCRIPTION_PARTITIONING;
const FILTER_MESSAGES_BEFORE_PUBLISHING = "FilteringMessagesBeforePublishing";
/**
 * The entity's size in bytes.
 *
 * @internal
 * @hidden
 */

exports.FILTER_MESSAGES_BEFORE_PUBLISHING = FILTER_MESSAGES_BEFORE_PUBLISHING;
const SIZE_IN_BYTES = "SizeInBytes";
/**
 * The entity's message count.
 *
 * @internal
 * @hidden
 */

exports.SIZE_IN_BYTES = SIZE_IN_BYTES;
const MESSAGE_COUNT = "MessageCount";
/**
 * The topic's subscription count.
 *
 * @internal
 * @hidden
 */

exports.MESSAGE_COUNT = MESSAGE_COUNT;
const SUBSCRIPTION_COUNT = "SubscriptionCount";
/**
 * The topic / subscription's count details.
 *
 * @internal
 * @hidden
 */

exports.SUBSCRIPTION_COUNT = SUBSCRIPTION_COUNT;
const COUNT_DETAILS = "CountDetails";
/**
 * The default rule name.
 *
 * @internal
 * @hidden
 */

exports.COUNT_DETAILS = COUNT_DETAILS;
const DEFAULT_RULE_NAME = "$Default";
/**
 * Max idle time before entity is deleted.
 * This is specified in ISO-8601 duration format such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
 * @internal
 * @hidden
 */

exports.DEFAULT_RULE_NAME = DEFAULT_RULE_NAME;
const AUTO_DELETE_ON_IDLE = "AutoDeleteOnIdle";
/**
 * The status information on response
 *
 * @internal
 * @hidden
 */

exports.AUTO_DELETE_ON_IDLE = AUTO_DELETE_ON_IDLE;
const STATUS = "Status";
/**
 * The URL of Service Bus entity to forward messages to.
 *
 * @internal
 * @hidden
 */

exports.STATUS = STATUS;
const FORWARD_TO = "ForwardTo";
/**
 * The user meta data information
 *
 * @internal
 * @hidden
 */

exports.FORWARD_TO = FORWARD_TO;
const USER_METADATA = "UserMetadata";
/**
 * The maximum size in megabytes.
 *
 * @internal
 * @hidden
 */

exports.USER_METADATA = USER_METADATA;
const MAX_SIZE_IN_MEGABYTES = "MaxSizeInMegabytes";
/**
 * The default message time to live.
 * This is specified in ISO-8601 duration format such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
 * @internal
 * @hidden
 */

exports.MAX_SIZE_IN_MEGABYTES = MAX_SIZE_IN_MEGABYTES;
const DEFAULT_MESSAGE_TIME_TO_LIVE = "DefaultMessageTimeToLive";
/**
 * The lock duration.
 * This is specified in ISO-8601 duration format such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
 * @internal
 * @hidden
 */

exports.DEFAULT_MESSAGE_TIME_TO_LIVE = DEFAULT_MESSAGE_TIME_TO_LIVE;
const LOCK_DURATION = "LockDuration";
/**
 * The indication if session is required or not.
 *
 * @internal
 * @hidden
 */

exports.LOCK_DURATION = LOCK_DURATION;
const REQUIRES_SESSION = "RequiresSession";
/**
 * The indication if duplicate detection is required or not.
 *
 * @internal
 * @hidden
 */

exports.REQUIRES_SESSION = REQUIRES_SESSION;
const REQUIRES_DUPLICATE_DETECTION = "RequiresDuplicateDetection";
/**
 * The indication if dead lettering on message expiration. If it is enabled and a message expires,
 * the Service Bus moves the message from the queue into the entity dead-letter sub-queue.
 * If disabled, message will be permanently deleted from the main entity.
 * Settable only at entity creation time.
 *
 * @internal
 * @hidden
 */

exports.REQUIRES_DUPLICATE_DETECTION = REQUIRES_DUPLICATE_DETECTION;
const DEAD_LETTERING_ON_MESSAGE_EXPIRATION = "DeadLetteringOnMessageExpiration";
/**
 * The indication if dead lettering on filter evaluation exceptions.
 *
 * @internal
 * @hidden
 */

exports.DEAD_LETTERING_ON_MESSAGE_EXPIRATION = DEAD_LETTERING_ON_MESSAGE_EXPIRATION;
const DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS = "DeadLetteringOnFilterEvaluationExceptions";
/**
 * The history time window for duplicate detection.
 * This is specified in ISO-8601 duration format such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
 * @internal
 * @hidden
 */

exports.DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS = DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS;
const DUPLICATE_DETECTION_HISTORY_TIME_WINDOW = "DuplicateDetectionHistoryTimeWindow";
/**
 * The maximum delivery count of messages after which if it is still not settled, gets moved to the dead-letter sub-queue.
 *
 * @internal
 * @hidden
 */

exports.DUPLICATE_DETECTION_HISTORY_TIME_WINDOW = DUPLICATE_DETECTION_HISTORY_TIME_WINDOW;
const MAX_DELIVERY_COUNT = "MaxDeliveryCount";
/**
 * Indicates if the queue has enabled batch operations.
 *
 * @internal
 * @hidden
 */

exports.MAX_DELIVERY_COUNT = MAX_DELIVERY_COUNT;
const ENABLE_BATCHED_OPERATIONS = "EnableBatchedOperations";
/**
 * Indicates whether the topic can be ordered
 *
 * @internal
 * @hidden
 */

exports.ENABLE_BATCHED_OPERATIONS = ENABLE_BATCHED_OPERATIONS;
const SUPPORT_ORDERING = "SupportOrdering";
/**
 * Indicates whether the topic/queue should be split across multiple partitions
 *
 * @internal
 * @hidden
 */

exports.SUPPORT_ORDERING = SUPPORT_ORDERING;
const ENABLE_PARTITIONING = "EnablePartitioning";
/**
 * The URL of Service Bus entity to forward deadlettered messages to.
 *
 * @internal
 * @hidden
 */

exports.ENABLE_PARTITIONING = ENABLE_PARTITIONING;
const FORWARD_DEADLETTERED_MESSAGES_TO = "ForwardDeadLetteredMessagesTo";
/**
 * Query string parameter to set Service Bus API version
 *
 * @internal
 * @hidden
 */

exports.FORWARD_DEADLETTERED_MESSAGES_TO = FORWARD_DEADLETTERED_MESSAGES_TO;
const API_VERSION_QUERY_KEY = "api-version";
/**
 * Current API version being sent to service bus
 *
 * @internal
 * @hidden
 */

exports.API_VERSION_QUERY_KEY = API_VERSION_QUERY_KEY;
const CURRENT_API_VERSION = "2017-04";
/**
 * Constant representing the Odata Error 'message' property
 *
 * @internal
 * @hidden
 */

exports.CURRENT_API_VERSION = CURRENT_API_VERSION;
const ODATA_ERROR_MESSAGE = "message";
/**
 * Constant representing the 'value' property of Odata Error 'message' property
 *
 * @internal
 * @hidden
 */

exports.ODATA_ERROR_MESSAGE = ODATA_ERROR_MESSAGE;
const ODATA_ERROR_MESSAGE_VALUE = "value";
/**
 * Marker for atom metadata.
 *
 * @internal
 * @hidden
 */

exports.ODATA_ERROR_MESSAGE_VALUE = ODATA_ERROR_MESSAGE_VALUE;
const XML_METADATA_MARKER = "$";
/**
 * Marker for atom value.
 *
 * @internal
 * @hidden
 */

exports.XML_METADATA_MARKER = XML_METADATA_MARKER;
const XML_VALUE_MARKER = "_";
/**
 * Constant representing the property where the atom default elements are stored.
 *
 * @internal
 * @hidden
 */

exports.XML_VALUE_MARKER = XML_VALUE_MARKER;
const ATOM_METADATA_MARKER = "_";
/**
 * Known HTTP status codes as documented and referenced in ATOM based management API feature
 * https://docs.microsoft.com/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
 * @internal
 * @hidden
 */

exports.ATOM_METADATA_MARKER = ATOM_METADATA_MARKER;
const HttpResponseCodes = {
  100: "Continue",
  101: "SwitchingProtocols",
  200: "Ok",
  201: "Created",
  202: "Accepted",
  203: "NonAuthoritativeInformation",
  204: "NoContent",
  205: "ResetContent",
  206: "PartialContent",
  300: "MultipleChoices",
  301: "Moved",
  302: "Redirect",
  303: "RedirectMethod",
  304: "NotModified",
  305: "UseProxy",
  306: "Unused",
  400: "BadRequest",
  401: "Unauthorized",
  402: "PaymentRequired",
  403: "Forbidden",
  404: "NotFound",
  405: "MethodNotAllowed",
  406: "NotAcceptable",
  407: "ProxyAuthenticationRequired",
  409: "Conflict",
  410: "Gone",
  411: "LengthRequired",
  412: "PreconditionFailed",
  413: "RequestEntityTooLarge",
  414: "RequestUriTooLong",
  415: "UnsupportedMediaType",
  416: "RequestRangeNotSatisfiable",
  417: "ExpectationFailed",
  426: "UpgradeRequired",
  500: "InternalServerError",
  501: "NotImplemented",
  502: "BadGateway",
  503: "ServiceUnavailable",
  504: "GatewayTimeout",
  505: "HttpVersionNotSupported"
};
exports.HttpResponseCodes = HttpResponseCodes;
},{}],"U2FQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseURL = void 0;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

/**
 * @internal
 * @hidden
 * @param {string} rawUrl
 */
const parseURL = rawUrl => {
  // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
  // @ts-ignore: "self" will exist in the browser.
  return new self.URL(rawUrl);
};

exports.parseURL = parseURL;
},{}],"YA3p":[function(require,module,exports) {
module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};

},{}],"yQtW":[function(require,module,exports) {
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
module.exports = function isBuffer(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
};
},{}],"RXMg":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUniqueName = getUniqueName;
exports.reorderLockToken = reorderLockToken;
exports.calculateRenewAfterDuration = calculateRenewAfterDuration;
exports.convertTicksToDate = convertTicksToDate;
exports.getProcessorCount = getProcessorCount;
exports.toBuffer = toBuffer;
exports.getString = getString;
exports.getStringOrUndefined = getStringOrUndefined;
exports.getInteger = getInteger;
exports.getIntegerOrUndefined = getIntegerOrUndefined;
exports.getDate = getDate;
exports.getBoolean = getBoolean;
exports.getBooleanOrUndefined = getBooleanOrUndefined;
exports.isJSONLikeObject = isJSONLikeObject;
exports.getMessageCountDetails = getMessageCountDetails;
exports.getXMLNSPrefix = getXMLNSPrefix;
exports.getAuthorizationRulesOrUndefined = getAuthorizationRulesOrUndefined;
exports.getRawAuthorizationRules = getRawAuthorizationRules;
exports.isAbsoluteUrl = isAbsoluteUrl;
exports.waitForTimeoutOrAbortOrResolve = waitForTimeoutOrAbortOrResolve;
exports.checkAndRegisterWithAbortSignal = checkAndRegisterWithAbortSignal;
exports.formatUserAgentPrefix = formatUserAgentPrefix;
exports.getHttpResponseOnly = exports.libInfo = exports.StandardAbortMessage = void 0;

var _tslib = require("tslib");

var _long = _interopRequireDefault(require("long"));

var _log = require("../log");

var _rheaPromise = require("rhea-promise");

var _isBuffer = _interopRequireDefault(require("is-buffer"));

var _buffer = require("buffer");

var Constants = _interopRequireWildcard(require("../util/constants"));

var _abortController = require("@azure/abort-controller");

var _coreHttp = require("@azure/core-http");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * Provides a uniue name by appending a string guid to the given string in the following format:
 * `{name}-{uuid}`.
 * @param name The nme of the entity
 */
function getUniqueName(name) {
  return `${name}-${(0, _rheaPromise.generate_uuid)()}`;
}
/**
 * @internal
 * @hidden
 * If you try to turn a Guid into a Buffer in .NET, the bytes of the first three groups get
 * flipped within the group, but the last two groups don't get flipped, so we end up with a
 * different byte order. This is the order of bytes needed to make Service Bus recognize the token.
 *
 * @param lockToken The lock token whose bytes need to be reorded.
 * @returns Buffer - Buffer representing reordered bytes.
 */


function reorderLockToken(lockTokenBytes) {
  if (!lockTokenBytes || !_buffer.Buffer.isBuffer(lockTokenBytes)) {
    return lockTokenBytes;
  }

  return _buffer.Buffer.from([lockTokenBytes[3], lockTokenBytes[2], lockTokenBytes[1], lockTokenBytes[0], lockTokenBytes[5], lockTokenBytes[4], lockTokenBytes[7], lockTokenBytes[6], lockTokenBytes[8], lockTokenBytes[9], lockTokenBytes[10], lockTokenBytes[11], lockTokenBytes[12], lockTokenBytes[13], lockTokenBytes[14], lockTokenBytes[15]]);
}
/**
 * @internal
 * @hidden
 * Provides the time in milliseconds after which the lock renewal should occur.
 * @param lockedUntilUtc - The time until which the message is locked.
 */


function calculateRenewAfterDuration(lockedUntilUtc) {
  const now = Date.now();
  const lockedUntil = lockedUntilUtc.getTime();
  const remainingTime = lockedUntil - now;

  _log.receiverLogger.verbose("Locked until utc  : %d", lockedUntil);

  _log.receiverLogger.verbose("Current time is   : %d", now);

  _log.receiverLogger.verbose("Remaining time is : %d", remainingTime);

  if (remainingTime < 1000) {
    return 0;
  }

  const buffer = Math.min(remainingTime / 2, 10000); // 10 seconds

  const renewAfter = remainingTime - buffer;

  _log.receiverLogger.verbose("Renew after       : %d", renewAfter);

  return renewAfter;
}
/**
 * @internal
 * @hidden
 * Converts the .net ticks to a JS Date object.
 *
 * - The epoch for the DateTimeOffset type is `0000-01-01`, while the epoch for JS Dates is
 * `1970-01-01`.
 * - The DateTimeOffset ticks value for the date `1970-01-01` is `621355968000000000`.
 *   - Hence, to convert it to the JS epoch; we `subtract` the delta from the given value.
 * - Ticks in DateTimeOffset is `1/10000000` second, while ticks in JS Date is `1/1000` second.
 *   - Thus, we `divide` the value by `10000` to convert it to JS Date ticks.
 *
 * @param buf Input as a Buffer
 * @returns Date The JS Date object.
 */


function convertTicksToDate(buf) {
  const epochMicroDiff = 621355968000000000;

  const longValue = _long.default.fromBytesBE(buf);

  const timeInMS = longValue.sub(epochMicroDiff).div(10000).toNumber();
  const result = new Date(timeInMS);

  _log.logger.verbose("The converted date is: %s", result.toString());

  return result;
}
/**
 * @internal
 * @hidden
 * Returns the number of logical processors in the system.
 */


function getProcessorCount() {
  if (_coreHttp.isNode) {
    const os = require("os");

    return os.cpus().length;
  } else {
    return navigator.hardwareConcurrency || 1;
  }
}
/**
 * @internal
 * @hidden
 * Converts any given input to a Buffer.
 * @param input The input that needs to be converted to a Buffer.
 */


function toBuffer(input) {
  let result;

  _log.messageLogger.verbose("[utils.toBuffer] The given message body that needs to be converted to buffer is: ", input);

  if ((0, _isBuffer.default)(input)) {
    result = input;
  } else {
    // string, undefined, null, boolean, array, object, number should end up here
    // coercing undefined to null as that will ensure that null value will be given to the
    // customer on receive.
    if (input === undefined) input = null;

    try {
      const inputStr = JSON.stringify(input);
      result = _buffer.Buffer.from(inputStr, "utf8");
    } catch (err) {
      const msg = `An error occurred while executing JSON.stringify() on the given input ` + input + `${err instanceof Error ? err.stack : JSON.stringify(err)}`;

      _log.messageLogger.warning("[utils.toBuffer] " + msg);

      throw err instanceof Error ? err : new Error(msg);
    }
  }

  _log.messageLogger.verbose("[utils.toBuffer] The converted buffer is: %O.", result);

  return result;
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve `string` value from given string,
 * or throws error if undefined.
 * @param value
 */


function getString(value, nameOfProperty) {
  const result = getStringOrUndefined(value);

  if (result == undefined) {
    throw new Error(`"${nameOfProperty}" received from service expected to be a string value and not undefined.`);
  }

  return result;
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve `string` value from given input,
 * or undefined if not passed in.
 * @param value
 */


function getStringOrUndefined(value) {
  if (value == undefined) {
    return undefined;
  }

  return value.toString();
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve `integer` value from given string,
 * or throws error if undefined.
 * @param value
 */


function getInteger(value, nameOfProperty) {
  const result = getIntegerOrUndefined(value);

  if (result == undefined) {
    throw new Error(`"${nameOfProperty}" received from service expected to be a number value and not undefined.`);
  }

  return result;
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve `integer` value from given string,
 * or undefined if not passed in.
 * @param value
 */


function getIntegerOrUndefined(value) {
  if (value == undefined) {
    return undefined;
  }

  const result = parseInt(value.toString());
  return result == NaN ? undefined : result;
}
/**
 * @internal
 * @hidden
 * Helper utility to convert ISO-8601 time into Date type.
 * @param value
 */


function getDate(value, nameOfProperty) {
  return new Date(getString(value, nameOfProperty));
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve `boolean` value from given string,
 * or throws error if undefined.
 * @param value
 */


function getBoolean(value, nameOfProperty) {
  const result = getBooleanOrUndefined(value);

  if (result == undefined) {
    throw new Error(`"${nameOfProperty}" received from service expected to be a boolean value and not undefined.`);
  }

  return result;
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve `boolean` value from given string,
 * or undefined if not passed in.
 * @param value
 */


function getBooleanOrUndefined(value) {
  if (value == undefined) {
    return undefined;
  }

  return value.toString().trim().toLowerCase() === "true";
}
/**
 * @internal
 * @hidden
 * Helps in differentiating JSON like objects from other kinds of objects.
 */


const EMPTY_JSON_OBJECT_CONSTRUCTOR = {}.constructor;
/**
 * @internal
 * @hidden
 * Returns `true` if given input is a JSON like object.
 * @param value
 */

function isJSONLikeObject(value) {
  // `value.constructor === {}.constructor` differentiates among the "object"s,
  //    would filter the JSON objects and won't match any array or other kinds of objects
  // -------------------------------------------------------------------------------
  // Few examples       | typeof obj ==="object" |  obj.constructor==={}.constructor
  // -------------------------------------------------------------------------------
  // {abc:1}            | true                   | true
  // ["a","b"]          | true                   | false
  // [{"a":1},{"b":2}]  | true                   | false
  // new Date()         | true                   | false
  // 123                | false                  | false
  // -------------------------------------------------------------------------------
  return typeof value === "object" && value.constructor === EMPTY_JSON_OBJECT_CONSTRUCTOR;
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve message count details from given input,
 * @param value
 */


function getMessageCountDetails(value) {
  const xmlnsPrefix = getXMLNSPrefix(value);

  if (value == undefined) {
    value = {};
  }

  return {
    activeMessageCount: parseInt(value[`${xmlnsPrefix}:ActiveMessageCount`]) || 0,
    deadLetterMessageCount: parseInt(value[`${xmlnsPrefix}:DeadLetterMessageCount`]) || 0,
    scheduledMessageCount: parseInt(value[`${xmlnsPrefix}:ScheduledMessageCount`]) || 0,
    transferMessageCount: parseInt(value[`${xmlnsPrefix}:TransferMessageCount`]) || 0,
    transferDeadLetterMessageCount: parseInt(value[`${xmlnsPrefix}:TransferDeadLetterMessageCount`]) || 0
  };
}
/**
 * @internal
 * @hidden
 * Gets the xmlns prefix from the root of the objects that are part of the parsed response body.
 */


function getXMLNSPrefix(value) {
  if (!value[Constants.XML_METADATA_MARKER]) {
    throw new Error(`Error occurred while parsing the response body - cannot find the XML_METADATA_MARKER "$" on the object ${JSON.stringify(value)}`);
  }

  const keys = Object.keys(value[Constants.XML_METADATA_MARKER]);

  if (keys.length !== 1) {
    throw new Error(`Error occurred while parsing the response body - unexpected number of "xmlns:\${prefix}" keys at ${JSON.stringify(value[Constants.XML_METADATA_MARKER])}`);
  }

  if (!keys[0].startsWith("xmlns:")) {
    throw new Error(`Error occurred while parsing the response body - unexpected key at ${JSON.stringify(value[Constants.XML_METADATA_MARKER])}`);
  } // Pick the substring that's after "xmlns:"


  const xmlnsPrefix = keys[0].substring(6);

  if (!xmlnsPrefix) {
    throw new Error(`Error occurred while parsing the response body - unexpected xmlns prefix at ${JSON.stringify(value[Constants.XML_METADATA_MARKER])}`);
  }

  return xmlnsPrefix;
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve array of `AuthorizationRule` from given input,
 * or undefined if not passed in.
 * @param value
 */


function getAuthorizationRulesOrUndefined(value) {
  const authorizationRules = []; // Ignore special case as Service Bus treats "" as a valid value for authorization rules

  if (typeof value === "string" && value.trim() === "") {
    return undefined;
  }

  if (value == undefined) {
    return undefined;
  }

  const rawAuthorizationRules = value.AuthorizationRule;

  if (Array.isArray(rawAuthorizationRules)) {
    for (let i = 0; i < rawAuthorizationRules.length; i++) {
      authorizationRules.push(buildAuthorizationRule(rawAuthorizationRules[i]));
    }
  } else {
    authorizationRules.push(buildAuthorizationRule(rawAuthorizationRules));
  }

  return authorizationRules;
}
/**
 * @internal
 * @hidden
 * Helper utility to build an instance of parsed authorization rule as `AuthorizationRule` from given input.
 * @param value
 */


function buildAuthorizationRule(value) {
  let accessRights;

  if (value["Rights"] != undefined) {
    accessRights = value["Rights"]["AccessRights"];
  }

  const authorizationRule = {
    claimType: value["ClaimType"],
    accessRights,
    keyName: value["KeyName"],
    primaryKey: value["PrimaryKey"],
    secondaryKey: value["SecondaryKey"]
  };

  if (authorizationRule.accessRights && !Array.isArray(authorizationRule.accessRights)) {
    authorizationRule.accessRights = [authorizationRule.accessRights];
  }

  return authorizationRule;
}
/**
 * @internal
 * @hidden
 * Helper utility to extract output containing array of `RawAuthorizationRule` instances from given input,
 * or undefined if not passed in.
 * @param value
 */


function getRawAuthorizationRules(authorizationRules) {
  if (authorizationRules == undefined) {
    return undefined;
  }

  if (!Array.isArray(authorizationRules)) {
    throw new TypeError(`authorizationRules must be an array of AuthorizationRule objects or undefined, but received ${JSON.stringify(authorizationRules, undefined, 2)}`);
  }

  const rawAuthorizationRules = [];

  for (let i = 0; i < authorizationRules.length; i++) {
    rawAuthorizationRules.push(buildRawAuthorizationRule(authorizationRules[i]));
  }

  return {
    AuthorizationRule: rawAuthorizationRules
  };
}
/**
 * @internal
 * @hidden
 * Helper utility to build an instance of raw authorization rule as RawAuthorizationRule from given `AuthorizationRule` input.
 * @param authorizationRule parsed Authorization Rule instance
 */


function buildRawAuthorizationRule(authorizationRule) {
  if (!isJSONLikeObject(authorizationRule) || authorizationRule === null) {
    throw new TypeError(`Expected authorizationRule input to be a JS object value, but received ${JSON.stringify(authorizationRule, undefined, 2)}`);
  }

  const rawAuthorizationRule = {
    ClaimType: authorizationRule.claimType,
    // ClaimValue is not settable by the users, but service expects the value for PUT requests
    ClaimValue: "None",
    Rights: {
      AccessRights: authorizationRule.accessRights
    },
    KeyName: authorizationRule.keyName,
    PrimaryKey: authorizationRule.primaryKey,
    SecondaryKey: authorizationRule.secondaryKey
  };
  rawAuthorizationRule[Constants.XML_METADATA_MARKER] = {
    "p5:type": "SharedAccessAuthorizationRule",
    "xmlns:p5": "http://www.w3.org/2001/XMLSchema-instance"
  };
  return rawAuthorizationRule;
}
/**
 * @internal
 * @hidden
 * Helper utility to check if given string is an absolute URL
 * @param url
 */


function isAbsoluteUrl(url) {
  const _url = url.toLowerCase();

  return _url.startsWith("sb://") || _url.startsWith("http://") || _url.startsWith("https://");
}
/**
 * @internal
 * @hidden
 */


const StandardAbortMessage = "The operation was aborted.";
/**
 * An executor for a function that returns a Promise that obeys both a timeout and an
 * optional AbortSignal.
 * @param timeoutMs - The number of milliseconds to allow before throwing an OperationTimeoutError.
 * @param timeoutMessage - The message to place in the .description field for the thrown exception for Timeout.
 * @param abortSignal - The abortSignal associated with containing operation.
 * @param abortErrorMsg - The abort error message associated with containing operation.
 * @param value - The value to be resolved with after a timeout of t milliseconds.
 * @returns {Promise<T>} - Resolved promise
 *
 * @internal
 * @hidden
 */

exports.StandardAbortMessage = StandardAbortMessage;

function waitForTimeoutOrAbortOrResolve(args) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
    if (args.abortSignal && args.abortSignal.aborted) {
      throw new _abortController.AbortError(StandardAbortMessage);
    }

    let timer = undefined;
    let clearAbortSignal = undefined;

    const clearAbortSignalAndTimer = () => {
      var _a, _b;

      ((_b = (_a = args.timeoutFunctions) === null || _a === void 0 ? void 0 : _a.clearTimeoutFn) !== null && _b !== void 0 ? _b : clearTimeout)(timer);

      if (clearAbortSignal) {
        clearAbortSignal();
      }
    }; // eslint-disable-next-line promise/param-names


    const abortOrTimeoutPromise = new Promise((_resolve, reject) => {
      var _a, _b;

      clearAbortSignal = checkAndRegisterWithAbortSignal(reject, args.abortSignal);
      timer = ((_b = (_a = args.timeoutFunctions) === null || _a === void 0 ? void 0 : _a.setTimeoutFn) !== null && _b !== void 0 ? _b : setTimeout)(() => {
        reject(new _rheaPromise.OperationTimeoutError(args.timeoutMessage));
      }, args.timeoutMs);
    });

    try {
      return yield Promise.race([abortOrTimeoutPromise, args.actionFn()]);
    } finally {
      clearAbortSignalAndTimer();
    }
  });
}
/**
 * Registers listener to the abort event on the abortSignal to call your abortFn and
 * returns a function that will clear the same listener.
 *
 * If abort signal is already aborted, then throws an AbortError and returns a function that does nothing
 *
 * @returns A function that removes any of our attached event listeners on the abort signal or an empty function if
 * the abortSignal was not defined.
 *
 * @internal
 * @hidden
 */


function checkAndRegisterWithAbortSignal(onAbortFn, abortSignal) {
  if (abortSignal == null) {
    return () => {};
  }

  if (abortSignal.aborted) {
    throw new _abortController.AbortError(StandardAbortMessage);
  }

  const onAbort = () => {
    abortSignal.removeEventListener("abort", onAbort);
    onAbortFn(new _abortController.AbortError(StandardAbortMessage));
  };

  abortSignal.addEventListener("abort", onAbort);
  return () => abortSignal.removeEventListener("abort", onAbort);
}
/**
 * @internal
 * @hidden
 * @property {string} libInfo The user agent prefix string for the ServiceBus client.
 * See guideline at https://azure.github.io/azure-sdk/general_azurecore.html#telemetry-policy
 */


const libInfo = `azsdk-js-azureservicebus/${Constants.packageJsonInfo.version}`;
/**
 * @internal
 * @hidden
 * Returns the formatted prefix by removing the spaces, by appending the libInfo.
 *
 * @param {string} [prefix]
 * @returns {string}
 */

exports.libInfo = libInfo;

function formatUserAgentPrefix(prefix) {
  let userAgentPrefix = `${(prefix || "").replace(" ", "")}`;
  userAgentPrefix = userAgentPrefix.length > 0 ? userAgentPrefix + " " : "";
  return `${userAgentPrefix}${libInfo}`;
}
/**
 * @internal
 * @hidden
 * Helper method which returns `HttpResponse` from an object of shape `HttpOperationResponse`.
 * @returns {HttpResponse}
 */


const getHttpResponseOnly = ({
  request,
  status,
  headers
}) => ({
  request,
  status,
  headers
});

exports.getHttpResponseOnly = getHttpResponseOnly;
},{"tslib":"CvJj","long":"YA3p","../log":"IupI","rhea-promise":"fxSK","is-buffer":"yQtW","buffer":"z1tx","../util/constants":"kjjy","@azure/abort-controller":"wyb9","@azure/core-http":"rj0o","os":"war4"}],"tZXy":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.executeAtomXmlOperation = executeAtomXmlOperation;
exports.sanitizeSerializableObject = sanitizeSerializableObject;
exports.serializeToAtomXmlRequest = serializeToAtomXmlRequest;
exports.deserializeAtomXmlResponse = deserializeAtomXmlResponse;
exports.buildError = buildError;

var _tslib = require("tslib");

var _coreHttp = require("@azure/core-http");

var Constants = _interopRequireWildcard(require("./constants"));

var _log = require("../log");

var _buffer = require("buffer");

var _parseUrl = require("./parseUrl");

var _utils = require("./utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * Utility to execute Atom XML operations as HTTP requests
 * @param webResource
 * @param serializer
 */
function executeAtomXmlOperation(serviceBusAtomManagementClient, webResource, serializer, operationOptions) {
  var _a, _b, _c, _d, _e;

  return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
    if (webResource.body) {
      const content = serializer.serialize(webResource.body);
      webResource.body = (0, _coreHttp.stringifyXML)(content, {
        rootName: "entry"
      });
    }

    if (webResource.method == "PUT") {
      webResource.headers.set("content-length", _buffer.Buffer.byteLength(webResource.body));
    }

    _log.administrationLogger.verbose(`Executing ATOM based HTTP request: ${webResource.body}`);

    const reqPrepareOptions = Object.assign(Object.assign({}, webResource), {
      headers: (_a = operationOptions.requestOptions) === null || _a === void 0 ? void 0 : _a.customHeaders,
      onUploadProgress: (_b = operationOptions.requestOptions) === null || _b === void 0 ? void 0 : _b.onUploadProgress,
      onDownloadProgress: (_c = operationOptions.requestOptions) === null || _c === void 0 ? void 0 : _c.onDownloadProgress,
      abortSignal: operationOptions.abortSignal,
      spanOptions: (_d = operationOptions.tracingOptions) === null || _d === void 0 ? void 0 : _d.spanOptions,
      disableJsonStringifyOnBody: true
    });
    webResource = webResource.prepare(reqPrepareOptions);
    webResource.timeout = ((_e = operationOptions.requestOptions) === null || _e === void 0 ? void 0 : _e.timeout) || 0;
    const response = yield serviceBusAtomManagementClient.sendRequest(webResource);

    _log.administrationLogger.verbose(`Received ATOM based HTTP response: ${response.bodyAsText}`);

    try {
      if (response.bodyAsText) {
        response.parsedBody = yield (0, _coreHttp.parseXML)(response.bodyAsText, {
          includeRoot: true
        });
      }
    } catch (err) {
      const error = new _coreHttp.RestError(`Error occurred while parsing the response body - expected the service to return valid xml content.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));

      _log.administrationLogger.logError(err, "Error parsing response body from Service");

      throw error;
    }

    return serializer.deserialize(response);
  });
}
/**
 * @internal
 * @hidden
 * The key-value pairs having undefined/null as the values would lead to the empty tags in the serialized XML request.
 * Empty tags in the request body is problematic because of the following reasons.
 * - ATOM based management operations throw a "Bad Request" error if empty tags are included in the XML request body at top level.
 * - At the inner levels, Service assigns the empty strings as values to the empty tags instead of throwing an error.
 *
 * This method recursively removes the key-value pairs with undefined/null as the values from the request object that is to be serialized.
 *
 * @param {{ [key: string]: any }} resource
 */


function sanitizeSerializableObject(resource) {
  Object.keys(resource).forEach(function (property) {
    if (resource[property] == undefined) {
      delete resource[property];
    } else if ((0, _utils.isJSONLikeObject)(resource[property])) {
      sanitizeSerializableObject(resource[property]);
    }
  });
}
/**
 * @internal
 * @hidden
 * Serializes input information to construct the Atom XML request
 * @param resourceName Name of the resource to be serialized like `QueueDescription`
 * @param resource The entity details
 * @param allowedProperties The set of properties that are allowed by the service for the
 * associated operation(s);
 */


function serializeToAtomXmlRequest(resourceName, resource) {
  const content = {};
  content[resourceName] = Object.assign({}, resource);
  sanitizeSerializableObject(content[resourceName]);
  content[resourceName][Constants.XML_METADATA_MARKER] = {
    xmlns: "http://schemas.microsoft.com/netservices/2010/10/servicebus/connect",
    "xmlns:i": "http://www.w3.org/2001/XMLSchema-instance"
  };
  content[Constants.XML_METADATA_MARKER] = {
    type: "application/xml"
  };
  const requestDetails = {
    updated: new Date().toISOString(),
    content: content
  };
  requestDetails[Constants.XML_METADATA_MARKER] = {
    xmlns: "http://www.w3.org/2005/Atom"
  };
  return requestDetails;
}
/**
 * @internal
 * @hidden
 * Transforms response to contain the parsed data.
 * @param nameProperties The set of 'name' properties to be constructed on the
 * resultant object e.g., QueueName, TopicName, etc.
 * @param response
 * @param shouldParseResponse
 */


function deserializeAtomXmlResponse(nameProperties, response) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
    // If received data is a non-valid HTTP response, the body is expected to contain error information
    if (response.status < 200 || response.status >= 300) {
      throw buildError(response);
    }

    parseAtomResult(response, nameProperties);
    return response;
  });
}
/**
 * @internal
 * @hidden
 * Utility to deserialize the given JSON content in response body based on
 * if it's a single `entry` or `feed` and updates the `response.parsedBody` to hold the evaluated output.
 * @param response Response containing the JSON value in `response.parsedBody`
 * @nameProperties The set of 'name' properties to be constructed on the
 * resultant object e.g., QueueName, TopicName, etc.
 * */


function parseAtomResult(response, nameProperties) {
  const atomResponseInJson = response.parsedBody;
  let result;

  if (!atomResponseInJson) {
    response.parsedBody = undefined;
    return;
  }

  if (atomResponseInJson.feed) {
    result = parseFeedResult(atomResponseInJson.feed);
  } else if (atomResponseInJson.entry) {
    result = parseEntryResult(atomResponseInJson.entry);
  }

  if (result) {
    if (Array.isArray(result)) {
      result.forEach(entry => {
        setName(entry, nameProperties);
      });
    } else {
      setName(result, nameProperties);
    }

    response.parsedBody = result;
    return;
  }

  _log.administrationLogger.warning("Failure in parsing response body from service. Expected response to be in Atom XML format and have either feed or entry components, but received - %0", atomResponseInJson);

  throw new _coreHttp.RestError("Error occurred while parsing the response body - expected the service to return atom xml content with either feed or entry elements.", _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
}
/**
 * @internal
 * @hidden
 * Utility to help parse given `entry` result
 * @param entry
 */


function parseEntryResult(entry) {
  let result;

  if (typeof entry !== "object" || entry == null || typeof entry.content !== "object" || entry.content == null) {
    return undefined;
  }

  const contentElementNames = Object.keys(entry.content).filter(function (key) {
    return key !== Constants.XML_METADATA_MARKER;
  });

  if (contentElementNames && contentElementNames[0]) {
    const contentRootElementName = contentElementNames[0];
    delete entry.content[contentRootElementName][Constants.XML_METADATA_MARKER];
    result = entry.content[contentRootElementName];

    if (result) {
      if (entry[Constants.XML_METADATA_MARKER]) {
        result[Constants.ATOM_METADATA_MARKER] = entry[Constants.XML_METADATA_MARKER];
      } else {
        result[Constants.ATOM_METADATA_MARKER] = {};
      }

      result[Constants.ATOM_METADATA_MARKER]["ContentRootElement"] = contentRootElementName;
      Object.keys(entry).forEach(property => {
        if (property !== "content" && property !== Constants.XML_METADATA_MARKER) {
          result[Constants.ATOM_METADATA_MARKER][property] = entry[property];
        }
      });
      return result;
    }
  }

  return undefined;
}
/**
 * @internal
 * @hidden
 * Utility to help parse link info from the given `feed` result
 * @param feedLink
 */


function parseLinkInfo(feedLink, relationship) {
  if (!feedLink || !Array.isArray(feedLink)) {
    return undefined;
  }

  for (const linkInfo of feedLink) {
    if (linkInfo[Constants.XML_METADATA_MARKER].rel === relationship) {
      return linkInfo[Constants.XML_METADATA_MARKER].href;
    }
  }

  return undefined;
}
/**
 * @internal
 * @hidden
 * Utility to help parse given `feed` result
 * @param feed
 */


function parseFeedResult(feed) {
  const result = [];

  if (typeof feed === "object" && feed != null && feed.entry) {
    if (Array.isArray(feed.entry)) {
      feed.entry.forEach(entry => {
        const parsedEntryResult = parseEntryResult(entry);

        if (parsedEntryResult) {
          result.push(parsedEntryResult);
        }
      });
    } else {
      const parsedEntryResult = parseEntryResult(feed.entry);

      if (parsedEntryResult) {
        result.push(parsedEntryResult);
      }
    }

    result.nextLink = parseLinkInfo(feed.link, "next");
  }

  return result;
}
/**
 * @internal
 * @hidden
 * @param {number} statusCode
 * @returns {statusCode is keyof typeof Constants.HttpResponseCodes}
 */


function isKnownResponseCode(statusCode) {
  return !!Constants.HttpResponseCodes[statusCode];
}
/**
 * @internal
 * @hidden
 * Extracts the applicable entity name(s) from the URL based on the known structure
 * and instantiates the corresponding name properties to the deserialized response
 *
 * The pattern matching checks to extract entity names are based on following
 * constraints dictated by the service
 * - '/' is allowed in Queue and Topic names
 * - '/' is not allowed in Namespace, Subscription and Rule names
 * - Valid pathname URL structures used in the ATOM based management API are
 *     - `<namespace-component>/<topic-name>/Subscriptions/<subscription-name>/Rules/<rule-name>`
 *     - `<namespace-component>/<topic-name>/Subscriptions/<subscription-name>`
 *     - `<namespace-component>/<any-entity-name>`
 *
 * @param entry
 * @param nameProperties
 */


function setName(entry, nameProperties) {
  if (entry[Constants.ATOM_METADATA_MARKER]) {
    let rawUrl = entry[Constants.ATOM_METADATA_MARKER].id; // The parsedUrl gets constructed differently for browser vs Node.
    // It is specifically behaves different for some of the Atom based management API where
    // the received URL in "id" element is of type "sb:// ... " and not a standard HTTP one
    // Hence, normalizing the URL for parsing to work as expected in browser

    if (rawUrl.startsWith("sb://")) {
      rawUrl = "https://" + rawUrl.substring(5);
    }

    const parsedUrl = (0, _parseUrl.parseURL)(rawUrl);
    const pathname = parsedUrl.pathname;
    const firstIndexOfDelimiter = pathname.indexOf("/");

    if (pathname.match("(.*)/(.*)/Subscriptions/(.*)/Rules/(.*)")) {
      const lastIndexOfSubscriptionsDelimiter = pathname.lastIndexOf("/Subscriptions/");
      const firstIndexOfRulesDelimiter = pathname.indexOf("/Rules/");
      entry[nameProperties[0]] = pathname.substring(firstIndexOfDelimiter + 1, lastIndexOfSubscriptionsDelimiter);
      entry[nameProperties[1]] = pathname.substring(lastIndexOfSubscriptionsDelimiter + 15, firstIndexOfRulesDelimiter);
      entry[nameProperties[2]] = pathname.substring(firstIndexOfRulesDelimiter + 7);
    } else if (pathname.match("(.*)/(.*)/Subscriptions/(.*)")) {
      const lastIndexOfSubscriptionsDelimiter = pathname.lastIndexOf("/Subscriptions/");
      entry[nameProperties[0]] = pathname.substring(firstIndexOfDelimiter + 1, lastIndexOfSubscriptionsDelimiter);
      entry[nameProperties[1]] = pathname.substring(lastIndexOfSubscriptionsDelimiter + 15);
    } else if (pathname.match("(.*)/(.*)")) {
      entry[nameProperties[0]] = pathname.substring(firstIndexOfDelimiter + 1);
    }
  }
}
/**
 * @internal
 * @hidden
 * Utility to help construct the normalized `RestError` object based on given error
 * information and other data present in the received `response` object.
 * @param response
 */


function buildError(response) {
  if (!isKnownResponseCode(response.status)) {
    throw new _coreHttp.RestError(`Service returned an error response with an unrecognized HTTP status code - ${response.status}`, "ServiceError", response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
  }

  const errorBody = response.parsedBody;
  let errorMessage;

  if (typeof errorBody === "string") {
    errorMessage = errorBody;
  } else {
    if (errorBody == undefined || errorBody.Error == undefined || errorBody.Error.Detail == undefined) {
      errorMessage = "Detailed error message information not available. Look at the 'code' property on error for more information.";
    } else {
      errorMessage = errorBody.Error.Detail;
    }
  }

  const errorCode = getErrorCode(response, errorMessage);
  const error = new _coreHttp.RestError(errorMessage, errorCode, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
  return error;
}
/**
 * @internal
 * @hidden
 * Helper utility to construct user friendly error codes based on based on given error
 * information and other data present in the received `response` object.
 * @param response
 * @param errorMessage
 */


function getErrorCode(response, errorMessage) {
  if (response.status == 401) {
    return "UnauthorizedRequestError";
  }

  if (response.status == 404) {
    return "MessageEntityNotFoundError";
  }

  if (response.status == 409) {
    if (response.request.method == "DELETE") {
      return "ServiceError";
    }

    if (response.request.method == "PUT" && response.request.headers.get("If-Match") == "*") {
      return "ServiceError";
    }

    if (errorMessage && errorMessage.toLowerCase().includes("subcode=40901")) {
      return "ServiceError";
    }

    return "MessageEntityAlreadyExistsError";
  }

  if (response.status == 403) {
    if (errorMessage && errorMessage.toLowerCase().includes("subcode=40301")) {
      return "InvalidOperationError";
    }

    return "QuotaExceededError";
  }

  if (response.status == 400) {
    return "ServiceError";
  }

  if (response.status == 503) {
    return "ServerBusyError";
  }

  return Constants.HttpResponseCodes[response.status];
}
},{"tslib":"CvJj","@azure/core-http":"rj0o","./constants":"kjjy","../log":"IupI","buffer":"z1tx","./parseUrl":"U2FQ","./utils":"RXMg"}],"a1vN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildNamespace = buildNamespace;
exports.NamespaceResourceSerializer = void 0;

var _tslib = require("tslib");

var _atomXmlHelper = require("../util/atomXmlHelper");

var _utils = require("../util/utils");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * Builds the namespace object from the raw json object gotten after deserializing the
 * response from the service
 * @param rawNamespace
 */
function buildNamespace(rawNamespace) {
  const messagingSku = (0, _utils.getString)(rawNamespace["MessagingSKU"], "messagingSku");
  return {
    createdAt: (0, _utils.getDate)(rawNamespace["CreatedTime"], "createdAt"),
    messagingSku: messagingSku,
    modifiedAt: (0, _utils.getDate)(rawNamespace["ModifiedTime"], "modifiedAt"),
    name: (0, _utils.getString)(rawNamespace["Name"], "name"),
    messagingUnits: messagingSku === "Premium" ? (0, _utils.getInteger)(rawNamespace["MessagingUnits"], "messagingUnits") : undefined
  };
}
/**
 * @internal
 * @hidden
 * Atom XML Serializer for Namespaces.
 */


class NamespaceResourceSerializer {
  serialize() {
    return (0, _atomXmlHelper.serializeToAtomXmlRequest)("NamespaceProperties", {});
  }

  deserialize(response) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return (0, _atomXmlHelper.deserializeAtomXmlResponse)(["name"], response);
    });
  }

}

exports.NamespaceResourceSerializer = NamespaceResourceSerializer;
},{"tslib":"CvJj","../util/atomXmlHelper":"tZXy","../util/utils":"RXMg"}],"q9Cz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildQueueOptions = buildQueueOptions;
exports.buildQueue = buildQueue;
exports.buildQueueRuntimeProperties = buildQueueRuntimeProperties;
exports.QueueResourceSerializer = void 0;

var _tslib = require("tslib");

var _atomXmlHelper = require("../util/atomXmlHelper");

var Constants = _interopRequireWildcard(require("../util/constants"));

var _utils = require("../util/utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * Builds the queue options object from the user provided options.
 * Handles the differences in casing for the property names,
 * converts values to string and ensures the right order as expected by the service
 * @param queue
 */
function buildQueueOptions(queue) {
  return {
    LockDuration: queue.lockDuration,
    MaxSizeInMegabytes: (0, _utils.getStringOrUndefined)(queue.maxSizeInMegabytes),
    RequiresDuplicateDetection: (0, _utils.getStringOrUndefined)(queue.requiresDuplicateDetection),
    RequiresSession: (0, _utils.getStringOrUndefined)(queue.requiresSession),
    DefaultMessageTimeToLive: queue.defaultMessageTimeToLive,
    DeadLetteringOnMessageExpiration: (0, _utils.getStringOrUndefined)(queue.deadLetteringOnMessageExpiration),
    DuplicateDetectionHistoryTimeWindow: queue.duplicateDetectionHistoryTimeWindow,
    MaxDeliveryCount: (0, _utils.getStringOrUndefined)(queue.maxDeliveryCount),
    EnableBatchedOperations: (0, _utils.getStringOrUndefined)(queue.enableBatchedOperations),
    AuthorizationRules: (0, _utils.getRawAuthorizationRules)(queue.authorizationRules),
    Status: (0, _utils.getStringOrUndefined)(queue.status),
    AutoDeleteOnIdle: (0, _utils.getStringOrUndefined)(queue.autoDeleteOnIdle),
    EnablePartitioning: (0, _utils.getStringOrUndefined)(queue.enablePartitioning),
    ForwardDeadLetteredMessagesTo: (0, _utils.getStringOrUndefined)(queue.forwardDeadLetteredMessagesTo),
    ForwardTo: (0, _utils.getStringOrUndefined)(queue.forwardTo),
    UserMetadata: (0, _utils.getStringOrUndefined)(queue.userMetadata),
    EntityAvailabilityStatus: (0, _utils.getStringOrUndefined)(queue.availabilityStatus),
    EnableExpress: (0, _utils.getStringOrUndefined)(queue.enableExpress)
  };
}
/**
 * @internal
 * @hidden
 * Builds the queue object from the raw json object gotten after deserializing the
 * response from the service
 * @param rawQueue
 */


function buildQueue(rawQueue) {
  return {
    name: (0, _utils.getString)(rawQueue[Constants.QUEUE_NAME], "queueName"),
    forwardTo: (0, _utils.getStringOrUndefined)(rawQueue[Constants.FORWARD_TO]),
    userMetadata: rawQueue[Constants.USER_METADATA],
    lockDuration: (0, _utils.getString)(rawQueue[Constants.LOCK_DURATION], "lockDuration"),
    maxSizeInMegabytes: (0, _utils.getInteger)(rawQueue[Constants.MAX_SIZE_IN_MEGABYTES], "maxSizeInMegabytes"),
    maxDeliveryCount: (0, _utils.getInteger)(rawQueue[Constants.MAX_DELIVERY_COUNT], "maxDeliveryCount"),
    enablePartitioning: (0, _utils.getBoolean)(rawQueue[Constants.ENABLE_PARTITIONING], "enablePartitioning"),
    requiresSession: (0, _utils.getBoolean)(rawQueue[Constants.REQUIRES_SESSION], "requiresSession"),
    enableBatchedOperations: (0, _utils.getBoolean)(rawQueue[Constants.ENABLE_BATCHED_OPERATIONS], "enableBatchedOperations"),
    defaultMessageTimeToLive: (0, _utils.getString)(rawQueue[Constants.DEFAULT_MESSAGE_TIME_TO_LIVE], "defaultMessageTimeToLive"),
    autoDeleteOnIdle: rawQueue[Constants.AUTO_DELETE_ON_IDLE],
    requiresDuplicateDetection: (0, _utils.getBoolean)(rawQueue[Constants.REQUIRES_DUPLICATE_DETECTION], "requiresDuplicateDetection"),
    duplicateDetectionHistoryTimeWindow: (0, _utils.getString)(rawQueue[Constants.DUPLICATE_DETECTION_HISTORY_TIME_WINDOW], "duplicateDetectionHistoryTimeWindow"),
    deadLetteringOnMessageExpiration: (0, _utils.getBoolean)(rawQueue[Constants.DEAD_LETTERING_ON_MESSAGE_EXPIRATION], "deadLetteringOnMessageExpiration"),
    forwardDeadLetteredMessagesTo: (0, _utils.getStringOrUndefined)(rawQueue[Constants.FORWARD_DEADLETTERED_MESSAGES_TO]),
    authorizationRules: (0, _utils.getAuthorizationRulesOrUndefined)(rawQueue[Constants.AUTHORIZATION_RULES]),
    status: rawQueue[Constants.STATUS],
    enableExpress: (0, _utils.getBoolean)(rawQueue[Constants.ENABLE_EXPRESS], "enableExpress"),
    availabilityStatus: rawQueue[Constants.ENTITY_AVAILABILITY_STATUS]
  };
}
/**
 * @internal
 * @hidden
 * Builds the queue runtime info object from the raw json object gotten after deserializing the
 * response from the service
 * @param rawQueue
 */


function buildQueueRuntimeProperties(rawQueue) {
  const messageCountDetails = (0, _utils.getMessageCountDetails)(rawQueue[Constants.COUNT_DETAILS]);
  return Object.assign(Object.assign({
    name: (0, _utils.getString)(rawQueue[Constants.QUEUE_NAME], "queueName"),
    sizeInBytes: (0, _utils.getIntegerOrUndefined)(rawQueue[Constants.SIZE_IN_BYTES]),
    totalMessageCount: (0, _utils.getIntegerOrUndefined)(rawQueue[Constants.MESSAGE_COUNT])
  }, messageCountDetails), {
    createdAt: (0, _utils.getDate)(rawQueue[Constants.CREATED_AT], "createdAt"),
    modifiedAt: (0, _utils.getDate)(rawQueue[Constants.UPDATED_AT], "modifiedAt"),
    accessedAt: (0, _utils.getDate)(rawQueue[Constants.ACCESSED_AT], "accessedAt")
  });
}
/**
 * @internal
 * @hidden
 * Atom XML Serializer for Queues.
 */


class QueueResourceSerializer {
  serialize(resource) {
    return (0, _atomXmlHelper.serializeToAtomXmlRequest)("QueueDescription", resource);
  }

  deserialize(response) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return (0, _atomXmlHelper.deserializeAtomXmlResponse)(["QueueName"], response);
    });
  }

}

exports.QueueResourceSerializer = QueueResourceSerializer;
},{"tslib":"CvJj","../util/atomXmlHelper":"tZXy","../util/constants":"kjjy","../util/utils":"RXMg"}],"qRu9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildRule = buildRule;
exports.buildInternalRuleResource = buildInternalRuleResource;
exports.isSqlRuleAction = isSqlRuleAction;
exports.buildInternalRawKeyValuePairs = buildInternalRawKeyValuePairs;
exports.RuleResourceSerializer = void 0;

var _tslib = require("tslib");

var _atomXmlHelper = require("../util/atomXmlHelper");

var Constants = _interopRequireWildcard(require("../util/constants"));

var _utils = require("../util/utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * Builds the rule object from the raw json object gotten after deserializing the
 * response from the service
 * @param rawRule
 */
function buildRule(rawRule) {
  return {
    name: (0, _utils.getString)(rawRule["RuleName"], "ruleName"),
    filter: getTopicFilter(rawRule["Filter"]),
    action: getRuleAction(rawRule["Action"])
  };
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve `filter` value from given input,
 * or undefined if not passed in.
 * @param value
 */


function getTopicFilter(value) {
  let result;

  if (value["SqlExpression"] != undefined) {
    result = {
      sqlExpression: value["SqlExpression"],
      sqlParameters: getKeyValuePairsOrUndefined(value["Parameters"], "SQLParameters")
    };
  } else {
    result = {
      correlationId: (0, _utils.getStringOrUndefined)(value["CorrelationId"]),
      subject: (0, _utils.getStringOrUndefined)(value["Label"]),
      to: (0, _utils.getStringOrUndefined)(value["To"]),
      replyTo: (0, _utils.getStringOrUndefined)(value["ReplyTo"]),
      replyToSessionId: (0, _utils.getStringOrUndefined)(value["ReplyToSessionId"]),
      sessionId: (0, _utils.getStringOrUndefined)(value["SessionId"]),
      messageId: (0, _utils.getStringOrUndefined)(value["MessageId"]),
      contentType: (0, _utils.getStringOrUndefined)(value["ContentType"]),
      applicationProperties: getKeyValuePairsOrUndefined(value["Properties"], "ApplicationProperties")
    };
  }

  return result;
}
/**
 * @internal
 * @hidden
 * Helper utility to retrieve rule `action` value from given input.
 * @param value
 */


function getRuleAction(value) {
  return {
    sqlExpression: value["SqlExpression"],
    sqlParameters: getKeyValuePairsOrUndefined(value["Parameters"], "SQLParameters")
  };
}
/**
 * @internal
 * @hidden
 *
 * @param {CreateRuleOptions} rule
 */


function buildInternalRuleResource(rule) {
  const resource = {
    Filter: {},
    Action: {},
    Name: rule.name
  };

  if (rule.filter == undefined) {
    // Defaults to creating a true filter if none specified
    resource.Filter = {
      SqlExpression: "1=1"
    };
    resource.Filter[Constants.XML_METADATA_MARKER] = {
      "p4:type": "SqlFilter",
      "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance"
    };
  } else {
    if (rule.filter.hasOwnProperty("sqlExpression")) {
      const sqlFilter = rule.filter;
      resource.Filter = {
        SqlExpression: sqlFilter.sqlExpression,
        Parameters: buildInternalRawKeyValuePairs(sqlFilter.sqlParameters, "sqlParameters")
      };
      resource.Filter[Constants.XML_METADATA_MARKER] = {
        "p4:type": "SqlFilter",
        "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance"
      };
    } else {
      const correlationFilter = rule.filter;
      resource.Filter = {
        CorrelationId: correlationFilter.correlationId,
        Label: correlationFilter.subject,
        To: correlationFilter.to,
        ReplyTo: correlationFilter.replyTo,
        ReplyToSessionId: correlationFilter.replyToSessionId,
        ContentType: correlationFilter.contentType,
        SessionId: correlationFilter.sessionId,
        MessageId: correlationFilter.messageId,
        Properties: buildInternalRawKeyValuePairs(correlationFilter.applicationProperties, "applicationProperties")
      };
      resource.Filter[Constants.XML_METADATA_MARKER] = {
        "p4:type": "CorrelationFilter",
        "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance"
      };
    }
  }

  if (rule.action == undefined || rule.action.sqlExpression == undefined) {
    // Defaults to creating an empty rule action instance if none specified
    resource.Action = {};
    resource.Action[Constants.XML_METADATA_MARKER] = {
      "p4:type": "EmptyRuleAction",
      "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance"
    };
  } else {
    resource.Action = {
      SqlExpression: rule.action.sqlExpression,
      Parameters: buildInternalRawKeyValuePairs(rule.action.sqlParameters, "sqlParameters")
    };
    resource.Action[Constants.XML_METADATA_MARKER] = {
      "p4:type": "SqlRuleAction",
      "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance"
    };
  }

  return resource;
}
/**
 * @internal
 * @hidden
 * RuleResourceSerializer for serializing / deserializing Rule entities
 */


class RuleResourceSerializer {
  serialize(rule) {
    return (0, _atomXmlHelper.serializeToAtomXmlRequest)("RuleDescription", buildInternalRuleResource(rule));
  }

  deserialize(response) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return (0, _atomXmlHelper.deserializeAtomXmlResponse)(["TopicName", "SubscriptionName", "RuleName"], response);
    });
  }

}
/**
 * @internal
 * @hidden
 */


exports.RuleResourceSerializer = RuleResourceSerializer;

function isSqlRuleAction(action) {
  return action != null && typeof action === "object" && "sqlExpression" in action;
}
/**
 * Service expects the XML request with the special type names serialized in the request,
 * the request would fail otherwise.
 *
 * @internal
 * @hidden
 */


var TypeMapForRequestSerialization;

(function (TypeMapForRequestSerialization) {
  TypeMapForRequestSerialization["double"] = "l28:double";
  TypeMapForRequestSerialization["string"] = "l28:string";
  TypeMapForRequestSerialization["long"] = "l28:long";
  TypeMapForRequestSerialization["date"] = "l28:dateTime";
  TypeMapForRequestSerialization["boolean"] = "l28:boolean";
})(TypeMapForRequestSerialization || (TypeMapForRequestSerialization = {}));
/**
 * @internal
 * @hidden
 */


var TypeMapForResponseDeserialization;

(function (TypeMapForResponseDeserialization) {
  TypeMapForResponseDeserialization["int"] = "int";
  TypeMapForResponseDeserialization["double"] = "double";
  TypeMapForResponseDeserialization["string"] = "string";
  TypeMapForResponseDeserialization["boolean"] = "boolean";
  TypeMapForResponseDeserialization["date"] = "dateTime";
})(TypeMapForResponseDeserialization || (TypeMapForResponseDeserialization = {}));
/**
 * Key-value pairs are supposed to be wrapped with this tag in the XML request, they are ignored otherwise.
 *
 * @internal
 * @hidden
 */


const keyValuePairXMLTag = "KeyValueOfstringanyType";
/**
 * @internal
 * @hidden
 * Helper utility to retrieve the key-value pairs from the RawKeyValue object from given input,
 * or undefined if not passed in.
 * @param value
 */

function getKeyValuePairsOrUndefined(value, attribute) {
  var _a;

  if (!value) {
    return undefined;
  }

  const properties = {};
  let rawProperties;

  if (!Array.isArray(value[keyValuePairXMLTag]) && ((_a = value[keyValuePairXMLTag]) === null || _a === void 0 ? void 0 : _a.Key)) {
    // When a single property is present,
    //    value["KeyValueOfstringanyType"] is { Key: <key>, Value: [Object] }
    // When multiple properties are present,
    //    value["KeyValueOfstringanyType"] is [ { Key: <key-1>, Value: [Object] }, { Key: <key-2>, Value: [Object] } ]
    // For consistency, wrapping `value["KeyValueOfstringanyType"]` as an array for the "single property" case.
    rawProperties = [value[keyValuePairXMLTag]];
  } else {
    rawProperties = value[keyValuePairXMLTag];
  }

  if (Array.isArray(rawProperties)) {
    for (const rawProperty of rawProperties) {
      const key = rawProperty.Key;
      const value = rawProperty.Value["_"];
      const encodedValueType = rawProperty.Value["$"]["i:type"].toString().substring(5);

      if (encodedValueType === TypeMapForResponseDeserialization.int || encodedValueType === TypeMapForResponseDeserialization.double) {
        properties[key] = Number(value);
      } else if (encodedValueType === TypeMapForResponseDeserialization.string) {
        properties[key] = value;
      } else if (encodedValueType === TypeMapForResponseDeserialization.boolean) {
        properties[key] = value === "true" ? true : false;
      } else if (encodedValueType === TypeMapForResponseDeserialization.date) {
        properties[key] = new Date(value);
      } else {
        throw new TypeError(`Unable to parse the key-value pairs in the response - ${JSON.stringify(rawProperty)}`);
      }
    }
  } else {
    throw new TypeError(`${attribute} in the response is not an array, unable to parse the response - ${JSON.stringify(value)}`);
  }

  return properties;
}
/**
 * @internal
 * @hidden
 * Helper utility to extract array of user properties key-value instances from given input,
 * or undefined if not passed in.
 * @param value
 */


function buildInternalRawKeyValuePairs(parameters, attribute) {
  if (parameters == undefined) {
    return undefined;
  }

  if (Array.isArray(parameters) || typeof parameters === "string" || typeof parameters !== "object" || Object.entries(parameters).length < 1) {
    throw new TypeError(`Unsupported value for the ${attribute} ${JSON.stringify(parameters)}, expected a JSON object with key-value pairs.`);
  }

  const rawParameters = [];

  for (let [key, value] of Object.entries(parameters)) {
    let type;

    if (typeof value === "number") {
      type = TypeMapForRequestSerialization.double;
    } else if (typeof value === "string") {
      type = TypeMapForRequestSerialization.string;
    } else if (typeof value === "boolean") {
      type = TypeMapForRequestSerialization.boolean;
    } else if (value instanceof Date && !isNaN(value.valueOf())) {
      type = TypeMapForRequestSerialization.date;
      value = value.toJSON();
    } else {
      throw new TypeError(`Unsupported type for the value in the ${attribute} for the key '${key}'`);
    }

    const rawParameter = {
      Key: key,
      Value: {
        [Constants.XML_METADATA_MARKER]: {
          "p4:type": type,
          "xmlns:l28": "http://www.w3.org/2001/XMLSchema"
        },
        [Constants.XML_VALUE_MARKER]: value
      }
    };
    rawParameters.push(rawParameter);
  }

  return {
    [keyValuePairXMLTag]: rawParameters
  };
}
},{"tslib":"CvJj","../util/atomXmlHelper":"tZXy","../util/constants":"kjjy","../util/utils":"RXMg"}],"y63P":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildSubscriptionOptions = buildSubscriptionOptions;
exports.buildSubscription = buildSubscription;
exports.buildSubscriptionRuntimeProperties = buildSubscriptionRuntimeProperties;
exports.SubscriptionResourceSerializer = void 0;

var _tslib = require("tslib");

var _atomXmlHelper = require("../util/atomXmlHelper");

var Constants = _interopRequireWildcard(require("../util/constants"));

var _utils = require("../util/utils");

var _ruleResourceSerializer = require("./ruleResourceSerializer");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * Builds the subscription options object from the user provided options.
 * Handles the differences in casing for the property names,
 * converts values to string and ensures the right order as expected by the service
 * @param subscription
 */
function buildSubscriptionOptions(subscription) {
  return {
    LockDuration: subscription.lockDuration,
    RequiresSession: (0, _utils.getStringOrUndefined)(subscription.requiresSession),
    DefaultMessageTimeToLive: (0, _utils.getStringOrUndefined)(subscription.defaultMessageTimeToLive),
    DeadLetteringOnMessageExpiration: (0, _utils.getStringOrUndefined)(subscription.deadLetteringOnMessageExpiration),
    DeadLetteringOnFilterEvaluationExceptions: (0, _utils.getStringOrUndefined)(subscription.deadLetteringOnFilterEvaluationExceptions),
    DefaultRuleDescription: subscription.defaultRuleOptions ? (0, _ruleResourceSerializer.buildInternalRuleResource)(subscription.defaultRuleOptions) : undefined,
    MaxDeliveryCount: (0, _utils.getStringOrUndefined)(subscription.maxDeliveryCount),
    EnableBatchedOperations: (0, _utils.getStringOrUndefined)(subscription.enableBatchedOperations),
    Status: (0, _utils.getStringOrUndefined)(subscription.status),
    ForwardTo: (0, _utils.getStringOrUndefined)(subscription.forwardTo),
    UserMetadata: (0, _utils.getStringOrUndefined)(subscription.userMetadata),
    ForwardDeadLetteredMessagesTo: (0, _utils.getStringOrUndefined)(subscription.forwardDeadLetteredMessagesTo),
    AutoDeleteOnIdle: (0, _utils.getStringOrUndefined)(subscription.autoDeleteOnIdle),
    EntityAvailabilityStatus: (0, _utils.getStringOrUndefined)(subscription.availabilityStatus)
  };
}
/**
 * @internal
 * @hidden
 * Builds the subscription object from the raw json object gotten after deserializing
 * the response from the service
 * @param rawSubscription
 */


function buildSubscription(rawSubscription) {
  return {
    subscriptionName: (0, _utils.getString)(rawSubscription[Constants.SUBSCRIPTION_NAME], "subscriptionName"),
    topicName: (0, _utils.getString)(rawSubscription[Constants.TOPIC_NAME], "topicName"),
    lockDuration: (0, _utils.getString)(rawSubscription[Constants.LOCK_DURATION], "lockDuration"),
    maxDeliveryCount: (0, _utils.getInteger)(rawSubscription[Constants.MAX_DELIVERY_COUNT], "maxDeliveryCount"),
    requiresSession: (0, _utils.getBoolean)(rawSubscription[Constants.REQUIRES_SESSION], "requiresSession"),
    enableBatchedOperations: (0, _utils.getBoolean)(rawSubscription[Constants.ENABLE_BATCHED_OPERATIONS], "enableBatchedOperations"),
    defaultMessageTimeToLive: (0, _utils.getString)(rawSubscription[Constants.DEFAULT_MESSAGE_TIME_TO_LIVE], "defaultMessageTimeToLive"),
    autoDeleteOnIdle: (0, _utils.getString)(rawSubscription[Constants.AUTO_DELETE_ON_IDLE], "autoDeleteOnIdle"),
    deadLetteringOnMessageExpiration: (0, _utils.getBoolean)(rawSubscription[Constants.DEAD_LETTERING_ON_MESSAGE_EXPIRATION], "deadLetteringOnMessageExpiration"),
    deadLetteringOnFilterEvaluationExceptions: (0, _utils.getBoolean)(rawSubscription[Constants.DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS], "deadLetteringOnFilterEvaluationExceptions"),
    forwardDeadLetteredMessagesTo: (0, _utils.getStringOrUndefined)(rawSubscription[Constants.FORWARD_DEADLETTERED_MESSAGES_TO]),
    forwardTo: (0, _utils.getStringOrUndefined)(rawSubscription[Constants.FORWARD_TO]),
    userMetadata: rawSubscription[Constants.USER_METADATA],
    status: (0, _utils.getString)(rawSubscription[Constants.STATUS], "status"),
    availabilityStatus: (0, _utils.getString)(rawSubscription[Constants.ENTITY_AVAILABILITY_STATUS], "availabilityStatus")
  };
}
/**
 * @internal
 * @hidden
 * Builds the subscription runtime info object from the raw json object gotten after deserializing
 * the response from the service
 * @param rawSubscription
 */


function buildSubscriptionRuntimeProperties(rawSubscription) {
  const messageCountDetails = (0, _utils.getMessageCountDetails)(rawSubscription[Constants.COUNT_DETAILS]);
  return {
    subscriptionName: (0, _utils.getString)(rawSubscription[Constants.SUBSCRIPTION_NAME], "subscriptionName"),
    topicName: (0, _utils.getString)(rawSubscription[Constants.TOPIC_NAME], "topicName"),
    totalMessageCount: (0, _utils.getInteger)(rawSubscription[Constants.MESSAGE_COUNT], "messageCount"),
    activeMessageCount: messageCountDetails.activeMessageCount,
    deadLetterMessageCount: messageCountDetails.deadLetterMessageCount,
    transferDeadLetterMessageCount: messageCountDetails.transferDeadLetterMessageCount,
    transferMessageCount: messageCountDetails.transferMessageCount,
    createdAt: (0, _utils.getDate)(rawSubscription[Constants.CREATED_AT], "createdAt"),
    modifiedAt: (0, _utils.getDate)(rawSubscription[Constants.UPDATED_AT], "modifiedAt"),
    accessedAt: (0, _utils.getDate)(rawSubscription[Constants.ACCESSED_AT], "accessedAt")
  };
}
/**
 * @internal
 * @hidden
 * SubscriptionResourceSerializer for serializing / deserializing Subscription entities
 */


class SubscriptionResourceSerializer {
  serialize(resource) {
    return (0, _atomXmlHelper.serializeToAtomXmlRequest)("SubscriptionDescription", resource);
  }

  deserialize(response) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return (0, _atomXmlHelper.deserializeAtomXmlResponse)(["TopicName", "SubscriptionName"], response);
    });
  }

}

exports.SubscriptionResourceSerializer = SubscriptionResourceSerializer;
},{"tslib":"CvJj","../util/atomXmlHelper":"tZXy","../util/constants":"kjjy","../util/utils":"RXMg","./ruleResourceSerializer":"qRu9"}],"AJY0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildTopicOptions = buildTopicOptions;
exports.buildTopic = buildTopic;
exports.buildTopicRuntimeProperties = buildTopicRuntimeProperties;
exports.TopicResourceSerializer = void 0;

var _tslib = require("tslib");

var _atomXmlHelper = require("../util/atomXmlHelper");

var Constants = _interopRequireWildcard(require("../util/constants"));

var _utils = require("../util/utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * Builds the topic options object from the user provided options.
 * Handles the differences in casing for the property names,
 * converts values to string and ensures the right order as expected by the service
 * @param topic
 */
function buildTopicOptions(topic) {
  return {
    DefaultMessageTimeToLive: topic.defaultMessageTimeToLive,
    MaxSizeInMegabytes: (0, _utils.getStringOrUndefined)(topic.maxSizeInMegabytes),
    RequiresDuplicateDetection: (0, _utils.getStringOrUndefined)(topic.requiresDuplicateDetection),
    DuplicateDetectionHistoryTimeWindow: topic.duplicateDetectionHistoryTimeWindow,
    EnableBatchedOperations: (0, _utils.getStringOrUndefined)(topic.enableBatchedOperations),
    AuthorizationRules: (0, _utils.getRawAuthorizationRules)(topic.authorizationRules),
    Status: (0, _utils.getStringOrUndefined)(topic.status),
    UserMetadata: (0, _utils.getStringOrUndefined)(topic.userMetadata),
    SupportOrdering: (0, _utils.getStringOrUndefined)(topic.supportOrdering),
    AutoDeleteOnIdle: (0, _utils.getStringOrUndefined)(topic.autoDeleteOnIdle),
    EnablePartitioning: (0, _utils.getStringOrUndefined)(topic.enablePartitioning),
    EntityAvailabilityStatus: (0, _utils.getStringOrUndefined)(topic.availabilityStatus),
    EnableExpress: (0, _utils.getStringOrUndefined)(topic.enableExpress)
  };
}
/**
 * @internal
 * @hidden
 * Builds the topic object from the raw json object gotten after deserializing the
 * response from the service
 * @param rawTopic
 */


function buildTopic(rawTopic) {
  return {
    name: (0, _utils.getString)(rawTopic[Constants.TOPIC_NAME], "topicName"),
    maxSizeInMegabytes: (0, _utils.getInteger)(rawTopic[Constants.MAX_SIZE_IN_MEGABYTES], "maxSizeInMegabytes"),
    enablePartitioning: (0, _utils.getBoolean)(rawTopic[Constants.ENABLE_PARTITIONING], "enablePartitioning"),
    supportOrdering: (0, _utils.getBoolean)(rawTopic[Constants.SUPPORT_ORDERING], "supportOrdering"),
    enableBatchedOperations: (0, _utils.getBoolean)(rawTopic[Constants.ENABLE_BATCHED_OPERATIONS], "enableBatchedOperations"),
    defaultMessageTimeToLive: (0, _utils.getString)(rawTopic[Constants.DEFAULT_MESSAGE_TIME_TO_LIVE], "defaultMessageTimeToLive"),
    autoDeleteOnIdle: rawTopic[Constants.AUTO_DELETE_ON_IDLE],
    requiresDuplicateDetection: (0, _utils.getBoolean)(rawTopic[Constants.REQUIRES_DUPLICATE_DETECTION], "requiresDuplicateDetection"),
    duplicateDetectionHistoryTimeWindow: (0, _utils.getString)(rawTopic[Constants.DUPLICATE_DETECTION_HISTORY_TIME_WINDOW], "duplicateDetectionHistoryTimeWindow"),
    authorizationRules: (0, _utils.getAuthorizationRulesOrUndefined)(rawTopic[Constants.AUTHORIZATION_RULES]),
    userMetadata: rawTopic[Constants.USER_METADATA],
    status: rawTopic[Constants.STATUS],
    enableExpress: (0, _utils.getBoolean)(rawTopic[Constants.ENABLE_EXPRESS], "enableExpress"),
    availabilityStatus: rawTopic[Constants.ENTITY_AVAILABILITY_STATUS]
  };
}
/**
 * @internal
 * @hidden
 * Builds the topic runtime info object from the raw json object gotten after deserializing the
 * response from the service
 * @param rawTopic
 */


function buildTopicRuntimeProperties(rawTopic) {
  return {
    name: (0, _utils.getString)(rawTopic[Constants.TOPIC_NAME], "topicName"),
    sizeInBytes: (0, _utils.getIntegerOrUndefined)(rawTopic[Constants.SIZE_IN_BYTES]),
    subscriptionCount: (0, _utils.getIntegerOrUndefined)(rawTopic[Constants.SUBSCRIPTION_COUNT]),
    createdAt: (0, _utils.getDate)(rawTopic[Constants.CREATED_AT], "createdAt"),
    scheduledMessageCount: (0, _utils.getMessageCountDetails)(rawTopic[Constants.COUNT_DETAILS]).scheduledMessageCount,
    modifiedAt: (0, _utils.getDate)(rawTopic[Constants.UPDATED_AT], "modifiedAt"),
    accessedAt: (0, _utils.getDate)(rawTopic[Constants.ACCESSED_AT], "accessedAt")
  };
}
/**
 * @internal
 * @hidden
 * TopicResourceSerializer for serializing / deserializing Topic entities
 */


class TopicResourceSerializer {
  serialize(resource) {
    return (0, _atomXmlHelper.serializeToAtomXmlRequest)("TopicDescription", resource);
  }

  deserialize(response) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return (0, _atomXmlHelper.deserializeAtomXmlResponse)(["TopicName"], response);
    });
  }

}

exports.TopicResourceSerializer = TopicResourceSerializer;
},{"tslib":"CvJj","../util/atomXmlHelper":"tZXy","../util/constants":"kjjy","../util/utils":"RXMg"}],"HqYT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * A JavaScript implementation of the SHA family of hashes - defined in FIPS PUB 180-4, FIPS PUB 202,
 * and SP 800-185 - as well as the corresponding HMAC implementation as defined in FIPS PUB 198-1.
 *
 * Copyright 2008-2020 Brian Turek, 1998-2009 Paul Johnston & Contributors
 * Distributed under the BSD License
 * See http://caligatio.github.com/jsSHA/ for more information
 */
const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

function n(t, n, e, r) {
  let i, s, o;
  const h = n || [0],
        u = (e = e || 0) >>> 3,
        w = -1 === r ? 3 : 0;

  for (i = 0; i < t.length; i += 1) o = i + u, s = o >>> 2, h.length <= s && h.push(0), h[s] |= t[i] << 8 * (w + r * (o % 4));

  return {
    value: h,
    binLen: 8 * t.length + e
  };
}

function e(e, r, i) {
  switch (r) {
    case "UTF8":
    case "UTF16BE":
    case "UTF16LE":
      break;

    default:
      throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
  }

  switch (e) {
    case "HEX":
      return function (t, n, e) {
        return function (t, n, e, r) {
          let i, s, o, h;
          if (0 != t.length % 2) throw new Error("String of HEX type must be in byte increments");
          const u = n || [0],
                w = (e = e || 0) >>> 3,
                c = -1 === r ? 3 : 0;

          for (i = 0; i < t.length; i += 2) {
            if (s = parseInt(t.substr(i, 2), 16), isNaN(s)) throw new Error("String of HEX type contains invalid characters");

            for (h = (i >>> 1) + w, o = h >>> 2; u.length <= o;) u.push(0);

            u[o] |= s << 8 * (c + r * (h % 4));
          }

          return {
            value: u,
            binLen: 4 * t.length + e
          };
        }(t, n, e, i);
      };

    case "TEXT":
      return function (t, n, e) {
        return function (t, n, e, r, i) {
          let s,
              o,
              h,
              u,
              w,
              c,
              f,
              a,
              l = 0;
          const A = e || [0],
                E = (r = r || 0) >>> 3;
          if ("UTF8" === n) for (f = -1 === i ? 3 : 0, h = 0; h < t.length; h += 1) for (s = t.charCodeAt(h), o = [], 128 > s ? o.push(s) : 2048 > s ? (o.push(192 | s >>> 6), o.push(128 | 63 & s)) : 55296 > s || 57344 <= s ? o.push(224 | s >>> 12, 128 | s >>> 6 & 63, 128 | 63 & s) : (h += 1, s = 65536 + ((1023 & s) << 10 | 1023 & t.charCodeAt(h)), o.push(240 | s >>> 18, 128 | s >>> 12 & 63, 128 | s >>> 6 & 63, 128 | 63 & s)), u = 0; u < o.length; u += 1) {
            for (c = l + E, w = c >>> 2; A.length <= w;) A.push(0);

            A[w] |= o[u] << 8 * (f + i * (c % 4)), l += 1;
          } else for (f = -1 === i ? 2 : 0, a = "UTF16LE" === n && 1 !== i || "UTF16LE" !== n && 1 === i, h = 0; h < t.length; h += 1) {
            for (s = t.charCodeAt(h), !0 === a && (u = 255 & s, s = u << 8 | s >>> 8), c = l + E, w = c >>> 2; A.length <= w;) A.push(0);

            A[w] |= s << 8 * (f + i * (c % 4)), l += 2;
          }
          return {
            value: A,
            binLen: 8 * l + r
          };
        }(t, r, n, e, i);
      };

    case "B64":
      return function (n, e, r) {
        return function (n, e, r, i) {
          let s,
              o,
              h,
              u,
              w,
              c,
              f,
              a = 0;
          const l = e || [0],
                A = (r = r || 0) >>> 3,
                E = -1 === i ? 3 : 0,
                H = n.indexOf("=");
          if (-1 === n.search(/^[a-zA-Z0-9=+/]+$/)) throw new Error("Invalid character in base-64 string");
          if (n = n.replace(/=/g, ""), -1 !== H && H < n.length) throw new Error("Invalid '=' found in base-64 string");

          for (o = 0; o < n.length; o += 4) {
            for (w = n.substr(o, 4), u = 0, h = 0; h < w.length; h += 1) s = t.indexOf(w.charAt(h)), u |= s << 18 - 6 * h;

            for (h = 0; h < w.length - 1; h += 1) {
              for (f = a + A, c = f >>> 2; l.length <= c;) l.push(0);

              l[c] |= (u >>> 16 - 8 * h & 255) << 8 * (E + i * (f % 4)), a += 1;
            }
          }

          return {
            value: l,
            binLen: 8 * a + r
          };
        }(n, e, r, i);
      };

    case "BYTES":
      return function (t, n, e) {
        return function (t, n, e, r) {
          let i, s, o, h;
          const u = n || [0],
                w = (e = e || 0) >>> 3,
                c = -1 === r ? 3 : 0;

          for (s = 0; s < t.length; s += 1) i = t.charCodeAt(s), h = s + w, o = h >>> 2, u.length <= o && u.push(0), u[o] |= i << 8 * (c + r * (h % 4));

          return {
            value: u,
            binLen: 8 * t.length + e
          };
        }(t, n, e, i);
      };

    case "ARRAYBUFFER":
      try {
        new ArrayBuffer(0);
      } catch (t) {
        throw new Error("ARRAYBUFFER not supported by this environment");
      }

      return function (t, e, r) {
        return function (t, e, r, i) {
          return n(new Uint8Array(t), e, r, i);
        }(t, e, r, i);
      };

    case "UINT8ARRAY":
      try {
        new Uint8Array(0);
      } catch (t) {
        throw new Error("UINT8ARRAY not supported by this environment");
      }

      return function (t, e, r) {
        return n(t, e, r, i);
      };

    default:
      throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
  }
}

function r(n, e, r, i) {
  switch (n) {
    case "HEX":
      return function (t) {
        return function (t, n, e, r) {
          let i,
              s,
              o = "";
          const h = n / 8,
                u = -1 === e ? 3 : 0;

          for (i = 0; i < h; i += 1) s = t[i >>> 2] >>> 8 * (u + e * (i % 4)), o += "0123456789abcdef".charAt(s >>> 4 & 15) + "0123456789abcdef".charAt(15 & s);

          return r.outputUpper ? o.toUpperCase() : o;
        }(t, e, r, i);
      };

    case "B64":
      return function (n) {
        return function (n, e, r, i) {
          let s,
              o,
              h,
              u,
              w,
              c = "";
          const f = e / 8,
                a = -1 === r ? 3 : 0;

          for (s = 0; s < f; s += 3) for (u = s + 1 < f ? n[s + 1 >>> 2] : 0, w = s + 2 < f ? n[s + 2 >>> 2] : 0, h = (n[s >>> 2] >>> 8 * (a + r * (s % 4)) & 255) << 16 | (u >>> 8 * (a + r * ((s + 1) % 4)) & 255) << 8 | w >>> 8 * (a + r * ((s + 2) % 4)) & 255, o = 0; o < 4; o += 1) c += 8 * s + 6 * o <= e ? t.charAt(h >>> 6 * (3 - o) & 63) : i.b64Pad;

          return c;
        }(n, e, r, i);
      };

    case "BYTES":
      return function (t) {
        return function (t, n, e) {
          let r,
              i,
              s = "";
          const o = n / 8,
                h = -1 === e ? 3 : 0;

          for (r = 0; r < o; r += 1) i = t[r >>> 2] >>> 8 * (h + e * (r % 4)) & 255, s += String.fromCharCode(i);

          return s;
        }(t, e, r);
      };

    case "ARRAYBUFFER":
      try {
        new ArrayBuffer(0);
      } catch (t) {
        throw new Error("ARRAYBUFFER not supported by this environment");
      }

      return function (t) {
        return function (t, n, e) {
          let r;
          const i = n / 8,
                s = new ArrayBuffer(i),
                o = new Uint8Array(s),
                h = -1 === e ? 3 : 0;

          for (r = 0; r < i; r += 1) o[r] = t[r >>> 2] >>> 8 * (h + e * (r % 4)) & 255;

          return s;
        }(t, e, r);
      };

    case "UINT8ARRAY":
      try {
        new Uint8Array(0);
      } catch (t) {
        throw new Error("UINT8ARRAY not supported by this environment");
      }

      return function (t) {
        return function (t, n, e) {
          let r;
          const i = n / 8,
                s = -1 === e ? 3 : 0,
                o = new Uint8Array(i);

          for (r = 0; r < i; r += 1) o[r] = t[r >>> 2] >>> 8 * (s + e * (r % 4)) & 255;

          return o;
        }(t, e, r);
      };

    default:
      throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
  }
}

const i = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298],
      s = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428],
      o = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225],
      h = "Chosen SHA variant is not supported";

function u(t, n) {
  let e, r;
  const i = t.binLen >>> 3,
        s = n.binLen >>> 3,
        o = i << 3,
        h = 4 - i << 3;

  if (i % 4 != 0) {
    for (e = 0; e < s; e += 4) r = i + e >>> 2, t.value[r] |= n.value[e >>> 2] << o, t.value.push(0), t.value[r + 1] |= n.value[e >>> 2] >>> h;

    return (t.value.length << 2) - 4 >= s + i && t.value.pop(), {
      value: t.value,
      binLen: t.binLen + n.binLen
    };
  }

  return {
    value: t.value.concat(n.value),
    binLen: t.binLen + n.binLen
  };
}

function w(t) {
  const n = {
    outputUpper: !1,
    b64Pad: "=",
    outputLen: -1
  },
        e = t || {},
        r = "Output length must be a multiple of 8";

  if (n.outputUpper = e.outputUpper || !1, e.b64Pad && (n.b64Pad = e.b64Pad), e.outputLen) {
    if (e.outputLen % 8 != 0) throw new Error(r);
    n.outputLen = e.outputLen;
  } else if (e.shakeLen) {
    if (e.shakeLen % 8 != 0) throw new Error(r);
    n.outputLen = e.shakeLen;
  }

  if ("boolean" != typeof n.outputUpper) throw new Error("Invalid outputUpper formatting option");
  if ("string" != typeof n.b64Pad) throw new Error("Invalid b64Pad formatting option");
  return n;
}

function c(t, n, r, i) {
  const s = t + " must include a value and format";

  if (!n) {
    if (!i) throw new Error(s);
    return i;
  }

  if (void 0 === n.value || !n.format) throw new Error(s);
  return e(n.format, n.encoding || "UTF8", r)(n.value);
}

class f {
  constructor(t, n, e) {
    const r = e || {};
    if (this.t = n, this.i = r.encoding || "UTF8", this.numRounds = r.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds) throw new Error("numRounds must a integer >= 1");
    this.s = t, this.o = [], this.h = 0, this.u = !1, this.l = 0, this.A = !1, this.H = [], this.S = [];
  }

  update(t) {
    let n,
        e = 0;
    const r = this.p >>> 5,
          i = this.m(t, this.o, this.h),
          s = i.binLen,
          o = i.value,
          h = s >>> 5;

    for (n = 0; n < h; n += r) e + this.p <= s && (this.C = this.R(o.slice(n, n + r), this.C), e += this.p);

    this.l += e, this.o = o.slice(e >>> 5), this.h = s % this.p, this.u = !0;
  }

  getHash(t, n) {
    let e,
        i,
        s = this.U;
    const o = w(n);

    if (this.v) {
      if (-1 === o.outputLen) throw new Error("Output length must be specified in options");
      s = o.outputLen;
    }

    const h = r(t, s, this.K, o);
    if (this.A && this.T) return h(this.T(o));

    for (i = this.F(this.o.slice(), this.h, this.l, this.g(this.C), s), e = 1; e < this.numRounds; e += 1) this.v && s % 32 != 0 && (i[i.length - 1] &= 16777215 >>> 24 - s % 32), i = this.F(i, s, 0, this.B(this.s), s);

    return h(i);
  }

  setHMACKey(t, n, r) {
    if (!this.L) throw new Error("Variant does not support HMAC");
    if (this.u) throw new Error("Cannot set MAC key after calling update");
    const i = e(n, (r || {}).encoding || "UTF8", this.K);
    this.M(i(t));
  }

  M(t) {
    const n = this.p >>> 3,
          e = n / 4 - 1;
    let r;
    if (1 !== this.numRounds) throw new Error("Cannot set numRounds with MAC");
    if (this.A) throw new Error("MAC key already set");

    for (n < t.binLen / 8 && (t.value = this.F(t.value, t.binLen, 0, this.B(this.s), this.U)); t.value.length <= e;) t.value.push(0);

    for (r = 0; r <= e; r += 1) this.H[r] = 909522486 ^ t.value[r], this.S[r] = 1549556828 ^ t.value[r];

    this.C = this.R(this.H, this.C), this.l = this.p, this.A = !0;
  }

  getHMAC(t, n) {
    const e = w(n);
    return r(t, this.U, this.K, e)(this.k());
  }

  k() {
    let t;
    if (!this.A) throw new Error("Cannot call getHMAC without first setting MAC key");
    const n = this.F(this.o.slice(), this.h, this.l, this.g(this.C), this.U);
    return t = this.R(this.S, this.B(this.s)), t = this.F(n, this.U, this.p, t, this.U), t;
  }

}

function a(t, n) {
  return t << n | t >>> 32 - n;
}

function l(t, n) {
  return t >>> n | t << 32 - n;
}

function A(t, n) {
  return t >>> n;
}

function E(t, n, e) {
  return t ^ n ^ e;
}

function H(t, n, e) {
  return t & n ^ ~t & e;
}

function S(t, n, e) {
  return t & n ^ t & e ^ n & e;
}

function b(t) {
  return l(t, 2) ^ l(t, 13) ^ l(t, 22);
}

function p(t, n) {
  const e = (65535 & t) + (65535 & n);
  return (65535 & (t >>> 16) + (n >>> 16) + (e >>> 16)) << 16 | 65535 & e;
}

function d(t, n, e, r) {
  const i = (65535 & t) + (65535 & n) + (65535 & e) + (65535 & r);
  return (65535 & (t >>> 16) + (n >>> 16) + (e >>> 16) + (r >>> 16) + (i >>> 16)) << 16 | 65535 & i;
}

function m(t, n, e, r, i) {
  const s = (65535 & t) + (65535 & n) + (65535 & e) + (65535 & r) + (65535 & i);
  return (65535 & (t >>> 16) + (n >>> 16) + (e >>> 16) + (r >>> 16) + (i >>> 16) + (s >>> 16)) << 16 | 65535 & s;
}

function C(t) {
  return l(t, 7) ^ l(t, 18) ^ A(t, 3);
}

function y(t) {
  return l(t, 6) ^ l(t, 11) ^ l(t, 25);
}

function R(t) {
  return [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
}

function U(t, n) {
  let e, r, i, s, o, h, u;
  const w = [];

  for (e = n[0], r = n[1], i = n[2], s = n[3], o = n[4], u = 0; u < 80; u += 1) w[u] = u < 16 ? t[u] : a(w[u - 3] ^ w[u - 8] ^ w[u - 14] ^ w[u - 16], 1), h = u < 20 ? m(a(e, 5), H(r, i, s), o, 1518500249, w[u]) : u < 40 ? m(a(e, 5), E(r, i, s), o, 1859775393, w[u]) : u < 60 ? m(a(e, 5), S(r, i, s), o, 2400959708, w[u]) : m(a(e, 5), E(r, i, s), o, 3395469782, w[u]), o = s, s = i, i = a(r, 30), r = e, e = h;

  return n[0] = p(e, n[0]), n[1] = p(r, n[1]), n[2] = p(i, n[2]), n[3] = p(s, n[3]), n[4] = p(o, n[4]), n;
}

function v(t, n, e, r) {
  let i;
  const s = 15 + (n + 65 >>> 9 << 4),
        o = n + e;

  for (; t.length <= s;) t.push(0);

  for (t[n >>> 5] |= 128 << 24 - n % 32, t[s] = 4294967295 & o, t[s - 1] = o / 4294967296 | 0, i = 0; i < t.length; i += 16) r = U(t.slice(i, i + 16), r);

  return r;
}

class K extends f {
  constructor(t, n, r) {
    if ("SHA-1" !== t) throw new Error(h);
    super(t, n, r);
    const i = r || {};
    this.L = !0, this.T = this.k, this.K = -1, this.m = e(this.t, this.i, this.K), this.R = U, this.g = function (t) {
      return t.slice();
    }, this.B = R, this.F = v, this.C = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.p = 512, this.U = 160, this.v = !1, i.hmacKey && this.M(c("hmacKey", i.hmacKey, this.K));
  }

}

function T(t) {
  let n;
  return n = "SHA-224" == t ? s.slice() : o.slice(), n;
}

function F(t, n) {
  let e, r, s, o, h, u, w, c, f, a, E;
  const R = [];

  for (e = n[0], r = n[1], s = n[2], o = n[3], h = n[4], u = n[5], w = n[6], c = n[7], E = 0; E < 64; E += 1) R[E] = E < 16 ? t[E] : d(l(U = R[E - 2], 17) ^ l(U, 19) ^ A(U, 10), R[E - 7], C(R[E - 15]), R[E - 16]), f = m(c, y(h), H(h, u, w), i[E], R[E]), a = p(b(e), S(e, r, s)), c = w, w = u, u = h, h = p(o, f), o = s, s = r, r = e, e = p(f, a);

  var U;
  return n[0] = p(e, n[0]), n[1] = p(r, n[1]), n[2] = p(s, n[2]), n[3] = p(o, n[3]), n[4] = p(h, n[4]), n[5] = p(u, n[5]), n[6] = p(w, n[6]), n[7] = p(c, n[7]), n;
}

class g extends f {
  constructor(t, n, r) {
    if ("SHA-224" !== t && "SHA-256" !== t) throw new Error(h);
    super(t, n, r);
    const i = r || {};
    this.T = this.k, this.L = !0, this.K = -1, this.m = e(this.t, this.i, this.K), this.R = F, this.g = function (t) {
      return t.slice();
    }, this.B = T, this.F = function (n, e, r, i) {
      return function (t, n, e, r, i) {
        let s, o;
        const h = 15 + (n + 65 >>> 9 << 4),
              u = n + e;

        for (; t.length <= h;) t.push(0);

        for (t[n >>> 5] |= 128 << 24 - n % 32, t[h] = 4294967295 & u, t[h - 1] = u / 4294967296 | 0, s = 0; s < t.length; s += 16) r = F(t.slice(s, s + 16), r);

        return o = "SHA-224" === i ? [r[0], r[1], r[2], r[3], r[4], r[5], r[6]] : r, o;
      }(n, e, r, i, t);
    }, this.C = T(t), this.p = 512, this.U = "SHA-224" === t ? 224 : 256, this.v = !1, i.hmacKey && this.M(c("hmacKey", i.hmacKey, this.K));
  }

}

class B {
  constructor(t, n) {
    this.Y = t, this.N = n;
  }

}

function L(t, n) {
  let e;
  return n > 32 ? (e = 64 - n, new B(t.N << n | t.Y >>> e, t.Y << n | t.N >>> e)) : 0 !== n ? (e = 32 - n, new B(t.Y << n | t.N >>> e, t.N << n | t.Y >>> e)) : t;
}

function M(t, n) {
  let e;
  return n < 32 ? (e = 32 - n, new B(t.Y >>> n | t.N << e, t.N >>> n | t.Y << e)) : (e = 64 - n, new B(t.N >>> n | t.Y << e, t.Y >>> n | t.N << e));
}

function k(t, n) {
  return new B(t.Y >>> n, t.N >>> n | t.Y << 32 - n);
}

function Y(t, n, e) {
  return new B(t.Y & n.Y ^ t.Y & e.Y ^ n.Y & e.Y, t.N & n.N ^ t.N & e.N ^ n.N & e.N);
}

function N(t) {
  const n = M(t, 28),
        e = M(t, 34),
        r = M(t, 39);
  return new B(n.Y ^ e.Y ^ r.Y, n.N ^ e.N ^ r.N);
}

function I(t, n) {
  let e, r;
  e = (65535 & t.N) + (65535 & n.N), r = (t.N >>> 16) + (n.N >>> 16) + (e >>> 16);
  const i = (65535 & r) << 16 | 65535 & e;
  e = (65535 & t.Y) + (65535 & n.Y) + (r >>> 16), r = (t.Y >>> 16) + (n.Y >>> 16) + (e >>> 16);
  return new B((65535 & r) << 16 | 65535 & e, i);
}

function X(t, n, e, r) {
  let i, s;
  i = (65535 & t.N) + (65535 & n.N) + (65535 & e.N) + (65535 & r.N), s = (t.N >>> 16) + (n.N >>> 16) + (e.N >>> 16) + (r.N >>> 16) + (i >>> 16);
  const o = (65535 & s) << 16 | 65535 & i;
  i = (65535 & t.Y) + (65535 & n.Y) + (65535 & e.Y) + (65535 & r.Y) + (s >>> 16), s = (t.Y >>> 16) + (n.Y >>> 16) + (e.Y >>> 16) + (r.Y >>> 16) + (i >>> 16);
  return new B((65535 & s) << 16 | 65535 & i, o);
}

function z(t, n, e, r, i) {
  let s, o;
  s = (65535 & t.N) + (65535 & n.N) + (65535 & e.N) + (65535 & r.N) + (65535 & i.N), o = (t.N >>> 16) + (n.N >>> 16) + (e.N >>> 16) + (r.N >>> 16) + (i.N >>> 16) + (s >>> 16);
  const h = (65535 & o) << 16 | 65535 & s;
  s = (65535 & t.Y) + (65535 & n.Y) + (65535 & e.Y) + (65535 & r.Y) + (65535 & i.Y) + (o >>> 16), o = (t.Y >>> 16) + (n.Y >>> 16) + (e.Y >>> 16) + (r.Y >>> 16) + (i.Y >>> 16) + (s >>> 16);
  return new B((65535 & o) << 16 | 65535 & s, h);
}

function x(t, n) {
  return new B(t.Y ^ n.Y, t.N ^ n.N);
}

function _(t) {
  const n = M(t, 19),
        e = M(t, 61),
        r = k(t, 6);
  return new B(n.Y ^ e.Y ^ r.Y, n.N ^ e.N ^ r.N);
}

function O(t) {
  const n = M(t, 1),
        e = M(t, 8),
        r = k(t, 7);
  return new B(n.Y ^ e.Y ^ r.Y, n.N ^ e.N ^ r.N);
}

function P(t) {
  const n = M(t, 14),
        e = M(t, 18),
        r = M(t, 41);
  return new B(n.Y ^ e.Y ^ r.Y, n.N ^ e.N ^ r.N);
}

const V = [new B(i[0], 3609767458), new B(i[1], 602891725), new B(i[2], 3964484399), new B(i[3], 2173295548), new B(i[4], 4081628472), new B(i[5], 3053834265), new B(i[6], 2937671579), new B(i[7], 3664609560), new B(i[8], 2734883394), new B(i[9], 1164996542), new B(i[10], 1323610764), new B(i[11], 3590304994), new B(i[12], 4068182383), new B(i[13], 991336113), new B(i[14], 633803317), new B(i[15], 3479774868), new B(i[16], 2666613458), new B(i[17], 944711139), new B(i[18], 2341262773), new B(i[19], 2007800933), new B(i[20], 1495990901), new B(i[21], 1856431235), new B(i[22], 3175218132), new B(i[23], 2198950837), new B(i[24], 3999719339), new B(i[25], 766784016), new B(i[26], 2566594879), new B(i[27], 3203337956), new B(i[28], 1034457026), new B(i[29], 2466948901), new B(i[30], 3758326383), new B(i[31], 168717936), new B(i[32], 1188179964), new B(i[33], 1546045734), new B(i[34], 1522805485), new B(i[35], 2643833823), new B(i[36], 2343527390), new B(i[37], 1014477480), new B(i[38], 1206759142), new B(i[39], 344077627), new B(i[40], 1290863460), new B(i[41], 3158454273), new B(i[42], 3505952657), new B(i[43], 106217008), new B(i[44], 3606008344), new B(i[45], 1432725776), new B(i[46], 1467031594), new B(i[47], 851169720), new B(i[48], 3100823752), new B(i[49], 1363258195), new B(i[50], 3750685593), new B(i[51], 3785050280), new B(i[52], 3318307427), new B(i[53], 3812723403), new B(i[54], 2003034995), new B(i[55], 3602036899), new B(i[56], 1575990012), new B(i[57], 1125592928), new B(i[58], 2716904306), new B(i[59], 442776044), new B(i[60], 593698344), new B(i[61], 3733110249), new B(i[62], 2999351573), new B(i[63], 3815920427), new B(3391569614, 3928383900), new B(3515267271, 566280711), new B(3940187606, 3454069534), new B(4118630271, 4000239992), new B(116418474, 1914138554), new B(174292421, 2731055270), new B(289380356, 3203993006), new B(460393269, 320620315), new B(685471733, 587496836), new B(852142971, 1086792851), new B(1017036298, 365543100), new B(1126000580, 2618297676), new B(1288033470, 3409855158), new B(1501505948, 4234509866), new B(1607167915, 987167468), new B(1816402316, 1246189591)];

function Z(t) {
  return "SHA-384" === t ? [new B(3418070365, s[0]), new B(1654270250, s[1]), new B(2438529370, s[2]), new B(355462360, s[3]), new B(1731405415, s[4]), new B(41048885895, s[5]), new B(3675008525, s[6]), new B(1203062813, s[7])] : [new B(o[0], 4089235720), new B(o[1], 2227873595), new B(o[2], 4271175723), new B(o[3], 1595750129), new B(o[4], 2917565137), new B(o[5], 725511199), new B(o[6], 4215389547), new B(o[7], 327033209)];
}

function j(t, n) {
  let e, r, i, s, o, h, u, w, c, f, a, l;
  const A = [];

  for (e = n[0], r = n[1], i = n[2], s = n[3], o = n[4], h = n[5], u = n[6], w = n[7], a = 0; a < 80; a += 1) a < 16 ? (l = 2 * a, A[a] = new B(t[l], t[l + 1])) : A[a] = X(_(A[a - 2]), A[a - 7], O(A[a - 15]), A[a - 16]), c = z(w, P(o), (H = h, S = u, new B((E = o).Y & H.Y ^ ~E.Y & S.Y, E.N & H.N ^ ~E.N & S.N)), V[a], A[a]), f = I(N(e), Y(e, r, i)), w = u, u = h, h = o, o = I(s, c), s = i, i = r, r = e, e = I(c, f);

  var E, H, S;
  return n[0] = I(e, n[0]), n[1] = I(r, n[1]), n[2] = I(i, n[2]), n[3] = I(s, n[3]), n[4] = I(o, n[4]), n[5] = I(h, n[5]), n[6] = I(u, n[6]), n[7] = I(w, n[7]), n;
}

class q extends f {
  constructor(t, n, r) {
    if ("SHA-384" !== t && "SHA-512" !== t) throw new Error(h);
    super(t, n, r);
    const i = r || {};
    this.T = this.k, this.L = !0, this.K = -1, this.m = e(this.t, this.i, this.K), this.R = j, this.g = function (t) {
      return t.slice();
    }, this.B = Z, this.F = function (n, e, r, i) {
      return function (t, n, e, r, i) {
        let s, o;
        const h = 31 + (n + 129 >>> 10 << 5),
              u = n + e;

        for (; t.length <= h;) t.push(0);

        for (t[n >>> 5] |= 128 << 24 - n % 32, t[h] = 4294967295 & u, t[h - 1] = u / 4294967296 | 0, s = 0; s < t.length; s += 32) r = j(t.slice(s, s + 32), r);

        return o = "SHA-384" === i ? [(r = r)[0].Y, r[0].N, r[1].Y, r[1].N, r[2].Y, r[2].N, r[3].Y, r[3].N, r[4].Y, r[4].N, r[5].Y, r[5].N] : [r[0].Y, r[0].N, r[1].Y, r[1].N, r[2].Y, r[2].N, r[3].Y, r[3].N, r[4].Y, r[4].N, r[5].Y, r[5].N, r[6].Y, r[6].N, r[7].Y, r[7].N], o;
      }(n, e, r, i, t);
    }, this.C = Z(t), this.p = 1024, this.U = "SHA-384" === t ? 384 : 512, this.v = !1, i.hmacKey && this.M(c("hmacKey", i.hmacKey, this.K));
  }

}

const D = [new B(0, 1), new B(0, 32898), new B(2147483648, 32906), new B(2147483648, 2147516416), new B(0, 32907), new B(0, 2147483649), new B(2147483648, 2147516545), new B(2147483648, 32777), new B(0, 138), new B(0, 136), new B(0, 2147516425), new B(0, 2147483658), new B(0, 2147516555), new B(2147483648, 139), new B(2147483648, 32905), new B(2147483648, 32771), new B(2147483648, 32770), new B(2147483648, 128), new B(0, 32778), new B(2147483648, 2147483658), new B(2147483648, 2147516545), new B(2147483648, 32896), new B(0, 2147483649), new B(2147483648, 2147516424)],
      G = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];

function J(t) {
  let n;
  const e = [];

  for (n = 0; n < 5; n += 1) e[n] = [new B(0, 0), new B(0, 0), new B(0, 0), new B(0, 0), new B(0, 0)];

  return e;
}

function Q(t) {
  let n;
  const e = [];

  for (n = 0; n < 5; n += 1) e[n] = t[n].slice();

  return e;
}

function W(t, n) {
  let e, r, i, s;
  const o = [],
        h = [];
  if (null !== t) for (r = 0; r < t.length; r += 2) n[(r >>> 1) % 5][(r >>> 1) / 5 | 0] = x(n[(r >>> 1) % 5][(r >>> 1) / 5 | 0], new B(t[r + 1], t[r]));

  for (e = 0; e < 24; e += 1) {
    for (s = J(), r = 0; r < 5; r += 1) o[r] = (u = n[r][0], w = n[r][1], c = n[r][2], f = n[r][3], a = n[r][4], new B(u.Y ^ w.Y ^ c.Y ^ f.Y ^ a.Y, u.N ^ w.N ^ c.N ^ f.N ^ a.N));

    for (r = 0; r < 5; r += 1) h[r] = x(o[(r + 4) % 5], L(o[(r + 1) % 5], 1));

    for (r = 0; r < 5; r += 1) for (i = 0; i < 5; i += 1) n[r][i] = x(n[r][i], h[r]);

    for (r = 0; r < 5; r += 1) for (i = 0; i < 5; i += 1) s[i][(2 * r + 3 * i) % 5] = L(n[r][i], G[r][i]);

    for (r = 0; r < 5; r += 1) for (i = 0; i < 5; i += 1) n[r][i] = x(s[r][i], new B(~s[(r + 1) % 5][i].Y & s[(r + 2) % 5][i].Y, ~s[(r + 1) % 5][i].N & s[(r + 2) % 5][i].N));

    n[0][0] = x(n[0][0], D[e]);
  }

  var u, w, c, f, a;
  return n;
}

function $(t) {
  let n,
      e,
      r = 0;
  const i = [0, 0],
        s = [4294967295 & t, t / 4294967296 & 2097151];

  for (n = 6; n >= 0; n--) e = s[n >> 2] >>> 8 * n & 255, 0 === e && 0 === r || (i[r + 1 >> 2] |= e << 8 * (r + 1), r += 1);

  return r = 0 !== r ? r : 1, i[0] |= r, {
    value: r + 1 > 4 ? i : [i[0]],
    binLen: 8 + 8 * r
  };
}

function tt(t) {
  return u($(t.binLen), t);
}

function nt(t, n) {
  let e,
      r = $(n);
  r = u(r, t);
  const i = n >>> 2,
        s = (i - r.value.length % i) % i;

  for (e = 0; e < s; e++) r.value.push(0);

  return r.value;
}

class et extends f {
  constructor(t, n, r) {
    let i = 6,
        s = 0;
    super(t, n, r);
    const o = r || {};

    if (1 !== this.numRounds) {
      if (o.kmacKey || o.hmacKey) throw new Error("Cannot set numRounds with MAC");
      if ("CSHAKE128" === this.s || "CSHAKE256" === this.s) throw new Error("Cannot set numRounds for CSHAKE variants");
    }

    switch (this.K = 1, this.m = e(this.t, this.i, this.K), this.R = W, this.g = Q, this.B = J, this.C = J(), this.v = !1, t) {
      case "SHA3-224":
        this.p = s = 1152, this.U = 224, this.L = !0, this.T = this.k;
        break;

      case "SHA3-256":
        this.p = s = 1088, this.U = 256, this.L = !0, this.T = this.k;
        break;

      case "SHA3-384":
        this.p = s = 832, this.U = 384, this.L = !0, this.T = this.k;
        break;

      case "SHA3-512":
        this.p = s = 576, this.U = 512, this.L = !0, this.T = this.k;
        break;

      case "SHAKE128":
        i = 31, this.p = s = 1344, this.U = -1, this.v = !0, this.L = !1, this.T = null;
        break;

      case "SHAKE256":
        i = 31, this.p = s = 1088, this.U = -1, this.v = !0, this.L = !1, this.T = null;
        break;

      case "KMAC128":
        i = 4, this.p = s = 1344, this.I(r), this.U = -1, this.v = !0, this.L = !1, this.T = this.X;
        break;

      case "KMAC256":
        i = 4, this.p = s = 1088, this.I(r), this.U = -1, this.v = !0, this.L = !1, this.T = this.X;
        break;

      case "CSHAKE128":
        this.p = s = 1344, i = this._(r), this.U = -1, this.v = !0, this.L = !1, this.T = null;
        break;

      case "CSHAKE256":
        this.p = s = 1088, i = this._(r), this.U = -1, this.v = !0, this.L = !1, this.T = null;
        break;

      default:
        throw new Error(h);
    }

    this.F = function (t, n, e, r, o) {
      return function (t, n, e, r, i, s, o) {
        let h,
            u,
            w = 0;
        const c = [],
              f = i >>> 5,
              a = n >>> 5;

        for (h = 0; h < a && n >= i; h += f) r = W(t.slice(h, h + f), r), n -= i;

        for (t = t.slice(h), n %= i; t.length < f;) t.push(0);

        for (h = n >>> 3, t[h >> 2] ^= s << h % 4 * 8, t[f - 1] ^= 2147483648, r = W(t, r); 32 * c.length < o && (u = r[w % 5][w / 5 | 0], c.push(u.N), !(32 * c.length >= o));) c.push(u.Y), w += 1, 0 == 64 * w % i && (W(null, r), w = 0);

        return c;
      }(t, n, 0, r, s, i, o);
    }, o.hmacKey && this.M(c("hmacKey", o.hmacKey, this.K));
  }

  _(t, n) {
    const e = function (t) {
      const n = t || {};
      return {
        funcName: c("funcName", n.funcName, 1, {
          value: [],
          binLen: 0
        }),
        customization: c("Customization", n.customization, 1, {
          value: [],
          binLen: 0
        })
      };
    }(t || {});

    n && (e.funcName = n);
    const r = u(tt(e.funcName), tt(e.customization));

    if (0 !== e.customization.binLen || 0 !== e.funcName.binLen) {
      const t = nt(r, this.p >>> 3);

      for (let n = 0; n < t.length; n += this.p >>> 5) this.C = this.R(t.slice(n, n + (this.p >>> 5)), this.C), this.l += this.p;

      return 4;
    }

    return 31;
  }

  I(t) {
    const n = function (t) {
      const n = t || {};
      return {
        kmacKey: c("kmacKey", n.kmacKey, 1),
        funcName: {
          value: [1128353099],
          binLen: 32
        },
        customization: c("Customization", n.customization, 1, {
          value: [],
          binLen: 0
        })
      };
    }(t || {});

    this._(t, n.funcName);

    const e = nt(tt(n.kmacKey), this.p >>> 3);

    for (let t = 0; t < e.length; t += this.p >>> 5) this.C = this.R(e.slice(t, t + (this.p >>> 5)), this.C), this.l += this.p;

    this.A = !0;
  }

  X(t) {
    const n = u({
      value: this.o.slice(),
      binLen: this.h
    }, function (t) {
      let n,
          e,
          r = 0;
      const i = [0, 0],
            s = [4294967295 & t, t / 4294967296 & 2097151];

      for (n = 6; n >= 0; n--) e = s[n >> 2] >>> 8 * n & 255, 0 === e && 0 === r || (i[r >> 2] |= e << 8 * r, r += 1);

      return r = 0 !== r ? r : 1, i[r >> 2] |= r << 8 * r, {
        value: r + 1 > 4 ? i : [i[0]],
        binLen: 8 + 8 * r
      };
    }(t.outputLen));
    return this.F(n.value, n.binLen, this.l, this.g(this.C), t.outputLen);
  }

}

class _default {
  constructor(t, n, e) {
    if ("SHA-1" == t) this.O = new K(t, n, e);else if ("SHA-224" == t || "SHA-256" == t) this.O = new g(t, n, e);else if ("SHA-384" == t || "SHA-512" == t) this.O = new q(t, n, e);else {
      if ("SHA3-224" != t && "SHA3-256" != t && "SHA3-384" != t && "SHA3-512" != t && "SHAKE128" != t && "SHAKE256" != t && "CSHAKE128" != t && "CSHAKE256" != t && "KMAC128" != t && "KMAC256" != t) throw new Error(h);
      this.O = new et(t, n, e);
    }
  }

  update(t) {
    this.O.update(t);
  }

  getHash(t, n) {
    return this.O.getHash(t, n);
  }

  setHMACKey(t, n, e) {
    this.O.setHMACKey(t, n, e);
  }

  getHMAC(t, n) {
    return this.O.getHMAC(t, n);
  }

}

exports.default = _default;
},{}],"vW7r":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SharedAccessSignatureCredential = exports.SharedKeyCredential = void 0;

var _coreAmqp = require("@azure/core-amqp");

var _buffer = require("buffer");

var _isBuffer = _interopRequireDefault(require("is-buffer"));

var _jssha = _interopRequireDefault(require("jssha"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @class SharedKeyCredential
 * @internal
 * @hidden
 * Defines the SharedKeyCredential.
 */
class SharedKeyCredential {
  /**
   * Initializes a new instance of SharedKeyCredential
   * @constructor
   * @param {string} keyName - The name of the EventHub/ServiceBus key.
   * @param {string} key - The secret value associated with the above EventHub/ServiceBus key
   */
  constructor(keyName, key) {
    this.keyName = keyName;
    this.key = key;
  }
  /**
   * Gets the sas token for the specified audience
   * @param {string} [audience] - The audience for which the token is desired.
   */


  getToken(audience) {
    return this._createToken(Math.floor(Date.now() / 1000) + 3600, audience);
  }
  /**
   * Creates the sas token based on the provided information
   * @param {string | number} expiry - The time period in unix time after which the token will expire.
   * @param {string} [audience] - The audience for which the token is desired.
   * @param {string | Buffer} [hashInput] The input to be provided to hmac to create the hash.
   */


  _createToken(expiry, audience, hashInput) {
    audience = encodeURIComponent(audience);
    const keyName = encodeURIComponent(this.keyName);
    const stringToSign = audience + "\n" + expiry;
    hashInput = hashInput || this.key;
    let shaObj;

    if ((0, _isBuffer.default)(hashInput)) {
      shaObj = new _jssha.default("SHA-256", "ARRAYBUFFER");
      shaObj.setHMACKey(hashInput, "ARRAYBUFFER");
      shaObj.update(_buffer.Buffer.from(stringToSign));
    } else {
      shaObj = new _jssha.default("SHA-256", "TEXT");
      shaObj.setHMACKey(hashInput, "TEXT");
      shaObj.update(stringToSign);
    }

    const sig = encodeURIComponent(shaObj.getHMAC("B64"));
    return {
      token: `SharedAccessSignature sr=${audience}&sig=${sig}&se=${expiry}&skn=${keyName}`,
      expiresOnTimestamp: expiry
    };
  }
  /**
   * Creates a token provider from the EventHub/ServiceBus connection string;
   * @param {string} connectionString - The EventHub/ServiceBus connection string
   */


  static fromConnectionString(connectionString) {
    const parsed = (0, _coreAmqp.parseConnectionString)(connectionString);

    if (parsed.SharedAccessSignature == null) {
      return new SharedKeyCredential(parsed.SharedAccessKeyName, parsed.SharedAccessKey);
    } else {
      return new SharedAccessSignatureCredential(parsed.SharedAccessSignature);
    }
  }

}
/**
 * A credential that takes a SharedAccessSignature:
 * `SharedAccessSignature sr=<resource>&sig=<signature>&se=<expiry>&skn=<keyname>`
 *
 * @internal
 * @hidden
 */


exports.SharedKeyCredential = SharedKeyCredential;

class SharedAccessSignatureCredential extends SharedKeyCredential {
  /**
   * @param sharedAccessSignature A shared access signature of the form
   * `SharedAccessSignature sr=<resource>&sig=<signature>&se=<expiry>&skn=<keyname>`
   */
  constructor(sharedAccessSignature) {
    super("", "");
    this._accessToken = {
      token: sharedAccessSignature,
      expiresOnTimestamp: 0
    };
  }
  /**
   * Retrieve a valid token for authenticaton.
   *
   * @param _audience Not applicable in SharedAccessSignatureCredential as the token is not re-generated at every invocation of the method
   */


  getToken(_audience) {
    return this._accessToken;
  }

}

exports.SharedAccessSignatureCredential = SharedAccessSignatureCredential;
},{"@azure/core-amqp":"n95d","buffer":"z1tx","is-buffer":"yQtW","jssha":"HqYT"}],"I4ko":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateKey = generateKey;

var _tslib = require("tslib");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

/**
 * @internal
 * @hidden
 * @param {string} secret
 * @param {string} stringToSign
 * @returns {Promise<string>}
 */
function generateKey(secret, stringToSign) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
    const key = yield window.crypto.subtle.importKey("raw", convertToUint8Array(secret), {
      name: "HMAC",
      hash: {
        name: "SHA-256"
      }
    }, false, ["sign"]);
    const signature = yield window.crypto.subtle.sign("HMAC", key, convertToUint8Array(stringToSign));
    const base64encodedString = encodeByteArray(new Uint8Array(signature));
    const result = encodeURIComponent(base64encodedString);
    return result;
  });
}
/**
 * @internal
 * @hidden
 * @param {string} value
 */


function convertToUint8Array(value) {
  const arr = new Uint8Array(value.length);

  for (let i = 0; i < value.length; i++) {
    arr[i] = value.charCodeAt(i);
  }

  return arr;
}
/**
 * Encodes a byte array in base64 format.
 * @param value the Uint8Aray to encode
 * @internal
 * @hidden
 * @param {Uint8Array} value
 * @returns {string}
 */


function encodeByteArray(value) {
  let str = "";

  for (let i = 0; i < value.length; i++) {
    str += String.fromCharCode(value[i]);
  }

  return btoa(str);
}
},{"tslib":"CvJj"}],"Wx48":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SasServiceClientCredentials = void 0;

var _tslib = require("tslib");

var _servicebusSharedKeyCredential = require("../servicebusSharedKeyCredential");

var _coreHttp = require("@azure/core-http");

var _crypto = require("./crypto");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * @class SasServiceClientCredentials
 * @implements {ServiceClientCredentials}
 */
class SasServiceClientCredentials {
  /**
   * Creates a new sasServiceClientCredentials object.
   *
   * @constructor
   * @param {string} sharedAccessKeyName The SAS key name to use.
   * @param {string} sharedAccessKey The SAS key value to use
   */
  constructor(sharedAccessKeyName, sharedAccessKey) {
    this.keyName = sharedAccessKeyName;
    this.keyValue = sharedAccessKey;
    this.sharedKeyCredential = new _servicebusSharedKeyCredential.SharedKeyCredential(this.keyName, this.keyValue);
  }

  _generateSignature(targetUri, expirationDate) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const stringToSign = `${targetUri}\n${expirationDate}`;
      const result = yield (0, _crypto.generateKey)(this.keyValue, stringToSign);
      return result;
    });
  }
  /**
   * Signs a request with the Authentication header.
   *
   * @param {WebResource} webResource The WebResource to be signed.
   * @returns {Promise<WebResource>} The signed request object.
   */


  signRequest(webResource) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      if (!webResource.headers) webResource.headers = new _coreHttp.HttpHeaders();
      const targetUri = encodeURIComponent(webResource.url.toLowerCase()).toLowerCase();
      const date = new Date();
      date.setMinutes(date.getMinutes() + 5);
      const expirationDate = Math.round(date.getTime() / 1000);
      const signature = yield this._generateSignature(targetUri, expirationDate);
      webResource.headers.set("authorization", `SharedAccessSignature sig=${signature}&se=${expirationDate}&skn=${this.keyName}&sr=${targetUri}`);
      webResource.withCredentials = true;
      return webResource;
    });
  }

  getToken(audience) {
    return this.sharedKeyCredential.getToken(audience);
  }

}

exports.SasServiceClientCredentials = SasServiceClientCredentials;
},{"tslib":"CvJj","../servicebusSharedKeyCredential":"vW7r","@azure/core-http":"rj0o","./crypto":"I4ko"}],"C8Py":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSpan = createSpan;
exports.getCanonicalCode = getCanonicalCode;

var _coreHttp = require("@azure/core-http");

var _coreTracing = require("@azure/core-tracing");

var _api = require("@opentelemetry/api");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * Creates a span using the global tracer.
 * @param name The name of the operation being performed.
 * @param operationOptions The options for the underlying http request.
 */
function createSpan(operationName, operationOptions = {}) {
  var _a, _b, _c;

  const tracer = (0, _coreTracing.getTracer)();
  const spanOptions = Object.assign(Object.assign({}, (_a = operationOptions.tracingOptions) === null || _a === void 0 ? void 0 : _a.spanOptions), {
    kind: _api.SpanKind.INTERNAL
  });
  const span = tracer.startSpan(`Azure.ServiceBus.${operationName}`, spanOptions);
  span.setAttribute("az.namespace", "Microsoft.ServiceBus");
  let newSpanOptions = ((_b = operationOptions.tracingOptions) === null || _b === void 0 ? void 0 : _b.spanOptions) || {};

  if (span.isRecording()) {
    newSpanOptions = Object.assign(Object.assign({}, (_c = operationOptions.tracingOptions) === null || _c === void 0 ? void 0 : _c.spanOptions), {
      parent: span.context(),
      attributes: Object.assign(Object.assign({}, spanOptions.attributes), {
        "az.namespace": "Microsoft.ServiceBus"
      })
    });
  }

  return {
    span,
    updatedOperationOptions: Object.assign(Object.assign({}, operationOptions), {
      tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), {
        spanOptions: newSpanOptions
      })
    })
  };
}
/**
 * @internal
 * @hidden
 */


function getCanonicalCode(err) {
  if (err instanceof _coreHttp.RestError) {
    switch (err.statusCode) {
      case 401:
        return _api.CanonicalCode.PERMISSION_DENIED;

      case 404:
        return _api.CanonicalCode.NOT_FOUND;

      case 412:
        return _api.CanonicalCode.FAILED_PRECONDITION;
    }
  }

  return _api.CanonicalCode.UNKNOWN;
}
},{"@azure/core-http":"rj0o","@azure/core-tracing":"xbTt","@opentelemetry/api":"fNAU"}],"XwmX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServiceBusAdministrationClient = void 0;

var _tslib = require("tslib");

var _coreAmqp = require("@azure/core-amqp");

var _coreAuth = require("@azure/core-auth");

var _coreHttp = require("@azure/core-http");

var _log = require("./log");

var _namespaceResourceSerializer = require("./serializers/namespaceResourceSerializer");

var _queueResourceSerializer = require("./serializers/queueResourceSerializer");

var _ruleResourceSerializer = require("./serializers/ruleResourceSerializer");

var _subscriptionResourceSerializer = require("./serializers/subscriptionResourceSerializer");

var _topicResourceSerializer = require("./serializers/topicResourceSerializer");

var _atomXmlHelper = require("./util/atomXmlHelper");

var Constants = _interopRequireWildcard(require("./util/constants"));

var _parseUrl = require("./util/parseUrl");

var _sasServiceClientCredentials = require("./util/sasServiceClientCredentials");

var _tracing = require("./util/tracing");

var _utils = require("./util/utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * All operations return promises that resolve to an object that has the relevant output.
 * These objects also have a property called `_response` that you can use if you want to
 * access the direct response from the service.
 */
class ServiceBusAdministrationClient extends _coreHttp.ServiceClient {
  constructor(fullyQualifiedNamespaceOrConnectionString1, credentialOrOptions2, options3) {
    var _a;

    let options;
    let fullyQualifiedNamespace;
    let credentials;
    let authPolicy;

    if ((0, _coreAuth.isTokenCredential)(credentialOrOptions2)) {
      fullyQualifiedNamespace = fullyQualifiedNamespaceOrConnectionString1;
      options = options3 || {};
      credentials = credentialOrOptions2;
      authPolicy = (0, _coreHttp.bearerTokenAuthenticationPolicy)(credentials, _coreAmqp.Constants.aadServiceBusScope);
    } else {
      const connectionString = fullyQualifiedNamespaceOrConnectionString1;
      options = credentialOrOptions2 || {};
      const connectionStringObj = (0, _coreAmqp.parseConnectionString)(connectionString);

      if (connectionStringObj.Endpoint == undefined) {
        throw new Error("Missing Endpoint in connection string.");
      }

      try {
        fullyQualifiedNamespace = connectionStringObj.Endpoint.match(".*://([^/]*)")[1];
      } catch (error) {
        throw new Error("Endpoint in the connection string is not valid.");
      }

      credentials = new _sasServiceClientCredentials.SasServiceClientCredentials(connectionStringObj.SharedAccessKeyName, connectionStringObj.SharedAccessKey);
      authPolicy = (0, _coreHttp.signingPolicy)(credentials);
    }

    const userAgentPrefix = (0, _utils.formatUserAgentPrefix)((_a = options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix);
    const serviceClientOptions = (0, _coreHttp.createPipelineFromOptions)(Object.assign(Object.assign({}, options), {
      userAgentOptions: {
        userAgentPrefix
      }
    }), authPolicy);
    super(credentials, serviceClientOptions);
    this.endpoint = fullyQualifiedNamespace;
    this.endpointWithProtocol = fullyQualifiedNamespace.endsWith("/") ? "sb://" + fullyQualifiedNamespace : "sb://" + fullyQualifiedNamespace + "/";
    this.credentials = credentials;
    this.namespaceResourceSerializer = new _namespaceResourceSerializer.NamespaceResourceSerializer();
    this.queueResourceSerializer = new _queueResourceSerializer.QueueResourceSerializer();
    this.topicResourceSerializer = new _topicResourceSerializer.TopicResourceSerializer();
    this.subscriptionResourceSerializer = new _subscriptionResourceSerializer.SubscriptionResourceSerializer();
    this.ruleResourceSerializer = new _ruleResourceSerializer.RuleResourceSerializer();
  }
  /**
   * Returns an object representing the metadata related to a service bus namespace.
   * @param queueName
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   */


  getNamespaceProperties(operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      _log.administrationLogger.verbose(`Performing management operation - getNamespaceProperties()`);

      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getNamespaceProperties", operationOptions);

      try {
        const response = yield this.getResource("$namespaceinfo", this.namespaceResourceSerializer, updatedOperationOptions);
        return this.buildNamespacePropertiesResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Creates a queue with given name, configured using the given options
   * @param queueName
   * @param options Options to configure the Queue being created(For example, you can configure a queue to support partitions or sessions)
   *  and the operation options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  createQueue(queueName, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-createQueue", options);

      try {
        _log.administrationLogger.verbose(`Performing management operation - createQueue() for "${queueName}" with options: %j`, options);

        const response = yield this.putResource(queueName, (0, _queueResourceSerializer.buildQueueOptions)(options || {}), this.queueResourceSerializer, false, updatedOperationOptions);
        return this.buildQueueResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Returns an object representing the Queue and its properties.
   * If you want to get the Queue runtime info like message count details, use `getQueueRuntimeProperties` API.
   * @param queueName
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  getQueue(queueName, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getQueue", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - getQueue() for "${queueName}"`);

        const response = yield this.getResource(queueName, this.queueResourceSerializer, updatedOperationOptions);
        return this.buildQueueResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Returns an object representing the Queue runtime info like message count details.
   * @param queueName
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  getQueueRuntimeProperties(queueName, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getQueueRuntimeProperties", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - getQueueRuntimeProperties() for "${queueName}"`);

        const response = yield this.getResource(queueName, this.queueResourceSerializer, updatedOperationOptions);
        return this.buildQueueRuntimePropertiesResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Returns a list of objects, each representing a Queue along with its properties.
   * If you want to get the runtime info of the queues like message count, use `getQueuesRuntimeProperties` API instead.
   * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  getQueues(options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getQueues", options);

      try {
        _log.administrationLogger.verbose(`Performing management operation - getQueues() with options: %j`, options);

        const response = yield this.listResources("$Resources/Queues", updatedOperationOptions, this.queueResourceSerializer);
        return this.buildListQueuesResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }

  listQueuesPage(marker, options = {}) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function* listQueuesPage_1() {
      let listResponse;

      do {
        listResponse = yield (0, _tslib.__await)(this.getQueues(Object.assign({
          skip: Number(marker),
          maxCount: options.maxPageSize
        }, options)));
        marker = listResponse.continuationToken;
        yield yield (0, _tslib.__await)(listResponse);
      } while (marker);
    });
  }

  listQueuesAll(options = {}) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function* listQueuesAll_1() {
      var e_1, _a;

      let marker;

      try {
        for (var _b = (0, _tslib.__asyncValues)(this.listQueuesPage(marker, options)), _c; _c = yield (0, _tslib.__await)(_b.next()), !_c.done;) {
          const segment = _c.value;
          yield (0, _tslib.__await)(yield* (0, _tslib.__asyncDelegator)((0, _tslib.__asyncValues)(segment)));
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) yield (0, _tslib.__await)(_a.call(_b));
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    });
  }
  /**
   * Returns an async iterable iterator to list all the queues.
   *
   * .byPage() returns an async iterable iterator to list the queues in pages.
   *
   * @param {OperationOptions} [options]
   * @returns {PagedAsyncIterableIterator<
   *     QueueProperties,
   *     EntitiesResponse<QueueProperties>,
   *   >} An asyncIterableIterator that supports paging.
   * @memberof ServiceBusAdministrationClient
   */


  listQueues(options) {
    _log.administrationLogger.verbose(`Performing management operation - listQueues() with options: %j`, options);

    const iter = this.listQueuesAll(options);
    return {
      /**
       * @member {Promise} [next] The next method, part of the iteration protocol
       */
      next() {
        return iter.next();
      },

      /**
       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },

      /**
       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (settings = {}) => {
        this.throwIfInvalidContinuationToken(settings.continuationToken);
        return this.listQueuesPage(settings.continuationToken, Object.assign({
          maxPageSize: settings.maxPageSize
        }, options));
      }
    };
  }
  /**
   * Returns a list of objects, each representing a Queue's runtime info like message count details.
   * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  getQueuesRuntimeProperties(options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getQueuesRuntimeProperties", options);

      try {
        _log.administrationLogger.verbose(`Performing management operation - getQueuesRuntimeProperties() with options: %j`, options);

        const response = yield this.listResources("$Resources/Queues", updatedOperationOptions, this.queueResourceSerializer);
        return this.buildListQueuesRuntimePropertiesResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }

  listQueuesRuntimePropertiesPage(marker, options = {}) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function* listQueuesRuntimePropertiesPage_1() {
      let listResponse;

      do {
        listResponse = yield (0, _tslib.__await)(this.getQueuesRuntimeProperties(Object.assign({
          skip: Number(marker),
          maxCount: options.maxPageSize
        }, options)));
        marker = listResponse.continuationToken;
        yield yield (0, _tslib.__await)(listResponse);
      } while (marker);
    });
  }

  listQueuesRuntimePropertiesAll(options = {}) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function* listQueuesRuntimePropertiesAll_1() {
      var e_2, _a;

      let marker;

      try {
        for (var _b = (0, _tslib.__asyncValues)(this.listQueuesRuntimePropertiesPage(marker, options)), _c; _c = yield (0, _tslib.__await)(_b.next()), !_c.done;) {
          const segment = _c.value;
          yield (0, _tslib.__await)(yield* (0, _tslib.__asyncDelegator)((0, _tslib.__asyncValues)(segment)));
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) yield (0, _tslib.__await)(_a.call(_b));
        } finally {
          if (e_2) throw e_2.error;
        }
      }
    });
  }
  /**
   * Returns an async iterable iterator to list runtime info of the queues.
   *
   * .byPage() returns an async iterable iterator to list runtime info of the queues in pages.
   *
   *
   * @param {OperationOptions} [options]
   * @returns {PagedAsyncIterableIterator<
   *     QueueRuntimeProperties,
   *     EntitiesResponse<QueueRuntimeProperties>,
   *   >} An asyncIterableIterator that supports paging.
   * @memberof ServiceBusAdministrationClient
   */


  listQueuesRuntimeProperties(options) {
    _log.administrationLogger.verbose(`Performing management operation - listQueuesRuntimeProperties() with options: %j`, options);

    const iter = this.listQueuesRuntimePropertiesAll(options);
    return {
      /**
       * @member {Promise} [next] The next method, part of the iteration protocol
       */
      next() {
        return iter.next();
      },

      /**
       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },

      /**
       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (settings = {}) => {
        this.throwIfInvalidContinuationToken(settings.continuationToken);
        return this.listQueuesRuntimePropertiesPage(settings.continuationToken, Object.assign({
          maxPageSize: settings.maxPageSize
        }, options));
      }
    };
  }
  /**
   * Updates the queue based on the queue properties provided.
   * All queue properties must be set even though only a subset of them are actually updatable.
   * Therefore, the suggested flow is to use the output from `getQueue()`, update the desired properties in it, and then pass the modified object to `updateQueue()`.
   *
   * See https://docs.microsoft.com/rest/api/servicebus/update-queue for more details.
   *
   * @param queue Object representing the properties of the queue and the raw response.
   * `requiresSession`, `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the queue.
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  updateQueue(queue, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-updateQueue", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - updateQueue() for "${queue.name}" with options: %j`, queue);

        if (!(0, _utils.isJSONLikeObject)(queue) || queue == null) {
          throw new TypeError(`Parameter "queue" must be an object of type "QueueDescription" and cannot be undefined or null.`);
        }

        if (!queue.name) {
          throw new TypeError(`"name" attribute of the parameter "queue" cannot be undefined.`);
        }

        const response = yield this.putResource(queue.name, (0, _queueResourceSerializer.buildQueueOptions)(queue), this.queueResourceSerializer, true, updatedOperationOptions);
        return this.buildQueueResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Deletes a queue.
   * @param queueName
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  deleteQueue(queueName, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-deleteQueue", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - deleteQueue() for "${queueName}"`);

        const response = yield this.deleteResource(queueName, this.queueResourceSerializer, updatedOperationOptions);
        return {
          _response: (0, _utils.getHttpResponseOnly)(response)
        };
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Checks whether a given queue exists or not.
   * @param queueName
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   */


  queueExists(queueName, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-queueExists", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - queueExists() for "${queueName}"`);

        try {
          yield this.getQueue(queueName, updatedOperationOptions);
        } catch (error) {
          if (error.code == "MessageEntityNotFoundError") {
            return false;
          }

          throw error;
        }

        return true;
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Creates a topic with given name, configured using the given options
   * @param topicName
   * @param options Options to configure the Topic being created(For example, you can configure a topic to support partitions)
   * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  createTopic(topicName, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-createTopic", options);

      try {
        _log.administrationLogger.verbose(`Performing management operation - createTopic() for "${topicName}" with options: %j`, options);

        const response = yield this.putResource(topicName, (0, _topicResourceSerializer.buildTopicOptions)(options || {}), this.topicResourceSerializer, false, updatedOperationOptions);
        return this.buildTopicResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Returns an object representing the Topic and its properties.
   * If you want to get the Topic runtime info like subscription count details, use `getTopicRuntimeProperties` API.
   * @param topicName
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  getTopic(topicName, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getTopic", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - getTopic() for "${topicName}"`);

        const response = yield this.getResource(topicName, this.topicResourceSerializer, updatedOperationOptions);
        return this.buildTopicResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Returns an object representing the Topic runtime info like subscription count.
   * @param topicName
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  getTopicRuntimeProperties(topicName, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getTopicRuntimeProperties", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - getTopicRuntimeProperties() for "${topicName}"`);

        const response = yield this.getResource(topicName, this.topicResourceSerializer, updatedOperationOptions);
        return this.buildTopicRuntimePropertiesResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Returns a list of objects, each representing a Topic along with its properties.
   * If you want to get the runtime info of the topics like subscription count, use `getTopicsRuntimeProperties` API instead.
   * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  getTopics(options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getTopics", options);

      try {
        _log.administrationLogger.verbose(`Performing management operation - getTopics() with options: %j`, options);

        const response = yield this.listResources("$Resources/Topics", updatedOperationOptions, this.topicResourceSerializer);
        return this.buildListTopicsResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }

  listTopicsPage(marker, options = {}) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function* listTopicsPage_1() {
      let listResponse;

      do {
        listResponse = yield (0, _tslib.__await)(this.getTopics(Object.assign({
          skip: Number(marker),
          maxCount: options.maxPageSize
        }, options)));
        marker = listResponse.continuationToken;
        yield yield (0, _tslib.__await)(listResponse);
      } while (marker);
    });
  }

  listTopicsAll(options = {}) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function* listTopicsAll_1() {
      var e_3, _a;

      let marker;

      try {
        for (var _b = (0, _tslib.__asyncValues)(this.listTopicsPage(marker, options)), _c; _c = yield (0, _tslib.__await)(_b.next()), !_c.done;) {
          const segment = _c.value;
          yield (0, _tslib.__await)(yield* (0, _tslib.__asyncDelegator)((0, _tslib.__asyncValues)(segment)));
        }
      } catch (e_3_1) {
        e_3 = {
          error: e_3_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) yield (0, _tslib.__await)(_a.call(_b));
        } finally {
          if (e_3) throw e_3.error;
        }
      }
    });
  }
  /**
   * Returns an async iterable iterator to list all the topics.
   *
   * .byPage() returns an async iterable iterator to list the topics in pages.
   *
   *
   * @param {OperationOptions} [options]
   * @returns {PagedAsyncIterableIterator<
   *     TopicProperties,
   *     EntitiesResponse<TopicProperties>,
   *   >} An asyncIterableIterator that supports paging.
   * @memberof ServiceBusAdministrationClient
   */


  listTopics(options) {
    _log.administrationLogger.verbose(`Performing management operation - listTopics() with options: %j`, options);

    const iter = this.listTopicsAll(options);
    return {
      /**
       * @member {Promise} [next] The next method, part of the iteration protocol
       */
      next() {
        return iter.next();
      },

      /**
       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },

      /**
       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (settings = {}) => {
        this.throwIfInvalidContinuationToken(settings.continuationToken);
        return this.listTopicsPage(settings.continuationToken, Object.assign({
          maxPageSize: settings.maxPageSize
        }, options));
      }
    };
  }
  /**
   * Returns a list of objects, each representing a Topic's runtime info like subscription count.
   * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  getTopicsRuntimeProperties(options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getTopicsRuntimeProperties", options);

      try {
        _log.administrationLogger.verbose(`Performing management operation - getTopicsRuntimeProperties() with options: %j`, options);

        const response = yield this.listResources("$Resources/Topics", updatedOperationOptions, this.topicResourceSerializer);
        return this.buildListTopicsRuntimePropertiesResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }

  listTopicsRuntimePropertiesPage(marker, options = {}) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function* listTopicsRuntimePropertiesPage_1() {
      let listResponse;

      do {
        listResponse = yield (0, _tslib.__await)(this.getTopicsRuntimeProperties(Object.assign({
          skip: Number(marker),
          maxCount: options.maxPageSize
        }, options)));
        marker = listResponse.continuationToken;
        yield yield (0, _tslib.__await)(listResponse);
      } while (marker);
    });
  }

  listTopicsRuntimePropertiesAll(options = {}) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function* listTopicsRuntimePropertiesAll_1() {
      var e_4, _a;

      let marker;

      try {
        for (var _b = (0, _tslib.__asyncValues)(this.listTopicsRuntimePropertiesPage(marker, options)), _c; _c = yield (0, _tslib.__await)(_b.next()), !_c.done;) {
          const segment = _c.value;
          yield (0, _tslib.__await)(yield* (0, _tslib.__asyncDelegator)((0, _tslib.__asyncValues)(segment)));
        }
      } catch (e_4_1) {
        e_4 = {
          error: e_4_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) yield (0, _tslib.__await)(_a.call(_b));
        } finally {
          if (e_4) throw e_4.error;
        }
      }
    });
  }
  /**
   * Returns an async iterable iterator to list runtime info of the topics.
   *
   * .byPage() returns an async iterable iterator to list runtime info of the topics in pages.
   *
   *
   * @param {OperationOptions} [options]
   * @returns {PagedAsyncIterableIterator<
   *     TopicRuntimeProperties,
   *     EntitiesResponse<TopicRuntimeProperties>,
      *   >} An asyncIterableIterator that supports paging.
   * @memberof ServiceBusAdministrationClient
   */


  listTopicsRuntimeProperties(options) {
    _log.administrationLogger.verbose(`Performing management operation - listTopicsRuntimeProperties() with options: %j`, options);

    const iter = this.listTopicsRuntimePropertiesAll(options);
    return {
      /**
       * @member {Promise} [next] The next method, part of the iteration protocol
       */
      next() {
        return iter.next();
      },

      /**
       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },

      /**
       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (settings = {}) => {
        this.throwIfInvalidContinuationToken(settings.continuationToken);
        return this.listTopicsRuntimePropertiesPage(settings.continuationToken, Object.assign({
          maxPageSize: settings.maxPageSize
        }, options));
      }
    };
  }
  /**
   * Updates the topic based on the topic properties provided.
   * All topic properties must be set even though only a subset of them are actually updatable.
   * Therefore, the suggested flow is to use the output from `getTopic()`, update the desired properties in it, and then pass the modified object to `updateTopic()`.
   *
   * See https://docs.microsoft.com/rest/api/servicebus/update-topic for more details.
   *
   * @param topic Object representing the properties of the topic and the raw response.
   * `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the topic.
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  updateTopic(topic, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-updateTopic", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - updateTopic() for "${topic.name}" with options: %j`, topic);

        if (!(0, _utils.isJSONLikeObject)(topic) || topic == null) {
          throw new TypeError(`Parameter "topic" must be an object of type "TopicDescription" and cannot be undefined or null.`);
        }

        if (!topic.name) {
          throw new TypeError(`"name" attribute of the parameter "topic" cannot be undefined.`);
        }

        const response = yield this.putResource(topic.name, (0, _topicResourceSerializer.buildTopicOptions)(topic), this.topicResourceSerializer, true, updatedOperationOptions);
        return this.buildTopicResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Deletes a topic.
   * @param topicName
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  deleteTopic(topicName, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-deleteTopic", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - deleteTopic() for "${topicName}"`);

        const response = yield this.deleteResource(topicName, this.topicResourceSerializer, updatedOperationOptions);
        return {
          _response: (0, _utils.getHttpResponseOnly)(response)
        };
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Checks whether a given topic exists or not.
   * @param topicName
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   */


  topicExists(topicName, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-topicExists", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - topicExists() for "${topicName}"`);

        try {
          yield this.getTopic(topicName, updatedOperationOptions);
        } catch (error) {
          if (error.code == "MessageEntityNotFoundError") {
            return false;
          }

          throw error;
        }

        return true;
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Creates a subscription with given name, configured using the given options
   * @param topicName
   * @param subscriptionName
   * @param options Options to configure the Subscription being created(For example, you can configure a Subscription to support partitions or sessions)
   * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  createSubscription(topicName, subscriptionName, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-createSubscription", options);

      try {
        _log.administrationLogger.verbose(`Performing management operation - createSubscription() for "${subscriptionName}" with options: %j`, options);

        const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
        const response = yield this.putResource(fullPath, (0, _subscriptionResourceSerializer.buildSubscriptionOptions)(options || {}), this.subscriptionResourceSerializer, false, updatedOperationOptions);
        return this.buildSubscriptionResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Returns an object representing the Subscription and its properties.
   * If you want to get the Subscription runtime info like message count details, use `getSubscriptionRuntimeProperties` API.
   * @param topicName
   * @param subscriptionName
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  getSubscription(topicName, subscriptionName, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getSubscription", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - getSubscription() for "${subscriptionName}"`);

        const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
        const response = yield this.getResource(fullPath, this.subscriptionResourceSerializer, updatedOperationOptions);
        return this.buildSubscriptionResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Returns an object representing the Subscription runtime info like message count details.
   * @param topicName
   * @param subscriptionName
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  getSubscriptionRuntimeProperties(topicName, subscriptionName, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getSubscriptionRuntimeProperties", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - getSubscriptionRuntimeProperties() for "${subscriptionName}"`);

        const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
        const response = yield this.getResource(fullPath, this.subscriptionResourceSerializer, updatedOperationOptions);
        return this.buildSubscriptionRuntimePropertiesResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Returns a list of objects, each representing a Subscription along with its properties.
   * If you want to get the runtime info of the subscriptions like message count, use `getSubscriptionsRuntimeProperties` API instead.
   * @param topicName
   * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  getSubscriptions(topicName, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getSubscriptions", options);

      try {
        _log.administrationLogger.verbose(`Performing management operation - getSubscriptions() with options: %j`, options);

        const response = yield this.listResources(topicName + "/Subscriptions/", updatedOperationOptions, this.subscriptionResourceSerializer);
        return this.buildListSubscriptionsResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }

  listSubscriptionsPage(topicName, marker, options = {}) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function* listSubscriptionsPage_1() {
      let listResponse;

      do {
        listResponse = yield (0, _tslib.__await)(this.getSubscriptions(topicName, Object.assign({
          skip: Number(marker),
          maxCount: options.maxPageSize
        }, options)));
        marker = listResponse.continuationToken;
        yield yield (0, _tslib.__await)(listResponse);
      } while (marker);
    });
  }

  listSubscriptionsAll(topicName, options = {}) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function* listSubscriptionsAll_1() {
      var e_5, _a;

      let marker;

      try {
        for (var _b = (0, _tslib.__asyncValues)(this.listSubscriptionsPage(topicName, marker, options)), _c; _c = yield (0, _tslib.__await)(_b.next()), !_c.done;) {
          const segment = _c.value;
          yield (0, _tslib.__await)(yield* (0, _tslib.__asyncDelegator)((0, _tslib.__asyncValues)(segment)));
        }
      } catch (e_5_1) {
        e_5 = {
          error: e_5_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) yield (0, _tslib.__await)(_a.call(_b));
        } finally {
          if (e_5) throw e_5.error;
        }
      }
    });
  }
  /**
   *
   * Returns an async iterable iterator to list all the subscriptions
   * under the specified topic.
   *
   * .byPage() returns an async iterable iterator to list the subscriptions in pages.
   *
   * @memberof ServiceBusAdministrationClient
   * @param {string} topicName
   * @param {OperationOptions} [options]
   * @returns {PagedAsyncIterableIterator<
   *     SubscriptionProperties,
   *     EntitiesResponse<SubscriptionProperties>
   *   >} An asyncIterableIterator that supports paging.
   * @memberof ServiceBusAdministrationClient
   */


  listSubscriptions(topicName, options) {
    _log.administrationLogger.verbose(`Performing management operation - listSubscriptions() with options: %j`, options);

    const iter = this.listSubscriptionsAll(topicName, options);
    return {
      /**
       * @member {Promise} [next] The next method, part of the iteration protocol
       */
      next() {
        return iter.next();
      },

      /**
       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },

      /**
       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (settings = {}) => {
        this.throwIfInvalidContinuationToken(settings.continuationToken);
        return this.listSubscriptionsPage(topicName, settings.continuationToken, Object.assign({
          maxPageSize: settings.maxPageSize
        }, options));
      }
    };
  }
  /**
   * Returns a list of objects, each representing a Subscription's runtime info like message count details.
   * @param topicName
   * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  getSubscriptionsRuntimeProperties(topicName, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getSubscriptionsRuntimeProperties", options);

      try {
        _log.administrationLogger.verbose(`Performing management operation - getSubscriptionsRuntimeProperties() with options: %j`, options);

        const response = yield this.listResources(topicName + "/Subscriptions/", updatedOperationOptions, this.subscriptionResourceSerializer);
        return this.buildListSubscriptionsRuntimePropertiesResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }

  listSubscriptionsRuntimePropertiesPage(topicName, marker, options = {}) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function* listSubscriptionsRuntimePropertiesPage_1() {
      let listResponse;

      do {
        listResponse = yield (0, _tslib.__await)(this.getSubscriptionsRuntimeProperties(topicName, Object.assign({
          skip: Number(marker),
          maxCount: options.maxPageSize
        }, options)));
        marker = listResponse.continuationToken;
        yield yield (0, _tslib.__await)(listResponse);
      } while (marker);
    });
  }

  listSubscriptionsRuntimePropertiesAll(topicName, options = {}) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function* listSubscriptionsRuntimePropertiesAll_1() {
      var e_6, _a;

      let marker;

      try {
        for (var _b = (0, _tslib.__asyncValues)(this.listSubscriptionsRuntimePropertiesPage(topicName, marker, options)), _c; _c = yield (0, _tslib.__await)(_b.next()), !_c.done;) {
          const segment = _c.value;
          yield (0, _tslib.__await)(yield* (0, _tslib.__asyncDelegator)((0, _tslib.__asyncValues)(segment)));
        }
      } catch (e_6_1) {
        e_6 = {
          error: e_6_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) yield (0, _tslib.__await)(_a.call(_b));
        } finally {
          if (e_6) throw e_6.error;
        }
      }
    });
  }
  /**
   * Returns an async iterable iterator to list runtime info of the subscriptions
   * under the specified topic.
   *
   * .byPage() returns an async iterable iterator to list runtime info of subscriptions in pages.
   *
   * @param {string} topicName
   * @param {OperationOptions} [options]
   * @returns {PagedAsyncIterableIterator<
   *     SubscriptionRuntimeProperties,
   *     EntitiesResponse<SubscriptionRuntimeProperties>,
      *   >}  An asyncIterableIterator that supports paging.
   * @memberof ServiceBusAdministrationClient
   */


  listSubscriptionsRuntimeProperties(topicName, options) {
    _log.administrationLogger.verbose(`Performing management operation - listSubscriptionsRuntimeProperties() with options: %j`, options);

    const iter = this.listSubscriptionsRuntimePropertiesAll(topicName, options);
    return {
      /**
       * @member {Promise} [next] The next method, part of the iteration protocol
       */
      next() {
        return iter.next();
      },

      /**
       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },

      /**
       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (settings = {}) => {
        this.throwIfInvalidContinuationToken(settings.continuationToken);
        return this.listSubscriptionsRuntimePropertiesPage(topicName, settings.continuationToken, Object.assign({
          maxPageSize: settings.maxPageSize
        }, options));
      }
    };
  }
  /**
   * Updates the subscription based on the subscription properties provided.
   * All subscription properties must be set even though only a subset of them are actually updatable.
   * Therefore, the suggested flow is to use the output from `getSubscription()`, update the desired properties in it, and then pass the modified object to `updateSubscription()`.
   *
   * @param subscription Object representing the properties of the subscription and the raw response.
   * `subscriptionName`, `topicName`, and `requiresSession` can't be updated after creating the subscription.
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  updateSubscription(subscription, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-updateSubscription", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - updateSubscription() for "${subscription.subscriptionName}" with options: %j`, subscription);

        if (!(0, _utils.isJSONLikeObject)(subscription) || subscription == null) {
          throw new TypeError(`Parameter "subscription" must be an object of type "SubscriptionDescription" and cannot be undefined or null.`);
        }

        if (!subscription.topicName || !subscription.subscriptionName) {
          throw new TypeError(`The attributes "topicName" and "subscriptionName" of the parameter "subscription" cannot be undefined.`);
        }

        const fullPath = this.getSubscriptionPath(subscription.topicName, subscription.subscriptionName);
        const response = yield this.putResource(fullPath, (0, _subscriptionResourceSerializer.buildSubscriptionOptions)(subscription), this.subscriptionResourceSerializer, true, updatedOperationOptions);
        return this.buildSubscriptionResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Deletes a subscription.
   * @param topicName
   * @param subscriptionName
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  deleteSubscription(topicName, subscriptionName, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-deleteSubscription", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - deleteSubscription() for "${subscriptionName}"`);

        const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
        const response = yield this.deleteResource(fullPath, this.subscriptionResourceSerializer, updatedOperationOptions);
        return {
          _response: (0, _utils.getHttpResponseOnly)(response)
        };
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Checks whether a given subscription exists in the topic or not.
   * @param topicName
   * @param subscriptionName
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   */


  subscriptionExists(topicName, subscriptionName, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-subscriptionExists", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - subscriptionExists() for "${topicName}" and "${subscriptionName}"`);

        try {
          yield this.getSubscription(topicName, subscriptionName, updatedOperationOptions);
        } catch (error) {
          if (error.code == "MessageEntityNotFoundError") {
            return false;
          }

          throw error;
        }

        return true;
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }

  createRule(topicName, subscriptionName, ruleName, ruleFilter, ruleActionOrOperationOptions, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      let ruleAction = undefined;
      let operOptions;

      if (ruleActionOrOperationOptions) {
        if ((0, _ruleResourceSerializer.isSqlRuleAction)(ruleActionOrOperationOptions)) {
          // Overload#2 - where the sqlExpression in the ruleAction is defined
          ruleAction = ruleActionOrOperationOptions;
          operOptions = operationOptions;
        } else {
          // Overload#1
          // Overload#2 - where the sqlExpression in the ruleAction is undefined
          operOptions = Object.assign(Object.assign({}, ruleActionOrOperationOptions), operationOptions);
        }
      }

      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-createRule", operOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - createRule() for "${ruleName}" with filter: "%j"`, ruleFilter);

        const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);
        const response = yield this.putResource(fullPath, {
          name: ruleName,
          filter: ruleFilter,
          action: ruleAction
        }, this.ruleResourceSerializer, false, updatedOperationOptions);
        return this.buildRuleResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Returns an object representing the Rule with the given name along with all its properties.
   * @param topicName
   * @param subscriptionName
   * @param ruleName
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  getRule(topicName, subscriptionName, ruleName, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getRule", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - getRule() for "${ruleName}"`);

        const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);
        const response = yield this.getResource(fullPath, this.ruleResourceSerializer, updatedOperationOptions);
        return this.buildRuleResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Lists existing rules.
   * @param topicName
   * @param subscriptionName
   * @param options The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  getRules(topicName, subscriptionName, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getRules", options);

      try {
        _log.administrationLogger.verbose(`Performing management operation - getRules() with options: %j`, options);

        const fullPath = this.getSubscriptionPath(topicName, subscriptionName) + "/Rules/";
        const response = yield this.listResources(fullPath, updatedOperationOptions, this.ruleResourceSerializer);
        return this.buildListRulesResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }

  listRulesPage(topicName, subscriptionName, marker, options = {}) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function* listRulesPage_1() {
      let listResponse;

      do {
        listResponse = yield (0, _tslib.__await)(this.getRules(topicName, subscriptionName, Object.assign({
          skip: Number(marker),
          maxCount: options.maxPageSize
        }, options)));
        marker = listResponse.continuationToken;
        yield yield (0, _tslib.__await)(listResponse);
      } while (marker);
    });
  }

  listRulesAll(topicName, subscriptionName, options = {}) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function* listRulesAll_1() {
      var e_7, _a;

      let marker;

      try {
        for (var _b = (0, _tslib.__asyncValues)(this.listRulesPage(topicName, subscriptionName, marker, options)), _c; _c = yield (0, _tslib.__await)(_b.next()), !_c.done;) {
          const segment = _c.value;
          yield (0, _tslib.__await)(yield* (0, _tslib.__asyncDelegator)((0, _tslib.__asyncValues)(segment)));
        }
      } catch (e_7_1) {
        e_7 = {
          error: e_7_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) yield (0, _tslib.__await)(_a.call(_b));
        } finally {
          if (e_7) throw e_7.error;
        }
      }
    });
  }
  /**
   * Returns an async iterable iterator to list all the rules
   * under the specified subscription.
   *
   * .byPage() returns an async iterable iterator to list the rules in pages.
   *
   * @param {string} topicName
   * @param {string} subscriptionName
   * @param {OperationOptions} [options]
   * @returns {PagedAsyncIterableIterator<RuleProperties, EntitiesResponse<RuleProperties>>} An asyncIterableIterator that supports paging.
   * @memberof ServiceBusAdministrationClient
   */


  listRules(topicName, subscriptionName, options) {
    _log.administrationLogger.verbose(`Performing management operation - listRules() with options: %j`, options);

    const iter = this.listRulesAll(topicName, subscriptionName, options);
    return {
      /**
       * @member {Promise} [next] The next method, part of the iteration protocol
       */
      next() {
        return iter.next();
      },

      /**
       * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },

      /**
       * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (settings = {}) => {
        this.throwIfInvalidContinuationToken(settings.continuationToken);
        return this.listRulesPage(topicName, subscriptionName, settings.continuationToken, Object.assign({
          maxPageSize: settings.maxPageSize
        }, options));
      }
    };
  }
  /**
   * Updates properties on the Rule by the given name based on the given options.
   * All rule properties must be set even if one of them is being updated.
   * Therefore, the suggested flow is to use the output from `getRule()`, update the desired properties in it, and then pass the modified object to `updateRule()`.
   *
   * @param topicName
   * @param subscriptionName
   * @param rule Options to configure the Rule being updated and the raw response.
   * For example, you can configure the filter to apply on associated Topic/Subscription.
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  updateRule(topicName, subscriptionName, rule, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-updateRule", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - updateRule() for "${rule.name}" with options: %j`, rule);

        if (!(0, _utils.isJSONLikeObject)(rule) || rule === null) {
          throw new TypeError(`Parameter "rule" must be an object of type "RuleDescription" and cannot be undefined or null.`);
        }

        if (!rule.name) {
          throw new TypeError(`"name" attribute of the parameter "rule" cannot be undefined.`);
        }

        const fullPath = this.getRulePath(topicName, subscriptionName, rule.name);
        const response = yield this.putResource(fullPath, rule, this.ruleResourceSerializer, true, updatedOperationOptions);
        return this.buildRuleResponse(response);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Deletes a rule.
   * @param topicName
   * @param subscriptionName
   * @param ruleName
   * @param operationOptions The options that can be used to abort, trace and control other configurations on the HTTP request.
   *
   * Following are errors that can be expected from this operation
   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
   * bad requests or requests resulting in conflicting operation on the server,
   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
   */


  deleteRule(topicName, subscriptionName, ruleName, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-deleteRule", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - deleteRule() for "${ruleName}"`);

        const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);
        const response = yield this.deleteResource(fullPath, this.ruleResourceSerializer, updatedOperationOptions);
        return {
          _response: (0, _utils.getHttpResponseOnly)(response)
        };
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Checks whether a given rule exists or not.
   *
   * @param {string} topicName
   * @param {string} subscriptionName
   * @param {string} ruleName
   * @param {OperationOptions} [operationOptions]
   */


  ruleExists(topicName, subscriptionName, ruleName, operationOptions) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-ruleExists", operationOptions);

      try {
        _log.administrationLogger.verbose(`Performing management operation - ruleExists() for "${ruleName}"`);

        try {
          yield this.getRule(topicName, subscriptionName, ruleName, updatedOperationOptions);
        } catch (error) {
          if (error.code == "MessageEntityNotFoundError") {
            return false;
          }

          throw error;
        }

        return true;
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Creates or updates a resource based on `isUpdate` parameter.
   * @param name
   * @param entityFields
   * @param isUpdate
   * @param serializer
   */


  putResource(name, entityFields, serializer, isUpdate = false, operationOptions = {}) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-putResource", operationOptions);

      try {
        const webResource = new _coreHttp.WebResource(this.getUrl(name), "PUT");
        webResource.body = entityFields;

        if (isUpdate) {
          webResource.headers.set("If-Match", "*");
        }

        const queueOrSubscriptionFields = entityFields;

        if (queueOrSubscriptionFields.ForwardTo || queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo) {
          const token = this.credentials instanceof _sasServiceClientCredentials.SasServiceClientCredentials ? this.credentials.getToken(this.endpoint).token : (yield this.credentials.getToken([_coreAmqp.Constants.aadServiceBusScope])).token;

          if (queueOrSubscriptionFields.ForwardTo) {
            webResource.headers.set("ServiceBusSupplementaryAuthorization", token);

            if (!(0, _utils.isAbsoluteUrl)(queueOrSubscriptionFields.ForwardTo)) {
              queueOrSubscriptionFields.ForwardTo = this.endpointWithProtocol.concat(queueOrSubscriptionFields.ForwardTo);
            }
          }

          if (queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo) {
            webResource.headers.set("ServiceBusDlqSupplementaryAuthorization", token);

            if (!(0, _utils.isAbsoluteUrl)(queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo)) {
              queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo = this.endpointWithProtocol.concat(queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo);
            }
          }
        }

        webResource.headers.set("content-type", "application/atom+xml;type=entry;charset=utf-8");
        return (0, _atomXmlHelper.executeAtomXmlOperation)(this, webResource, serializer, updatedOperationOptions);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Gets a resource.
   * @param name
   * @param serializer
   */


  getResource(name, serializer, operationOptions = {}) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-getResource", operationOptions);

      try {
        const webResource = new _coreHttp.WebResource(this.getUrl(name), "GET");
        const response = yield (0, _atomXmlHelper.executeAtomXmlOperation)(this, webResource, serializer, updatedOperationOptions);

        if (response.parsedBody == undefined || Array.isArray(response.parsedBody) && response.parsedBody.length == 0) {
          const err = new _coreHttp.RestError(`The messaging entity "${name}" being requested cannot be found.`, "MessageEntityNotFoundError", response.status, (0, _coreHttp.stripRequest)(webResource), (0, _coreHttp.stripResponse)(response));
          throw err;
        }

        return response;
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Lists existing resources
   * @param name
   * @param options
   * @param serializer
   */


  listResources(name, options = {}, serializer) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-listResources", options);

      try {
        const queryParams = {};

        if (options) {
          if (options.skip) {
            queryParams["$skip"] = options.skip.toString();
          }

          if (options.maxCount) {
            queryParams["$top"] = options.maxCount.toString();
          }
        }

        const webResource = new _coreHttp.WebResource(this.getUrl(name, queryParams), "GET");
        return (0, _atomXmlHelper.executeAtomXmlOperation)(this, webResource, serializer, updatedOperationOptions);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }
  /**
   * Deletes a resource.
   * @param name
   */


  deleteResource(name, serializer, operationOptions = {}) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        span,
        updatedOperationOptions
      } = (0, _tracing.createSpan)("ServiceBusAdministrationClient-deleteResource", operationOptions);

      try {
        const webResource = new _coreHttp.WebResource(this.getUrl(name), "DELETE");
        return (0, _atomXmlHelper.executeAtomXmlOperation)(this, webResource, serializer, updatedOperationOptions);
      } catch (e) {
        span.setStatus({
          code: (0, _tracing.getCanonicalCode)(e),
          message: e.message
        });
        throw e;
      } finally {
        span.end();
      }
    });
  }

  getUrl(path, queryParams) {
    const baseUri = `https://${this.endpoint}/${path}`;

    const requestUrl = _coreHttp.URLBuilder.parse(baseUri);

    requestUrl.setQueryParameter(Constants.API_VERSION_QUERY_KEY, Constants.CURRENT_API_VERSION);

    if (queryParams) {
      for (const key of Object.keys(queryParams)) {
        requestUrl.setQueryParameter(key, queryParams[key]);
      }
    }

    return requestUrl.toString();
  }

  getSubscriptionPath(topicName, subscriptionName) {
    return topicName + "/Subscriptions/" + subscriptionName;
  }

  getRulePath(topicName, subscriptionName, ruleName) {
    return topicName + "/Subscriptions/" + subscriptionName + "/Rules/" + ruleName;
  }

  getMarkerFromNextLinkUrl(url) {
    if (!url) {
      return undefined;
    }

    try {
      return (0, _parseUrl.parseURL)(url).searchParams.get(Constants.XML_METADATA_MARKER + "skip");
    } catch (error) {
      throw new Error(`Unable to parse the '${Constants.XML_METADATA_MARKER}skip' from the next-link in the response ` + error);
    }
  }

  buildNamespacePropertiesResponse(response) {
    try {
      const namespace = (0, _namespaceResourceSerializer.buildNamespace)(response.parsedBody);
      const namespaceResponse = Object.defineProperty(namespace || {}, "_response", {
        value: (0, _utils.getHttpResponseOnly)(response)
      });
      return namespaceResponse;
    } catch (err) {
      _log.administrationLogger.logError(err, "Failure parsing response from service");

      throw new _coreHttp.RestError(`Error occurred while parsing the response body - cannot form a namespace object using the response from the service.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
    }
  }

  buildListQueuesResponse(response) {
    try {
      const queues = [];
      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);

      if (!Array.isArray(response.parsedBody)) {
        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
      }

      const rawQueueArray = response.parsedBody;

      for (let i = 0; i < rawQueueArray.length; i++) {
        const queue = (0, _queueResourceSerializer.buildQueue)(rawQueueArray[i]);

        if (queue) {
          queues.push(queue);
        }
      }

      const listQueuesResponse = Object.defineProperty(queues, "_response", {
        value: (0, _utils.getHttpResponseOnly)(response)
      });
      listQueuesResponse.continuationToken = nextMarker;
      return listQueuesResponse;
    } catch (err) {
      _log.administrationLogger.logError(err, "Failure parsing response from service");

      throw new _coreHttp.RestError(`Error occurred while parsing the response body - cannot form a list of queues using the response from the service.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
    }
  }

  buildListQueuesRuntimePropertiesResponse(response) {
    try {
      const queues = [];
      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);

      if (!Array.isArray(response.parsedBody)) {
        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
      }

      const rawQueueArray = response.parsedBody;

      for (let i = 0; i < rawQueueArray.length; i++) {
        const queue = (0, _queueResourceSerializer.buildQueueRuntimeProperties)(rawQueueArray[i]);

        if (queue) {
          queues.push(queue);
        }
      }

      const listQueuesResponse = Object.defineProperty(queues, "_response", {
        value: (0, _utils.getHttpResponseOnly)(response)
      });
      listQueuesResponse.continuationToken = nextMarker;
      return listQueuesResponse;
    } catch (err) {
      _log.administrationLogger.logError(err, "Failure parsing response from service");

      throw new _coreHttp.RestError(`Error occurred while parsing the response body - cannot form a list of queues using the response from the service.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
    }
  }

  buildQueueResponse(response) {
    try {
      const queue = (0, _queueResourceSerializer.buildQueue)(response.parsedBody);
      const queueResponse = Object.defineProperty(queue || {}, "_response", {
        value: (0, _utils.getHttpResponseOnly)(response)
      });
      return queueResponse;
    } catch (err) {
      _log.administrationLogger.logError(err, "Failure parsing response from service");

      throw new _coreHttp.RestError(`Error occurred while parsing the response body - cannot form a queue object using the response from the service.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
    }
  }

  buildQueueRuntimePropertiesResponse(response) {
    try {
      const queue = (0, _queueResourceSerializer.buildQueueRuntimeProperties)(response.parsedBody);
      const queueResponse = Object.defineProperty(queue || {}, "_response", {
        value: (0, _utils.getHttpResponseOnly)(response)
      });
      return queueResponse;
    } catch (err) {
      _log.administrationLogger.logError(err, "Failure parsing response from service");

      throw new _coreHttp.RestError(`Error occurred while parsing the response body - cannot form a queue object using the response from the service.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
    }
  }

  buildListTopicsResponse(response) {
    try {
      const topics = [];
      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);

      if (!Array.isArray(response.parsedBody)) {
        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
      }

      const rawTopicArray = response.parsedBody;

      for (let i = 0; i < rawTopicArray.length; i++) {
        const topic = (0, _topicResourceSerializer.buildTopic)(rawTopicArray[i]);

        if (topic) {
          topics.push(topic);
        }
      }

      const listTopicsResponse = Object.defineProperty(topics, "_response", {
        value: (0, _utils.getHttpResponseOnly)(response)
      });
      listTopicsResponse.continuationToken = nextMarker;
      return listTopicsResponse;
    } catch (err) {
      _log.administrationLogger.logError(err, "Failure parsing response from service");

      throw new _coreHttp.RestError(`Error occurred while parsing the response body - cannot form a list of topics using the response from the service.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
    }
  }

  buildListTopicsRuntimePropertiesResponse(response) {
    try {
      const topics = [];
      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);

      if (!Array.isArray(response.parsedBody)) {
        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
      }

      const rawTopicArray = response.parsedBody;

      for (let i = 0; i < rawTopicArray.length; i++) {
        const topic = (0, _topicResourceSerializer.buildTopicRuntimeProperties)(rawTopicArray[i]);

        if (topic) {
          topics.push(topic);
        }
      }

      const listTopicsResponse = Object.defineProperty(topics, "_response", {
        value: (0, _utils.getHttpResponseOnly)(response)
      });
      listTopicsResponse.continuationToken = nextMarker;
      return listTopicsResponse;
    } catch (err) {
      _log.administrationLogger.logError(err, "Failure parsing response from service");

      throw new _coreHttp.RestError(`Error occurred while parsing the response body - cannot form a list of topics using the response from the service.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
    }
  }

  buildTopicResponse(response) {
    try {
      const topic = (0, _topicResourceSerializer.buildTopic)(response.parsedBody);
      const topicResponse = Object.defineProperty(topic || {}, "_response", {
        value: (0, _utils.getHttpResponseOnly)(response)
      });
      return topicResponse;
    } catch (err) {
      _log.administrationLogger.logError(err, "Failure parsing response from service");

      throw new _coreHttp.RestError(`Error occurred while parsing the response body - cannot form a topic object using the response from the service.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
    }
  }

  buildTopicRuntimePropertiesResponse(response) {
    try {
      const topic = (0, _topicResourceSerializer.buildTopicRuntimeProperties)(response.parsedBody);
      const topicResponse = Object.defineProperty(topic || {}, "_response", {
        value: (0, _utils.getHttpResponseOnly)(response)
      });
      return topicResponse;
    } catch (err) {
      _log.administrationLogger.logError(err, "Failure parsing response from service");

      throw new _coreHttp.RestError(`Error occurred while parsing the response body - cannot form a topic object using the response from the service.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
    }
  }

  buildListSubscriptionsResponse(response) {
    try {
      const subscriptions = [];
      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);

      if (!Array.isArray(response.parsedBody)) {
        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
      }

      const rawSubscriptionArray = response.parsedBody;

      for (let i = 0; i < rawSubscriptionArray.length; i++) {
        const subscription = (0, _subscriptionResourceSerializer.buildSubscription)(rawSubscriptionArray[i]);

        if (subscription) {
          subscriptions.push(subscription);
        }
      }

      const listSubscriptionsResponse = Object.defineProperty(subscriptions, "_response", {
        value: (0, _utils.getHttpResponseOnly)(response)
      });
      listSubscriptionsResponse.continuationToken = nextMarker;
      return listSubscriptionsResponse;
    } catch (err) {
      _log.administrationLogger.logError(err, "Failure parsing response from service");

      throw new _coreHttp.RestError(`Error occurred while parsing the response body - cannot form a list of subscriptions using the response from the service.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
    }
  }

  buildListSubscriptionsRuntimePropertiesResponse(response) {
    try {
      const subscriptions = [];
      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);

      if (!Array.isArray(response.parsedBody)) {
        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
      }

      const rawSubscriptionArray = response.parsedBody;

      for (let i = 0; i < rawSubscriptionArray.length; i++) {
        const subscription = (0, _subscriptionResourceSerializer.buildSubscriptionRuntimeProperties)(rawSubscriptionArray[i]);

        if (subscription) {
          subscriptions.push(subscription);
        }
      }

      const listSubscriptionsResponse = Object.defineProperty(subscriptions, "_response", {
        value: (0, _utils.getHttpResponseOnly)(response)
      });
      listSubscriptionsResponse.continuationToken = nextMarker;
      return listSubscriptionsResponse;
    } catch (err) {
      _log.administrationLogger.logError(err, "Failure parsing response from service");

      throw new _coreHttp.RestError(`Error occurred while parsing the response body - cannot form a list of subscriptions using the response from the service.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
    }
  }

  buildSubscriptionResponse(response) {
    try {
      const subscription = (0, _subscriptionResourceSerializer.buildSubscription)(response.parsedBody);
      const subscriptionResponse = Object.defineProperty(subscription || {}, "_response", {
        value: (0, _utils.getHttpResponseOnly)(response)
      });
      return subscriptionResponse;
    } catch (err) {
      _log.administrationLogger.logError(err, "Failure parsing response from service");

      throw new _coreHttp.RestError(`Error occurred while parsing the response body - cannot form a subscription object using the response from the service.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
    }
  }

  buildSubscriptionRuntimePropertiesResponse(response) {
    try {
      const subscription = (0, _subscriptionResourceSerializer.buildSubscriptionRuntimeProperties)(response.parsedBody);
      const subscriptionResponse = Object.defineProperty(subscription || {}, "_response", {
        value: (0, _utils.getHttpResponseOnly)(response)
      });
      return subscriptionResponse;
    } catch (err) {
      _log.administrationLogger.logError(err, "Failure parsing response from service");

      throw new _coreHttp.RestError(`Error occurred while parsing the response body - cannot form a subscription object using the response from the service.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
    }
  }

  buildListRulesResponse(response) {
    try {
      const rules = [];
      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);

      if (!Array.isArray(response.parsedBody)) {
        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
      }

      const rawRuleArray = response.parsedBody;

      for (let i = 0; i < rawRuleArray.length; i++) {
        const rule = (0, _ruleResourceSerializer.buildRule)(rawRuleArray[i]);

        if (rule) {
          rules.push(rule);
        }
      }

      const listRulesResponse = Object.defineProperty(rules, "_response", {
        value: (0, _utils.getHttpResponseOnly)(response)
      });
      listRulesResponse.continuationToken = nextMarker;
      return listRulesResponse;
    } catch (err) {
      _log.administrationLogger.logError(err, "Failure parsing response from service");

      throw new _coreHttp.RestError(`Error occurred while parsing the response body - cannot form a list of rules using the response from the service.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
    }
  }

  buildRuleResponse(response) {
    try {
      const rule = (0, _ruleResourceSerializer.buildRule)(response.parsedBody);
      const ruleResponse = Object.defineProperty(rule || {}, "_response", {
        value: (0, _utils.getHttpResponseOnly)(response)
      });
      return ruleResponse;
    } catch (err) {
      _log.administrationLogger.logError(err, "Failure parsing response from service");

      throw new _coreHttp.RestError(`Error occurred while parsing the response body - cannot form a rule object using the response from the service.`, _coreHttp.RestError.PARSE_ERROR, response.status, (0, _coreHttp.stripRequest)(response.request), (0, _coreHttp.stripResponse)(response));
    }
  }

  throwIfInvalidContinuationToken(token) {
    if (!(token === undefined || typeof token === "string" && Number(token) >= 0)) {
      throw new Error(`Invalid continuationToken ${token} provided`);
    }
  }

}

exports.ServiceBusAdministrationClient = ServiceBusAdministrationClient;
},{"tslib":"CvJj","@azure/core-amqp":"n95d","@azure/core-auth":"Ujm9","@azure/core-http":"rj0o","./log":"IupI","./serializers/namespaceResourceSerializer":"a1vN","./serializers/queueResourceSerializer":"q9Cz","./serializers/ruleResourceSerializer":"qRu9","./serializers/subscriptionResourceSerializer":"y63P","./serializers/topicResourceSerializer":"AJY0","./util/atomXmlHelper":"tZXy","./util/constants":"kjjy","./util/parseUrl":"U2FQ","./util/sasServiceClientCredentials":"Wx48","./util/tracing":"C8Py","./util/utils":"RXMg"}],"RpJR":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultDataTransformer = void 0;

var _rheaPromise = require("rhea-promise");

var _isBuffer = _interopRequireDefault(require("is-buffer"));

var _buffer = require("buffer");

var _log = require("./log");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * The default data transformer that will be used by the Azure SDK.
 * @internal
 * @hidden
 */
const defaultDataTransformer = {
  /**
   * A function that takes the body property from an EventData object
   * and returns an encoded body (some form of AMQP type).
   *
   * @param {*} body The AMQP message body
   * @return {DataSection} encodedBody - The encoded AMQP message body as an AMQP Data type
   * (data section in rhea terms). Section object with following properties:
   * - typecode: 117 (0x75)
   * - content: The given AMQP message body as a Buffer.
   * - multiple: true | undefined.
   */
  encode(body) {
    let result;

    if ((0, _isBuffer.default)(body)) {
      result = _rheaPromise.message.data_section(body);
    } else {
      // string, undefined, null, boolean, array, object, number should end up here
      // coercing undefined to null as that will ensure that null value will be given to the
      // customer on receive.
      if (body === undefined) body = null; // tslint:disable-line

      try {
        const bodyStr = JSON.stringify(body);
        result = _rheaPromise.message.data_section(_buffer.Buffer.from(bodyStr, "utf8"));
      } catch (err) {
        const msg = `An error occurred while executing JSON.stringify() on the given body ` + body + `${err ? err.stack : JSON.stringify(err)}`;

        _log.logger.warning("[encode] " + msg);

        (0, _log.logErrorStackTrace)(_log.logger, err);
        throw new Error(msg);
      }
    }

    return result;
  },

  /**
   * @property {Function} [decode] A function that takes the body property from an AMQP message
   * (an AMQP Data type (data section in rhea terms)) and returns the decoded message body.
   * If it cannot decode the body then it returns the body
   * as-is.
   * @param {DataSection} body The AMQP message body
   * @return {*} decoded body or the given body as-is.
   */
  decode(body) {
    let processedBody = body;

    try {
      if (body.content && (0, _isBuffer.default)(body.content)) {
        // This indicates that we are getting the AMQP described type. Let us try decoding it.
        processedBody = body.content;
      }

      try {
        // Trying to stringify and JSON.parse() anything else will fail flat and we shall return
        // the original type back
        const bodyStr = processedBody.toString("utf8");
        processedBody = JSON.parse(bodyStr);
      } catch (err) {
        _log.logger.verbose("[decode] An error occurred while trying JSON.parse() on the received body. " + "The error is %O", err);
      }
    } catch (err) {
      _log.logger.verbose("[decode] An error occurred while decoding the received message body. The error is: %O", err);
    }

    return processedBody;
  }

};
exports.defaultDataTransformer = defaultDataTransformer;
},{"rhea-promise":"fxSK","is-buffer":"yQtW","buffer":"z1tx","./log":"IupI"}],"jl8f":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMessagePropertyTypeMismatchError = getMessagePropertyTypeMismatchError;
exports.toRheaMessage = toRheaMessage;
exports.fromRheaMessage = fromRheaMessage;
exports.isServiceBusMessage = isServiceBusMessage;
exports.ServiceBusMessageImpl = exports.DispositionType = void 0;

var _coreAmqp = require("@azure/core-amqp");

var _buffer = require("buffer");

var _long = _interopRequireDefault(require("long"));

var _rheaPromise = require("rhea-promise");

var _dataTransformer = require("./dataTransformer");

var _log = require("./log");

var _utils = require("./util/utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 */
var DispositionType;
exports.DispositionType = DispositionType;

(function (DispositionType) {
  DispositionType["complete"] = "complete";
  DispositionType["deadletter"] = "deadletter";
  DispositionType["abandon"] = "abandon";
  DispositionType["defer"] = "defer";
})(DispositionType || (exports.DispositionType = DispositionType = {}));
/**
 * @internal
 * @hidden
 * Gets the error message for when a property on given message is not of expected type
 */


function getMessagePropertyTypeMismatchError(msg) {
  if (msg.contentType != null && typeof msg.contentType !== "string") {
    return new TypeError("The property 'contentType' on the message must be of type 'string'");
  }

  if (msg.subject != null && typeof msg.subject !== "string") {
    return new TypeError("The property 'label' on the message must be of type 'string'");
  }

  if (msg.to != null && typeof msg.to !== "string") {
    return new TypeError("The property 'to' on the message must be of type 'string'");
  }

  if (msg.replyTo != null && typeof msg.replyTo !== "string") {
    return new TypeError("The property 'replyTo' on the message must be of type 'string'");
  }

  if (msg.replyToSessionId != null && typeof msg.replyToSessionId !== "string") {
    return new TypeError("The property 'replyToSessionId' on the message must be of type 'string'");
  }

  if (msg.timeToLive != null && typeof msg.timeToLive !== "number") {
    return new TypeError("The property 'timeToLive' on the message must be of type 'number'");
  }

  if (msg.sessionId != null && typeof msg.sessionId !== "string") {
    return new TypeError("The property 'sessionId' on the message must be of type 'string'");
  }

  if (msg.messageId != null && typeof msg.messageId !== "string" && typeof msg.messageId !== "number" && !_buffer.Buffer.isBuffer(msg.messageId)) {
    return new TypeError("The property 'messageId' on the message must be of type string, number or Buffer");
  }

  if (msg.correlationId != null && typeof msg.correlationId !== "string" && typeof msg.correlationId !== "number" && !_buffer.Buffer.isBuffer(msg.correlationId)) {
    return new TypeError("The property 'correlationId' on the message must be of type string, number or Buffer");
  }

  return;
}
/**
 * @internal
 * @hidden
 * Converts given ServiceBusMessage to RheaMessage
 */


function toRheaMessage(msg) {
  const amqpMsg = {
    body: msg.body,
    message_annotations: {}
  };

  if (msg.applicationProperties != null) {
    amqpMsg.application_properties = msg.applicationProperties;
  }

  if (msg.contentType != null) {
    amqpMsg.content_type = msg.contentType;
  }

  if (msg.sessionId != null) {
    if (msg.sessionId.length > _coreAmqp.Constants.maxSessionIdLength) {
      throw new Error("Length of 'sessionId' property on the message cannot be greater than 128 characters.");
    }

    amqpMsg.group_id = msg.sessionId;
  }

  if (msg.replyTo != null) {
    amqpMsg.reply_to = msg.replyTo;
  }

  if (msg.to != null) {
    amqpMsg.to = msg.to;
  }

  if (msg.subject != null) {
    amqpMsg.subject = msg.subject;
  }

  if (msg.messageId != null) {
    if (typeof msg.messageId === "string" && msg.messageId.length > _coreAmqp.Constants.maxMessageIdLength) {
      throw new Error("Length of 'messageId' property on the message cannot be greater than 128 characters.");
    }

    amqpMsg.message_id = msg.messageId;
  }

  if (msg.correlationId != null) {
    amqpMsg.correlation_id = msg.correlationId;
  }

  if (msg.replyToSessionId != null) {
    amqpMsg.reply_to_group_id = msg.replyToSessionId;
  }

  if (msg.timeToLive != null && msg.timeToLive !== _coreAmqp.Constants.maxDurationValue) {
    amqpMsg.ttl = msg.timeToLive;
    amqpMsg.creation_time = Date.now();

    if (_coreAmqp.Constants.maxAbsoluteExpiryTime - amqpMsg.creation_time > amqpMsg.ttl) {
      amqpMsg.absolute_expiry_time = amqpMsg.creation_time + amqpMsg.ttl;
    } else {
      amqpMsg.absolute_expiry_time = _coreAmqp.Constants.maxAbsoluteExpiryTime;
    }
  }

  if (msg.partitionKey != null) {
    if (msg.partitionKey.length > _coreAmqp.Constants.maxPartitionKeyLength) {
      throw new Error("Length of 'partitionKey' property on the message cannot be greater than 128 characters.");
    }

    amqpMsg.message_annotations[_coreAmqp.Constants.partitionKey] = msg.partitionKey;
  } // Will be required later for implementing Transactions
  // if (msg.viaPartitionKey != null) {
  //   if (msg.viaPartitionKey.length > Constants.maxPartitionKeyLength) {
  //     throw new Error(
  //       "Length of 'viaPartitionKey' property on the message cannot be greater than 128 characters."
  //     );
  //   }
  //   amqpMsg.message_annotations![Constants.viaPartitionKey] = msg.viaPartitionKey;
  // }


  if (msg.scheduledEnqueueTimeUtc != null) {
    amqpMsg.message_annotations[_coreAmqp.Constants.scheduledEnqueueTime] = msg.scheduledEnqueueTimeUtc;
  }

  _log.messageLogger.verbose("SBMessage to RheaMessage: %O", amqpMsg);

  return amqpMsg;
}
/**
 * @internal
 * @hidden
 * Converts given RheaMessage to ServiceBusReceivedMessage
 */


function fromRheaMessage(msg, delivery, shouldReorderLockToken) {
  var _a, _b;

  if (!msg) {
    msg = {
      body: undefined
    };
  }

  const sbmsg = {
    body: msg.body
  };

  if (msg.application_properties != null) {
    sbmsg.applicationProperties = msg.application_properties;
  }

  if (msg.content_type != null) {
    sbmsg.contentType = msg.content_type;
  }

  if (msg.group_id != null) {
    sbmsg.sessionId = msg.group_id;
  }

  if (msg.reply_to != null) {
    sbmsg.replyTo = msg.reply_to;
  }

  if (msg.to != null) {
    sbmsg.to = msg.to;
  }

  if (msg.ttl != null) {
    sbmsg.timeToLive = msg.ttl;
  }

  if (msg.subject != null) {
    sbmsg.subject = msg.subject;
  }

  if (msg.message_id != null) {
    sbmsg.messageId = msg.message_id;
  }

  if (msg.correlation_id != null) {
    sbmsg.correlationId = msg.correlation_id;
  }

  if (msg.reply_to_group_id != null) {
    sbmsg.replyToSessionId = msg.reply_to_group_id;
  }

  if (msg.message_annotations != null) {
    if (msg.message_annotations[_coreAmqp.Constants.partitionKey] != null) {
      sbmsg.partitionKey = msg.message_annotations[_coreAmqp.Constants.partitionKey];
    } // Will be required later for implementing Transactions
    // if (msg.message_annotations[Constants.viaPartitionKey] != null) {
    //   sbmsg.viaPartitionKey = msg.message_annotations[Constants.viaPartitionKey];
    // }


    if (msg.message_annotations[_coreAmqp.Constants.scheduledEnqueueTime] != null) {
      sbmsg.scheduledEnqueueTimeUtc = msg.message_annotations[_coreAmqp.Constants.scheduledEnqueueTime];
    }
  }

  const props = {};

  if (msg.message_annotations != null) {
    if (msg.message_annotations[_coreAmqp.Constants.deadLetterSource] != null) {
      props.deadLetterSource = msg.message_annotations[_coreAmqp.Constants.deadLetterSource];
    }

    if (msg.message_annotations[_coreAmqp.Constants.enqueueSequenceNumber] != null) {
      props.enqueuedSequenceNumber = msg.message_annotations[_coreAmqp.Constants.enqueueSequenceNumber];
    }

    if (msg.message_annotations[_coreAmqp.Constants.sequenceNumber] != null) {
      if (_buffer.Buffer.isBuffer(msg.message_annotations[_coreAmqp.Constants.sequenceNumber])) {
        props.sequenceNumber = _long.default.fromBytesBE(msg.message_annotations[_coreAmqp.Constants.sequenceNumber]);
      } else {
        props.sequenceNumber = _long.default.fromNumber(msg.message_annotations[_coreAmqp.Constants.sequenceNumber]);
      }
    }

    if (msg.message_annotations[_coreAmqp.Constants.enqueuedTime] != null) {
      props.enqueuedTimeUtc = new Date(msg.message_annotations[_coreAmqp.Constants.enqueuedTime]);
    }

    if (msg.message_annotations[_coreAmqp.Constants.lockedUntil] != null) {
      props.lockedUntilUtc = new Date(msg.message_annotations[_coreAmqp.Constants.lockedUntil]);
    }
  }

  if (msg.ttl != null && msg.ttl >= _coreAmqp.Constants.maxDurationValue - props.enqueuedTimeUtc.getTime()) {
    props.expiresAtUtc = new Date(_coreAmqp.Constants.maxDurationValue);
  } else {
    props.expiresAtUtc = new Date(props.enqueuedTimeUtc.getTime() + msg.ttl);
  }

  const rcvdsbmsg = Object.assign(Object.assign(Object.assign({
    _rawAmqpMessage: _coreAmqp.AmqpAnnotatedMessage.fromRheaMessage(msg),
    _delivery: delivery,
    deliveryCount: msg.delivery_count,
    lockToken: delivery && delivery.tag && delivery.tag.length !== 0 ? (0, _rheaPromise.uuid_to_string)(shouldReorderLockToken === true ? (0, _utils.reorderLockToken)(typeof delivery.tag === "string" ? _buffer.Buffer.from(delivery.tag) : delivery.tag) : typeof delivery.tag === "string" ? _buffer.Buffer.from(delivery.tag) : delivery.tag) : undefined
  }, sbmsg), props), {
    deadLetterReason: (_a = sbmsg.applicationProperties) === null || _a === void 0 ? void 0 : _a.DeadLetterReason,
    deadLetterErrorDescription: (_b = sbmsg.applicationProperties) === null || _b === void 0 ? void 0 : _b.DeadLetterErrorDescription
  });

  _log.messageLogger.verbose("AmqpMessage to ServiceBusReceivedMessage: %O", rcvdsbmsg);

  return rcvdsbmsg;
}
/**
 * @internal
 * @hidden
 */


function isServiceBusMessage(possible) {
  return possible != null && typeof possible === "object" && "body" in possible;
}
/**
 * Describes the message received from Service Bus.
 *
 * @internal
 * @hidden
 * @class ServiceBusMessageImpl
 * @implements {ServiceBusReceivedMessage}
 */


class ServiceBusMessageImpl {
  /**
   * @internal
   */
  constructor(msg, delivery, shouldReorderLockToken, receiveMode) {
    Object.assign(this, fromRheaMessage(msg, delivery, shouldReorderLockToken)); // Lock on a message is applicable only in peekLock mode, but the service sets
    // the lock token even in receiveAndDelete mode if the entity in question is partitioned.

    if (receiveMode === "receiveAndDelete") {
      this.lockToken = undefined;
    }

    if (msg.body) {
      this.body = _dataTransformer.defaultDataTransformer.decode(msg.body);
    } // TODO: _rawAmqpMessage is already being populated in fromRheaMessage(), no need to do it twice


    this._rawAmqpMessage = _coreAmqp.AmqpAnnotatedMessage.fromRheaMessage(msg);
    this.delivery = delivery;
  }
  /**
   * Creates a clone of the current message to allow it to be re-sent to the queue
   * @returns ServiceBusMessage
   */


  clone() {
    // We are returning a ServiceBusMessage object because that object can then be sent to Service Bus
    const clone = {
      body: this.body,
      contentType: this.contentType,
      correlationId: this.correlationId,
      subject: this.subject,
      messageId: this.messageId,
      partitionKey: this.partitionKey,
      replyTo: this.replyTo,
      replyToSessionId: this.replyToSessionId,
      scheduledEnqueueTimeUtc: this.scheduledEnqueueTimeUtc,
      sessionId: this.sessionId,
      timeToLive: this.timeToLive,
      to: this.to,
      applicationProperties: this.applicationProperties // Will be required later for implementing Transactions
      // viaPartitionKey: this.viaPartitionKey

    };
    return clone;
  }

}

exports.ServiceBusMessageImpl = ServiceBusMessageImpl;
},{"@azure/core-amqp":"n95d","buffer":"z1tx","long":"YA3p","rhea-promise":"fxSK","./dataTransformer":"RpJR","./log":"IupI","./util/utils":"RXMg"}],"tdxx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.translateServiceBusError = translateServiceBusError;
exports.isServiceBusError = isServiceBusError;
exports.ServiceBusError = exports.wellKnownMessageCodesToServiceBusCodes = void 0;

var _coreAmqp = require("@azure/core-amqp");

/**
 * Translation between the MessagingErrorCodes into a ServiceBusCode
 *
 * @internal
 * @hidden
 */
const wellKnownMessageCodesToServiceBusCodes = new Map([["MessagingEntityNotFoundError", "MessagingEntityNotFound"], ["MessageLockLostError", "MessageLockLost"], ["MessageNotFoundError", "MessageNotFound"], ["MessageTooLargeError", "MessageSizeExceeded"], ["MessagingEntityAlreadyExistsError", "MessagingEntityAlreadyExists"], ["MessagingEntityDisabledError", "MessagingEntityDisabled"], ["QuotaExceededError", "QuotaExceeded"], ["ServerBusyError", "ServiceBusy"], ["OperationTimeoutError", "ServiceTimeout"], ["ServiceCommunicationError", "ServiceCommunicationProblem"], ["SessionCannotBeLockedError", "SessionCannotBeLocked"], ["SessionLockLostError", "SessionLockLost"], ["UnauthorizedError", "UnauthorizedAccess"]]);
/**
 * Errors that occur within Service Bus.
 */

exports.wellKnownMessageCodesToServiceBusCodes = wellKnownMessageCodesToServiceBusCodes;

class ServiceBusError extends _coreAmqp.MessagingError {
  constructor(messageOrError, code) {
    const message = typeof messageOrError === "string" ? messageOrError : messageOrError.message;
    super(message);

    if (typeof messageOrError === "string") {
      this.code = code !== null && code !== void 0 ? code : "GeneralError";
    } else {
      for (const prop in messageOrError) {
        this[prop] = messageOrError[prop];
      }

      this.code = ServiceBusError.normalizeMessagingCode(messageOrError.code); // For GeneralErrors, prefix the error message with the MessagingError code to provide
      // more context to the user.

      if (this.code === "GeneralError" && messageOrError.code) {
        this.message = `${messageOrError.code}: ${this.message}`;
      }
    }

    this.name = "ServiceBusError";
  }

  static normalizeMessagingCode(oldCode) {
    if (oldCode == null || !wellKnownMessageCodesToServiceBusCodes.has(oldCode)) {
      return "GeneralError";
    }

    return wellKnownMessageCodesToServiceBusCodes.get(oldCode);
  }

}
/**
 * Translates an error into either an Error or a ServiceBusError which provides a `reason` code that
 * can be used by clients to programatically react to errors.
 *
 * If you are calling `@azure/core-amqp/translate` you should swap to using this function instead since it provides
 * Service Bus specific handling of the error (falling back to default translate behavior otherwise).
 *
 * @internal
 * @hidden
 */


exports.ServiceBusError = ServiceBusError;

function translateServiceBusError(err) {
  if (isServiceBusError(err)) {
    return err;
  }

  const translatedError = (0, _coreAmqp.translate)(err);

  if ((0, _coreAmqp.isMessagingError)(translatedError)) {
    return new ServiceBusError(translatedError);
  }

  return translatedError;
}
/**
 * Determines if an error is of type `ServiceBusError`
 *
 * @param err An error to check to see if it's of type ServiceBusError
 */


function isServiceBusError(err) {
  return (err === null || err === void 0 ? void 0 : err.name) === "ServiceBusError";
}
},{"@azure/core-amqp":"n95d"}],"tkX2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LinkEntity = void 0;

var _tslib = require("tslib");

var _coreAmqp = require("@azure/core-amqp");

var _rheaPromise = require("rhea-promise");

var _utils = require("../util/utils");

var _abortController = require("@azure/abort-controller");

var _servicebusSharedKeyCredential = require("../servicebusSharedKeyCredential");

var _serviceBusError = require("../serviceBusError");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * Describes the base class for entities like MessageSender, MessageReceiver and Management client.
 */
class LinkEntity {
  /**
   * Creates a new ClientEntity instance.
   * @constructor
   * @param baseName The base name to use for the link. A unique ID will be appended to this.
   * @param entityPath The entity path (ex: 'your-queue')
   * @param context The connection context.
   * @param options Options that can be provided while creating the LinkEntity.
   */
  constructor(baseName, entityPath, context, _linkType, _logger, options) {
    this.baseName = baseName;
    this.entityPath = entityPath;
    this._linkType = _linkType;
    this._logger = _logger;
    /**
     * Indicates that close() has been called on this link and
     * that it should not be allowed to reopen.
     */

    this._wasClosedPermanently = false;
    /**
     * A lock that ensures that opening and closing this
     * link properly cooperate.
     */

    this._openLock = (0, _rheaPromise.generate_uuid)();
    if (!options) options = {};
    this._context = context;
    this.address = options.address || "";
    this.audience = options.audience || "";
    this.name = (0, _utils.getUniqueName)(baseName);
    this._logPrefix = `[${context.connectionId}|${this._linkType}:${this.name}]`;
  }

  get logPrefix() {
    return this._logPrefix;
  }
  /**
   * Determines whether the AMQP link is open. If open then returns true else returns false.
   * @return {boolean} boolean
   */


  isOpen() {
    const result = this._link ? this._link.isOpen() : false;

    this._logger.verbose(`${this._logPrefix} is open? ${result}`);

    return result;
  }
  /**
   * Initializes this LinkEntity, setting this._link with the result of  `createRheaLink`, which
   * is implemented by child classes.
   *
   * @returns A Promise that resolves when the link has been properly initialized
   * @throws {AbortError} if the link has been closed via 'close'
   */


  initLink(options, abortSignal) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      // we'll check that the connection isn't in the process of recycling (and if so, wait for it to complete)
      yield this._context.readyToOpenLink();

      this._logger.verbose(`${this._logPrefix} Attempting to acquire lock token ${this._openLock} for initializing link`);

      return _coreAmqp.defaultLock.acquire(this._openLock, () => {
        this._logger.verbose(`${this._logPrefix} Lock ${this._openLock} acquired for initializing link`);

        return this._initLinkImpl(options, abortSignal);
      });
    });
  }

  _initLinkImpl(options, abortSignal) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const checkAborted = () => {
        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
          throw new _abortController.AbortError(_utils.StandardAbortMessage);
        }
      };

      const connectionId = this._context.connectionId;
      checkAborted();

      if (options.name) {
        this.name = options.name;
        this._logPrefix = `[${connectionId}|${this._linkType}:${this.name}]`;
      }

      if (this._wasClosedPermanently) {
        this._logger.verbose(`${this._logPrefix} Link has been permanently closed. Not reopening.`);

        throw new _abortController.AbortError(`Link has been permanently closed. Not reopening.`);
      }

      if (this.isOpen()) {
        this._logger.verbose(`${this._logPrefix} Link is already open. Returning.`);

        return;
      }

      this._logger.verbose(`${this._logPrefix} Is not open and is not currently connecting. Opening.`);

      try {
        yield this._negotiateClaim();
        checkAborted();
        this.checkIfConnectionReady();

        this._logger.verbose(`${this._logPrefix} Creating with options %O`, options);

        this._link = yield this.createRheaLink(options);
        checkAborted();

        this._ensureTokenRenewal();

        this._logger.verbose(`${this._logPrefix} Link has been created.`);
      } catch (err) {
        this._logger.logError(err, `${this._logPrefix} Error thrown when creating the link`);

        yield this.closeLinkImpl();
        throw err;
      }
    });
  }
  /**
   * Clears token renewal for current link, removes current LinkEntity instance from cache,
   * and closes the underlying AMQP link.
   * Once closed, this instance of LinkEntity is not meant to be re-used.
   */


  close() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      // Set the flag to indicate that this instance of LinkEntity is not meant to be re-used.
      this._wasClosedPermanently = true;

      this._logger.verbose(`${this.logPrefix} permanently closing this link.`); // Remove the underlying AMQP link from the cache


      switch (this._linkType) {
        case "s":
          {
            delete this._context.senders[this.name];
            break;
          }

        case "br":
        case "sr":
          {
            delete this._context.messageReceivers[this.name];
            break;
          }

        case "ms":
          {
            delete this._context.messageSessions[this.name];
            break;
          }
      }

      yield this.closeLink();

      this._logger.verbose(`${this.logPrefix} permanently closed this link.`);
    });
  }
  /**
   * Closes the internally held rhea link, stops the token renewal timer and sets
   * the this._link field to undefined.
   */


  closeLink() {
    this._logger.verbose(`${this._logPrefix} Attempting to acquire lock token ${this._openLock} for closing link`);

    return _coreAmqp.defaultLock.acquire(this._openLock, () => {
      this._logger.verbose(`${this._logPrefix} Lock ${this._openLock} acquired for closing link`);

      return this.closeLinkImpl();
    });
  }

  closeLinkImpl() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._logger.verbose(`${this._logPrefix} closeLinkImpl() called`);

      clearTimeout(this._tokenRenewalTimer);
      this._tokenRenewalTimer = undefined;

      if (this._link) {
        try {
          const link = this._link;
          this._link = undefined; // This should take care of closing the link and it's underlying session. This should also
          // remove them from the internal map.

          yield link.close();

          this._logger.verbose(`${this._logPrefix} closed.`);
        } catch (err) {
          this._logger.logError(err, `${this._logPrefix} An error occurred while closing the link`);
        }
      }
    });
  }
  /**
   * Provides the current type of the ClientEntity.
   * @return {string} The entity type.
   */


  get _type() {
    let result = "LinkEntity";

    if (this.constructor && this.constructor.name) {
      result = this.constructor.name;
    }

    return result;
  }

  get wasClosedPermanently() {
    return this._wasClosedPermanently;
  }

  get link() {
    return this._link;
  }
  /**
   * Negotiates the cbs claim for the ClientEntity.
   * @param {boolean} [setTokenRenewal] Set the token renewal timer. Default false.
   * @return {Promise<void>} Promise<void>
   */


  _negotiateClaim(setTokenRenewal) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._logger.verbose(`${this._logPrefix} negotiateclaim() has been called`); // Wait for the connectionContext to be ready to open the link.


      this.checkIfConnectionReady(); // Acquire the lock and establish a cbs session if it does not exist on the connection.
      // Although node.js is single threaded, we need a locking mechanism to ensure that a
      // race condition does not happen while creating a shared resource (in this case the
      // cbs session, since we want to have exactly 1 cbs session per connection).

      this._logger.verbose("%s Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: " + "'%s' with address: '%s'.", this.logPrefix, this._context.cbsSession.cbsLock, this._type, this.name, this.address);

      yield _coreAmqp.defaultLock.acquire(this._context.cbsSession.cbsLock, () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        this.checkIfConnectionReady();
        return this._context.cbsSession.init();
      }));
      let tokenObject;
      let tokenType;

      if (this._context.tokenCredential instanceof _servicebusSharedKeyCredential.SharedKeyCredential) {
        tokenObject = this._context.tokenCredential.getToken(this.audience);
        tokenType = _coreAmqp.TokenType.CbsTokenTypeSas; // expiresOnTimestamp can be 0 if the token is not meant to be renewed
        // (ie, SharedAccessSignatureCredential)

        if (tokenObject.expiresOnTimestamp > 0) {
          // renew sas token in every 45 minutes
          this._tokenTimeout = (3600 - 900) * 1000;
        }
      } else {
        const aadToken = yield this._context.tokenCredential.getToken(_coreAmqp.Constants.aadServiceBusScope);

        if (!aadToken) {
          throw new Error(`Failed to get token from the provided "TokenCredential" object`);
        }

        tokenObject = aadToken;
        tokenType = _coreAmqp.TokenType.CbsTokenTypeJwt;
        this._tokenTimeout = tokenObject.expiresOnTimestamp - Date.now() - 2 * 60 * 1000;
      }

      this._logger.verbose("%s %s: calling negotiateClaim for audience '%s'.", this.logPrefix, this._type, this.audience); // Acquire the lock to negotiate the CBS claim.


      this._logger.verbose("%s Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.", this.logPrefix, this._context.negotiateClaimLock, this._type, this.name, this.address);

      if (!tokenObject) {
        throw new Error("Token cannot be null");
      }

      yield _coreAmqp.defaultLock.acquire(this._context.negotiateClaimLock, () => {
        this.checkIfConnectionReady();
        return this._context.cbsSession.negotiateClaim(this.audience, tokenObject.token, tokenType);
      });

      this._logger.verbose("%s Negotiated claim for %s '%s' with with address: %s", this.logPrefix, this._type, this.name, this.address);

      if (setTokenRenewal) {
        this._ensureTokenRenewal();
      }
    });
  }
  /**
   * Checks to see if the connection is in a "reopening" state. If it is
   * we need to _not_ use it otherwise we'll trigger some race conditions
   * within rhea (for instance, errors about _process not being defined).
   */


  checkIfConnectionReady() {
    if (!this._context.isConnectionClosing()) {
      return;
    }

    this._logger.verbose(`${this._logPrefix} Connection is reopening, aborting link initialization.`);

    const err = new _serviceBusError.ServiceBusError("Connection is reopening, aborting link initialization.", "GeneralError");
    err.retryable = true;
    throw err;
  }
  /**
   * Ensures that the token is renewed within the predefined renewal margin.
   * @returns {void}
   */


  _ensureTokenRenewal() {
    if (!this._tokenTimeout) {
      return;
    } // Clear the existing token renewal timer.
    // This scenario can happen if the connection goes down and is brought back up
    // before the `nextRenewalTimeout` was reached.


    if (this._tokenRenewalTimer) {
      clearTimeout(this._tokenRenewalTimer);
    }

    this._tokenRenewalTimer = setTimeout(() => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      try {
        yield this._negotiateClaim(true);
      } catch (err) {
        this._logger.logError(err, "%s %s '%s' with address %s, an error occurred while renewing the token", this.logPrefix, this._type, this.name, this.address);
      }
    }), this._tokenTimeout);

    this._logger.verbose("%s %s '%s' with address %s, has next token renewal in %d milliseconds @(%s).", this.logPrefix, this._type, this.name, this.address, this._tokenTimeout, new Date(Date.now() + this._tokenTimeout).toString());
  }

}

exports.LinkEntity = LinkEntity;
},{"tslib":"CvJj","@azure/core-amqp":"n95d","rhea-promise":"fxSK","../util/utils":"RXMg","@azure/abort-controller":"wyb9","../servicebusSharedKeyCredential":"vW7r","../serviceBusError":"tdxx"}],"TKJx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.throwErrorIfConnectionClosed = throwErrorIfConnectionClosed;
exports.getSenderClosedErrorMsg = getSenderClosedErrorMsg;
exports.getReceiverClosedErrorMsg = getReceiverClosedErrorMsg;
exports.getAlreadyReceivingErrorMsg = getAlreadyReceivingErrorMsg;
exports.throwTypeErrorIfParameterMissing = throwTypeErrorIfParameterMissing;
exports.throwTypeErrorIfParameterTypeMismatch = throwTypeErrorIfParameterTypeMismatch;
exports.throwTypeErrorIfParameterNotLong = throwTypeErrorIfParameterNotLong;
exports.throwTypeErrorIfParameterNotLongArray = throwTypeErrorIfParameterNotLongArray;
exports.throwTypeErrorIfParameterIsEmptyString = throwTypeErrorIfParameterIsEmptyString;
exports.throwErrorIfInvalidOperationOnMessage = throwErrorIfInvalidOperationOnMessage;
exports.throwIfNotValidServiceBusMessage = throwIfNotValidServiceBusMessage;
exports.PartitionKeySessionIdMismatchError = exports.MessageAlreadySettled = exports.InvalidOperationForPeekedMessage = exports.InvalidOperationInReceiveAndDeleteMode = exports.InvalidMaxMessageCountError = exports.entityPathMisMatchError = void 0;

var _log = require("../log");

var _long = _interopRequireDefault(require("long"));

var _serviceBusMessage = require("../serviceBusMessage");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Error message to use when EntityPath in connection string does not match the
 * queue or topic name passed to the methods in the ServiceBusClient that create
 * senders and receivers.
 *
 * @internal
 * @hidden
 */
const entityPathMisMatchError = "The queue or topic name provided does not match the EntityPath in the connection string passed to the ServiceBusClient constructor.";
/**
 * Error message for when maxMessageCount provided is invalid.
 *
 * @internal
 * @hidden
 */

exports.entityPathMisMatchError = entityPathMisMatchError;
const InvalidMaxMessageCountError = "'maxMessageCount' must be a number greater than 0.";
/**
 * @internal
 * @hidden
 * Logs and throws Error if the current AMQP connection is closed.
 * @param context The ConnectionContext associated with the current AMQP connection.
 */

exports.InvalidMaxMessageCountError = InvalidMaxMessageCountError;

function throwErrorIfConnectionClosed(context) {
  if (context && context.wasConnectionCloseCalled) {
    const errorMessage = "The underlying AMQP connection is closed.";
    const error = new Error(errorMessage);

    _log.logger.warning(`[${context.connectionId}] %O`, error);

    throw error;
  }
}
/**
 * @internal
 * @hidden
 * Gets the error message when a sender is used when its already closed
 * @param entityPath Value of the `entityPath` property on the client which denotes its name
 */


function getSenderClosedErrorMsg(entityPath) {
  return `The sender for "${entityPath}" has been closed and can no longer be used. ` + `Please create a new sender using the "createSender" method on the ServiceBusClient.`;
}
/**
 * @internal
 * @hidden
 * Gets the error message when a receiver is used when its already closed
 * @param entityPath Value of the `entityPath` property on the client which denotes its name
 * @param sessionId If using session receiver, then the id of the session
 */


function getReceiverClosedErrorMsg(entityPath, sessionId) {
  if (sessionId == undefined) {
    return `The receiver for "${entityPath}" has been closed and can no longer be used. ` + `Please create a new receiver using the "createReceiver" method on the ServiceBusClient.`;
  }

  return `The receiver for session "${sessionId}" in "${entityPath}" has been closed and can no ` + `longer be used. Please create a new receiver using the "acceptSession" or "acceptNextSession" method on the ServiceBusClient.`;
}
/**
 * @internal
 * @hidden
 * @param entityPath Value of the `entityPath` property on the client which denotes its name
 * @param sessionId If using session receiver, then the id of the session
 */


function getAlreadyReceivingErrorMsg(entityPath, sessionId) {
  if (sessionId == undefined) {
    return `The receiver for "${entityPath}" is already receiving messages.`;
  }

  return `The receiver for session "${sessionId}" for "${entityPath}" is already receiving messages.`;
}
/**
 * @internal
 * @hidden
 * Logs and Throws TypeError if given parameter is undefined or null
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to check
 * @param parameterValue Value of the parameter to check
 */


function throwTypeErrorIfParameterMissing(connectionId, parameterName, parameterValue) {
  if (parameterValue === undefined || parameterValue === null) {
    const error = new TypeError(`Missing parameter "${parameterName}"`);

    _log.logger.warning(`[${connectionId}] %O`, error);

    throw error;
  }
}
/**
 * @internal
 * @hidden
 * Logs and Throws TypeError if given parameter is not of expected type
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to type check
 * @param parameterValue Value of the parameter to type check
 * @param expectedType Expected type of the parameter
 */


function throwTypeErrorIfParameterTypeMismatch(connectionId, parameterName, parameterValue, expectedType) {
  if (typeof parameterValue !== expectedType) {
    const error = new TypeError(`The parameter "${parameterName}" should be of type "${expectedType}"`);

    _log.logger.warning(`[${connectionId}] %O`, error);

    throw error;
  }
}
/**
 * @internal
 * @hidden
 * Logs and Throws TypeError if given parameter is not of type `Long` or an array of type `Long`
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to type check
 * @param parameterValue Value of the parameter to type check
 */


function throwTypeErrorIfParameterNotLong(connectionId, parameterName, parameterValue) {
  if (Array.isArray(parameterValue)) {
    return throwTypeErrorIfParameterNotLongArray(connectionId, parameterName, parameterValue);
  }

  if (_long.default.isLong(parameterValue)) {
    return;
  }

  const error = new TypeError(`The parameter "${parameterName}" should be of type "Long"`);

  _log.logger.warning(`[${connectionId}] %O`, error);

  throw error;
}
/**
 * @internal
 * @hidden
 * Logs and Throws TypeError if given parameter is not an array of type `Long`
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to type check
 * @param parameterValue Value of the parameter to type check
 */


function throwTypeErrorIfParameterNotLongArray(connectionId, parameterName, parameterValue) {
  if (parameterValue.every(item => _long.default.isLong(item))) {
    return;
  }

  const error = new TypeError(`The parameter "${parameterName}" should be an array of type "Long"`);

  _log.logger.warning(`[${connectionId}] %O`, error);

  throw error;
}
/**
 * @internal
 * @hidden
 * Logs and Throws TypeError if given parameter is an empty string
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to type check
 * @param parameterValue Value of the parameter to type check
 */


function throwTypeErrorIfParameterIsEmptyString(connectionId, parameterName, parameterValue) {
  if (parameterValue !== "") {
    return;
  }

  const error = new TypeError(`Empty string not allowed in parameter "${parameterName}"`);

  _log.logger.warning(`[${connectionId}] %O`, error);

  throw error;
}
/**
 * @internal
 * @hidden
 * The error message for operations on the receiver that are invalid for a message received in receiveAndDelete mode.
 */


const InvalidOperationInReceiveAndDeleteMode = "The operation is not supported in 'receiveAndDelete' receive mode.";
/**
 * @internal
 * @hidden
 * The error message for operations on the receiver that are invalid for a peeked message.
 */

exports.InvalidOperationInReceiveAndDeleteMode = InvalidOperationInReceiveAndDeleteMode;
const InvalidOperationForPeekedMessage = "This operation is not supported for peeked messages. Only messages received using 'receiveMessages()', 'subscribe()' and 'getMessageIterator()' methods on the receiver in 'peekLock' receive mode can be settled.";
/**
 * @internal
 * @hidden
 * The error message for when one attempts to settle an already settled message.
 */

exports.InvalidOperationForPeekedMessage = InvalidOperationForPeekedMessage;
const MessageAlreadySettled = "The message has either been deleted or already settled";
/**
 * Throws error if the ServiceBusReceivedMessage cannot be settled.
 * @internal
 * @hidden
 */

exports.MessageAlreadySettled = MessageAlreadySettled;

function throwErrorIfInvalidOperationOnMessage(message, receiveMode, connectionId) {
  let error;

  if (receiveMode === "receiveAndDelete") {
    error = new Error(InvalidOperationInReceiveAndDeleteMode);
  } else if (!message.lockToken) {
    error = new Error(InvalidOperationForPeekedMessage);
  }

  if (error) {
    _log.receiverLogger.logError(error, "[%s] An error occurred for message with id '%s'", connectionId, message.messageId);

    throw error;
  }
}
/**
 * Error message for when the ServiceBusMessage provided by the user has different values
 * for partitionKey and sessionId.
 * @internal
 * @hidden
 * @throw
 */


const PartitionKeySessionIdMismatchError = "The fields 'partitionKey' and 'sessionId' cannot have different values.";
/**
 * Throws error if the given object is not a valid ServiceBusMessage
 * @internal
 * @hidden
 * @param msg The object that needs to be validated as a ServiceBusMessage
 * @param errorMessageForWrongType The error message to use when given object is not a ServiceBusMessage
 */

exports.PartitionKeySessionIdMismatchError = PartitionKeySessionIdMismatchError;

function throwIfNotValidServiceBusMessage(msg, errorMessageForWrongType) {
  if (!(0, _serviceBusMessage.isServiceBusMessage)(msg)) {
    throw new TypeError(errorMessageForWrongType);
  }

  if (msg.partitionKey && msg.sessionId && msg.partitionKey !== msg.sessionId) {
    throw new TypeError(PartitionKeySessionIdMismatchError);
  }
}
},{"../log":"IupI","long":"YA3p","../serviceBusMessage":"jl8f"}],"JfPU":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ManagementClient = void 0;

var _tslib = require("tslib");

var _long = _interopRequireDefault(require("long"));

var _rheaPromise = require("rhea-promise");

var _coreAmqp = require("@azure/core-amqp");

var _serviceBusMessage = require("../serviceBusMessage");

var _linkEntity = require("./linkEntity");

var _log = require("../log");

var _utils = require("../util/utils");

var _errors = require("../util/errors");

var _constants = require("../util/constants");

var _buffer = require("buffer");

var _serviceBusError = require("../serviceBusError");

var _dataTransformer = require("../dataTransformer");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 */
const correlationProperties = ["correlationId", "messageId", "to", "replyTo", "subject", "sessionId", "replyToSessionId", "contentType", "applicationProperties"];
/**
 * @internal
 * @hidden
 * @class ManagementClient
 * Describes the ServiceBus Management Client that talks
 * to the $management endpoint over AMQP connection.
 */

class ManagementClient extends _linkEntity.LinkEntity {
  /**
   * @constructor
   * Instantiates the management client.
   * @param context The connection context
   * @param entityPath - The name/path of the entity (queue/topic/subscription name)
   * for which the management request needs to be made.
   * @param {ManagementClientOptions} [options] Options to be provided for creating the
   * "$management" client.
   */
  constructor(context, entityPath, options) {
    super(`${entityPath}/$management`, entityPath, context, "mgmt", _log.managementClientLogger, {
      address: options && options.address ? options.address : _coreAmqp.Constants.management,
      audience: options && options.audience ? options.audience : `${context.config.endpoint}${entityPath}/$management`
    });
    /**
     * @property {string} replyTo The reply to Guid for the management client.
     */

    this.replyTo = (0, _rheaPromise.generate_uuid)();
    /**
     * @property _lastPeekedSequenceNumber Provides the sequence number of the last peeked message.
     */

    this._lastPeekedSequenceNumber = _long.default.ZERO;
    this._context = context;
  }

  _init(abortSignal) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);

      try {
        const rxopt = {
          source: {
            address: this.address
          },
          name: this.replyTo,
          target: {
            address: this.replyTo
          },
          onSessionError: context => {
            const sbError = (0, _serviceBusError.translateServiceBusError)(context.session.error);

            _log.managementClientLogger.logError(sbError, `${this.logPrefix} An error occurred on the session for request/response links for $management`);
          }
        };
        const sropt = {
          target: {
            address: this.address
          },
          onError: context => {
            const ehError = (0, _serviceBusError.translateServiceBusError)(context.sender.error);

            _log.managementClientLogger.logError(ehError, `${this.logPrefix} An error occurred on the $management sender link`);
          }
        }; // Even if multiple parallel requests reach here, the initLink secures a lock
        // to ensure there won't be multiple initializations

        yield this.initLink({
          senderOptions: sropt,
          receiverOptions: rxopt
        }, abortSignal);
      } catch (err) {
        err = (0, _serviceBusError.translateServiceBusError)(err);

        _log.managementClientLogger.logError(err, `${this.logPrefix} An error occurred while establishing the $management links`);

        throw err;
      }
    });
  }

  createRheaLink(options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const rheaLink = yield _coreAmqp.RequestResponseLink.create(this._context.connection, options.senderOptions, options.receiverOptions); // Attach listener for the `receiver_error` events to log the errors.
      // "message" event listener is added in core-amqp.
      // "rhea" doesn't allow setting only the "onError" handler in the options if it is not accompanied by an "onMessage" handler.
      // Hence, not passing onError handler in the receiver options, adding a handler below.

      rheaLink.receiver.on(_rheaPromise.ReceiverEvents.receiverError, context => {
        const ehError = (0, _serviceBusError.translateServiceBusError)(context.receiver.error);

        _log.managementClientLogger.logError(ehError, `${this.logPrefix} An error occurred on the $management receiver link`);
      });
      return rheaLink;
    });
  }
  /**
   * Given array of typed values, returns the element in given index
   */


  _safelyGetTypedValueFromArray(data, index) {
    return Array.isArray(data) && data.length > index && data[index] ? data[index].value : undefined;
  }

  _makeManagementRequest(request, internalLogger, sendRequestOptions = {}) {
    var _a;

    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      if (request.message_id == undefined) {
        request.message_id = (0, _rheaPromise.generate_uuid)();
      }

      const retryTimeoutInMs = (_a = sendRequestOptions.timeoutInMs) !== null && _a !== void 0 ? _a : _coreAmqp.Constants.defaultOperationTimeoutInMs;
      const initOperationStartTime = Date.now();

      const actionAfterTimeout = reject => {
        const desc = `The request with message_id "${request.message_id}" timed out. Please try again later.`;
        const e = {
          name: "OperationTimeoutError",
          message: desc
        };
        reject(e);
      };

      let waitTimer;
      const operationTimeout = new Promise((_, reject) => {
        waitTimer = setTimeout(() => actionAfterTimeout(reject), retryTimeoutInMs);
      });
      internalLogger.verbose(`${this.logPrefix} Acquiring lock to get the management req res link.`);

      try {
        if (!this.isOpen()) {
          yield Promise.race([this._init(sendRequestOptions === null || sendRequestOptions === void 0 ? void 0 : sendRequestOptions.abortSignal), operationTimeout]);
        }
      } finally {
        clearTimeout(waitTimer);
      } // time taken by the init operation


      const timeTakenByInit = Date.now() - initOperationStartTime; // Left over time

      sendRequestOptions.timeoutInMs = retryTimeoutInMs - timeTakenByInit;

      try {
        if (!request.message_id) request.message_id = (0, _rheaPromise.generate_uuid)();
        return yield this.link.sendRequest(request, sendRequestOptions);
      } catch (err) {
        err = (0, _serviceBusError.translateServiceBusError)(err);
        internalLogger.logError(err, "%s An error occurred during send on management request-response link with address " + "'%s': %O", this.logPrefix, this.address, err);
        throw err;
      }
    });
  }
  /**
   * Closes the AMQP management session to the ServiceBus namespace for this client,
   * returning a promise that will be resolved when disconnection is completed.
   * @return Promise<void>
   */


  close() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      try {
        // Always clear the timeout, as the isOpen check may report
        // false without ever having cleared the timeout otherwise.
        // NOTE: management link currently doesn't have a separate concept of "detaching" like
        // the other links do. When we add handling of this (via the onDetached call, like other links)
        // we can change this back to closeLink("permanent").
        yield this.closeLink();

        _log.managementClientLogger.verbose("Successfully closed the management session.");
      } catch (err) {
        _log.managementClientLogger.logError(err, `${this.logPrefix} An error occurred while closing the management session`);

        throw err;
      }
    });
  }
  /**
   * Fetches the next batch of active messages. The first call to `peek()` fetches the first
   * active message for this client. Each subsequent call fetches the subsequent message in the
   * entity.
   *
   * Unlike a `received` message, `peeked` message will not have lock token associated with it,
   * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`. This method will
   * also fetch even Deferred messages (but not Deadlettered message).
   *
   * @param messageCount The number of messages to retrieve. Default value `1`.
   * @returns Promise<ReceivedSBMessage[]>
   */


  peek(messageCount, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);
      return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), messageCount, undefined, options);
    });
  }
  /**
   * Fetches the next batch of active messages in the current MessageSession. The first call to
   * `peek()` fetches the first active message for this client. Each subsequent call fetches the
   * subsequent message in the entity.
   *
   * Unlike a `received` message, `peeked` message will not have lock token associated with it,
   * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`.  This method will
   * also fetch even Deferred messages (but not Deadlettered message).
   *
   * @param sessionId The sessionId from which messages need to be peeked.
   * @param messageCount The number of messages to retrieve. Default value `1`.
   * @returns Promise<ReceivedMessageInfo[]>
   */


  peekMessagesBySession(sessionId, messageCount, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);
      return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), messageCount, sessionId, options);
    });
  }
  /**
   * Peeks the desired number of messages from the specified sequence number.
   *
   * @param fromSequenceNumber The sequence number from where to read the message.
   * @param messageCount The number of messages to retrieve. Default value `1`.
   * @param sessionId The sessionId from which messages need to be peeked.
   * @returns Promise<ReceivedMessageInfo[]>
   */


  peekBySequenceNumber(fromSequenceNumber, maxMessageCount, sessionId, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);
      const connId = this._context.connectionId; // Checks for fromSequenceNumber

      (0, _errors.throwTypeErrorIfParameterMissing)(connId, "fromSequenceNumber", fromSequenceNumber);
      (0, _errors.throwTypeErrorIfParameterNotLong)(connId, "fromSequenceNumber", fromSequenceNumber); // Checks for maxMessageCount

      (0, _errors.throwTypeErrorIfParameterMissing)(this._context.connectionId, "maxMessageCount", maxMessageCount);
      (0, _errors.throwTypeErrorIfParameterTypeMismatch)(this._context.connectionId, "maxMessageCount", maxMessageCount, "number");

      if (isNaN(maxMessageCount) || maxMessageCount < 1) {
        throw new TypeError(_errors.InvalidMaxMessageCountError);
      }

      const messageList = [];

      try {
        const messageBody = {};
        messageBody[_coreAmqp.Constants.fromSequenceNumber] = _rheaPromise.types.wrap_long(_buffer.Buffer.from(fromSequenceNumber.toBytesBE()));
        messageBody[_coreAmqp.Constants.messageCount] = _rheaPromise.types.wrap_int(maxMessageCount);

        if (sessionId != undefined) {
          messageBody[_coreAmqp.Constants.sessionIdMapKey] = sessionId;
        }

        const request = {
          body: messageBody,
          reply_to: this.replyTo,
          application_properties: {
            operation: _coreAmqp.Constants.operations.peekMessage
          }
        };

        if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
          request.application_properties[_coreAmqp.Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
        }

        request.application_properties[_coreAmqp.Constants.trackingId] = (0, _rheaPromise.generate_uuid)(); // TODO: it'd be nice to attribute this peek request to the actual receiver that made it. So have them pass in a
        // log prefix rather than just falling back to the management links.

        _log.receiverLogger.verbose("%s Peek by sequence number request body: %O.", this.logPrefix, request.body);

        const result = yield this._makeManagementRequest(request, _log.receiverLogger, options);

        if (result.application_properties.statusCode !== 204) {
          const messages = result.body.messages;

          for (const msg of messages) {
            const decodedMessage = _rheaPromise.message.decode(msg.message);

            const message = (0, _serviceBusMessage.fromRheaMessage)(decodedMessage);
            message.body = _dataTransformer.defaultDataTransformer.decode(message.body);
            messageList.push(message);
            this._lastPeekedSequenceNumber = message.sequenceNumber;
          }
        }
      } catch (err) {
        const error = (0, _serviceBusError.translateServiceBusError)(err);

        _log.receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to peek messages to $management endpoint`); // statusCode == 404 then do not throw


        if (error.code !== _coreAmqp.ConditionErrorNameMapper["com.microsoft:message-not-found"]) {
          throw error;
        }
      }

      return messageList;
    });
  }
  /**
   * Renews the lock on the message. The lock will be renewed based on the setting specified on
   * the queue.
   *
   * When a message is received in `PeekLock` mode, the message is locked on the server for this
   * receiver instance for a duration as specified during the Queue/Subscription creation
   * (LockDuration). If processing of the message requires longer than this duration, the
   * lock needs to be renewed. For each renewal, it resets the time the message is locked by the
   * LockDuration set on the Entity.
   *
   * @param lockToken Lock token of the message
   * @param options Options that can be set while sending the request.
   * @returns Promise<Date> New lock token expiry date and time in UTC format.
   */


  renewLock(lockToken, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);
      if (!options) options = {};
      if (options.timeoutInMs == null) options.timeoutInMs = 5000;

      try {
        const messageBody = {};
        messageBody[_coreAmqp.Constants.lockTokens] = _rheaPromise.types.wrap_array([(0, _rheaPromise.string_to_uuid)(lockToken)], 0x98, undefined);
        const request = {
          body: messageBody,
          reply_to: this.replyTo,
          application_properties: {
            operation: _coreAmqp.Constants.operations.renewLock
          }
        };
        request.application_properties[_coreAmqp.Constants.trackingId] = (0, _rheaPromise.generate_uuid)();

        if (options.associatedLinkName) {
          request.application_properties[_coreAmqp.Constants.associatedLinkName] = options.associatedLinkName;
        }

        _log.receiverLogger.verbose("[%s] Renew message Lock request: %O.", this._context.connectionId, request);

        const result = yield this._makeManagementRequest(request, _log.receiverLogger, {
          abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
          requestName: "renewLock"
        });
        const lockedUntilUtc = new Date(result.body.expirations[0]);
        return lockedUntilUtc;
      } catch (err) {
        const error = (0, _serviceBusError.translateServiceBusError)(err);

        _log.receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);

        throw error;
      }
    });
  }
  /**
   * Schedules an array of messages to appear on Service Bus at a later time.
   *
   * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.
   * @param messages - An array of messages that needs to be scheduled.
   * @returns Promise<number> The sequence numbers of messages that were scheduled.
   */


  scheduleMessages(scheduledEnqueueTimeUtc, messages, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);

      if (!messages.length) {
        return [];
      }

      const messageBody = [];

      for (let i = 0; i < messages.length; i++) {
        const item = messages[i];
        if (!item.messageId) item.messageId = (0, _rheaPromise.generate_uuid)();
        item.scheduledEnqueueTimeUtc = scheduledEnqueueTimeUtc;
        const amqpMessage = (0, _serviceBusMessage.toRheaMessage)(item);
        amqpMessage.body = _dataTransformer.defaultDataTransformer.encode(amqpMessage.body);

        try {
          const entry = {
            message: _rheaPromise.message.encode(amqpMessage),
            "message-id": item.messageId
          };

          if (item.sessionId) {
            entry[_coreAmqp.Constants.sessionIdMapKey] = item.sessionId;
          }

          if (item.partitionKey) {
            entry["partition-key"] = item.partitionKey;
          } // Will be required later for implementing Transactions
          // if (item.viaPartitionKey) {
          //   entry["via-partition-key"] = item.viaPartitionKey;
          // }


          const wrappedEntry = _rheaPromise.types.wrap_map(entry);

          messageBody.push(wrappedEntry);
        } catch (err) {
          let error;

          if (err instanceof TypeError || err.name === "TypeError") {
            // `RheaMessageUtil.encode` can fail if message properties are of invalid type
            // rhea throws errors with name `TypeError` but not an instance of `TypeError`, so catch them too
            // Errors in such cases do not have user-friendly message or call stack
            // So use `getMessagePropertyTypeMismatchError` to get a better error message
            error = (0, _serviceBusError.translateServiceBusError)((0, _serviceBusMessage.getMessagePropertyTypeMismatchError)(item) || err);
          } else {
            error = (0, _serviceBusError.translateServiceBusError)(err);
          }

          _log.senderLogger.logError(error, `${this.logPrefix} An error occurred while encoding the item at position ${i} in the messages array`);

          throw error;
        }
      }

      try {
        const request = {
          body: {
            messages: messageBody
          },
          reply_to: this.replyTo,
          application_properties: {
            operation: _coreAmqp.Constants.operations.scheduleMessage
          }
        };

        if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
          request.application_properties[_coreAmqp.Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
        }

        request.application_properties[_coreAmqp.Constants.trackingId] = (0, _rheaPromise.generate_uuid)();

        _log.senderLogger.verbose("%s Schedule messages request body: %O.", this.logPrefix, request.body);

        const result = yield this._makeManagementRequest(request, _log.senderLogger, options);
        const sequenceNumbers = result.body[_coreAmqp.Constants.sequenceNumbers];
        const sequenceNumbersAsLong = [];

        for (let i = 0; i < sequenceNumbers.length; i++) {
          if (typeof sequenceNumbers[i] === "number") {
            sequenceNumbersAsLong.push(_long.default.fromNumber(sequenceNumbers[i]));
          } else {
            sequenceNumbersAsLong.push(_long.default.fromBytesBE(sequenceNumbers[i]));
          }
        }

        return sequenceNumbersAsLong;
      } catch (err) {
        const error = (0, _serviceBusError.translateServiceBusError)(err);

        _log.senderLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to schedule messages to $management endpoint`);

        throw error;
      }
    });
  }
  /**
   * Cancels an array of messages that were scheduled.
   * @param sequenceNumbers - An Array of sequence numbers of the message to be cancelled.
   * @returns Promise<void>
   */


  cancelScheduledMessages(sequenceNumbers, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);

      if (!sequenceNumbers.length) {
        return;
      }

      const messageBody = {};
      messageBody[_coreAmqp.Constants.sequenceNumbers] = [];

      for (let i = 0; i < sequenceNumbers.length; i++) {
        const sequenceNumber = sequenceNumbers[i];

        try {
          messageBody[_coreAmqp.Constants.sequenceNumbers].push(_buffer.Buffer.from(sequenceNumber.toBytesBE()));
        } catch (err) {
          const error = (0, _serviceBusError.translateServiceBusError)(err);

          _log.senderLogger.logError(error, `${this.logPrefix} An error occurred while encoding the item at position ${i} in the sequenceNumbers array`);

          throw error;
        }
      }

      try {
        messageBody[_coreAmqp.Constants.sequenceNumbers] = _rheaPromise.types.wrap_array(messageBody[_coreAmqp.Constants.sequenceNumbers], 0x81, undefined);
        const request = {
          body: messageBody,
          reply_to: this.replyTo,
          application_properties: {
            operation: _coreAmqp.Constants.operations.cancelScheduledMessage
          }
        };

        if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
          request.application_properties[_coreAmqp.Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
        }

        request.application_properties[_coreAmqp.Constants.trackingId] = (0, _rheaPromise.generate_uuid)();

        _log.senderLogger.verbose("%s Cancel scheduled messages request body: %O.", this.logPrefix, request.body);

        yield this._makeManagementRequest(request, _log.senderLogger, options);
        return;
      } catch (err) {
        const error = (0, _serviceBusError.translateServiceBusError)(err);

        _log.senderLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to cancel the scheduled message to $management endpoint`);

        throw error;
      }
    });
  }
  /**
   * Receives a list of deferred messages identified by `sequenceNumbers`.
   *
   * @param sequenceNumbers A list containing the sequence numbers to receive.
   * @param receiveMode The mode in which the receiver was created.
   * @returns Promise<ServiceBusMessage[]>
   * - Returns a list of messages identified by the given sequenceNumbers.
   * - Returns an empty list if no messages are found.
   * - Throws an error if the messages have not been deferred.
   */


  receiveDeferredMessages(sequenceNumbers, receiveMode, sessionId, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);

      if (!sequenceNumbers.length) {
        return [];
      }

      const messageList = [];
      const messageBody = {};
      messageBody[_coreAmqp.Constants.sequenceNumbers] = [];

      for (let i = 0; i < sequenceNumbers.length; i++) {
        const sequenceNumber = sequenceNumbers[i];

        try {
          messageBody[_coreAmqp.Constants.sequenceNumbers].push(_buffer.Buffer.from(sequenceNumber.toBytesBE()));
        } catch (err) {
          const error = (0, _serviceBusError.translateServiceBusError)(err);

          _log.receiverLogger.logError(error, `${this.logPrefix} An error occurred while encoding the item at position ${i} in the sequenceNumbers array`);

          throw error;
        }
      }

      try {
        messageBody[_coreAmqp.Constants.sequenceNumbers] = _rheaPromise.types.wrap_array(messageBody[_coreAmqp.Constants.sequenceNumbers], 0x81, undefined);
        const receiverSettleMode = receiveMode === "receiveAndDelete" ? 0 : 1;
        messageBody[_coreAmqp.Constants.receiverSettleMode] = _rheaPromise.types.wrap_uint(receiverSettleMode);

        if (sessionId != null) {
          messageBody[_coreAmqp.Constants.sessionIdMapKey] = sessionId;
        }

        const request = {
          body: messageBody,
          reply_to: this.replyTo,
          application_properties: {
            operation: _coreAmqp.Constants.operations.receiveBySequenceNumber
          }
        };

        if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
          request.application_properties[_coreAmqp.Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
        }

        request.application_properties[_coreAmqp.Constants.trackingId] = (0, _rheaPromise.generate_uuid)();

        _log.receiverLogger.verbose("%s Receive deferred messages request body: %O.", this.logPrefix, request.body);

        const result = yield this._makeManagementRequest(request, _log.receiverLogger, options);
        const messages = result.body.messages;

        for (const msg of messages) {
          const decodedMessage = _rheaPromise.message.decode(msg.message);

          const message = new _serviceBusMessage.ServiceBusMessageImpl(decodedMessage, {
            tag: msg["lock-token"]
          }, false, receiveMode);
          messageList.push(message);
        }

        return messageList;
      } catch (err) {
        const error = (0, _serviceBusError.translateServiceBusError)(err);

        _log.receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to receive deferred messages to $management endpoint`);

        throw error;
      }
    });
  }
  /**
   * Updates the disposition status of deferred messages.
   *
   * @param lockTokens Message lock tokens to update disposition status.
   * @param dispositionStatus The disposition status to be set
   * @param options Optional parameters that can be provided while updating the disposition status.
   *
   * @returns Promise<void>
   */


  updateDispositionStatus(lockToken, dispositionType, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);
      if (!options) options = {};

      try {
        let dispositionStatus;
        if (dispositionType === _serviceBusMessage.DispositionType.abandon) dispositionStatus = "abandoned";else if (dispositionType === _serviceBusMessage.DispositionType.complete) dispositionStatus = "completed";else if (dispositionType === _serviceBusMessage.DispositionType.defer) dispositionStatus = "defered";else if (dispositionType === _serviceBusMessage.DispositionType.deadletter) dispositionStatus = "suspended";else throw new Error(`Provided "dispositionType" - ${dispositionType} is invalid`);
        const messageBody = {};
        const lockTokenBuffer = [];
        lockTokenBuffer.push((0, _rheaPromise.string_to_uuid)(lockToken));
        messageBody[_coreAmqp.Constants.lockTokens] = _rheaPromise.types.wrap_array(lockTokenBuffer, 0x98, undefined);
        messageBody[_coreAmqp.Constants.dispositionStatus] = dispositionStatus;

        if (options.deadLetterDescription != null) {
          messageBody[_coreAmqp.Constants.deadLetterDescription] = options.deadLetterDescription;
        }

        if (options.deadLetterReason != null) {
          messageBody[_coreAmqp.Constants.deadLetterReason] = options.deadLetterReason;
        }

        if (options.propertiesToModify != null) {
          messageBody[_coreAmqp.Constants.propertiesToModify] = options.propertiesToModify;
        }

        if (options.sessionId != null) {
          messageBody[_coreAmqp.Constants.sessionIdMapKey] = options.sessionId;
        }

        const request = {
          body: messageBody,
          reply_to: this.replyTo,
          application_properties: {
            operation: _coreAmqp.Constants.operations.updateDisposition
          }
        };

        if (options.associatedLinkName) {
          request.application_properties[_coreAmqp.Constants.associatedLinkName] = options.associatedLinkName;
        }

        request.application_properties[_coreAmqp.Constants.trackingId] = (0, _rheaPromise.generate_uuid)();

        _log.receiverLogger.verbose("%s Update disposition status request body: %O.", this.logPrefix, request.body);

        yield this._makeManagementRequest(request, _log.receiverLogger, options);
      } catch (err) {
        const error = (0, _serviceBusError.translateServiceBusError)(err);

        _log.receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to update disposition status to $management endpoint`);

        throw error;
      }
    });
  }
  /**
   * Renews the lock for the specified session.
   *
   * @param sessionId Id of the session for which the lock needs to be renewed
   * @param options Options that can be set while sending the request.
   * @returns Promise<Date> New lock token expiry date and time in UTC format.
   */


  renewSessionLock(sessionId, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);

      try {
        const messageBody = {};
        messageBody[_coreAmqp.Constants.sessionIdMapKey] = sessionId;
        const request = {
          body: messageBody,
          reply_to: this.replyTo,
          application_properties: {
            operation: _coreAmqp.Constants.operations.renewSessionLock
          }
        };
        request.application_properties[_coreAmqp.Constants.trackingId] = (0, _rheaPromise.generate_uuid)();

        if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
          request.application_properties[_coreAmqp.Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
        }

        _log.receiverLogger.verbose("%s Renew Session Lock request body: %O.", this.logPrefix, request.body);

        const result = yield this._makeManagementRequest(request, _log.receiverLogger, options);
        const lockedUntilUtc = new Date(result.body.expiration);

        _log.receiverLogger.verbose("%s Lock for session '%s' will expire at %s.", this.logPrefix, sessionId, lockedUntilUtc.toString());

        return lockedUntilUtc;
      } catch (err) {
        const error = (0, _serviceBusError.translateServiceBusError)(err);

        _log.receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);

        throw error;
      }
    });
  }
  /**
   * Sets the state of the specified session.
   *
   * @param sessionId The session for which the state needs to be set
   * @param state The state that needs to be set.
   * @returns Promise<void>
   */


  setSessionState(sessionId, state, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);

      try {
        const messageBody = {};
        messageBody[_coreAmqp.Constants.sessionIdMapKey] = sessionId;
        messageBody["session-state"] = (0, _utils.toBuffer)(state);
        const request = {
          body: messageBody,
          reply_to: this.replyTo,
          application_properties: {
            operation: _coreAmqp.Constants.operations.setSessionState
          }
        };

        if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
          request.application_properties[_coreAmqp.Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
        }

        request.application_properties[_coreAmqp.Constants.trackingId] = (0, _rheaPromise.generate_uuid)();

        _log.receiverLogger.verbose("%s Set Session state request body: %O.", this.logPrefix, request.body);

        yield this._makeManagementRequest(request, _log.receiverLogger, options);
      } catch (err) {
        const error = (0, _serviceBusError.translateServiceBusError)(err);

        _log.receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);

        throw error;
      }
    });
  }
  /**
   * Gets the state of the specified session.
   *
   * @param sessionId The session for which the state needs to be retrieved.
   * @returns Promise<any> The state of that session
   */


  getSessionState(sessionId, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);

      try {
        const messageBody = {};
        messageBody[_coreAmqp.Constants.sessionIdMapKey] = sessionId;
        const request = {
          body: messageBody,
          reply_to: this.replyTo,
          application_properties: {
            operation: _coreAmqp.Constants.operations.getSessionState
          }
        };

        if (options === null || options === void 0 ? void 0 : options.associatedLinkName) {
          request.application_properties[_coreAmqp.Constants.associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
        }

        request.application_properties[_coreAmqp.Constants.trackingId] = (0, _rheaPromise.generate_uuid)();

        _log.receiverLogger.verbose("%s Get session state request body: %O.", this.logPrefix, request.body);

        const result = yield this._makeManagementRequest(request, _log.receiverLogger, options);
        return result.body["session-state"] ? _dataTransformer.defaultDataTransformer.decode(result.body["session-state"]) : result.body["session-state"];
      } catch (err) {
        const error = (0, _serviceBusError.translateServiceBusError)(err);

        _log.receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);

        throw error;
      }
    });
  }
  /**
   * Lists the sessions on the ServiceBus Queue/Topic.
   * @param lastUpdateTime Filter to include only sessions updated after a given time.
   * @param skip The number of sessions to skip
   * @param top Maximum numer of sessions.
   * @returns Promise<string[]> A list of session ids.
   */


  listMessageSessions(skip, top, lastUpdatedTime, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);
      const defaultLastUpdatedTimeForListingSessions = 259200000; // 3 * 24 * 3600 * 1000

      if (typeof skip !== "number") {
        throw new Error("'skip' is a required parameter and must be of type 'number'.");
      }

      if (typeof top !== "number") {
        throw new Error("'top' is a required parameter and must be of type 'number'.");
      }

      if (lastUpdatedTime && !(lastUpdatedTime instanceof Date)) {
        throw new Error("'lastUpdatedTime' must be of type 'Date'.");
      }

      if (!lastUpdatedTime) {
        lastUpdatedTime = new Date(Date.now() - defaultLastUpdatedTimeForListingSessions);
      }

      try {
        const messageBody = {};
        messageBody["last-updated-time"] = lastUpdatedTime;
        messageBody["skip"] = _rheaPromise.types.wrap_int(skip);
        messageBody["top"] = _rheaPromise.types.wrap_int(top);
        const request = {
          body: messageBody,
          reply_to: this.replyTo,
          application_properties: {
            operation: _coreAmqp.Constants.operations.enumerateSessions
          }
        };
        request.application_properties[_coreAmqp.Constants.trackingId] = (0, _rheaPromise.generate_uuid)();

        _log.managementClientLogger.verbose("%s List sessions request body: %O.", this.logPrefix, request.body);

        const response = yield this._makeManagementRequest(request, _log.managementClientLogger, options);
        return response && response.body && response.body["sessions-ids"] || [];
      } catch (err) {
        const error = (0, _serviceBusError.translateServiceBusError)(err);

        _log.managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);

        throw error;
      }
    });
  }
  /**
   * Get all the rules on the Subscription.
   * @returns Promise<RuleDescription[]> A list of rules.
   */


  getRules(options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);

      try {
        const request = {
          body: {
            top: _rheaPromise.types.wrap_int(_constants.max32BitNumber),
            skip: _rheaPromise.types.wrap_int(0)
          },
          reply_to: this.replyTo,
          application_properties: {
            operation: _coreAmqp.Constants.operations.enumerateRules
          }
        };
        request.application_properties[_coreAmqp.Constants.trackingId] = (0, _rheaPromise.generate_uuid)();

        _log.managementClientLogger.verbose("%s Get rules request body: %O.", this.logPrefix, request.body);

        const response = yield this._makeManagementRequest(request, _log.managementClientLogger, options);

        if (response.application_properties.statusCode === 204 || !response.body || !Array.isArray(response.body.rules)) {
          return [];
        } // Reference: https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-request-response#response-11


        const result = response.body.rules || [];
        const rules = [];
        result.forEach(x => {
          const ruleDescriptor = x["rule-description"]; // We use the first three elements of the `ruleDescriptor.value` to get filter, action, name

          if (!ruleDescriptor || !ruleDescriptor.descriptor || ruleDescriptor.descriptor.value !== _coreAmqp.Constants.descriptorCodes.ruleDescriptionList || !Array.isArray(ruleDescriptor.value) || ruleDescriptor.value.length < 3) {
            return;
          }

          const filtersRawData = ruleDescriptor.value[0];
          const actionsRawData = ruleDescriptor.value[1];
          const rule = {
            name: ruleDescriptor.value[2].value
          };

          switch (filtersRawData.descriptor.value) {
            case _coreAmqp.Constants.descriptorCodes.trueFilterList:
              rule.filter = "1=1";
              break;

            case _coreAmqp.Constants.descriptorCodes.falseFilterList:
              rule.filter = "1=0";
              break;

            case _coreAmqp.Constants.descriptorCodes.sqlFilterList:
              rule.filter = this._safelyGetTypedValueFromArray(filtersRawData.value, 0);
              break;

            case _coreAmqp.Constants.descriptorCodes.correlationFilterList:
              rule.filter = {
                correlationId: this._safelyGetTypedValueFromArray(filtersRawData.value, 0),
                messageId: this._safelyGetTypedValueFromArray(filtersRawData.value, 1),
                to: this._safelyGetTypedValueFromArray(filtersRawData.value, 2),
                replyTo: this._safelyGetTypedValueFromArray(filtersRawData.value, 3),
                subject: this._safelyGetTypedValueFromArray(filtersRawData.value, 4),
                sessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 5),
                replyToSessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 6),
                contentType: this._safelyGetTypedValueFromArray(filtersRawData.value, 7),
                applicationProperties: this._safelyGetTypedValueFromArray(filtersRawData.value, 8)
              };
              break;

            default:
              _log.managementClientLogger.warning(`${this.logPrefix} Found unexpected descriptor code for the filter: ${filtersRawData.descriptor.value}`);

              break;
          }

          if (actionsRawData.descriptor.value === _coreAmqp.Constants.descriptorCodes.sqlRuleActionList && Array.isArray(actionsRawData.value) && actionsRawData.value.length) {
            rule.action = this._safelyGetTypedValueFromArray(actionsRawData.value, 0);
          }

          rules.push(rule);
        });
        return rules;
      } catch (err) {
        const error = (0, _serviceBusError.translateServiceBusError)(err);

        _log.managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the get rules request to $management endpoint`);

        throw error;
      }
    });
  }
  /**
   * Removes the rule on the Subscription identified by the given rule name.
   * @param ruleName
   */


  removeRule(ruleName, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);
      (0, _errors.throwTypeErrorIfParameterMissing)(this._context.connectionId, "ruleName", ruleName);
      ruleName = String(ruleName);
      (0, _errors.throwTypeErrorIfParameterIsEmptyString)(this._context.connectionId, "ruleName", ruleName);

      try {
        const request = {
          body: {
            "rule-name": _rheaPromise.types.wrap_string(ruleName)
          },
          reply_to: this.replyTo,
          application_properties: {
            operation: _coreAmqp.Constants.operations.removeRule
          }
        };
        request.application_properties[_coreAmqp.Constants.trackingId] = (0, _rheaPromise.generate_uuid)();

        _log.managementClientLogger.verbose("%s Remove Rule request body: %O.", this.logPrefix, request.body);

        yield this._makeManagementRequest(request, _log.managementClientLogger, options);
      } catch (err) {
        const error = (0, _serviceBusError.translateServiceBusError)(err);

        _log.managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the remove rule request to $management endpoint`);

        throw error;
      }
    });
  }
  /**
   * Adds a rule on the subscription as defined by the given rule name, filter and action
   * @param ruleName Name of the rule
   * @param filter A Boolean, SQL expression or a Correlation filter
   * @param sqlRuleActionExpression Action to perform if the message satisfies the filtering expression
   */


  addRule(ruleName, filter, sqlRuleActionExpression, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);
      (0, _errors.throwTypeErrorIfParameterMissing)(this._context.connectionId, "ruleName", ruleName);
      ruleName = String(ruleName);
      (0, _errors.throwTypeErrorIfParameterIsEmptyString)(this._context.connectionId, "ruleName", ruleName);
      (0, _errors.throwTypeErrorIfParameterMissing)(this._context.connectionId, "filter", filter);

      if (typeof filter !== "boolean" && typeof filter !== "string" && !correlationProperties.some(validProperty => filter.hasOwnProperty(validProperty))) {
        throw new TypeError(`The parameter "filter" should be either a boolean, string or implement the CorrelationRuleFilter interface.`);
      }

      try {
        const ruleDescription = {};

        switch (typeof filter) {
          case "boolean":
            ruleDescription["sql-filter"] = {
              expression: filter ? "1=1" : "1=0"
            };
            break;

          case "string":
            ruleDescription["sql-filter"] = {
              expression: filter
            };
            break;

          default:
            ruleDescription["correlation-filter"] = {
              "correlation-id": filter.correlationId,
              "message-id": filter.messageId,
              to: filter.to,
              "reply-to": filter.replyTo,
              subject: filter.subject,
              "session-id": filter.sessionId,
              "reply-to-session-id": filter.replyToSessionId,
              "content-type": filter.contentType,
              applicationProperties: filter.applicationProperties
            };
            break;
        }

        if (sqlRuleActionExpression !== undefined) {
          ruleDescription["sql-rule-action"] = {
            expression: String(sqlRuleActionExpression)
          };
        }

        const request = {
          body: {
            "rule-name": _rheaPromise.types.wrap_string(ruleName),
            "rule-description": _rheaPromise.types.wrap_map(ruleDescription)
          },
          reply_to: this.replyTo,
          application_properties: {
            operation: _coreAmqp.Constants.operations.addRule
          }
        };
        request.application_properties[_coreAmqp.Constants.trackingId] = (0, _rheaPromise.generate_uuid)();

        _log.managementClientLogger.verbose("%s Add Rule request body: %O.", this.logPrefix, request.body);

        yield this._makeManagementRequest(request, _log.managementClientLogger, options);
      } catch (err) {
        const error = (0, _serviceBusError.translateServiceBusError)(err);

        _log.managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the Add rule request to $management endpoint`);

        throw error;
      }
    });
  }

}

exports.ManagementClient = ManagementClient;
},{"tslib":"CvJj","long":"YA3p","rhea-promise":"fxSK","@azure/core-amqp":"n95d","../serviceBusMessage":"jl8f","./linkEntity":"tkX2","../log":"IupI","../util/utils":"RXMg","../util/errors":"TKJx","../util/constants":"kjjy","buffer":"z1tx","../serviceBusError":"tdxx","../dataTransformer":"RpJR"}],"L60p":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRuntimeInfo = getRuntimeInfo;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Returns information about the platform this function is being run on.
 * @hidden
 * @internal
 */
function getRuntimeInfo() {
  const navigator = window.navigator;
  const osInfo = {
    key: "OS",
    value: (navigator.oscpu || navigator.platform).replace(" ", "")
  };
  return `${osInfo.key}/${osInfo.value}`;
}
},{}],"VwcI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConnectionContext = void 0;

var _tslib = require("tslib");

var _log = require("./log");

var _constants = require("./util/constants");

var _coreAmqp = require("@azure/core-amqp");

var _rheaPromise = require("rhea-promise");

var _managementClient = require("./core/managementClient");

var _utils = require("./util/utils");

var _runtimeInfo = require("./util/runtimeInfo");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * Helper method to call onDetached on the receivers from the connection context upon seeing an error.
 */
function callOnDetachedOnReceivers(connectionContext, contextOrConnectionError, receiverType) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
    const detachCalls = [];

    for (const receiverName of Object.keys(connectionContext.messageReceivers)) {
      const receiver = connectionContext.messageReceivers[receiverName];

      if (receiver && receiver.receiverType === receiverType) {
        _log.connectionLogger.verbose("[%s] calling detached on %s receiver '%s'.", connectionContext.connection.id, receiver.receiverType, receiver.name);

        detachCalls.push(receiver.onDetached(contextOrConnectionError).catch(err => {
          _log.connectionLogger.logError(err, "[%s] An error occurred while calling onDetached() on the %s receiver '%s'", connectionContext.connection.id, receiver.receiverType, receiver.name);
        }));
      }
    }

    return Promise.all(detachCalls);
  });
}
/**
 * @internal
 * @hidden
 * Helper method to get the number of receivers of specified type from the connectionContext.
 */


function getNumberOfReceivers(connectionContext, receiverType) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
    if (receiverType === "session") {
      const receivers = connectionContext.messageSessions;
      return Object.keys(receivers).length;
    }

    const receivers = connectionContext.messageReceivers;
    const receiverNames = Object.keys(receivers);
    const count = receiverNames.reduce((acc, name) => receivers[name].receiverType === receiverType ? ++acc : acc, 0);
    return count;
  });
}
/**
 * @internal
 * @hidden
 */


var ConnectionContext;
exports.ConnectionContext = ConnectionContext;

(function (ConnectionContext) {
  function create(config, tokenCredential, options) {
    var _a;

    if (!options) options = {};
    const userAgent = `${(0, _utils.formatUserAgentPrefix)((_a = options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix)} ${(0, _runtimeInfo.getRuntimeInfo)()}`;
    const parameters = {
      config: config,
      // re-enabling this will be a post-GA discussion similar to event-hubs.
      // dataTransformer: options.dataTransformer,
      isEntityPathRequired: false,
      connectionProperties: {
        product: "MSJSClient",
        userAgent,
        version: _constants.packageJsonInfo.version
      }
    }; // Let us create the base context and then add ServiceBus specific ConnectionContext properties.

    const connectionContext = _coreAmqp.ConnectionContextBase.create(parameters);

    connectionContext.tokenCredential = tokenCredential;
    connectionContext.senders = {};
    connectionContext.messageReceivers = {};
    connectionContext.messageSessions = {};
    connectionContext.managementClients = {};
    let waitForConnectionRefreshResolve;
    let waitForConnectionRefreshPromise;
    Object.assign(connectionContext, {
      isConnectionClosing() {
        // When the connection is not open, but the remote end is open,
        // then the rhea connection is in the process of terminating.
        return Boolean(!this.connection.isOpen() && this.connection.isRemoteOpen());
      },

      readyToOpenLink() {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
          _log.connectionLogger.verbose(`[${this.connectionId}] Waiting until the connection is ready to open link.`); // Check that the connection isn't in the process of closing.
          // This can happen when the idle timeout has been reached but
          // the underlying socket is waiting to be destroyed.


          if (this.isConnectionClosing()) {
            _log.connectionLogger.verbose(`[${this.connectionId}] Connection is closing, waiting for disconnected event`); // Wait for the disconnected event that indicates the underlying socket has closed.


            yield this.waitForDisconnectedEvent();
          } // Wait for the connection to be reset.


          yield this.waitForConnectionReset();

          _log.connectionLogger.verbose(`[${this.connectionId}] Connection is ready to open link.`);
        });
      },

      waitForDisconnectedEvent() {
        return new Promise(resolve => {
          _log.connectionLogger.verbose(`[${this.connectionId}] Attempting to reinitialize connection` + ` but the connection is in the process of closing.` + ` Waiting for the disconnect event before continuing.`);

          this.connection.once(_rheaPromise.ConnectionEvents.disconnected, resolve);
        });
      },

      waitForConnectionReset() {
        // Check if the connection is currently in the process of disconnecting.
        if (waitForConnectionRefreshPromise) {
          _log.connectionLogger.verbose(`[${this.connectionId}] Waiting for connection reset`);

          return waitForConnectionRefreshPromise;
        }

        _log.connectionLogger.verbose(`[${this.connectionId}] Connection not waiting to be reset. Resolving immediately.`);

        return Promise.resolve();
      },

      getReceiverFromCache(receiverName, sessionId) {
        if (sessionId != null && this.messageSessions[receiverName]) {
          return this.messageSessions[receiverName];
        }

        if (this.messageReceivers[receiverName]) {
          return this.messageReceivers[receiverName];
        }

        let existingReceivers = "";

        if (sessionId != null) {
          for (const messageSessionName of Object.keys(this.messageSessions)) {
            if (this.messageSessions[messageSessionName].sessionId === sessionId) {
              existingReceivers = this.messageSessions[messageSessionName].name;
              break;
            }
          }
        } else {
          existingReceivers += (existingReceivers ? ", " : "") + Object.keys(this.messageReceivers).join(",");
        }

        _log.connectionLogger.verbose("[%s] Failed to find receiver '%s' among existing receivers: %s", this.connectionId, receiverName, existingReceivers);

        return;
      },

      getManagementClient(entityPath) {
        if (!this.managementClients[entityPath]) {
          this.managementClients[entityPath] = new _managementClient.ManagementClient(this, entityPath, {
            address: `${entityPath}/$management`
          });
        }

        return this.managementClients[entityPath];
      }

    }); // Define listeners to be added to the connection object for
    // "connection_open" and "connection_error" events.

    const onConnectionOpen = () => {
      connectionContext.wasConnectionCloseCalled = false;

      _log.connectionLogger.verbose("[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.", connectionContext.connection.id, connectionContext.wasConnectionCloseCalled);
    };

    const disconnected = context => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      if (waitForConnectionRefreshPromise) {
        return;
      }

      waitForConnectionRefreshPromise = new Promise(resolve => {
        waitForConnectionRefreshResolve = resolve;
      });
      const connectionError = context.connection && context.connection.error ? context.connection.error : undefined;

      if (connectionError) {
        _log.connectionLogger.logError(connectionError, "[%s] Error (context.connection.error) occurred on the amqp connection", connectionContext.connection.id);
      }

      const contextError = context.error;

      if (contextError) {
        _log.connectionLogger.logError(contextError, "[%s] Error (context.error) occurred on the amqp connection", connectionContext.connection.id);
      }

      const state = {
        wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,
        numSenders: Object.keys(connectionContext.senders).length,
        numReceivers: Object.keys(connectionContext.messageReceivers).length + Object.keys(connectionContext.messageSessions).length
      }; // Clear internal map maintained by rhea to avoid reconnecting of old links once the
      // connection is back up.

      connectionContext.connection.removeAllSessions(); // Close the cbs session to ensure all the event handlers are released.

      yield connectionContext.cbsSession.close(); // Close the management sessions to ensure all the event handlers are released.

      for (const entityPath of Object.keys(connectionContext.managementClients)) {
        yield connectionContext.managementClients[entityPath].close();
      } // Calling onDetached on sender


      if (!state.wasConnectionCloseCalled && state.numSenders) {
        // We don't do recovery for the sender:
        //   Because we don't want to keep the sender active all the time
        //   and the "next" send call would bear the burden of creating the link.
        // Call onDetached() on sender so that it can gracefully shutdown
        //   by cleaning up the timers and closing the links.
        // We don't call onDetached for sender after `refreshConnection()`
        //   because any new send calls that potentially initialize links would also get affected if called later.
        _log.connectionLogger.verbose(`[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${state.numSenders} ` + `senders. We should not reconnect.`);

        const detachCalls = [];

        for (const senderName of Object.keys(connectionContext.senders)) {
          const sender = connectionContext.senders[senderName];

          if (sender) {
            _log.connectionLogger.verbose("[%s] calling detached on sender '%s'.", connectionContext.connection.id, sender.name);

            detachCalls.push(sender.onDetached().catch(err => {
              _log.connectionLogger.logError(err, "[%s] An error occurred while calling onDetached() the sender '%s'", connectionContext.connection.id, sender.name);
            }));
          }
        }

        yield Promise.all(detachCalls);
      } // Calling onDetached on batching receivers for the same reasons as sender


      const numBatchingReceivers = getNumberOfReceivers(connectionContext, "batching");

      if (!state.wasConnectionCloseCalled && numBatchingReceivers) {
        _log.connectionLogger.verbose(`[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numBatchingReceivers} ` + `batching receivers. We should reconnect.`); // Call onDetached() on receivers so that batching receivers it can gracefully close any ongoing batch operation


        yield callOnDetachedOnReceivers(connectionContext, connectionError || contextError, "batching"); // TODO:
        //  `callOnDetachedOnReceivers` handles "connectionContext.messageReceivers".
        //  ...What to do for sessions (connectionContext.messageSessions) ??
      }

      yield refreshConnection(connectionContext);
      waitForConnectionRefreshResolve();
      waitForConnectionRefreshPromise = undefined; // The connection should always be brought back up if the sdk did not call connection.close()
      // and there was at least one receiver link on the connection before it went down.

      _log.connectionLogger.verbose("[%s] state: %O", connectionContext.connectionId, state); // Calling onDetached on streaming receivers


      const numStreamingReceivers = getNumberOfReceivers(connectionContext, "streaming");

      if (!state.wasConnectionCloseCalled && numStreamingReceivers) {
        _log.connectionLogger.verbose(`[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numStreamingReceivers} ` + `streaming receivers. We should reconnect.`); // Calling `onDetached()` on streaming receivers after the refreshConnection() since `onDetached()` would
        // recover the streaming receivers and that would only be possible after the connection is refreshed.
        //
        // This is different from the batching receiver since `onDetached()` for the batching receiver would
        // return the outstanding messages and close the receive link.


        yield callOnDetachedOnReceivers(connectionContext, connectionError || contextError, "streaming");
      }
    });

    const protocolError = context => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      if (context.connection && context.connection.error) {
        _log.connectionLogger.logError(context.connection.error, "[%s] Error (context.connection.error) occurred on the amqp connection", connectionContext.connection.id);
      }

      if (context.error) {
        _log.connectionLogger.logError(context.error, "[%s] Error (context.error) occurred on the amqp connection", connectionContext.connection.id);
      }
    });

    const error = context => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      if (context.connection && context.connection.error) {
        _log.connectionLogger.logError(context.connection.error, "[%s] Error (context.connection.error) occurred on the amqp connection", connectionContext.connection.id);
      }

      if (context.error) {
        _log.connectionLogger.logError(context.error, "[%s] Error (context.error) occurred on the amqp connection", connectionContext.connection.id);
      }
    });

    function refreshConnection(connectionContext) {
      return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        const originalConnectionId = connectionContext.connectionId;

        try {
          yield cleanConnectionContext(connectionContext);
        } catch (err) {
          _log.connectionLogger.logError(err, `[${connectionContext.connectionId}] There was an error closing the connection before reconnecting`);
        } // Create a new connection, id, locks, and cbs client.


        connectionContext.refreshConnection();
        addConnectionListeners(connectionContext.connection);

        _log.connectionLogger.verbose(`The connection "${originalConnectionId}" has been updated to "${connectionContext.connectionId}".`);
      });
    }

    function addConnectionListeners(connection) {
      // Add listeners on the connection object.
      connection.on(_rheaPromise.ConnectionEvents.connectionOpen, onConnectionOpen);
      connection.on(_rheaPromise.ConnectionEvents.disconnected, disconnected);
      connection.on(_rheaPromise.ConnectionEvents.protocolError, protocolError);
      connection.on(_rheaPromise.ConnectionEvents.error, error);
    }

    function cleanConnectionContext(connectionContext) {
      return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        // Remove listeners from the connection object.
        connectionContext.connection.removeListener(_rheaPromise.ConnectionEvents.connectionOpen, onConnectionOpen);
        connectionContext.connection.removeListener(_rheaPromise.ConnectionEvents.disconnected, disconnected);
        connectionContext.connection.removeListener(_rheaPromise.ConnectionEvents.protocolError, protocolError);
        connectionContext.connection.removeListener(_rheaPromise.ConnectionEvents.error, error); // Close the connection

        yield connectionContext.connection.close();
      });
    }

    addConnectionListeners(connectionContext.connection);

    _log.connectionLogger.verbose("[%s] Created connection context successfully.", connectionContext.connectionId);

    return connectionContext;
  }

  ConnectionContext.create = create;
  /**
   * Closes the AMQP connection created by this ServiceBusClient along with AMQP links for
   * sender/receivers created by the queue/topic/subscription clients created by this
   * ServiceBusClient.
   * Once closed,
   * - the clients created by this ServiceBusClient cannot be used to send/receive messages anymore.
   * - this ServiceBusClient cannot be used to create any new queues/topics/subscriptions clients.
   * @returns {Promise<any>}
   */

  function close(context) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const logPrefix = `[${context.connectionId}]`;

      try {
        _log.connectionLogger.verbose(`${logPrefix} Permanently closing the amqp connection on the client.`); // Close all the senders.


        const senderNames = Object.keys(context.senders);

        _log.connectionLogger.verbose(`${logPrefix} Permanently closing ${senderNames.length} senders.`);

        for (const senderName of senderNames) {
          yield context.senders[senderName].close();
        } // Close all MessageReceiver instances


        const messageReceiverNames = Object.keys(context.messageReceivers);

        _log.connectionLogger.verbose(`${logPrefix} Permanently closing ${messageReceiverNames.length} receivers.`);

        for (const receiverName of messageReceiverNames) {
          yield context.messageReceivers[receiverName].close();
        } // Close all MessageSession instances


        const messageSessionNames = Object.keys(context.messageSessions);

        _log.connectionLogger.verbose(`${logPrefix} Permanently closing ${messageSessionNames.length} session receivers.`);

        for (const messageSessionName of messageSessionNames) {
          yield context.messageSessions[messageSessionName].close();
        } // Close all the ManagementClients.


        const managementClientsEntityPaths = Object.keys(context.managementClients);

        _log.connectionLogger.verbose(`${logPrefix} Permanently closing ${managementClientsEntityPaths.length} session receivers.`);

        for (const entityPath of managementClientsEntityPaths) {
          yield context.managementClients[entityPath].close();
        }

        _log.connectionLogger.verbose(`${logPrefix} Permanently closing cbsSession`);

        yield context.cbsSession.close();

        _log.connectionLogger.verbose(`${logPrefix} Permanently closing internal connection`);

        yield context.connection.close();
        context.wasConnectionCloseCalled = true;

        _log.connectionLogger.verbose(`[${logPrefix} Permanently closed the amqp connection on the client.`);
      } catch (err) {
        const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));

        _log.connectionLogger.logError(err, `${logPrefix} An error occurred while closing the connection`);

        throw errObj;
      }
    });
  }

  ConnectionContext.close = close;
})(ConnectionContext || (exports.ConnectionContext = ConnectionContext = {}));
},{"tslib":"CvJj","./log":"IupI","./util/constants":"kjjy","@azure/core-amqp":"n95d","rhea-promise":"fxSK","./core/managementClient":"JfPU","./util/utils":"RXMg","./util/runtimeInfo":"L60p"}],"lfFE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createConnectionContext = createConnectionContext;
exports.createConnectionContextForConnectionString = createConnectionContextForConnectionString;
exports.createConnectionContextForTokenCredential = createConnectionContextForTokenCredential;
exports.getEntityNameFromConnectionString = getEntityNameFromConnectionString;

var _coreAmqp = require("@azure/core-amqp");

var _connectionContext = require("./connectionContext");

var _servicebusSharedKeyCredential = require("./servicebusSharedKeyCredential");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 *
 * @param {string} connectionString
 * @param {(SharedKeyCredential | TokenCredential)} credential
 * @param {ServiceBusClientOptions} options
 */
function createConnectionContext(connectionString, credential, options) {
  var _a, _b;

  const config = _coreAmqp.ConnectionConfig.create(connectionString);

  config.webSocket = (_a = options === null || options === void 0 ? void 0 : options.webSocketOptions) === null || _a === void 0 ? void 0 : _a.webSocket;
  config.webSocketEndpointPath = "$servicebus/websocket";
  config.webSocketConstructorOptions = (_b = options === null || options === void 0 ? void 0 : options.webSocketOptions) === null || _b === void 0 ? void 0 : _b.webSocketConstructorOptions;
  return _connectionContext.ConnectionContext.create(config, credential, options);
}
/**
 * @param connectionString
 * @param options
 * @internal
 * @hidden
 */


function createConnectionContextForConnectionString(connectionString, options = {}) {
  const credential = _servicebusSharedKeyCredential.SharedKeyCredential.fromConnectionString(connectionString);

  return createConnectionContext(connectionString, credential, options);
}
/**
 *
 * @param credential
 * @param host
 * @param options
 * @internal
 * @hidden
 */


function createConnectionContextForTokenCredential(credential, host, options = {}) {
  if (typeof host !== "string") {
    throw new TypeError("`host` parameter is not a string");
  } // host, credential and options based constructor was invoked


  if (!host.endsWith("/")) {
    host += "/";
  }

  const connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;`;
  return createConnectionContext(connectionString, credential, options);
}
/**
 * Parses a connection string and extracts the EntityPath named entity out.
 * @param connectionString An entity specific Service Bus connection string.
 * @internal
 * @hidden
 */


function getEntityNameFromConnectionString(connectionString) {
  const entityPathMatch = connectionString.match(/^.+EntityPath=(.+?);{0,1}$/);

  if (entityPathMatch != null && entityPathMatch.length === 2) {
    return entityPathMatch[1];
  } else {
    throw new Error("No entity name present in the connection string");
  }
}
},{"@azure/core-amqp":"n95d","./connectionContext":"VwcI","./servicebusSharedKeyCredential":"vW7r"}],"xWS9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParentSpan = getParentSpan;
exports.createSendSpan = createSendSpan;
exports.trace = trace;

var _tslib = require("tslib");

var _api = require("@opentelemetry/api");

var _coreTracing = require("@azure/core-tracing");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// TODO: this code is a straight-copy from EventHubs. Need to merge.

/**
 * @internal
 * @hidden
 */
function getParentSpan(options) {
  var _a;

  return (_a = options === null || options === void 0 ? void 0 : options.spanOptions) === null || _a === void 0 ? void 0 : _a.parent;
}
/**
 * @internal
 * @hidden
 *
 * @param {(Span | SpanContext | null)} [parentSpan]
 * @param {SpanContext[]} [spanContextsToLink=[]]
 * @param {string} [entityPath]
 * @param {string} [host]
 */


function createSendSpan(parentSpan, spanContextsToLink = [], entityPath, host) {
  const links = spanContextsToLink.map(context => {
    return {
      context
    };
  });
  const tracer = (0, _coreTracing.getTracer)();
  const span = tracer.startSpan("Azure.ServiceBus.send", {
    kind: _api.SpanKind.CLIENT,
    parent: parentSpan,
    links
  });
  span.setAttribute("az.namespace", "Microsoft.ServiceBus");
  span.setAttribute("message_bus.destination", entityPath);
  span.setAttribute("peer.address", host);
  return span;
}
/**
 * Runs the `fn` passed in and marks the span as completed with an error (and the
 * corresponding message) or as OK.
 *
 * @hidden
 * @internal
 */


function trace(fn, span) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
    try {
      const ret = yield fn();
      span.setStatus({
        code: _api.CanonicalCode.OK
      });
      return ret;
    } catch (err) {
      span.setStatus({
        code: _api.CanonicalCode.UNKNOWN,
        message: err.message
      });
      throw err;
    } finally {
      span.end();
    }
  });
}
},{"tslib":"CvJj","@opentelemetry/api":"fNAU","@azure/core-tracing":"xbTt"}],"Kut1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onMessageSettled = onMessageSettled;
exports.createReceiverOptions = createReceiverOptions;

var _serviceBusError = require("../serviceBusError");

var _log = require("../log");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * This is the shared onSettled handler for all of the receiver implementations.
 *
 * The sequence is basically:
 * 1. User calls `await <ServiceBusMessage instance>.complete()`     (or other settlement methods)
 * 2. This creates a `Promise` that gets stored in the _deliveryDispositionMap
 * 3. When the service acknowledges the settlement this method gets called for that message.
 * 4. We resolve() the promise from the _deliveryDispositionMap.
 * 5. User's code after the settlement continues.
 *
 * @internal
 * @hidden
 */
function onMessageSettled(logPrefix, delivery, deliveryDispositionMap) {
  if (delivery) {
    const id = delivery.id;
    const state = delivery.remote_state;
    const settled = delivery.remote_settled;

    _log.receiverLogger.verbose("%s Delivery with id %d, remote_settled: %s, remote_state: %o has been " + "received.", logPrefix, id, settled, state && state.error ? state.error : state);

    if (settled && deliveryDispositionMap.has(id)) {
      const promise = deliveryDispositionMap.get(id);
      clearTimeout(promise.timer);

      _log.receiverLogger.verbose("%s Found the delivery with id %d in the map and cleared the timer.", logPrefix, id);

      const deleteResult = deliveryDispositionMap.delete(id);

      _log.receiverLogger.verbose("%s Successfully deleted the delivery with id %d from the map.", logPrefix, id, deleteResult);

      if (state && state.error && (state.error.condition || state.error.description)) {
        const error = (0, _serviceBusError.translateServiceBusError)(state.error);
        return promise.reject(error);
      }

      return promise.resolve();
    }
  }
}
/**
 * Creates the options that need to be specified while creating an AMQP receiver link.
 *
 * @internal
 * @hidden
 * @param {string} name
 * @param {ReceiveMode} receiveMode
 * @param {Source} source
 * @param {ReceiverHandlers} handlers
 */


function createReceiverOptions(name, receiveMode, source, handlers) {
  const rcvrOptions = Object.assign({
    name,
    // "autoaccept" being true in the "receiveAndDelete" mode sets the "settled" flag to true on the deliveries
    // which helps in clearing the circular buffer(size=2048) as it is needed to receive messages after 2048 of them are received.
    autoaccept: receiveMode === "receiveAndDelete" ? true : false,
    // receiveAndDelete -> first(0), peekLock -> second (1)
    rcv_settle_mode: receiveMode === "receiveAndDelete" ? 0 : 1,
    // receiveAndDelete -> settled (1), peekLock -> unsettled (0)
    snd_settle_mode: receiveMode === "receiveAndDelete" ? 1 : 0,
    source,
    credit_window: 0
  }, handlers);
  return rcvrOptions;
}
},{"../serviceBusError":"tdxx","../log":"IupI"}],"zec7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessageReceiver = void 0;

var _tslib = require("tslib");

var _coreAmqp = require("@azure/core-amqp");

var _log = require("../log");

var _linkEntity = require("./linkEntity");

var _serviceBusMessage = require("../serviceBusMessage");

var _utils = require("../util/utils");

var _shared = require("./shared");

var _serviceBusError = require("../serviceBusError");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * Describes the MessageReceiver that will receive messages from ServiceBus.
 * @class MessageReceiver
 */
class MessageReceiver extends _linkEntity.LinkEntity {
  constructor(context, entityPath, receiverType, options) {
    super(entityPath, entityPath, context, receiverType, _log.receiverLogger, {
      address: entityPath,
      audience: `${context.config.endpoint}${entityPath}`
    });
    /**
     * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that
     * are being actively disposed. It acts as a store for correlating the responses received for
     * active dispositions.
     */

    this._deliveryDispositionMap = new Map();
    this.receiverType = receiverType;
    this.receiveMode = options.receiveMode || "peekLock"; // If explicitly set to false then autoComplete is false else true (default).

    this.autoComplete = options.autoCompleteMessages === false ? options.autoCompleteMessages : true;
    this._lockRenewer = options.lockRenewer;
  }
  /**
   * Creates the options that need to be specified while creating an AMQP receiver link.
   */


  _createReceiverOptions(useNewName, handlers) {
    const rcvrOptions = (0, _shared.createReceiverOptions)(useNewName ? (0, _utils.getUniqueName)(this.baseName) : this.name, this.receiveMode, {
      address: this.address
    }, Object.assign({
      onSettled: context => {
        return (0, _shared.onMessageSettled)(this.logPrefix, context.delivery, this._deliveryDispositionMap);
      }
    }, handlers));
    return rcvrOptions;
  }
  /**
   * Creates a new AMQP receiver under a new AMQP session.
   *
   * @returns {Promise<void>} Promise<void>.
   */


  _init(options, abortSignal) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      try {
        yield this.initLink(options, abortSignal); // It is possible for someone to close the receiver and then start it again.
        // Thus make sure that the receiver is present in the client cache.

        this._context.messageReceivers[this.name] = this;
      } catch (err) {
        err = (0, _serviceBusError.translateServiceBusError)(err);

        _log.receiverLogger.logError(err, "%s An error occured while creating the receiver", this.logPrefix); // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.


        if (err.code === "OperationTimeoutError") {
          err.message = "Failed to create a receiver within allocated time and retry attempts.";
        }

        throw err;
      }
    });
  }

  createRheaLink(options, _abortSignal) {
    return this._context.connection.createReceiver(options);
  }
  /**
   * Clears lock renewal timers on all active messages, clears token remewal for current receiver,
   * removes current MessageReceiver instance from cache, and closes the underlying AMQP receiver.
   * @return {Promise<void>} Promise<void>.
   */


  close() {
    const _super = Object.create(null, {
      close: {
        get: () => super.close
      }
    });

    var _a;

    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (_a = this._lockRenewer) === null || _a === void 0 ? void 0 : _a.stopAll(this);
      yield _super.close.call(this);
    });
  }
  /**
   * Settles the message with the specified disposition.
   * @param message The ServiceBus Message that needs to be settled.
   * @param operation The disposition type.
   * @param options Optional parameters that can be provided while disposing the message.
   */


  settleMessage(message, operation, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return new Promise((resolve, reject) => {
        var _a;

        if (!options) options = {};

        if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {
          return reject(new Error(`operation: '${operation}' is not a valid operation.`));
        }

        (_a = this._lockRenewer) === null || _a === void 0 ? void 0 : _a.stop(this, message);
        const delivery = message.delivery;
        const timer = setTimeout(() => {
          this._deliveryDispositionMap.delete(delivery.id);

          _log.receiverLogger.verbose("%s Disposition for delivery id: %d, did not complete in %d milliseconds. " + "Hence rejecting the promise with timeout error.", this.logPrefix, delivery.id, _coreAmqp.Constants.defaultOperationTimeoutInMs);

          const e = {
            condition: _coreAmqp.ErrorNameConditionMapper.ServiceUnavailableError,
            description: "Operation to settle the message has timed out. The disposition of the " + "message may or may not be successful"
          };
          return reject((0, _serviceBusError.translateServiceBusError)(e));
        }, _coreAmqp.Constants.defaultOperationTimeoutInMs);

        this._deliveryDispositionMap.set(delivery.id, {
          resolve: resolve,
          reject: reject,
          timer: timer
        });

        if (operation === _serviceBusMessage.DispositionType.complete) {
          delivery.accept();
        } else if (operation === _serviceBusMessage.DispositionType.abandon) {
          const params = {
            undeliverable_here: false
          };
          if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;
          delivery.modified(params);
        } else if (operation === _serviceBusMessage.DispositionType.defer) {
          const params = {
            undeliverable_here: true
          };
          if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;
          delivery.modified(params);
        } else if (operation === _serviceBusMessage.DispositionType.deadletter) {
          const error = {
            condition: _coreAmqp.Constants.deadLetterName,
            info: Object.assign(Object.assign({}, options.propertiesToModify), {
              DeadLetterReason: options.deadLetterReason,
              DeadLetterErrorDescription: options.deadLetterDescription
            })
          };
          delivery.reject(error);
        }
      });
    });
  }

}

exports.MessageReceiver = MessageReceiver;
},{"tslib":"CvJj","@azure/core-amqp":"n95d","../log":"IupI","./linkEntity":"tkX2","../serviceBusMessage":"jl8f","../util/utils":"RXMg","./shared":"Kut1","../serviceBusError":"tdxx"}],"pEjc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReceiverHelper = void 0;

var _tslib = require("tslib");

var _rheaPromise = require("rhea-promise");

var _log = require("../log");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Wraps the receiver with some higher level operations for managing state
 * like credits, draining, etc...
 *
 * @internal
 * @hidden
 */
class ReceiverHelper {
  constructor(_getCurrentReceiver) {
    this._getCurrentReceiver = _getCurrentReceiver;
    this._isSuspended = false;
  }
  /**
   * Adds credits to the receiver, respecting any state that
   * indicates the receiver is closed or should not continue
   * to receive more messages.
   *
   * @param credits Number of credits to add.
   * @returns true if credits were added, false if there is no current receiver instance
   * or `stopReceivingMessages` has been called.
   */


  addCredit(credits) {
    const {
      receiver,
      logPrefix
    } = this._getCurrentReceiver();

    if (!this.canReceiveMessages()) {
      _log.receiverLogger.verbose(`${logPrefix} Asked to add ${credits} credits but the receiver is not able to receive messages`);

      return false;
    }

    if (receiver != null) {
      _log.receiverLogger.verbose(`${logPrefix} Adding ${credits} credits`);

      receiver.addCredit(credits);
    }

    return true;
  }
  /**
   * Drains the credits for the receiver and prevents the `receiverHelper.addCredit()` method from adding credits.
   * Call `resume()` to enable the `addCredit()` method.
   */


  suspend() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        receiver,
        logPrefix
      } = this._getCurrentReceiver();

      this._isSuspended = true;

      if (!this._isValidReceiver(receiver)) {
        return;
      }

      _log.receiverLogger.verbose(`${logPrefix} User has requested to stop receiving new messages, attempting to drain.`);

      return this.drain();
    });
  }
  /**
   * Resets tracking so `addCredit` works again.
   */


  resume() {
    this._isSuspended = false;
  }
  /**
   * Whether the receiver can receive messages.
   *
   * This checks if the the caller has decided to disable adding
   * credits via 'suspend' as well as whether the receiver itself is
   * still open.
   */


  canReceiveMessages() {
    const {
      receiver
    } = this._getCurrentReceiver();

    return !this._isSuspended && this._isValidReceiver(receiver);
  }
  /**
   * Initiates a drain for the current receiver and resolves when
   * the drain has completed.
   */


  drain() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const {
        receiver,
        logPrefix
      } = this._getCurrentReceiver();

      if (!this._isValidReceiver(receiver)) {
        return;
      }

      _log.receiverLogger.verbose(`${logPrefix} Receiver is starting drain. Remaining credits; ${receiver.credit}`);

      const drainPromise = new Promise(resolve => {
        receiver.once(_rheaPromise.ReceiverEvents.receiverDrained, () => {
          _log.receiverLogger.verbose(`${logPrefix} Receiver has been drained.`);

          receiver.drain = false;
          resolve();
        });
        receiver.drain = true; // this is not actually adding another credit - it'll just
        // cause the drain call to start.

        receiver.addCredit(1);
      });
      return drainPromise;
    });
  }

  _isValidReceiver(receiver) {
    return receiver != null && receiver.isOpen();
  }

}

exports.ReceiverHelper = ReceiverHelper;
},{"tslib":"CvJj","rhea-promise":"fxSK","../log":"IupI"}],"i7Sv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertValidMessageHandlers = assertValidMessageHandlers;
exports.getMessageIterator = getMessageIterator;
exports.wrapProcessErrorHandler = wrapProcessErrorHandler;
exports.completeMessage = completeMessage;
exports.abandonMessage = abandonMessage;
exports.deferMessage = deferMessage;
exports.deadLetterMessage = deadLetterMessage;

var _tslib = require("tslib");

var _log = require("../log");

var _serviceBusError = require("../serviceBusError");

var _serviceBusMessage = require("../serviceBusMessage");

var _coreAmqp = require("@azure/core-amqp");

var _errors = require("../util/errors");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 */
function assertValidMessageHandlers(handlers) {
  if (handlers && handlers.processMessage instanceof Function && handlers.processError instanceof Function) {
    return;
  }

  throw new TypeError('Invalid "MessageHandlers" provided.');
}
/**
 * @internal
 * @hidden
 */


function getMessageIterator(receiver, options) {
  return (0, _tslib.__asyncGenerator)(this, arguments, function* getMessageIterator_1() {
    while (true) {
      const messages = yield (0, _tslib.__await)(receiver.receiveMessages(1, options));

      if (messages.length === 0) {
        continue;
      }

      yield yield (0, _tslib.__await)(messages[0]);
    }
  });
}
/**
 * @internal
 * @hidden
 */


function wrapProcessErrorHandler(handlers, logger = _log.receiverLogger) {
  return args => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
    try {
      args.error = (0, _serviceBusError.translateServiceBusError)(args.error);
      yield handlers.processError(args);
    } catch (err) {
      logger.logError(err, `An error was thrown from the user's processError handler`);
    }
  });
}
/**
 * @internal
 * @hidden
 *
 * @param {ServiceBusMessageImpl} message
 * @param {ConnectionContext} context
 * @param {string} entityPath
 */


function completeMessage(message, context, entityPath) {
  _log.receiverLogger.verbose("[%s] Completing the message with id '%s'.", context.connectionId, message.messageId);

  return settleMessage(message, _serviceBusMessage.DispositionType.complete, context, entityPath);
}
/**
 * @internal
 * @hidden
 *
 * @param {ServiceBusMessageImpl} message
 * @param {ConnectionContext} context
 * @param {string} entityPath
 * @param {{ [key: string]: any }} [propertiesToModify]
 */


function abandonMessage(message, context, entityPath, propertiesToModify) {
  _log.receiverLogger.verbose("[%s] Abandoning the message with id '%s'.", context.connectionId, message.messageId);

  return settleMessage(message, _serviceBusMessage.DispositionType.abandon, context, entityPath, {
    propertiesToModify
  });
}
/**
 * @internal
 * @hidden
 *
 * @param {ServiceBusMessageImpl} message
 * @param {ConnectionContext} context
 * @param {string} entityPath
 * @param {{ [key: string]: any }} [propertiesToModify]
 */


function deferMessage(message, context, entityPath, propertiesToModify) {
  _log.receiverLogger.verbose("[%s] Deferring the message with id '%s'.", context.connectionId, message.messageId);

  return settleMessage(message, _serviceBusMessage.DispositionType.defer, context, entityPath, {
    propertiesToModify
  });
}
/**
 * @internal
 * @hidden
 *
 * @param {ServiceBusMessageImpl} message
 * @param {ConnectionContext} context
 * @param {string} entityPath
 * @param {(DeadLetterOptions & { [key: string]: any })} [propertiesToModify]
 */


function deadLetterMessage(message, context, entityPath, propertiesToModify) {
  _log.receiverLogger.verbose("[%s] Deadlettering the message with id '%s'.", context.connectionId, message.messageId);

  const actualPropertiesToModify = Object.assign({}, propertiesToModify); // these two fields are handled specially and don't need to be in here.

  delete actualPropertiesToModify.deadLetterErrorDescription;
  delete actualPropertiesToModify.deadLetterReason;
  const dispositionStatusOptions = {
    propertiesToModify: actualPropertiesToModify,
    deadLetterReason: propertiesToModify === null || propertiesToModify === void 0 ? void 0 : propertiesToModify.deadLetterReason,
    deadLetterDescription: propertiesToModify === null || propertiesToModify === void 0 ? void 0 : propertiesToModify.deadLetterErrorDescription
  };
  return settleMessage(message, _serviceBusMessage.DispositionType.deadletter, context, entityPath, dispositionStatusOptions);
}
/**
 * @internal
 * @hidden
 *
 * @param {ServiceBusMessageImpl} message
 * @param {DispositionType} operation
 * @param {ConnectionContext} context
 * @param {string} entityPath
 * @param {DispositionStatusOptions} [options]
 */


function settleMessage(message, operation, context, entityPath, options) {
  const isDeferredMessage = !message.delivery.link;
  const receiver = isDeferredMessage ? undefined : context.getReceiverFromCache(message.delivery.link.name, message.sessionId);
  const associatedLinkName = receiver === null || receiver === void 0 ? void 0 : receiver.name;
  let error;

  if (message.delivery.remote_settled) {
    error = new Error(_errors.MessageAlreadySettled);
  } else if (!isDeferredMessage && (!receiver || !receiver.isOpen()) && message.sessionId != undefined) {
    error = (0, _serviceBusError.translateServiceBusError)({
      description: `Failed to ${operation} the message as the AMQP link with which the message was ` + `received is no longer alive.`,
      condition: _coreAmqp.ErrorNameConditionMapper.SessionLockLostError
    });
  }

  if (error) {
    _log.receiverLogger.logError(error, "[%s] An error occurred when settling a message with id '%s'", context.connectionId, message.messageId);

    throw error;
  } // Message Settlement with managementLink
  // 1. If the received message is deferred as such messages can only be settled using managementLink
  // 2. If the associated receiver link is not available. This does not apply to messages from sessions as we need a lock on the session to do so.


  if (isDeferredMessage || (!receiver || !receiver.isOpen()) && message.sessionId == undefined) {
    return context.getManagementClient(entityPath).updateDispositionStatus(message.lockToken, operation, Object.assign(Object.assign({}, options), {
      associatedLinkName,
      sessionId: message.sessionId
    })).catch(err => {
      throw (0, _serviceBusError.translateServiceBusError)(err);
    });
  }

  return receiver.settleMessage(message, operation, options).catch(err => {
    throw (0, _serviceBusError.translateServiceBusError)(err);
  });
}
},{"tslib":"CvJj","../log":"IupI","../serviceBusError":"tdxx","../serviceBusMessage":"jl8f","@azure/core-amqp":"n95d","../util/errors":"TKJx"}],"eF7j":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StreamingReceiver = void 0;

var _tslib = require("tslib");

var _messageReceiver = require("./messageReceiver");

var _receiverHelper = require("./receiverHelper");

var _errors = require("../util/errors");

var _coreAmqp = require("@azure/core-amqp");

var _log = require("../log");

var _serviceBusMessage = require("../serviceBusMessage");

var _serviceBusError = require("../serviceBusError");

var _shared = require("../receivers/shared");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * Describes the streaming receiver where the user can receive the message
 * by providing handler functions.
 * @class StreamingReceiver
 * @extends MessageReceiver
 */
class StreamingReceiver extends _messageReceiver.MessageReceiver {
  /**
   * Instantiate a new Streaming receiver for receiving messages with handlers.
   *
   * @constructor
   * @param {ClientEntityContext} context                      The client entity context.
   * @param {ReceiveOptions} [options]                         Options for how you'd like to connect.
   */
  constructor(context, entityPath, options) {
    super(context, entityPath, "streaming", options);
    /**
     * @property {number} [maxConcurrentCalls] The maximum number of messages that should be
     * processed concurrently while in streaming mode. Once this limit has been reached, more
     * messages will not be received until the user's message handler has completed processing current message.
     * Default: 1
     */

    this.maxConcurrentCalls = 1;
    /**
     * Indicates whether the receiver is already actively
     * running `onDetached`.
     * This is expected to be true while the receiver attempts
     * to bring its link back up due to a retryable issue.
     */

    this._isDetaching = false;

    if (typeof (options === null || options === void 0 ? void 0 : options.maxConcurrentCalls) === "number" && (options === null || options === void 0 ? void 0 : options.maxConcurrentCalls) > 0) {
      this.maxConcurrentCalls = options.maxConcurrentCalls;
    }

    this._retryOptions = (options === null || options === void 0 ? void 0 : options.retryOptions) || {};
    this._retry = _coreAmqp.retry;
    this._receiverHelper = new _receiverHelper.ReceiverHelper(() => ({
      receiver: this.link,
      logPrefix: this.logPrefix
    }));

    this._onAmqpClose = context => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      var _a;

      const receiverError = context.receiver && context.receiver.error;
      const receiver = this.link || context.receiver;

      _log.receiverLogger.logError(receiverError, `${this.logPrefix} 'receiver_close' event occurred. The associated error is`);

      (_a = this._lockRenewer) === null || _a === void 0 ? void 0 : _a.stopAll(this);

      if (receiver && !receiver.isItselfClosed()) {
        yield this.onDetached(receiverError);
      } else {
        _log.receiverLogger.verbose("%s 'receiver_close' event occurred on the receiver '%s' with address '%s' " + "because the sdk initiated it. Hence not calling detached from the _onAmqpClose" + "() handler.", this.logPrefix, this.name, this.address);
      }
    });

    this._onSessionClose = context => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      var _b;

      const receiver = this.link || context.receiver;
      const sessionError = context.session && context.session.error;

      _log.receiverLogger.logError(sessionError, `${this.logPrefix} 'session_close' event occurred. The associated error is`);

      (_b = this._lockRenewer) === null || _b === void 0 ? void 0 : _b.stopAll(this);

      if (receiver && !receiver.isSessionItselfClosed()) {
        yield this.onDetached(sessionError);
      } else {
        _log.receiverLogger.verbose("%s 'session_close' event occurred on the session of receiver '%s' with address " + "'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose" + "() handler.", this.logPrefix, this.name, this.address);
      }
    });

    this._onAmqpError = context => {
      const receiverError = context.receiver && context.receiver.error;

      if (receiverError) {
        const sbError = (0, _serviceBusError.translateServiceBusError)(receiverError);

        _log.receiverLogger.logError(sbError, `${this.logPrefix} 'receiver_error' event occurred. The associated error is`);
      }
    };

    this._onSessionError = context => {
      const sessionError = context.session && context.session.error;

      if (sessionError) {
        const sbError = (0, _serviceBusError.translateServiceBusError)(sessionError);

        _log.receiverLogger.logError(sbError, `${this.logPrefix} 'session_error' event occurred. The associated error is`);
      }
    };

    this._onAmqpMessage = context => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      var _c, _d; // If the receiver got closed in PeekLock mode, avoid processing the message as we
      // cannot settle the message.


      if (this.receiveMode === "peekLock" && (!this.link || !this.link.isOpen())) {
        _log.receiverLogger.verbose("%s Not calling the user's message handler for the current message " + "as the receiver is closed", this.logPrefix);

        return;
      }

      const bMessage = new _serviceBusMessage.ServiceBusMessageImpl(context.message, context.delivery, true, this.receiveMode);
      (_c = this._lockRenewer) === null || _c === void 0 ? void 0 : _c.start(this, bMessage, err => {
        if (this._onError) {
          this._onError({
            error: err,
            errorSource: "renewLock",
            entityPath: this.entityPath,
            fullyQualifiedNamespace: this._context.config.host
          });
        }
      });

      try {
        yield this._onMessage(bMessage);
      } catch (err) {
        _log.receiverLogger.logError(err, "%s An error occurred while running user's message handler for the message " + "with id '%s' on the receiver '%s'", this.logPrefix, bMessage.messageId, this.name);

        this._onError({
          error: err,
          errorSource: "processMessageCallback",
          entityPath: this.entityPath,
          fullyQualifiedNamespace: this._context.config.host
        }); // Do not want renewLock to happen unnecessarily, while abandoning the message. Hence,
        // doing this here. Otherwise, this should be done in finally.


        (_d = this._lockRenewer) === null || _d === void 0 ? void 0 : _d.stop(this, bMessage);
        const error = (0, _serviceBusError.translateServiceBusError)(err); // Nothing much to do if user's message handler throws. Let us try abandoning the message.

        if (!bMessage.delivery.remote_settled && error.code !== _coreAmqp.ConditionErrorNameMapper["com.microsoft:message-lock-lost"] && this.receiveMode === "peekLock" && this.isOpen() // only try to abandon the messages if the connection is still open
        ) {
            try {
              _log.receiverLogger.logError(error, "%s Abandoning the message with id '%s' on the receiver '%s' since " + "an error occured: %O.", this.logPrefix, bMessage.messageId, this.name, error);

              yield (0, _shared.abandonMessage)(bMessage, this._context, entityPath);
            } catch (abandonError) {
              const translatedError = (0, _serviceBusError.translateServiceBusError)(abandonError);

              _log.receiverLogger.logError(translatedError, "%s An error occurred while abandoning the message with id '%s' on the " + "receiver '%s'", this.logPrefix, bMessage.messageId, this.name);

              this._onError({
                error: translatedError,
                errorSource: "abandon",
                entityPath: this.entityPath,
                fullyQualifiedNamespace: this._context.config.host
              });
            }
          }

        return;
      } finally {
        this._receiverHelper.addCredit(1);
      } // If we've made it this far, then user's message handler completed fine. Let us try
      // completing the message.


      if (this.autoComplete && this.receiveMode === "peekLock" && !bMessage.delivery.remote_settled) {
        try {
          _log.receiverLogger.verbose("%s Auto completing the message with id '%s' on " + "the receiver.", this.logPrefix, bMessage.messageId);

          yield (0, _shared.completeMessage)(bMessage, this._context, entityPath);
        } catch (completeError) {
          const translatedError = (0, _serviceBusError.translateServiceBusError)(completeError);

          _log.receiverLogger.logError(translatedError, "%s An error occurred while completing the message with id '%s' on the " + "receiver '%s'", this.logPrefix, bMessage.messageId, this.name);

          this._onError({
            error: translatedError,
            errorSource: "complete",
            entityPath: this.entityPath,
            fullyQualifiedNamespace: this._context.config.host
          });
        }
      }
    });
  }
  /**
   * Whether we are currently registered for receiving messages.
   */


  get isReceivingMessages() {
    // for the streaming receiver so long as we can receive messages then we
    // _are_ receiving messages - there's no in-between state like there is
    // with BatchingReceiver.
    return this._receiverHelper.canReceiveMessages();
  }

  _getHandlers() {
    return {
      onMessage: context => this._onAmqpMessage(context).catch(() => {
        /* */
      }),
      onClose: context => this._onAmqpClose(context).catch(() => {
        /* */
      }),
      onSessionClose: context => this._onSessionClose(context).catch(() => {
        /* */
      }),
      onError: this._onAmqpError,
      onSessionError: this._onSessionError
    };
  }

  stopReceivingMessages() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      yield this._receiverHelper.suspend();
    });
  }
  /**
   * Initializes the link. This method will retry infinitely until a connection is established.
   *
   * The retries are broken up into cycles. For each cycle we do a set of retries, using the user's
   * configured retryOptions. If that retry call fails we will report the error and then go into a
   * new cycle, repeating the retries the same as before.
   *
   * It is completely up to the user to break out of this retry cycle in their error handler by either:
   * 1. closing the receiver
   * 2. Calling `close` on the subscription instance they received when they initially called subscribe().
   * 3. aborting the abortSignal they passed in when calling subscribe (this does not apply in onDetached, however)
   */


  init(args) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      let numRetryCycles = 0;

      while (true) {
        ++numRetryCycles;
        const config = {
          operation: () => this._initOnce(args),
          connectionId: args.connectionId,
          operationType: _coreAmqp.RetryOperationType.receiverLink,
          // even though we're going to loop infinitely we allow them to control the pattern we use on each
          // retry run. This lets them toggle things like exponential retries, etc..
          retryOptions: this._retryOptions,
          abortSignal: args.abortSignal
        };

        try {
          yield this._retry(config);
          break;
        } catch (err) {
          // we only report the error here - this avoids spamming the user with too many
          // redundant reports of errors while still providing them incremental status on failures.
          args.onError({
            errorSource: "receive",
            entityPath: this.entityPath,
            fullyQualifiedNamespace: this._context.config.host,
            error: err
          }); // if the user aborts the operation we're immediately done.

          if (err.name === "AbortError") {
            throw err;
          }

          _log.receiverLogger.logError(err, `${this.logPrefix} Error thrown in retry cycle ${numRetryCycles}, restarting retry cycle with retry options`, this._retryOptions);

          continue;
        }
      }
    });
  }

  _initOnce(args) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const options = this._createReceiverOptions(args.useNewName, this._getHandlers());

      yield this._init(options, args.abortSignal); // this might seem odd but in reality this entire class is like one big function call that
      // results in a receive(). Once we're being initialized we should consider ourselves the
      // "owner" of the receiver and that it's now being locked into being the actual receiver.

      this._receiverHelper.resume();
    });
  }
  /**
   * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session.
   *
   * @param {OnMessage} onMessage The message handler to receive servicebus messages.
   * @param {OnError} onError The error handler to receive an error that occurs while receivin messages.
   */


  subscribe(onMessage, onError) {
    (0, _errors.throwErrorIfConnectionClosed)(this._context);
    this._onMessage = onMessage;
    this._onError = onError;

    this._receiverHelper.addCredit(this.maxConcurrentCalls);
  }
  /**
   * Will reconnect the receiver link if necessary.
   * @param receiverError The receiver error or connection error, if any.
   * @returns {Promise<void>} Promise<void>.
   */


  onDetached(receiverError) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      _log.receiverLogger.verbose(`${this.logPrefix} onDetached: reinitializing link.`); // User explicitly called `close` on the receiver, so link is already closed
      // and we can exit early.


      if (this.wasClosedPermanently) {
        _log.receiverLogger.verbose(`${this.logPrefix} onDetached: link has been closed permanently, not reinitializing. `);

        return;
      } // Prevent multiple onDetached invocations from running concurrently.


      if (this._isDetaching) {
        // This can happen when the network connection goes down for some amount of time.
        // The first connection `disconnect` will trigger `onDetached` and attempt to retry
        // creating the connection/receiver link.
        // While those retry attempts fail (until the network connection comes back up),
        // we'll continue to see connection `disconnect` errors.
        // These should be ignored until the already running `onDetached` completes
        // its retry attempts or errors.
        _log.receiverLogger.verbose(`${this.logPrefix} onDetached: Call to detached on streaming receiver '${this.name}' is already in progress.`);

        return;
      }

      this._isDetaching = true;
      const translatedError = receiverError ? (0, _serviceBusError.translateServiceBusError)(receiverError) : receiverError;

      _log.receiverLogger.logError(translatedError, `${this.logPrefix} onDetached: Reinitializing receiver because of error`);

      try {
        // Clears the token renewal timer. Closes the link and its session if they are open.
        // Removes the link and its session if they are present in rhea's cache.
        yield this.closeLink();
      } catch (err) {
        _log.receiverLogger.verbose(`${this.logPrefix} onDetached: Encountered an error when closing the previous link: `, err);
      }

      try {
        yield this.init({
          // provide a new name to the link while re-connecting it. This ensures that
          // the service does not send an error stating that the link is still open.
          useNewName: true,
          connectionId: this._context.connectionId,
          onError: args => this._onError && this._onError(args)
        });

        this._receiverHelper.addCredit(this.maxConcurrentCalls);

        _log.receiverLogger.verbose(`${this.logPrefix} onDetached: link has been reestablished, added ${this.maxConcurrentCalls} credits.`);
      } finally {
        this._isDetaching = false;
      }
    });
  }

}

exports.StreamingReceiver = StreamingReceiver;
},{"tslib":"CvJj","./messageReceiver":"zec7","./receiverHelper":"pEjc","../util/errors":"TKJx","@azure/core-amqp":"n95d","../log":"IupI","../serviceBusMessage":"jl8f","../serviceBusError":"tdxx","../receivers/shared":"i7Sv"}],"Q82k":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.instrumentServiceBusMessage = instrumentServiceBusMessage;
exports.extractSpanContextFromServiceBusMessage = extractSpanContextFromServiceBusMessage;
exports.createProcessingSpan = createProcessingSpan;
exports.createAndEndProcessingSpan = createAndEndProcessingSpan;
exports.TRACEPARENT_PROPERTY = void 0;

var _coreTracing = require("@azure/core-tracing");

var _api = require("@opentelemetry/api");

var _modelsToBeSharedWithEventHubs = require("../modelsToBeSharedWithEventHubs");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @hidden
 */
const TRACEPARENT_PROPERTY = "Diagnostic-Id";
/**
 * Populates the `ServiceBusMessage` with `SpanContext` info to support trace propagation.
 * Creates and returns a copy of the passed in `ServiceBusMessage` unless the `ServiceBusMessage`
 * has already been instrumented.
 * @param message The `ServiceBusMessage` to instrument.
 * @param span The `Span` containing the context to propagate tracing information.
 * @hidden
 * @internal
 */

exports.TRACEPARENT_PROPERTY = TRACEPARENT_PROPERTY;

function instrumentServiceBusMessage(message, span) {
  if (message.applicationProperties && message.applicationProperties[TRACEPARENT_PROPERTY]) {
    return message;
  } // create a copy so the original isn't modified


  message = Object.assign(Object.assign({}, message), {
    applicationProperties: Object.assign({}, message.applicationProperties)
  });
  const traceParent = (0, _coreTracing.getTraceParentHeader)(span.context());

  if (traceParent) {
    message.applicationProperties[TRACEPARENT_PROPERTY] = traceParent;
  }

  return message;
}
/**
 * Extracts the `SpanContext` from an `ServiceBusMessage` if the context exists.
 * @param message An individual `ServiceBusMessage` object.
 * @internal
 * @hidden
 */


function extractSpanContextFromServiceBusMessage(message) {
  if (!message.applicationProperties || !message.applicationProperties[TRACEPARENT_PROPERTY]) {
    return;
  }

  const diagnosticId = message.applicationProperties[TRACEPARENT_PROPERTY];
  return (0, _coreTracing.extractSpanContextFromTraceParentHeader)(diagnosticId);
}
/**
 * Provides an iterable over messages, whether it is a single message or multiple
 * messages.
 *
 * @param receivedMessages A single message or a set of messages
 * @internal
 * @hidden
 */


function* getReceivedMessages(receivedMessages) {
  if (!Array.isArray(receivedMessages)) {
    yield receivedMessages;
  } else {
    for (const message of receivedMessages) {
      yield message;
    }
  }
}
/**
 * A span that encompasses the period when the message has been received and
 * is being processed.
 *
 * NOTE: The amount of time the user would be considered processing the message is
 * not always clear - in that case the span will have a very short lifetime
 * since we'll start the span when we receive the message and end it when we
 * give the message to the user.
 *
 * @internal
 * @hidden
 */


function createProcessingSpan(receivedMessages, // NOTE: the connectionConfig also has an entityPath property but that only
// represents the optional entityPath in their connection string which is NOT
// what we want for tracing.
receiver, connectionConfig, options) {
  var _a;

  const links = [];

  for (const receivedMessage of getReceivedMessages(receivedMessages)) {
    const spanContext = extractSpanContextFromServiceBusMessage(receivedMessage);

    if (spanContext == null) {
      continue;
    }

    links.push({
      context: spanContext,
      attributes: {
        enqueuedTime: (_a = receivedMessage.enqueuedTimeUtc) === null || _a === void 0 ? void 0 : _a.getTime()
      }
    });
  }

  const span = (0, _coreTracing.getTracer)().startSpan("Azure.ServiceBus.process", {
    kind: _api.SpanKind.CONSUMER,
    links,
    parent: (0, _modelsToBeSharedWithEventHubs.getParentSpan)(options === null || options === void 0 ? void 0 : options.tracingOptions)
  });
  span.setAttributes({
    "az.namespace": "Microsoft.ServiceBus",
    "message_bus.destination": receiver.entityPath,
    "peer.address": connectionConfig.host
  });
  return span;
}
/**
 * Creates and immediately ends a processing span. Used when
 * the 'processing' occurs outside of our control so we don't
 * know the scope.
 *
 * @internal
 * @hidden
 */


function createAndEndProcessingSpan(receivedMessages, receiver, connectionConfig, options) {
  const span = createProcessingSpan(receivedMessages, receiver, connectionConfig, options);
  span.setStatus({
    code: _api.CanonicalCode.OK
  });
  span.end();
}
},{"@azure/core-tracing":"xbTt","@opentelemetry/api":"fNAU","../modelsToBeSharedWithEventHubs":"xWS9"}],"LTH6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRemainingWaitTimeInMsFn = getRemainingWaitTimeInMsFn;
exports.BatchingReceiverLite = exports.BatchingReceiver = void 0;

var _tslib = require("tslib");

var _log = require("../log");

var _rheaPromise = require("rhea-promise");

var _serviceBusMessage = require("../serviceBusMessage");

var _messageReceiver = require("./messageReceiver");

var _errors = require("../util/errors");

var _utils = require("../util/utils");

var _instrumentServiceBusMessage = require("../diagnostics/instrumentServiceBusMessage");

var _serviceBusError = require("../serviceBusError");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Describes the batching receiver where the user can receive a specified number of messages for
 * a predefined time.
 * @internal
 * @hidden
 * @class BatchingReceiver
 * @extends MessageReceiver
 */
class BatchingReceiver extends _messageReceiver.MessageReceiver {
  /**
   * Instantiate a new BatchingReceiver.
   *
   * @constructor
   * @param {ClientEntityContext} context The client entity context.
   * @param {ReceiveOptions} [options]  Options for how you'd like to connect.
   */
  constructor(context, entityPath, options) {
    super(context, entityPath, "batching", options);
    this._batchingReceiverLite = new BatchingReceiverLite(context, entityPath, abortSignal => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      let lastError;

      const rcvrOptions = this._createReceiverOptions(false, {
        onError: context => {
          var _a;

          lastError = (_a = context === null || context === void 0 ? void 0 : context.receiver) === null || _a === void 0 ? void 0 : _a.error;
        },
        onSessionError: context => {
          var _a;

          lastError = (_a = context === null || context === void 0 ? void 0 : context.session) === null || _a === void 0 ? void 0 : _a.error;
        },
        // ignored for now - the next call will just fail so they'll get an appropriate error from somewhere else.
        onClose: () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {}),
        onSessionClose: () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {}),
        // we don't add credits initially so we don't need to worry about handling any messages.
        onMessage: () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {})
      });

      yield this._init(rcvrOptions, abortSignal);

      if (lastError != null) {
        throw lastError;
      }

      return this.link;
    }), this.receiveMode);
  }

  get isReceivingMessages() {
    return this._batchingReceiverLite.isReceivingMessages;
  }
  /**
   * To be called when connection is disconnected to gracefully close ongoing receive request.
   * @param {AmqpError | Error} [connectionError] The connection error if any.
   * @returns {Promise<void>} Promise<void>.
   */


  onDetached(connectionError) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      yield this.closeLink();

      if (connectionError == null) {
        connectionError = new Error("Unknown error occurred on the AMQP connection while receiving messages.");
      }

      this._batchingReceiverLite.close(connectionError);
    });
  }
  /**
   * Receives a batch of messages from a ServiceBus Queue/Topic.
   * @param maxMessageCount The maximum number of messages to receive.
   * In Peeklock mode, this number is capped at 2047 due to constraints of the underlying buffer.
   * @param maxWaitTimeInMs The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.
   * @param maxTimeAfterFirstMessageInMs The total amount of time to wait after the first message
   * has been received. Defaults to 1 second.
   * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
   * @returns {Promise<ServiceBusMessageImpl[]>} A promise that resolves with an array of Message objects.
   */


  receive(maxMessageCount, maxWaitTimeInMs, maxTimeAfterFirstMessageInMs, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);

      try {
        _log.receiverLogger.verbose("[%s] Receiver '%s', setting max concurrent calls to 0.", this.logPrefix, this.name);

        const messages = yield this._batchingReceiverLite.receiveMessages(Object.assign({
          maxMessageCount,
          maxWaitTimeInMs,
          maxTimeAfterFirstMessageInMs
        }, options));

        if (this._lockRenewer) {
          for (const message of messages) {
            this._lockRenewer.start(this, message, _error => {// the auto lock renewer already logs this in a detailed way. So this hook is mainly here
              // to potentially forward the error to the user (which we're not doing yet)
            });
          }
        }

        return messages;
      } catch (error) {
        _log.receiverLogger.logError(error, "[%s] Rejecting receiveMessages()", this.logPrefix);

        throw error;
      }
    });
  }

  static create(context, entityPath, options) {
    (0, _errors.throwErrorIfConnectionClosed)(context);
    const bReceiver = new BatchingReceiver(context, entityPath, options);
    context.messageReceivers[bReceiver.name] = bReceiver;
    return bReceiver;
  }

}
/**
 * Gets a function that returns the smaller of the two timeouts,
 * taking into account elapsed time from when getRemainingWaitTimeInMsFn
 * was called.
 *
 * @param maxWaitTimeInMs Maximum time to wait for the first message
 * @param maxTimeAfterFirstMessageInMs Maximum time to wait after the first message before completing the receive.
 *
 * @internal
 * @hidden
 */


exports.BatchingReceiver = BatchingReceiver;

function getRemainingWaitTimeInMsFn(maxWaitTimeInMs, maxTimeAfterFirstMessageInMs) {
  const startTimeMs = Date.now();
  return () => {
    const remainingTimeMs = maxWaitTimeInMs - (Date.now() - startTimeMs);

    if (remainingTimeMs < 0) {
      return 0;
    }

    return Math.min(remainingTimeMs, maxTimeAfterFirstMessageInMs);
  };
}
/**
 * The internals of a batching receiver minus anything that would require us to hold onto a client entity context
 * or a receiver on a permanent basis.
 *
 * Usable with both session and non-session receivers.
 *
 * @internal
 * @hidden
 */


class BatchingReceiverLite {
  constructor(_connectionContext, entityPath, _getCurrentReceiver, _receiveMode) {
    this._connectionContext = _connectionContext;
    this.entityPath = entityPath;
    this._getCurrentReceiver = _getCurrentReceiver;
    this._receiveMode = _receiveMode;
    this._createAndEndProcessingSpan = _instrumentServiceBusMessage.createAndEndProcessingSpan;

    this._createServiceBusMessage = context => {
      return new _serviceBusMessage.ServiceBusMessageImpl(context.message, context.delivery, true, this._receiveMode);
    };

    this._getRemainingWaitTimeInMsFn = (maxWaitTimeInMs, maxTimeAfterFirstMessageInMs) => getRemainingWaitTimeInMsFn(maxWaitTimeInMs, maxTimeAfterFirstMessageInMs);

    this.isReceivingMessages = false;
  }
  /**
   * Receives a set of messages,
   *
   * @internal
   * @hidden
   */


  receiveMessages(args) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      try {
        this.isReceivingMessages = true;
        const receiver = yield this._getCurrentReceiver(args.abortSignal);

        if (receiver == null) {
          // (was somehow closed in between the init() and the return)
          return [];
        }

        const messages = yield new Promise((resolve, reject) => this._receiveMessagesImpl(receiver, args, resolve, reject));

        this._createAndEndProcessingSpan(messages, this, this._connectionContext.config, args);

        return messages;
      } finally {
        this._closeHandler = undefined;
        this.isReceivingMessages = false;
      }
    });
  }
  /**
   * Closes the receiver (optionally with an error), cancelling any current operations.
   *
   * @param connectionError An optional error (rhea doesn't always deliver one for certain disconnection events)
   */


  close(connectionError) {
    if (this._closeHandler) {
      this._closeHandler(connectionError);

      this._closeHandler = undefined;
    }
  }

  _receiveMessagesImpl(receiver, args, origResolve, origReject) {
    const getRemainingWaitTimeInMs = this._getRemainingWaitTimeInMsFn(args.maxWaitTimeInMs, args.maxTimeAfterFirstMessageInMs);

    const brokeredMessages = [];
    const loggingPrefix = `[${receiver.connection.id}|r:${receiver.name}]`;
    let totalWaitTimer; // eslint-disable-next-line prefer-const

    let cleanupBeforeResolveOrReject;

    const reject = err => {
      cleanupBeforeResolveOrReject();
      origReject(err);
    };

    const resolveImmediately = result => {
      cleanupBeforeResolveOrReject();
      origResolve(result);
    };

    const resolveAfterPendingMessageCallbacks = result => {
      // NOTE: through rhea-promise, most of our event handlers are made asynchronous by calling setTimeout(emit).
      // However, a small set (*error and drain) execute immediately. This can lead to a situation where the logical
      // ordering of events is correct but the execution order is incorrect because the events are not all getting
      // put into the task queue the same way.
      // setTimeout() ensures that we resolve _after_ any already-queued onMessage handlers that may
      // be waiting in the task queue.
      setTimeout(() => {
        cleanupBeforeResolveOrReject();
        origResolve(result);
      });
    };

    const onError = context => {
      var _a, _b, _c;

      const eventType = ((_a = context.session) === null || _a === void 0 ? void 0 : _a.error) != null ? "session_error" : "receiver_error";
      let error = ((_b = context.session) === null || _b === void 0 ? void 0 : _b.error) || ((_c = context.receiver) === null || _c === void 0 ? void 0 : _c.error);

      if (error) {
        error = (0, _serviceBusError.translateServiceBusError)(error);

        _log.receiverLogger.logError(error, `${loggingPrefix} '${eventType}' event occurred. Received an error`);
      } else {
        error = new _serviceBusError.ServiceBusError("An error occurred while receiving messages.", "GeneralError");
      }

      reject(error);
    };

    this._closeHandler = error => {
      if ( // no error, just closing. Go ahead and return what we have.
      error == null || // Return the collected messages if in ReceiveAndDelete mode because otherwise they are lost forever
      this._receiveMode === "receiveAndDelete" && brokeredMessages.length) {
        _log.receiverLogger.verbose(`${loggingPrefix} Closing. Resolving with ${brokeredMessages.length} messages.`);

        return resolveAfterPendingMessageCallbacks(brokeredMessages);
      }

      reject((0, _serviceBusError.translateServiceBusError)(error));
    };

    let abortSignalCleanupFunction = undefined; // Final action to be performed after
    // - maxMessageCount is reached or
    // - maxWaitTime is passed or
    // - newMessageWaitTimeoutInSeconds is passed since the last message was received

    const finalAction = () => {
      // Drain any pending credits.
      if (receiver.isOpen() && receiver.credit > 0) {
        _log.receiverLogger.verbose(`${loggingPrefix} Draining leftover credits(${receiver.credit}).`); // setting .drain and combining it with .addCredit results in (eventually) sending
        // a drain request to Service Bus. When the drain completes rhea will call `onReceiveDrain`
        // at which point we'll wrap everything up and resolve the promise.


        receiver.drain = true;
        receiver.addCredit(1);
      } else {
        _log.receiverLogger.verbose(`${loggingPrefix} Resolving receiveMessages() with ${brokeredMessages.length} messages.`); // we can resolve immediately (ie, no setTimeout call) because we have no
        // remaining messages (thus nothing to wait for)


        resolveImmediately(brokeredMessages);
      }
    }; // Action to be performed on the "message" event.


    const onReceiveMessage = context => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      // TODO: this appears to be aggravating a bug that we need to look into more deeply.
      // The same timeout+drain sequence should work fine for receiveAndDelete but it appears
      // to cause problems.
      if (this._receiveMode === "peekLock") {
        if (brokeredMessages.length === 0) {
          // We'll now remove the old timer (which was the overall `maxWaitTimeMs` timer)
          // and replace it with another timer that is a (probably) much shorter interval.
          //
          // This allows the user to get access to received messages earlier and also gives us
          // a chance to have fewer messages internally that could get lost if the user's
          // app crashes.
          if (totalWaitTimer) clearTimeout(totalWaitTimer);
          const remainingWaitTimeInMs = getRemainingWaitTimeInMs();
          totalWaitTimer = setTimeout(() => {
            _log.receiverLogger.verbose(`${loggingPrefix} Batching, waited for ${remainingWaitTimeInMs} milliseconds after receiving the first message.`);

            finalAction();
          }, remainingWaitTimeInMs);
        }
      }

      try {
        const data = this._createServiceBusMessage(context);

        if (brokeredMessages.length < args.maxMessageCount) {
          brokeredMessages.push(data);
        }
      } catch (err) {
        const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));

        _log.receiverLogger.logError(err, `${loggingPrefix} Received an error while converting AmqpMessage to ServiceBusMessage`);

        reject(errObj);
      }

      if (brokeredMessages.length === args.maxMessageCount) {
        finalAction();
      }
    });

    const onClose = context => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      var _a, _b, _c;

      const type = ((_a = context.session) === null || _a === void 0 ? void 0 : _a.error) != null ? "session_closed" : "receiver_closed";
      const error = ((_b = context.session) === null || _b === void 0 ? void 0 : _b.error) || ((_c = context.receiver) === null || _c === void 0 ? void 0 : _c.error);

      if (error) {
        _log.receiverLogger.logError(error, `${loggingPrefix} '${type}' event occurred. The associated error`);
      }
    }); // Action to be performed on the "receiver_drained" event.


    const onReceiveDrain = () => {
      receiver.removeListener(_rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
      receiver.drain = false;

      _log.receiverLogger.verbose(`${loggingPrefix} Drained, resolving receiveMessages() with ${brokeredMessages.length} messages.`);

      resolveAfterPendingMessageCallbacks(brokeredMessages);
    };

    cleanupBeforeResolveOrReject = () => {
      if (receiver != null) {
        receiver.removeListener(_rheaPromise.ReceiverEvents.receiverError, onError);
        receiver.removeListener(_rheaPromise.ReceiverEvents.message, onReceiveMessage);
        receiver.session.removeListener(_rheaPromise.SessionEvents.sessionError, onError);
        receiver.removeListener(_rheaPromise.ReceiverEvents.receiverClose, onClose);
        receiver.session.removeListener(_rheaPromise.SessionEvents.sessionClose, onClose);
        receiver.removeListener(_rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
      }

      if (totalWaitTimer) {
        clearTimeout(totalWaitTimer);
      }

      if (abortSignalCleanupFunction) {
        abortSignalCleanupFunction();
      }

      abortSignalCleanupFunction = undefined;
    };

    abortSignalCleanupFunction = (0, _utils.checkAndRegisterWithAbortSignal)(err => {
      reject(err);
    }, args.abortSignal);

    _log.receiverLogger.verbose(`${loggingPrefix} Adding credit for receiving ${args.maxMessageCount} messages.`); // By adding credit here, we let the service know that at max we can handle `maxMessageCount`
    // number of messages concurrently. We will return the user an array of messages that can
    // be of size upto maxMessageCount. Then the user needs to accordingly dispose
    // (complete/abandon/defer/deadletter) the messages from the array.


    receiver.addCredit(args.maxMessageCount);

    _log.receiverLogger.verbose(`${loggingPrefix} Setting the wait timer for ${args.maxWaitTimeInMs} milliseconds.`);

    totalWaitTimer = setTimeout(() => {
      _log.receiverLogger.verbose(`${loggingPrefix} Batching, waited for max wait time ${args.maxWaitTimeInMs} milliseconds.`);

      finalAction();
    }, args.maxWaitTimeInMs);
    receiver.on(_rheaPromise.ReceiverEvents.message, onReceiveMessage);
    receiver.on(_rheaPromise.ReceiverEvents.receiverError, onError);
    receiver.on(_rheaPromise.ReceiverEvents.receiverClose, onClose);
    receiver.on(_rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
    receiver.session.on(_rheaPromise.SessionEvents.sessionError, onError);
    receiver.session.on(_rheaPromise.SessionEvents.sessionClose, onClose);
  }

}

exports.BatchingReceiverLite = BatchingReceiverLite;
},{"tslib":"CvJj","../log":"IupI","rhea-promise":"fxSK","../serviceBusMessage":"jl8f","./messageReceiver":"zec7","../util/errors":"TKJx","../util/utils":"RXMg","../diagnostics/instrumentServiceBusMessage":"Q82k","../serviceBusError":"tdxx"}],"zRti":[function(require,module,exports) {
"use strict";
if (typeof Symbol === undefined || !Symbol.asyncIterator) {
    Symbol.asyncIterator = Symbol.for("Symbol.asyncIterator");
}

},{}],"k3aD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LockRenewer = void 0;

var _tslib = require("tslib");

var _log = require("../log");

var _utils = require("../util/utils");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Tracks locks for messages, renewing until a configurable duration.
 *
 * @internal
 * @hidden
 */
class LockRenewer {
  constructor(_context, _maxAutoRenewDurationInMs) {
    this._context = _context;
    this._maxAutoRenewDurationInMs = _maxAutoRenewDurationInMs;
    /**
     * @property _messageRenewLockTimers A map of link names to individual maps for each
     * link that map a message ID to its auto-renewal timer.
     */

    this._messageRenewLockTimers = new Map();
    this._calculateRenewAfterDuration = _utils.calculateRenewAfterDuration;
  }
  /**
   * Creates an AutoLockRenewer.
   *
   * @param linkEntity Your link entity instance (probably 'this')
   * @param context The connection context for your link entity (probably 'this._context')
   * @param options The ReceiveOptions passed through to your message receiver.
   * @returns if the lock mode is peek lock (or if is unspecified, thus defaulting to peekLock)
   * and the options.maxAutoLockRenewalDurationInMs is > 0..Otherwise, returns undefined.
   */


  static create(context, maxAutoRenewLockDurationInMs, receiveMode) {
    if (receiveMode !== "peekLock") {
      return undefined;
    }

    if (maxAutoRenewLockDurationInMs <= 0) {
      return undefined;
    }

    return new LockRenewer(context, maxAutoRenewLockDurationInMs);
  }
  /**
   * Cancels all pending lock renewals for messages on given link and removes all entries from our internal cache.
   */


  stopAll(linkEntity) {
    _log.receiverLogger.verbose(`${linkEntity.logPrefix} Clearing message renew lock timers for all the active messages.`);

    const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);

    if (messagesForLink == null) {
      return;
    }

    for (const messageId of messagesForLink.keys()) {
      this._stopAndRemoveById(linkEntity, messagesForLink, messageId);
    }

    this._messageRenewLockTimers.delete(linkEntity.name);
  }
  /**
   * Stops lock renewal for a single message.
   *
   * @param bMessage The message whose lock renewal we will stop.
   */


  stop(linkEntity, bMessage) {
    const messageId = bMessage.messageId;

    const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);

    if (messagesForLink == null) {
      return;
    }

    this._stopAndRemoveById(linkEntity, messagesForLink, messageId);
  }
  /**
   * Starts lock renewal for a single message.
   *
   * @param bMessage The message whose lock renewal we will start.
   */


  start(linkEntity, bMessage, onError) {
    try {
      const logPrefix = linkEntity.logPrefix;

      if (bMessage.lockToken == null) {
        throw new Error(`Can't start auto lock renewal for message with message id '${bMessage.messageId}' since it does not have a lock token.`);
      }

      const lockToken = bMessage.lockToken;

      const linkMessageMap = this._getOrCreateMapForLink(linkEntity); // - We need to renew locks before they expire by looking at bMessage.lockedUntilUtc.
      // - This autorenewal needs to happen **NO MORE** than maxAutoRenewDurationInMs
      // - We should be able to clear the renewal timer when the user's message handler
      // is done (whether it succeeds or fails).
      // Setting the messageId with undefined value in the linkMessageMap because we
      // track state by checking the presence of messageId in the map. It is removed from the map
      // when an attempt is made to settle the message (either by the user or by the sdk) OR
      // when the execution of user's message handler completes.


      linkMessageMap.set(bMessage.messageId, undefined);

      _log.receiverLogger.verbose(`${logPrefix} message with id '${bMessage.messageId}' is locked until ${bMessage.lockedUntilUtc.toString()}.`);

      const totalAutoLockRenewDuration = Date.now() + this._maxAutoRenewDurationInMs;

      _log.receiverLogger.verbose(`${logPrefix} Total autolockrenew duration for message with id '${bMessage.messageId}' is: ${new Date(totalAutoLockRenewDuration).toString()}`);

      const autoRenewLockTask = () => {
        const renewalNeededToMaintainLock = // if the lock expires _after_ our max auto-renew duration there's no reason to
        // spin up an auto-renewer - it's already held for the duration.
        new Date(totalAutoLockRenewDuration) > bMessage.lockedUntilUtc; // once we've exceeded the max amount of time we'll renew we can stop.

        const haventExceededMaxLockRenewalTime = Date.now() < totalAutoLockRenewDuration;

        if (renewalNeededToMaintainLock && haventExceededMaxLockRenewalTime) {
          if (linkMessageMap.has(bMessage.messageId)) {
            // TODO: We can run into problems with clock skew between the client and the server.
            // It would be better to calculate the duration based on the "lockDuration" property
            // of the queue. However, we do not have the management plane of the client ready for
            // now. Hence we rely on the lockedUntilUtc property on the message set by ServiceBus.
            const amount = this._calculateRenewAfterDuration(bMessage.lockedUntilUtc);

            _log.receiverLogger.verbose(`${logPrefix} Sleeping for ${amount} milliseconds while renewing the lock for message with id '${bMessage.messageId}'`); // Setting the value of the messageId to the actual timer. This will be cleared when
            // an attempt is made to settle the message (either by the user or by the sdk) OR
            // when the execution of user's message handler completes.


            const autoRenewTimer = setTimeout(() => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
              try {
                _log.receiverLogger.verbose(`${logPrefix} Attempting to renew the lock for message with id '${bMessage.messageId}'.`);

                bMessage.lockedUntilUtc = yield this._context.getManagementClient(linkEntity.entityPath).renewLock(lockToken, {
                  associatedLinkName: linkEntity.name
                });

                _log.receiverLogger.verbose(`${logPrefix} Successfully renewed the lock for message with id '${bMessage.messageId}'. Starting next auto-lock-renew cycle for message.`);

                autoRenewLockTask();
              } catch (err) {
                _log.receiverLogger.logError(err, `${logPrefix} An error occurred while auto renewing the message lock '${bMessage.lockToken}' for message with id '${bMessage.messageId}'`);

                onError(err);
              }
            }), amount); // Prevent the active Timer from keeping the Node.js event loop active.

            if (typeof autoRenewTimer.unref === "function") {
              autoRenewTimer.unref();
            }

            linkMessageMap.set(bMessage.messageId, autoRenewTimer);
          } else {
            _log.receiverLogger.verbose(`${logPrefix} Looks like the message lock renew timer has already been cleared for message with id '${bMessage.messageId}'.`);
          }
        } else {
          _log.receiverLogger.verbose(`${logPrefix} Current time ${new Date()} exceeds the total autolockrenew duration ${new Date(totalAutoLockRenewDuration)} for message with messageId '${bMessage.messageId}'. Hence we will stop the autoLockRenewTask.`);

          this.stop(linkEntity, bMessage);
        }
      }; // start


      autoRenewLockTask();
    } catch (err) {
      onError(err);
    }
  }

  _getOrCreateMapForLink(linkEntity) {
    if (!this._messageRenewLockTimers.has(linkEntity.name)) {
      this._messageRenewLockTimers.set(linkEntity.name, new Map());
    }

    return this._messageRenewLockTimers.get(linkEntity.name);
  }

  _stopAndRemoveById(linkEntity, linkMessageMap, messageId) {
    if (messageId == null) {
      throw new Error("Failed to stop auto lock renewal - no message ID");
    } // TODO: messageId doesn't actually need to be unique. Perhaps we should use lockToken
    // instead?


    if (linkMessageMap.has(messageId)) {
      clearTimeout(linkMessageMap.get(messageId));

      _log.receiverLogger.verbose(`${linkEntity.logPrefix} Cleared the message renew lock timer for message with id '${messageId}'.`);

      linkMessageMap.delete(messageId);
    }
  }

}

exports.LockRenewer = LockRenewer;
},{"tslib":"CvJj","../log":"IupI","../util/utils":"RXMg"}],"T1eE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultMaxTimeAfterFirstMessageForBatchingMs = exports.ServiceBusReceiverImpl = void 0;

var _tslib = require("tslib");

var _modelsToBeSharedWithEventHubs = require("../modelsToBeSharedWithEventHubs");

var _errors = require("../util/errors");

var _streamingReceiver = require("../core/streamingReceiver");

var _batchingReceiver = require("../core/batchingReceiver");

var _shared = require("./shared");

var _coreAmqp = require("@azure/core-amqp");

require("@azure/core-asynciterator-polyfill");

var _autoLockRenewer = require("../core/autoLockRenewer");

var _instrumentServiceBusMessage = require("../diagnostics/instrumentServiceBusMessage");

var _log = require("../log");

var _serviceBusError = require("../serviceBusError");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 */
class ServiceBusReceiverImpl {
  /**
   * @throws Error if the underlying connection is closed.
   */
  constructor(_context, entityPath, receiveMode, maxAutoRenewLockDurationInMs, retryOptions = {}) {
    this._context = _context;
    this.entityPath = entityPath;
    this.receiveMode = receiveMode;
    /**
     * @property {boolean} [_isClosed] Denotes if close() was called on this receiver
     */

    this._isClosed = false;
    (0, _errors.throwErrorIfConnectionClosed)(_context);
    this._retryOptions = retryOptions;
    this._lockRenewer = _autoLockRenewer.LockRenewer.create(this._context, maxAutoRenewLockDurationInMs, receiveMode);
    this._createProcessingSpan = _instrumentServiceBusMessage.createProcessingSpan;
  }

  get logPrefix() {
    return `[${this._context.connectionId}|receiver:${this.entityPath}]`;
  }

  _throwIfAlreadyReceiving() {
    if (this._isReceivingMessages()) {
      const errorMessage = (0, _errors.getAlreadyReceivingErrorMsg)(this.entityPath);
      const error = new Error(errorMessage);

      _log.receiverLogger.logError(error, `${this.logPrefix} is already receiving`);

      throw error;
    }
  }

  _throwIfReceiverOrConnectionClosed() {
    (0, _errors.throwErrorIfConnectionClosed)(this._context);

    if (this.isClosed) {
      const errorMessage = (0, _errors.getReceiverClosedErrorMsg)(this.entityPath);
      const error = new Error(errorMessage);

      _log.receiverLogger.logError(error, `${this.logPrefix} is closed`);

      throw error;
    }
  }

  get isClosed() {
    return this._isClosed || this._context.wasConnectionCloseCalled;
  }
  /**
   * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
   * from a Queue/Subscription.
   * To stop receiving messages, call `close()` on the Receiver.
   *
   * Throws an error if there is another receive operation in progress on the same receiver. If you
   * are not sure whether there is another receive operation running, check the `isReceivingMessages`
   * property on the receiver.
   *
   * @param onMessage - Handler for processing each incoming message.
   * @param onError - Handler for any error that occurs while receiving or processing messages.
   * @param options - Options to control if messages should be automatically completed, and/or have
   * their locks automatically renewed. You can control the maximum number of messages that should
   * be concurrently processed. You can also provide a timeout in milliseconds to denote the
   * amount of time to wait for a new message before closing the receiver.
   *
   * @returns void
   * @throws Error if the underlying connection or receiver is closed.
   * @throws Error if current receiver is already in state of receiving messages.
   * @throws ServiceBusError if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.
   */


  _registerMessageHandler(onInitialize, onMessage, onError, options) {
    this._throwIfReceiverOrConnectionClosed();

    this._throwIfAlreadyReceiving();

    const connId = this._context.connectionId;
    (0, _errors.throwTypeErrorIfParameterMissing)(connId, "onMessage", onMessage);
    (0, _errors.throwTypeErrorIfParameterMissing)(connId, "onError", onError);

    if (typeof onMessage !== "function") {
      throw new TypeError("The parameter 'onMessage' must be of type 'function'.");
    }

    if (typeof onError !== "function") {
      throw new TypeError("The parameter 'onError' must be of type 'function'.");
    }

    this._createStreamingReceiver(Object.assign(Object.assign({}, options), {
      receiveMode: this.receiveMode,
      retryOptions: this._retryOptions,
      lockRenewer: this._lockRenewer,
      onError
    })).then(sReceiver => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      if (!sReceiver) {
        return;
      }

      this._streamingReceiver = sReceiver;

      try {
        yield onInitialize();
      } catch (err) {
        onError({
          error: err,
          errorSource: "receive",
          entityPath: this.entityPath,
          fullyQualifiedNamespace: this._context.config.host
        });
      }

      if (!this.isClosed) {
        sReceiver.subscribe(onMessage, onError);
      } else {
        yield sReceiver.close();
      }

      return;
    })).catch(err => {
      // TODO: being a bit broad here but the only errors that should filter out this
      // far are going to be bootstrapping the subscription.
      onError({
        error: err,
        errorSource: "receive",
        entityPath: this.entityPath,
        fullyQualifiedNamespace: this._context.config.host
      });
    });
  }

  _createStreamingReceiver(options) {
    var _a;

    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);
      if (options.autoCompleteMessages == null) options.autoCompleteMessages = true; // When the user "stops" a streaming receiver (via the returned instance from 'subscribe' we just suspend
      // it, leaving the link open). This allows users to stop the flow of messages but still be able to settle messages
      // since the link itself hasn't been shut down.
      //
      // Users can, if they want, restart their subscription (since we've got a link already established).
      // So you'll have an instance here if the user has done:
      // 1. const subscription = receiver.subscribe()
      // 2. subscription.stop()
      // 3. receiver.subscribe()

      this._streamingReceiver = (_a = this._streamingReceiver) !== null && _a !== void 0 ? _a : new _streamingReceiver.StreamingReceiver(this._context, this.entityPath, options); // this ensures that if the outer service bus client is closed that  this receiver is cleaned up.
      // this mostly affects us if we're in the middle of init() - the connection (and receiver) are not yet
      // open but we do need to close the receiver to exit the init() loop.

      this._context.messageReceivers[this._streamingReceiver.name] = this._streamingReceiver;
      yield this._streamingReceiver.init(Object.assign({
        connectionId: this._context.connectionId,
        useNewName: false
      }, options));
      return this._streamingReceiver;
    });
  }

  receiveMessages(maxMessageCount, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      this._throwIfAlreadyReceiving();

      (0, _errors.throwTypeErrorIfParameterMissing)(this._context.connectionId, "maxMessageCount", maxMessageCount);
      (0, _errors.throwTypeErrorIfParameterTypeMismatch)(this._context.connectionId, "maxMessageCount", maxMessageCount, "number");

      if (isNaN(maxMessageCount) || maxMessageCount < 1) {
        throw new TypeError(_errors.InvalidMaxMessageCountError);
      }

      const receiveMessages = () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        var _a;

        if (!this._batchingReceiver || !this._context.messageReceivers[this._batchingReceiver.name]) {
          const options = {
            maxConcurrentCalls: 0,
            receiveMode: this.receiveMode,
            lockRenewer: this._lockRenewer
          };
          this._batchingReceiver = this._createBatchingReceiver(this._context, this.entityPath, options);
        }

        const receivedMessages = yield this._batchingReceiver.receive(maxMessageCount, (_a = options === null || options === void 0 ? void 0 : options.maxWaitTimeInMs) !== null && _a !== void 0 ? _a : _coreAmqp.Constants.defaultOperationTimeoutInMs, defaultMaxTimeAfterFirstMessageForBatchingMs, options !== null && options !== void 0 ? options : {});
        return receivedMessages;
      });

      const config = {
        connectionHost: this._context.config.host,
        connectionId: this._context.connectionId,
        operation: receiveMessages,
        operationType: _coreAmqp.RetryOperationType.receiveMessage,
        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
        retryOptions: this._retryOptions
      };
      return (0, _coreAmqp.retry)(config).catch(err => {
        throw (0, _serviceBusError.translateServiceBusError)(err);
      });
    });
  }

  getMessageIterator(options) {
    return (0, _shared.getMessageIterator)(this, options);
  }

  receiveDeferredMessages(sequenceNumbers, options = {}) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      (0, _errors.throwTypeErrorIfParameterMissing)(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
      (0, _errors.throwTypeErrorIfParameterNotLong)(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
      const deferredSequenceNumbers = Array.isArray(sequenceNumbers) ? sequenceNumbers : [sequenceNumbers];

      const receiveDeferredMessagesOperationPromise = () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        const deferredMessages = yield this._context.getManagementClient(this.entityPath).receiveDeferredMessages(deferredSequenceNumbers, this.receiveMode, undefined, Object.assign(Object.assign({}, options), {
          associatedLinkName: this._getAssociatedReceiverName(),
          requestName: "receiveDeferredMessages",
          timeoutInMs: this._retryOptions.timeoutInMs
        }));
        return deferredMessages;
      });

      const config = {
        operation: receiveDeferredMessagesOperationPromise,
        connectionId: this._context.connectionId,
        operationType: _coreAmqp.RetryOperationType.management,
        retryOptions: this._retryOptions,
        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
      };
      return (0, _coreAmqp.retry)(config);
    });
  } // ManagementClient methods # Begin


  peekMessages(maxMessageCount, options = {}) {
    var _a;

    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      const managementRequestOptions = Object.assign(Object.assign({}, options), {
        associatedLinkName: this._getAssociatedReceiverName(),
        requestName: "peekMessages",
        timeoutInMs: (_a = this._retryOptions) === null || _a === void 0 ? void 0 : _a.timeoutInMs
      });

      const peekOperationPromise = () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        if (options.fromSequenceNumber) {
          return yield this._context.getManagementClient(this.entityPath).peekBySequenceNumber(options.fromSequenceNumber, maxMessageCount, undefined, managementRequestOptions);
        } else {
          return yield this._context.getManagementClient(this.entityPath).peek(maxMessageCount, managementRequestOptions);
        }
      });

      const config = {
        operation: peekOperationPromise,
        connectionId: this._context.connectionId,
        operationType: _coreAmqp.RetryOperationType.management,
        retryOptions: this._retryOptions,
        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
      };
      return (0, _coreAmqp.retry)(config);
    });
  }

  subscribe(handlers, options) {
    (0, _shared.assertValidMessageHandlers)(handlers);
    options = options !== null && options !== void 0 ? options : {};
    const processError = (0, _shared.wrapProcessErrorHandler)(handlers);
    const internalMessageHandlers = handlers;

    this._registerMessageHandler(() => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      if (internalMessageHandlers === null || internalMessageHandlers === void 0 ? void 0 : internalMessageHandlers.processInitialize) {
        yield internalMessageHandlers.processInitialize();
      }
    }), message => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const span = this._createProcessingSpan(message, this, this._context.config, options);

      return (0, _modelsToBeSharedWithEventHubs.trace)(() => handlers.processMessage(message), span);
    }), processError, options);

    return {
      close: () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        var _a;

        return (_a = this._streamingReceiver) === null || _a === void 0 ? void 0 : _a.stopReceivingMessages();
      })
    };
  }

  completeMessage(message) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      (0, _errors.throwErrorIfInvalidOperationOnMessage)(message, this.receiveMode, this._context.connectionId);
      const msgImpl = message;
      return (0, _shared.completeMessage)(msgImpl, this._context, this.entityPath);
    });
  }

  abandonMessage(message, propertiesToModify) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      (0, _errors.throwErrorIfInvalidOperationOnMessage)(message, this.receiveMode, this._context.connectionId);
      const msgImpl = message;
      return (0, _shared.abandonMessage)(msgImpl, this._context, this.entityPath, propertiesToModify);
    });
  }

  deferMessage(message, propertiesToModify) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      (0, _errors.throwErrorIfInvalidOperationOnMessage)(message, this.receiveMode, this._context.connectionId);
      const msgImpl = message;
      return (0, _shared.deferMessage)(msgImpl, this._context, this.entityPath, propertiesToModify);
    });
  }

  deadLetterMessage(message, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      (0, _errors.throwErrorIfInvalidOperationOnMessage)(message, this.receiveMode, this._context.connectionId);
      const msgImpl = message;
      return (0, _shared.deadLetterMessage)(msgImpl, this._context, this.entityPath, options);
    });
  }

  renewMessageLock(message) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      (0, _errors.throwErrorIfInvalidOperationOnMessage)(message, this.receiveMode, this._context.connectionId);
      const msgImpl = message;
      let associatedLinkName;

      if (msgImpl.delivery.link) {
        const associatedReceiver = this._context.getReceiverFromCache(msgImpl.delivery.link.name);

        associatedLinkName = associatedReceiver === null || associatedReceiver === void 0 ? void 0 : associatedReceiver.name;
      }

      return this._context.getManagementClient(this.entityPath).renewLock(message.lockToken, {
        associatedLinkName
      }).then(lockedUntil => {
        message.lockedUntilUtc = lockedUntil;
        return lockedUntil;
      });
    });
  }

  close() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      try {
        this._isClosed = true;

        if (this._context.connection && this._context.connection.isOpen()) {
          // Close the streaming receiver.
          if (this._streamingReceiver) {
            yield this._streamingReceiver.close();
          } // Close the batching receiver.


          if (this._batchingReceiver) {
            yield this._batchingReceiver.close();
          }
        }
      } catch (err) {
        _log.receiverLogger.logError(err, `${this.logPrefix} An error occurred while closing the Receiver`);

        throw err;
      }
    });
  }
  /**
   * Indicates whether the receiver is currently receiving messages or not.
   * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.
   */


  _isReceivingMessages() {
    if (this._streamingReceiver && this._streamingReceiver.isOpen() && this._streamingReceiver.isReceivingMessages) {
      return true;
    }

    if (this._batchingReceiver && this._batchingReceiver.isOpen() && this._batchingReceiver.isReceivingMessages) {
      return true;
    }

    return false;
  }

  _createBatchingReceiver(context, entityPath, options) {
    return _batchingReceiver.BatchingReceiver.create(context, entityPath, options);
  }
  /**
   * Helper function to retrieve any active receiver name, regardless of streaming or
   * batching if it exists. This is used for optimization on the service side
   */


  _getAssociatedReceiverName() {
    if (this._streamingReceiver && this._streamingReceiver.isOpen()) {
      return this._streamingReceiver.name;
    }

    if (this._batchingReceiver && this._batchingReceiver.isOpen() && this._batchingReceiver.isReceivingMessages) {
      return this._batchingReceiver.name;
    }

    return;
  }

}
/**
 * The default time to wait for messages _after_ the first message
 * has been received.
 *
 * This timeout only applies to receiveMessages()
 *
 * @internal
 * @hidden
 */


exports.ServiceBusReceiverImpl = ServiceBusReceiverImpl;
const defaultMaxTimeAfterFirstMessageForBatchingMs = 1000;
exports.defaultMaxTimeAfterFirstMessageForBatchingMs = defaultMaxTimeAfterFirstMessageForBatchingMs;
},{"tslib":"CvJj","../modelsToBeSharedWithEventHubs":"xWS9","../util/errors":"TKJx","../core/streamingReceiver":"eF7j","../core/batchingReceiver":"LTH6","./shared":"i7Sv","@azure/core-amqp":"n95d","@azure/core-asynciterator-polyfill":"zRti","../core/autoLockRenewer":"k3aD","../diagnostics/instrumentServiceBusMessage":"Q82k","../log":"IupI","../serviceBusError":"tdxx"}],"oNPM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServiceBusSessionReceiverImpl = void 0;

var _tslib = require("tslib");

var _errors = require("../util/errors");

var _shared = require("./shared");

var _receiver = require("./receiver");

var _coreAmqp = require("@azure/core-amqp");

var _modelsToBeSharedWithEventHubs = require("../modelsToBeSharedWithEventHubs");

require("@azure/core-asynciterator-polyfill");

var _instrumentServiceBusMessage = require("../diagnostics/instrumentServiceBusMessage");

var _log = require("../log");

var _serviceBusError = require("../serviceBusError");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 */
class ServiceBusSessionReceiverImpl {
  /**
   * @internal
   * @throws Error if the underlying connection is closed.
   * @throws Error if an open receiver is already existing for given sessionId.
   */
  constructor(_messageSession, _context, entityPath, receiveMode, _retryOptions = {}) {
    this._messageSession = _messageSession;
    this._context = _context;
    this.entityPath = entityPath;
    this.receiveMode = receiveMode;
    this._retryOptions = _retryOptions;
    /**
     * @property {boolean} [_isClosed] Denotes if close() was called on this receiver
     */

    this._isClosed = false;
    (0, _errors.throwErrorIfConnectionClosed)(_context);
    this.sessionId = _messageSession.sessionId;
    this._createProcessingSpan = _instrumentServiceBusMessage.createProcessingSpan;
  }

  get logPrefix() {
    return `[${this._context.connectionId}|session:${this.entityPath}]`;
  }

  _throwIfReceiverOrConnectionClosed() {
    (0, _errors.throwErrorIfConnectionClosed)(this._context);

    if (this.isClosed) {
      if (this._isClosed) {
        const errorMessage = (0, _errors.getReceiverClosedErrorMsg)(this.entityPath, this.sessionId);
        const error = new Error(errorMessage);

        _log.receiverLogger.logError(error, `${this.logPrefix} already closed`);

        throw error;
      }

      const amqpError = {
        condition: _coreAmqp.ErrorNameConditionMapper.SessionLockLostError,
        description: `The session lock has expired on the session with id ${this.sessionId}`
      };
      throw (0, _serviceBusError.translateServiceBusError)(amqpError);
    }
  }

  _throwIfAlreadyReceiving() {
    if (this._isReceivingMessages()) {
      const errorMessage = (0, _errors.getAlreadyReceivingErrorMsg)(this.entityPath, this.sessionId);
      const error = new Error(errorMessage);

      _log.receiverLogger.logError(error, `${this.logPrefix} is already receiving.`);

      throw error;
    }
  }

  get isClosed() {
    return this._isClosed || !this._context.messageSessions[this._messageSession.name] || !this._messageSession.isOpen();
  }
  /**
   * @property The time in UTC until which the session is locked.
   * Every time `renewSessionLock()` is called, this time gets updated to current time plus the lock
   * duration as specified during the Queue/Subscription creation.
   *
   * When the lock on the session expires
   * - The current receiver can no longer be used to receive more messages.
   * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.
   * - Messages that were received in `peekLock` mode with this receiver but not yet settled
   * will land back in the Queue/Subscription with their delivery count incremented.
   *
   * @readonly
   */


  get sessionLockedUntilUtc() {
    return this._messageSession.sessionLockedUntilUtc;
  }
  /**
   * Renews the lock on the session for the duration as specified during the Queue/Subscription
   * creation. You can check the `sessionLockedUntilUtc` property for the time when the lock expires.
   *
   * When the lock on the session expires
   * - The current receiver can no longer be used to receive mode messages.
   * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.
   * - Messages that were received in `peekLock` mode with this receiver but not yet settled
   * will land back in the Queue/Subscription with their delivery count incremented.
   *
   * @param options - Options bag to pass an abort signal or tracing options.
   * @returns Promise<Date> - New lock token expiry date and time in UTC format.
   * @throws Error if the underlying connection or receiver is closed.
   * @throws `ServiceBusError` if the service returns an error while renewing session lock.
   */


  renewSessionLock(options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      const renewSessionLockOperationPromise = () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        this._messageSession.sessionLockedUntilUtc = yield this._context.getManagementClient(this.entityPath).renewSessionLock(this.sessionId, Object.assign(Object.assign({}, options), {
          associatedLinkName: this._messageSession.name,
          requestName: "renewSessionLock",
          timeoutInMs: this._retryOptions.timeoutInMs
        }));
        return this._messageSession.sessionLockedUntilUtc;
      });

      const config = {
        operation: renewSessionLockOperationPromise,
        connectionId: this._context.connectionId,
        operationType: _coreAmqp.RetryOperationType.management,
        retryOptions: this._retryOptions,
        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
      };
      return (0, _coreAmqp.retry)(config);
    });
  }
  /**
   * Sets the state on the Session. For more on session states, see
   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state Session State}
   * @param state The state that needs to be set.
   * @param options - Options bag to pass an abort signal or tracing options.
   * @throws Error if the underlying connection or receiver is closed.
   * @throws `ServiceBusError` if the service returns an error while setting the session state.
   */


  setSessionState(state, options = {}) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      const setSessionStateOperationPromise = () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        yield this._context.getManagementClient(this.entityPath).setSessionState(this.sessionId, state, Object.assign(Object.assign({}, options), {
          associatedLinkName: this._messageSession.name,
          requestName: "setState",
          timeoutInMs: this._retryOptions.timeoutInMs
        }));
        return;
      });

      const config = {
        operation: setSessionStateOperationPromise,
        connectionId: this._context.connectionId,
        operationType: _coreAmqp.RetryOperationType.management,
        retryOptions: this._retryOptions,
        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
      };
      return (0, _coreAmqp.retry)(config);
    });
  }
  /**
   * Gets the state of the Session. For more on session states, see
   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state Session State}
   * @param options - Options bag to pass an abort signal or tracing options.
   * @returns Promise<any> The state of that session
   * @throws Error if the underlying connection or receiver is closed.
   * @throws `ServiceBusError` if the service returns an error while retrieving session state.
   */


  getSessionState(options = {}) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      const getSessionStateOperationPromise = () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        return this._context.getManagementClient(this.entityPath).getSessionState(this.sessionId, Object.assign(Object.assign({}, options), {
          associatedLinkName: this._messageSession.name,
          requestName: "getState",
          timeoutInMs: this._retryOptions.timeoutInMs
        }));
      });

      const config = {
        operation: getSessionStateOperationPromise,
        connectionId: this._context.connectionId,
        operationType: _coreAmqp.RetryOperationType.management,
        retryOptions: this._retryOptions,
        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
      };
      return (0, _coreAmqp.retry)(config);
    });
  }

  peekMessages(maxMessageCount, options = {}) {
    var _a;

    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      const managementRequestOptions = Object.assign(Object.assign({}, options), {
        associatedLinkName: this._messageSession.name,
        requestName: "peekMessages",
        timeoutInMs: (_a = this._retryOptions) === null || _a === void 0 ? void 0 : _a.timeoutInMs
      });

      const peekOperationPromise = () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        if (options.fromSequenceNumber) {
          return yield this._context.getManagementClient(this.entityPath).peekBySequenceNumber(options.fromSequenceNumber, maxMessageCount, this.sessionId, managementRequestOptions);
        } else {
          return yield this._context.getManagementClient(this.entityPath).peekMessagesBySession(this.sessionId, maxMessageCount, managementRequestOptions);
        }
      });

      const config = {
        operation: peekOperationPromise,
        connectionId: this._context.connectionId,
        operationType: _coreAmqp.RetryOperationType.management,
        retryOptions: this._retryOptions,
        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
      };
      return (0, _coreAmqp.retry)(config);
    });
  }

  receiveDeferredMessages(sequenceNumbers, options = {}) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      (0, _errors.throwTypeErrorIfParameterMissing)(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
      (0, _errors.throwTypeErrorIfParameterNotLong)(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
      const deferredSequenceNumbers = Array.isArray(sequenceNumbers) ? sequenceNumbers : [sequenceNumbers];

      const receiveDeferredMessagesOperationPromise = () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        const deferredMessages = yield this._context.getManagementClient(this.entityPath).receiveDeferredMessages(deferredSequenceNumbers, this.receiveMode, this.sessionId, Object.assign(Object.assign({}, options), {
          associatedLinkName: this._messageSession.name,
          requestName: "receiveDeferredMessages",
          timeoutInMs: this._retryOptions.timeoutInMs
        }));
        return deferredMessages;
      });

      const config = {
        operation: receiveDeferredMessagesOperationPromise,
        connectionId: this._context.connectionId,
        operationType: _coreAmqp.RetryOperationType.management,
        retryOptions: this._retryOptions,
        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
      };
      return (0, _coreAmqp.retry)(config);
    });
  }

  receiveMessages(maxMessageCount, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      this._throwIfAlreadyReceiving();

      (0, _errors.throwTypeErrorIfParameterMissing)(this._context.connectionId, "maxMessageCount", maxMessageCount);
      (0, _errors.throwTypeErrorIfParameterTypeMismatch)(this._context.connectionId, "maxMessageCount", maxMessageCount, "number");

      if (isNaN(maxMessageCount) || maxMessageCount < 1) {
        throw new TypeError(_errors.InvalidMaxMessageCountError);
      }

      const receiveBatchOperationPromise = () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        var _a;

        const receivedMessages = yield this._messageSession.receiveMessages(maxMessageCount, (_a = options === null || options === void 0 ? void 0 : options.maxWaitTimeInMs) !== null && _a !== void 0 ? _a : _coreAmqp.Constants.defaultOperationTimeoutInMs, _receiver.defaultMaxTimeAfterFirstMessageForBatchingMs, options !== null && options !== void 0 ? options : {});
        return receivedMessages;
      });

      const config = {
        operation: receiveBatchOperationPromise,
        connectionId: this._context.connectionId,
        operationType: _coreAmqp.RetryOperationType.receiveMessage,
        retryOptions: this._retryOptions,
        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
      };
      return (0, _coreAmqp.retry)(config).catch(err => {
        throw (0, _serviceBusError.translateServiceBusError)(err);
      });
    });
  }

  subscribe(handlers, options) {
    // TODO - receiverOptions for subscribe??
    (0, _shared.assertValidMessageHandlers)(handlers);
    options = options !== null && options !== void 0 ? options : {};
    const processError = (0, _shared.wrapProcessErrorHandler)(handlers);

    this._registerMessageHandler(message => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const span = this._createProcessingSpan(message, this, this._context.config, options);

      return (0, _modelsToBeSharedWithEventHubs.trace)(() => handlers.processMessage(message), span);
    }), processError, options);

    return {
      close: () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        var _a;

        return (_a = this._messageSession) === null || _a === void 0 ? void 0 : _a.receiverHelper.suspend();
      })
    };
  }
  /**
   * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
   * from a Queue/Subscription.
   * To stop receiving messages, call `close()` on the SessionReceiver.
   *
   * Throws an error if there is another receive operation in progress on the same receiver. If you
   * are not sure whether there is another receive operation running, check the `isReceivingMessages`
   * property on the receiver.
   *
   * @param onMessage - Handler for processing each incoming message.
   * @param onError - Handler for any error that occurs while receiving or processing messages.
   * @param options - Options to control whether messages should be automatically completed
   * or if the lock on the session should be automatically renewed. You can control the
   * maximum number of messages that should be concurrently processed. You can
   * also provide a timeout in milliseconds to denote the amount of time to wait for a new message
   * before closing the receiver.
   *
   * @returns void
   * @throws Error if the underlying connection or receiver is closed.
   * @throws Error if the receiver is already in state of receiving messages.
   * @throws `ServiceBusError` if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.
   */


  _registerMessageHandler(onMessage, onError, options) {
    this._throwIfReceiverOrConnectionClosed();

    this._throwIfAlreadyReceiving();

    const connId = this._context.connectionId;
    (0, _errors.throwTypeErrorIfParameterMissing)(connId, "onMessage", onMessage);
    (0, _errors.throwTypeErrorIfParameterMissing)(connId, "onError", onError);

    if (typeof onMessage !== "function") {
      throw new TypeError("The parameter 'onMessage' must be of type 'function'.");
    }

    if (typeof onError !== "function") {
      throw new TypeError("The parameter 'onError' must be of type 'function'.");
    }

    try {
      this._messageSession.subscribe(onMessage, onError, options);
    } catch (err) {
      onError({
        error: err,
        errorSource: "receive",
        entityPath: this.entityPath,
        fullyQualifiedNamespace: this._context.config.host
      });
    }
  }

  getMessageIterator(options) {
    return (0, _shared.getMessageIterator)(this, options);
  }

  completeMessage(message) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      (0, _errors.throwErrorIfInvalidOperationOnMessage)(message, this.receiveMode, this._context.connectionId);
      const msgImpl = message;
      return (0, _shared.completeMessage)(msgImpl, this._context, this.entityPath);
    });
  }

  abandonMessage(message, propertiesToModify) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      (0, _errors.throwErrorIfInvalidOperationOnMessage)(message, this.receiveMode, this._context.connectionId);
      const msgImpl = message;
      return (0, _shared.abandonMessage)(msgImpl, this._context, this.entityPath, propertiesToModify);
    });
  }

  deferMessage(message, propertiesToModify) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      (0, _errors.throwErrorIfInvalidOperationOnMessage)(message, this.receiveMode, this._context.connectionId);
      const msgImpl = message;
      return (0, _shared.deferMessage)(msgImpl, this._context, this.entityPath, propertiesToModify);
    });
  }

  deadLetterMessage(message, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfReceiverOrConnectionClosed();

      (0, _errors.throwErrorIfInvalidOperationOnMessage)(message, this.receiveMode, this._context.connectionId);
      const msgImpl = message;
      return (0, _shared.deadLetterMessage)(msgImpl, this._context, this.entityPath, options);
    });
  }

  renewMessageLock() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      throw new Error("Renewing message lock is an invalid operation when working with sessions.");
    });
  }

  close() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      try {
        yield this._messageSession.close();
      } catch (err) {
        _log.receiverLogger.logError(err, "%s An error occurred while closing the SessionReceiver for session %s", this.logPrefix, this.sessionId);

        throw err;
      } finally {
        this._isClosed = true;
      }
    });
  }
  /**
   * Indicates whether the receiver is currently receiving messages or not.
   * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.
   */


  _isReceivingMessages() {
    return this._messageSession ? this._messageSession.isReceivingMessages : false;
  }

}

exports.ServiceBusSessionReceiverImpl = ServiceBusSessionReceiverImpl;
},{"tslib":"CvJj","../util/errors":"TKJx","./shared":"i7Sv","./receiver":"T1eE","@azure/core-amqp":"n95d","../modelsToBeSharedWithEventHubs":"xWS9","@azure/core-asynciterator-polyfill":"zRti","../diagnostics/instrumentServiceBusMessage":"Q82k","../log":"IupI","../serviceBusError":"tdxx"}],"cuA5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMessageSpan = createMessageSpan;

var _coreTracing = require("@azure/core-tracing");

var _api = require("@opentelemetry/api");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 */
function createMessageSpan(parentSpan, config) {
  const tracer = (0, _coreTracing.getTracer)();
  const span = tracer.startSpan("Azure.ServiceBus.message", {
    kind: _api.SpanKind.PRODUCER,
    parent: parentSpan
  });
  span.setAttribute("az.namespace", "Microsoft.ServiceBus");

  if (config) {
    span.setAttribute("message_bus.destination", config.entityPath);
    span.setAttribute("peer.address", config.host);
  }

  return span;
}
},{"@azure/core-tracing":"xbTt","@opentelemetry/api":"fNAU"}],"mpya":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServiceBusMessageBatchImpl = void 0;

var _serviceBusMessage = require("./serviceBusMessage");

var _errors = require("./util/errors");

var _rheaPromise = require("rhea-promise");

var _instrumentServiceBusMessage = require("./diagnostics/instrumentServiceBusMessage");

var _messageSpan = require("./diagnostics/messageSpan");

var _dataTransformer = require("./dataTransformer");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * The amount of bytes to reserve as overhead for a small message.
 */
const smallMessageOverhead = 5;
/**
 * @internal
 * @hidden
 * The amount of bytes to reserve as overhead for a large message.
 */

const largeMessageOverhead = 8;
/**
 * @internal
 * @hidden
 * The maximum number of bytes that a message may be to be considered small.
 */

const smallMessageMaxBytes = 255;
/**
 * An internal class representing a batch of messages which can be used to send messages to Service Bus.
 *
 * @class
 * @internal
 * @hidden
 */

class ServiceBusMessageBatchImpl {
  /**
   * ServiceBusMessageBatch should not be constructed using `new ServiceBusMessageBatch()`
   * Use the `createBatch()` method on your `Sender` instead.
   * @constructor
   * @internal
   * @hidden
   */
  constructor(_context, _maxSizeInBytes) {
    this._context = _context;
    this._maxSizeInBytes = _maxSizeInBytes;
    /**
     * @property Encoded amqp messages.
     */

    this._encodedMessages = [];
    /**
     * List of 'message' span contexts.
     */

    this._spanContexts = [];
    this._sizeInBytes = 0;
    this._batchMessageProperties = {};
  }
  /**
   * @property The maximum size of the batch, in bytes.
   * @readonly
   */


  get maxSizeInBytes() {
    return this._maxSizeInBytes;
  }
  /**
   * @property Size of the `ServiceBusMessageBatch` instance after the messages added to it have been
   * encoded into a single AMQP message.
   * @readonly
   */


  get sizeInBytes() {
    return this._sizeInBytes;
  }
  /**
   * @property Number of messages in the `ServiceBusMessageBatch` instance.
   * @readonly
   */


  get count() {
    return this._encodedMessages.length;
  }
  /**
   * Gets the "message" span contexts that were created when adding messages to the batch.
   * @internal
   * @hidden
   */


  get _messageSpanContexts() {
    return this._spanContexts;
  }
  /**
   * Generates an AMQP message that contains the provided encoded messages and annotations.
   *
   * @private
   * @param {Buffer[]} encodedMessages The already encoded messages to include in the AMQP batch.
   * @param {MessageAnnotations} [annotations] The message annotations to set on the batch.
   * @param {{ [key: string]: any }} [applicationProperties] The application properties to set on the batch.
   * @param {{ [key: string]: string }} [messageProperties] The message properties to set on the batch.
   * @returns {Buffer}
   * @memberof ServiceBusMessageBatchImpl
   */


  _generateBatch(encodedMessages, annotations, applicationProperties, messageProperties) {
    const batchEnvelope = {
      body: _rheaPromise.message.data_sections(encodedMessages),
      message_annotations: annotations,
      application_properties: applicationProperties
    };

    if (messageProperties) {
      for (const prop of _rheaPromise.messageProperties) {
        if (messageProperties[prop]) {
          batchEnvelope[prop] = messageProperties[prop];
        }
      }
    }

    return _rheaPromise.message.encode(batchEnvelope);
  }
  /**
   * @property Represents the single AMQP message which is the result of encoding all the events
   * added into the `ServiceBusMessageBatch` instance.
   *
   * This is not meant for the user to use directly.
   *
   * When the `ServiceBusMessageBatch` instance is passed to the `sendBatch()` method on the `Sender`,
   * this single batched AMQP message is what gets sent over the wire to the service.
   * @readonly
   */


  _generateMessage() {
    return this._generateBatch(this._encodedMessages, this._batchAnnotations, this._batchApplicationProperties, this._batchMessageProperties);
  }
  /**
   * Tries to add a message to the batch if permitted by the batch's size limit.
   * **NOTE**: Always remember to check the return value of this method, before calling it again
   * for the next message.
   *
   * @param message  An individual service bus message.
   * @returns A boolean value indicating if the message has been added to the batch or not.
   */


  tryAddMessage(message, options = {}) {
    (0, _errors.throwTypeErrorIfParameterMissing)(this._context.connectionId, "message", message);
    (0, _errors.throwIfNotValidServiceBusMessage)(message, "Provided value for 'message' must be of type ServiceBusMessage."); // check if the event has already been instrumented

    const previouslyInstrumented = Boolean(message.applicationProperties && message.applicationProperties[_instrumentServiceBusMessage.TRACEPARENT_PROPERTY]);
    let spanContext;

    if (!previouslyInstrumented) {
      const messageSpan = (0, _messageSpan.createMessageSpan)(options === null || options === void 0 ? void 0 : options.parentSpan, this._context.config);
      message = (0, _instrumentServiceBusMessage.instrumentServiceBusMessage)(message, messageSpan);
      spanContext = messageSpan.context();
      messageSpan.end();
    } // Convert ServiceBusMessage to AmqpMessage.


    const amqpMessage = (0, _serviceBusMessage.toRheaMessage)(message);
    amqpMessage.body = _dataTransformer.defaultDataTransformer.encode(message.body);
    let encodedMessage;

    try {
      encodedMessage = _rheaPromise.message.encode(amqpMessage);
    } catch (error) {
      if (error instanceof TypeError || error.name === "TypeError") {
        throw (0, _serviceBusMessage.getMessagePropertyTypeMismatchError)(message) || error;
      }

      throw error;
    }

    let currentSize = this._sizeInBytes; // The first time an event is added, we need to calculate
    // the overhead of creating an AMQP batch, including the
    // message_annotations, application_properties and message_properties
    // that are taken from the 1st message.

    if (this.count === 0) {
      if (amqpMessage.message_annotations) {
        this._batchAnnotations = amqpMessage.message_annotations;
      }

      if (amqpMessage.application_properties) {
        this._batchApplicationProperties = amqpMessage.application_properties;
      }

      for (const prop of _rheaPromise.messageProperties) {
        if (amqpMessage[prop]) {
          this._batchMessageProperties[prop] = amqpMessage[prop];
        }
      } // Figure out the overhead of creating a batch by generating an empty batch
      // with the expected batch annotations.


      currentSize += this._generateBatch([], this._batchAnnotations, this._batchApplicationProperties, this._batchMessageProperties).length;
    }

    const messageSize = encodedMessage.length;
    const messageOverhead = messageSize <= smallMessageMaxBytes ? smallMessageOverhead : largeMessageOverhead;
    currentSize += messageSize + messageOverhead; // Check if the size of the batch exceeds the maximum allowed size
    // once we add the new event to it.

    if (currentSize > this._maxSizeInBytes) {
      return false;
    } // The message will fit in the batch, so it is now safe to store it.


    this._encodedMessages.push(encodedMessage);

    if (spanContext) {
      this._spanContexts.push(spanContext);
    }

    this._sizeInBytes = currentSize;
    return true;
  }

}

exports.ServiceBusMessageBatchImpl = ServiceBusMessageBatchImpl;
},{"./serviceBusMessage":"jl8f","./util/errors":"TKJx","rhea-promise":"fxSK","./diagnostics/instrumentServiceBusMessage":"Q82k","./diagnostics/messageSpan":"cuA5","./dataTransformer":"RpJR"}],"jzJG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessageSender = void 0;

var _tslib = require("tslib");

var _log = require("../log");

var _rheaPromise = require("rhea-promise");

var _coreAmqp = require("@azure/core-amqp");

var _serviceBusMessage = require("../serviceBusMessage");

var _linkEntity = require("./linkEntity");

var _utils = require("../util/utils");

var _errors = require("../util/errors");

var _serviceBusMessageBatch = require("../serviceBusMessageBatch");

var _serviceBusError = require("../serviceBusError");

var _dataTransformer = require("../dataTransformer");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * Describes the MessageSender that will send messages to ServiceBus.
 * @class MessageSender
 */
class MessageSender extends _linkEntity.LinkEntity {
  constructor(context, entityPath, retryOptions) {
    super(entityPath, entityPath, context, "sender", _log.senderLogger, {
      address: entityPath,
      audience: `${context.config.endpoint}${entityPath}`
    });
    this._retryOptions = retryOptions;

    this._onAmqpError = context => {
      const senderError = context.sender && context.sender.error;

      _log.senderLogger.logError(senderError, "%s 'sender_error' event occurred on the sender '%s' with address '%s'. " + "The associated error", this.logPrefix, this.name, this.address); // TODO: Consider rejecting promise in trySendBatch() or createBatch()

    };

    this._onSessionError = context => {
      const sessionError = context.session && context.session.error;

      _log.senderLogger.logError(sessionError, "%s 'session_error' event occurred on the session of sender '%s' with address '%s'. " + "The associated error", this.logPrefix, this.name, this.address); // TODO: Consider rejecting promise in trySendBatch() or createBatch()

    };

    this._onAmqpClose = context => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const senderError = context.sender && context.sender.error;

      _log.senderLogger.logError(senderError, `${this.logPrefix} 'sender_close' event occurred. The associated error is`);

      yield this.onDetached().catch(err => {
        _log.senderLogger.logError(err, `${this.logPrefix} error when closing sender after 'sender_close' event`);
      });
    });

    this._onSessionClose = context => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const sessionError = context.session && context.session.error;

      _log.senderLogger.logError(sessionError, `${this.logPrefix} 'session_close' event occurred. The associated error is`);

      yield this.onDetached().catch(err => {
        _log.senderLogger.logError(err, `${this.logPrefix} error when closing sender after 'session_close' event`);
      });
    });
  }

  _createSenderOptions(timeoutInMs, newName) {
    if (newName) this.name = (0, _utils.getUniqueName)(this.baseName);
    const srOptions = {
      name: this.name,
      target: {
        address: this.address
      },
      onError: this._onAmqpError,
      onClose: this._onAmqpClose,
      onSessionError: this._onSessionError,
      onSessionClose: this._onSessionClose,
      sendTimeoutInSeconds: timeoutInMs / 1000
    };

    _log.senderLogger.verbose(`${this.logPrefix} Creating sender with options: %O`, srOptions);

    return srOptions;
  }
  /**
   * Tries to send the message to ServiceBus if there is enough credit to send them
   * and the circular buffer has available space to settle the message after sending them.
   *
   * We have implemented a synchronous send over here in the sense that we shall be waiting
   * for the message to be accepted or rejected and accordingly resolve or reject the promise.
   *
   * @param encodedMessage The encoded message to be sent to ServiceBus.
   * @param sendBatch Boolean indicating whether the encoded message represents a batch of messages or not
   * @return {Promise<Delivery>} Promise<Delivery>
   */


  _trySend(encodedMessage, sendBatch, options) {
    const abortSignal = options === null || options === void 0 ? void 0 : options.abortSignal;
    const timeoutInMs = this._retryOptions.timeoutInMs == undefined ? _coreAmqp.Constants.defaultOperationTimeoutInMs : this._retryOptions.timeoutInMs;

    const sendEventPromise = () => new Promise((resolve, reject) => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;

      const initStartTime = Date.now();

      if (!this.isOpen()) {
        try {
          yield (0, _utils.waitForTimeoutOrAbortOrResolve)({
            actionFn: () => this.open(undefined, options === null || options === void 0 ? void 0 : options.abortSignal),
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
            timeoutMs: timeoutInMs,
            timeoutMessage: `[${this._context.connectionId}] Sender "${this.name}" ` + `with address "${this.address}", was not able to send the message right now, due ` + `to operation timeout.`
          });
        } catch (err) {
          err = (0, _serviceBusError.translateServiceBusError)(err);

          _log.senderLogger.logError(err, "%s An error occurred while creating the sender", this.logPrefix, this.name);

          return reject(err);
        }
      }

      try {
        const timeTakenByInit = Date.now() - initStartTime;

        _log.senderLogger.verbose("%s Sender '%s', credit: %d available: %d", this.logPrefix, this.name, (_a = this.link) === null || _a === void 0 ? void 0 : _a.credit, (_d = (_c = (_b = this.link) === null || _b === void 0 ? void 0 : _b.session) === null || _c === void 0 ? void 0 : _c.outgoing) === null || _d === void 0 ? void 0 : _d.available());

        if (!((_e = this.link) === null || _e === void 0 ? void 0 : _e.sendable())) {
          _log.senderLogger.verbose("%s Sender '%s', waiting for 1 second for sender to become sendable", this.logPrefix, this.name);

          yield (0, _coreAmqp.delay)(1000);

          _log.senderLogger.verbose("%s Sender '%s' after waiting for a second, credit: %d available: %d", this.logPrefix, this.name, (_f = this.link) === null || _f === void 0 ? void 0 : _f.credit, (_j = (_h = (_g = this.link) === null || _g === void 0 ? void 0 : _g.session) === null || _h === void 0 ? void 0 : _h.outgoing) === null || _j === void 0 ? void 0 : _j.available());
        }

        if ((_k = this.link) === null || _k === void 0 ? void 0 : _k.sendable()) {
          if (timeoutInMs <= timeTakenByInit) {
            const desc = `${this.logPrefix} Sender "${this.name}" ` + `with address "${this.address}", was not able to send the message right now, due ` + `to operation timeout.`;

            _log.senderLogger.warning(desc);

            const e = {
              condition: _coreAmqp.ErrorNameConditionMapper.ServiceUnavailableError,
              description: desc
            };
            return reject((0, _serviceBusError.translateServiceBusError)(e));
          }

          try {
            this.link.sendTimeoutInSeconds = (timeoutInMs - timeTakenByInit) / 1000;
            const delivery = yield this.link.send(encodedMessage, undefined, sendBatch ? 0x80013700 : 0);

            _log.senderLogger.verbose("%s Sender '%s', sent message with delivery id: %d", this.logPrefix, this.name, delivery.id);

            return resolve();
          } catch (error) {
            error = (0, _serviceBusError.translateServiceBusError)(error.innerError || error);

            _log.senderLogger.logError(error, `${this.logPrefix} An error occurred while sending the message`);

            return reject(error);
          }
        } else {
          // let us retry to send the message after some time.
          const msg = `[${this.logPrefix}] Sender "${this.name}", ` + `cannot send the message right now. Please try later.`;

          _log.senderLogger.warning(msg);

          const amqpError = {
            condition: _coreAmqp.ErrorNameConditionMapper.SenderBusyError,
            description: msg
          };
          reject((0, _serviceBusError.translateServiceBusError)(amqpError));
        }
      } catch (err) {
        reject(err);
      }
    }));

    const config = {
      operation: sendEventPromise,
      connectionId: this._context.connectionId,
      operationType: _coreAmqp.RetryOperationType.sendMessage,
      retryOptions: this._retryOptions,
      abortSignal: abortSignal
    };
    return (0, _coreAmqp.retry)(config);
  }

  createRheaLink(options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const sender = yield this._context.connection.createAwaitableSender(options);
      sender.setMaxListeners(1000);
      return sender;
    });
  }
  /**
   * Initializes the sender session on the connection.
   */


  open(options, abortSignal) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      try {
        if (!options) {
          options = this._createSenderOptions(_coreAmqp.Constants.defaultOperationTimeoutInMs);
        }

        yield this.initLink(options, abortSignal);
      } catch (err) {
        err = (0, _serviceBusError.translateServiceBusError)(err);

        _log.senderLogger.logError(err, `${this.logPrefix} An error occurred while creating the sender`); // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.


        if (err.code === "OperationTimeoutError") {
          err.message = "Failed to create a sender within allocated time and retry attempts.";
        }

        throw err;
      }
    });
  }
  /**
   * Closes the rhea link.
   * To be called when connection is disconnected, onAmqpClose and onSessionClose events.
   * @returns {Promise<void>} Promise<void>.
   */


  onDetached() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      // Clears the token renewal timer. Closes the link and its session if they are open.
      // Removes the link and its session if they are present in rhea's cache.
      yield this.closeLink();
    });
  }
  /**
   * Determines whether the AMQP sender link is open. If open then returns true else returns false.
   * @return {boolean} boolean
   */


  isOpen() {
    const result = this.link == null ? false : this.link.isOpen();

    _log.senderLogger.verbose("%s Sender '%s' with address '%s' is open? -> %s", this.logPrefix, this.name, this.address, result);

    return result;
  }
  /**
   * Sends the given message, with the given options on this link
   *
   * @param {ServiceBusMessage} data Message to send.  Will be sent as UTF8-encoded JSON string.
   * @returns {Promise<void>}
   */


  send(data, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);

      try {
        const amqpMessage = (0, _serviceBusMessage.toRheaMessage)(data);
        amqpMessage.body = _dataTransformer.defaultDataTransformer.encode(data.body); // TODO: this body of logic is really similar to what's in sendMessages. Unify what we can.

        let encodedMessage;

        try {
          encodedMessage = _rheaPromise.message.encode(amqpMessage);
        } catch (error) {
          if (error instanceof TypeError || error.name === "TypeError") {
            // `RheaMessageUtil.encode` can fail if message properties are of invalid type
            // rhea throws errors with name `TypeError` but not an instance of `TypeError`, so catch them too
            // Errors in such cases do not have user-friendly message or call stack
            // So use `getMessagePropertyTypeMismatchError` to get a better error message
            throw (0, _serviceBusMessage.getMessagePropertyTypeMismatchError)(data) || error;
          }

          throw error;
        }

        _log.senderLogger.verbose("%s Sender '%s', trying to send message: %O", this.logPrefix, this.name, data);

        return yield this._trySend(encodedMessage, false, options);
      } catch (err) {
        _log.senderLogger.logError(err, "%s An error occurred while sending the message: %O\nError", this.logPrefix, data);

        throw err;
      }
    });
  } // Not exposed to the users

  /**
   * Send a batch of Message to the ServiceBus in a single AMQP message. The "message_annotations",
   * "application_properties" and "properties" of the first message will be set as that
   * of the envelope (batch message).
   * @param {Array<Message>} inputMessages  An array of Message objects to be sent in a
   * Batch message.
   * @return {Promise<void>}
   */


  sendMessages(inputMessages, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);

      try {
        if (!Array.isArray(inputMessages)) {
          inputMessages = [inputMessages];
        }

        _log.senderLogger.verbose("%s Sender '%s', trying to send Message[]: %O", this.logPrefix, this.name, inputMessages);

        const amqpMessages = [];
        const encodedMessages = []; // Convert Message to AmqpMessage.

        for (let i = 0; i < inputMessages.length; i++) {
          const amqpMessage = (0, _serviceBusMessage.toRheaMessage)(inputMessages[i]);
          amqpMessage.body = _dataTransformer.defaultDataTransformer.encode(inputMessages[i].body);
          amqpMessages[i] = amqpMessage;

          try {
            encodedMessages[i] = _rheaPromise.message.encode(amqpMessage);
          } catch (error) {
            if (error instanceof TypeError || error.name === "TypeError") {
              throw (0, _serviceBusMessage.getMessagePropertyTypeMismatchError)(inputMessages[i]) || error;
            }

            throw error;
          }
        } // Convert every encoded message to amqp data section


        const batchMessage = {
          body: _rheaPromise.message.data_sections(encodedMessages)
        }; // Set message_annotations, application_properties and properties of the first message as
        // that of the envelope (batch message).

        if (amqpMessages[0].message_annotations) {
          batchMessage.message_annotations = amqpMessages[0].message_annotations;
        }

        if (amqpMessages[0].application_properties) {
          batchMessage.application_properties = amqpMessages[0].application_properties;
        }

        for (const prop of _rheaPromise.messageProperties) {
          if (amqpMessages[0][prop]) {
            batchMessage[prop] = amqpMessages[0][prop];
          }
        } // Finally encode the envelope (batch message).


        const encodedBatchMessage = _rheaPromise.message.encode(batchMessage);

        _log.senderLogger.verbose("%s Sender '%s', sending encoded batch message.", this.logPrefix, this.name, encodedBatchMessage);

        return yield this._trySend(encodedBatchMessage, true, options);
      } catch (err) {
        _log.senderLogger.logError(err, "%s Sender '%s': An error occurred while sending the messages: %O\nError", this.logPrefix, this.name, inputMessages);

        throw err;
      }
    });
  }
  /**
   * Returns maximum message size on the AMQP sender link.
   *
   * Options to configure the `createBatch` method on the `Sender`.
   * - `maxSizeInBytes`: The upper limit for the size of batch.
   *
   * Example usage:
   * ```js
   * {
   *     retryOptions: { maxRetries: 5; timeoutInMs: 10 }
   * }
   * ```
   * @param {{retryOptions?: RetryOptions}} [options={}]
   * @returns {Promise<number>}
   */


  getMaxMessageSize(options = {}) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const retryOptions = options.retryOptions || {};

      if (this.isOpen()) {
        return this.link.maxMessageSize;
      }

      return new Promise((resolve, reject) => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        try {
          const config = {
            operation: () => this.open(undefined, options === null || options === void 0 ? void 0 : options.abortSignal),
            connectionId: this._context.connectionId,
            operationType: _coreAmqp.RetryOperationType.senderLink,
            retryOptions: retryOptions,
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
          };
          yield (0, _coreAmqp.retry)(config);
          return resolve(this.link.maxMessageSize);
        } catch (err) {
          reject(err);
        }
      }));
    });
  }

  createBatch(options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);
      let maxMessageSize = yield this.getMaxMessageSize({
        retryOptions: this._retryOptions,
        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
      });

      if (options === null || options === void 0 ? void 0 : options.maxSizeInBytes) {
        if (options.maxSizeInBytes > maxMessageSize) {
          const error = new Error(`Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link.`);
          throw error;
        }

        maxMessageSize = options.maxSizeInBytes;
      }

      return new _serviceBusMessageBatch.ServiceBusMessageBatchImpl(this._context, maxMessageSize);
    });
  }

  sendBatch(batchMessage, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(this._context);

      try {
        _log.senderLogger.verbose("%s Sender '%s', sending encoded batch message.", this.logPrefix, this.name, batchMessage);

        return yield this._trySend(batchMessage._generateMessage(), true, options);
      } catch (err) {
        _log.senderLogger.logError(err, "%s Sender '%s': An error occurred while sending the messages: %O\nError", this.logPrefix, this.name, batchMessage);

        throw err;
      }
    });
  }

  static create(context, entityPath, retryOptions) {
    (0, _errors.throwErrorIfConnectionClosed)(context);
    const sbSender = new MessageSender(context, entityPath, retryOptions);
    context.senders[sbSender.name] = sbSender;
    return sbSender;
  }

}

exports.MessageSender = MessageSender;
},{"tslib":"CvJj","../log":"IupI","rhea-promise":"fxSK","@azure/core-amqp":"n95d","../serviceBusMessage":"jl8f","./linkEntity":"tkX2","../util/utils":"RXMg","../util/errors":"TKJx","../serviceBusMessageBatch":"mpya","../serviceBusError":"tdxx","../dataTransformer":"RpJR"}],"x6kC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isServiceBusMessageBatch = isServiceBusMessageBatch;
exports.ServiceBusSenderImpl = void 0;

var _tslib = require("tslib");

var _messageSender = require("./core/messageSender");

var _errors = require("./util/errors");

var _coreAmqp = require("@azure/core-amqp");

var _modelsToBeSharedWithEventHubs = require("./modelsToBeSharedWithEventHubs");

var _api = require("@opentelemetry/api");

var _log = require("./log");

var _serviceBusError = require("./serviceBusError");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * @class ServiceBusSenderImpl
 * @implements {ServiceBusSender}
 */
class ServiceBusSenderImpl {
  /**
   * @internal
   * @throws Error if the underlying connection is closed.
   */
  constructor(_context, _entityPath, retryOptions = {}) {
    this._context = _context;
    this._entityPath = _entityPath;
    /**
     * @property Denotes if close() was called on this sender
     */

    this._isClosed = false;
    (0, _errors.throwErrorIfConnectionClosed)(_context);
    this.entityPath = _entityPath;
    this._sender = _messageSender.MessageSender.create(this._context, _entityPath, retryOptions);
    this._retryOptions = retryOptions;
  }

  get logPrefix() {
    return `[${this._context.connectionId}|sender:${this.entityPath}]`;
  }

  _throwIfSenderOrConnectionClosed() {
    (0, _errors.throwErrorIfConnectionClosed)(this._context);

    if (this.isClosed) {
      const errorMessage = (0, _errors.getSenderClosedErrorMsg)(this._entityPath);
      const error = new Error(errorMessage);

      _log.senderLogger.logError(error, `[${this._context.connectionId}] is closed`);

      throw error;
    }
  }

  get isClosed() {
    return this._isClosed || this._context.wasConnectionCloseCalled;
  }

  sendMessages(messages, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfSenderOrConnectionClosed();

      (0, _errors.throwTypeErrorIfParameterMissing)(this._context.connectionId, "messages", messages);
      const invalidTypeErrMsg = "Provided value for 'messages' must be of type ServiceBusMessage, ServiceBusMessageBatch or an array of type ServiceBusMessage.";
      let batch;

      if (isServiceBusMessageBatch(messages)) {
        batch = messages;
      } else {
        if (!Array.isArray(messages)) {
          messages = [messages];
        }

        batch = yield this.createMessageBatch(options);

        for (const message of messages) {
          (0, _errors.throwIfNotValidServiceBusMessage)(message, invalidTypeErrMsg);

          if (!batch.tryAddMessage(message, {
            parentSpan: (0, _modelsToBeSharedWithEventHubs.getParentSpan)(options === null || options === void 0 ? void 0 : options.tracingOptions)
          })) {
            // this is too big - throw an error
            throw new _serviceBusError.ServiceBusError("Messages were too big to fit in a single batch. Remove some messages and try again or create your own batch using createBatch(), which gives more fine-grained control.", "MessageSizeExceeded");
          }
        }
      }

      const sendSpan = (0, _modelsToBeSharedWithEventHubs.createSendSpan)((0, _modelsToBeSharedWithEventHubs.getParentSpan)(options === null || options === void 0 ? void 0 : options.tracingOptions), batch._messageSpanContexts, this.entityPath, this._context.config.host);

      try {
        const result = yield this._sender.sendBatch(batch, options);
        sendSpan.setStatus({
          code: _api.CanonicalCode.OK
        });
        return result;
      } catch (error) {
        sendSpan.setStatus({
          code: _api.CanonicalCode.UNKNOWN,
          message: error.message
        });
        throw error;
      } finally {
        sendSpan.end();
      }
    });
  }

  createMessageBatch(options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfSenderOrConnectionClosed();

      return this._sender.createBatch(options);
    });
  }

  scheduleMessages(messages, scheduledEnqueueTimeUtc, options = {}) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfSenderOrConnectionClosed();

      (0, _errors.throwTypeErrorIfParameterMissing)(this._context.connectionId, "scheduledEnqueueTimeUtc", scheduledEnqueueTimeUtc);
      (0, _errors.throwTypeErrorIfParameterMissing)(this._context.connectionId, "messages", messages);
      const messagesToSchedule = Array.isArray(messages) ? messages : [messages];

      for (const message of messagesToSchedule) {
        (0, _errors.throwIfNotValidServiceBusMessage)(message, "Provided value for 'messages' must be of type ServiceBusMessage or an array of type ServiceBusMessage.");
      }

      const scheduleMessageOperationPromise = () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        return this._context.getManagementClient(this._entityPath).scheduleMessages(scheduledEnqueueTimeUtc, messagesToSchedule, Object.assign(Object.assign({}, options), {
          associatedLinkName: this._sender.name,
          requestName: "scheduleMessages",
          timeoutInMs: this._retryOptions.timeoutInMs
        }));
      });

      const config = {
        operation: scheduleMessageOperationPromise,
        connectionId: this._context.connectionId,
        operationType: _coreAmqp.RetryOperationType.management,
        retryOptions: this._retryOptions,
        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
      };
      return (0, _coreAmqp.retry)(config);
    });
  }

  cancelScheduledMessages(sequenceNumbers, options = {}) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this._throwIfSenderOrConnectionClosed();

      (0, _errors.throwTypeErrorIfParameterMissing)(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
      (0, _errors.throwTypeErrorIfParameterNotLong)(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
      const sequenceNumbersToCancel = Array.isArray(sequenceNumbers) ? sequenceNumbers : [sequenceNumbers];

      const cancelSchedulesMessagesOperationPromise = () => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        return this._context.getManagementClient(this._entityPath).cancelScheduledMessages(sequenceNumbersToCancel, Object.assign(Object.assign({}, options), {
          associatedLinkName: this._sender.name,
          requestName: "cancelScheduledMessages",
          timeoutInMs: this._retryOptions.timeoutInMs
        }));
      });

      const config = {
        operation: cancelSchedulesMessagesOperationPromise,
        connectionId: this._context.connectionId,
        operationType: _coreAmqp.RetryOperationType.management,
        retryOptions: this._retryOptions,
        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
      };
      return (0, _coreAmqp.retry)(config);
    });
  } // async open(options?: OperationOptionsBase): Promise<void> {
  //   this._throwIfSenderOrConnectionClosed();
  //   const config: RetryConfig<void> = {
  //     // TODO: Pass tracing options too
  //     operation: () => this._sender.open(undefined, options?.abortSignal),
  //     connectionId: this._context.connectionId,
  //     operationType: RetryOperationType.senderLink,
  //     retryOptions: this._retryOptions,
  //     abortSignal: options?.abortSignal
  //   };
  //   return retry<void>(config);
  // }


  close() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      try {
        this._isClosed = true;
        yield this._sender.close();
      } catch (err) {
        _log.senderLogger.logError(err, `${this.logPrefix} An error occurred while closing the Sender`);

        throw err;
      }
    });
  }

}
/**
 * @internal
 * @hidden
 */


exports.ServiceBusSenderImpl = ServiceBusSenderImpl;

function isServiceBusMessageBatch(messageBatchOrAnything) {
  if (messageBatchOrAnything == null) {
    return false;
  }

  const possibleBatch = messageBatchOrAnything;
  return typeof possibleBatch.tryAddMessage === "function" && typeof possibleBatch.maxSizeInBytes === "number" && typeof possibleBatch.sizeInBytes === "number";
}
},{"tslib":"CvJj","./core/messageSender":"jzJG","./util/errors":"TKJx","@azure/core-amqp":"n95d","./modelsToBeSharedWithEventHubs":"xWS9","@opentelemetry/api":"fNAU","./log":"IupI","./serviceBusError":"tdxx"}],"p5Ip":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessageSession = void 0;

var _tslib = require("tslib");

var _coreAmqp = require("@azure/core-amqp");

var _rheaPromise = require("rhea-promise");

var _linkEntity = require("../core/linkEntity");

var _log = require("../log");

var _serviceBusMessage = require("../serviceBusMessage");

var _errors = require("../util/errors");

var _utils = require("../util/utils");

var _batchingReceiver = require("../core/batchingReceiver");

var _shared = require("../core/shared");

var _abortController = require("@azure/abort-controller");

var _receiverHelper = require("../core/receiverHelper");

var _serviceBusError = require("../serviceBusError");

var _shared2 = require("../receivers/shared");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * @internal
 * @hidden
 * Describes the receiver for a Message Session.
 */
class MessageSession extends _linkEntity.LinkEntity {
  /**
   * Constructs a MessageSession instance which lets you receive messages as batches
   * or via callbacks using subscribe.
   *
   * @param _providedSessionId The sessionId provided by the user. This can be the
   * name of a session ID to open (empty string is also valid) or it can be undefined,
   * to indicate we want the next unlocked non-empty session.
   */
  constructor(context, entityPath, _providedSessionId, options) {
    super(entityPath, entityPath, context, "session", _log.receiverLogger, {
      address: entityPath,
      audience: `${context.config.endpoint}${entityPath}`
    });
    this._providedSessionId = _providedSessionId;
    /**
     * @property {number} [maxConcurrentCalls] The maximum number of messages that should be
     * processed concurrently in a session while in streaming mode. Once this limit has been reached,
     * more messages will not be received until the user's message handler has completed processing current message.
     * - **Default**: `1` (message in a session at a time).
     */

    this.maxConcurrentCalls = 1;
    /**
     * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that
     * are being actively disposed. It acts as a store for correlating the responses received for
     * active dispositions.
     */

    this._deliveryDispositionMap = new Map();
    this._receiverHelper = new _receiverHelper.ReceiverHelper(() => ({
      receiver: this.link,
      logPrefix: this.logPrefix
    }));
    if (!options) options = {};
    this.autoComplete = false;
    if (this._providedSessionId != undefined) this.sessionId = this._providedSessionId;
    this.receiveMode = options.receiveMode || "peekLock";
    this.maxAutoRenewDurationInMs = options.maxAutoLockRenewalDurationInMs != null ? options.maxAutoLockRenewalDurationInMs : 300 * 1000;
    this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;
    this.autoRenewLock = this.maxAutoRenewDurationInMs > 0 && this.receiveMode === "peekLock";
    this._isReceivingMessagesForSubscriber = false;
    this._batchingReceiverLite = new _batchingReceiver.BatchingReceiverLite(context, entityPath, _abortSignal => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return this.link;
    }), this.receiveMode); // setting all the handlers

    this._onSettled = context => {
      const delivery = context.delivery;
      (0, _shared.onMessageSettled)(this.logPrefix, delivery, this._deliveryDispositionMap);
    };

    this._notifyError = args => {
      if (this._onError) {
        this._onError(args);

        _log.receiverLogger.verbose("%s Notified the user's error handler about the error received by the Receiver", this.logPrefix);
      }
    };

    this._onAmqpError = context => {
      const receiverError = context.receiver && context.receiver.error;

      if (receiverError) {
        const sbError = (0, _serviceBusError.translateServiceBusError)(receiverError);

        if (sbError.code === "SessionLockLostError") {
          sbError.message = `The session lock has expired on the session with id ${this.sessionId}.`;
        }

        _log.receiverLogger.logError(sbError, "%s An error occurred for Receiver", this.logPrefix);

        this._notifyError({
          error: sbError,
          errorSource: "receive",
          entityPath: this.entityPath,
          fullyQualifiedNamespace: this._context.config.host
        });
      }
    };

    this._onSessionError = context => {
      const connectionId = this._context.connectionId;
      const sessionError = context.session && context.session.error;

      if (sessionError) {
        const sbError = (0, _serviceBusError.translateServiceBusError)(sessionError);

        _log.receiverLogger.logError(sbError, "[%s] An error occurred on the session for Receiver '%s': %O.", connectionId, this.name, sbError);

        this._notifyError({
          error: sbError,
          errorSource: "receive",
          entityPath: this.entityPath,
          fullyQualifiedNamespace: this._context.config.host
        });
      }
    };

    this._onAmqpClose = context => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const connectionId = this._context.connectionId;
      const receiverError = context.receiver && context.receiver.error;
      const receiver = this.link || context.receiver;

      if (receiverError) {
        const sbError = (0, _serviceBusError.translateServiceBusError)(receiverError);

        _log.receiverLogger.logError(sbError, "[%s] 'receiver_close' event occurred for receiver '%s' for sessionId '%s'. " + "The associated error is: %O", connectionId, this.name, this.sessionId, sbError); // no need to notify the user's error handler since rhea guarantees that receiver_error
        // will always be emitted before receiver_close.

      }

      if (receiver && !receiver.isItselfClosed()) {
        _log.receiverLogger.verbose("%s 'receiver_close' event occurred on the receiver for sessionId '%s' " + "and the sdk did not initiate this. Hence, let's gracefully close the receiver.", this.logPrefix, this.sessionId);

        try {
          yield this.close();
        } catch (err) {
          _log.receiverLogger.logError(err, "%s An error occurred while closing the receiver for sessionId '%s'.", this.logPrefix, this.sessionId);
        }
      } else {
        _log.receiverLogger.verbose("%s 'receiver_close' event occurred on the receiver for sessionId '%s' " + "because the sdk initiated it. Hence no need to gracefully close the receiver", this.logPrefix, this.sessionId);
      }
    });

    this._onSessionClose = context => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const receiver = this.link || context.receiver;
      const sessionError = context.session && context.session.error;

      if (sessionError) {
        const sbError = (0, _serviceBusError.translateServiceBusError)(sessionError);

        _log.receiverLogger.logError(sbError, "%s 'session_close' event occurred for receiver for sessionId '%s'. " + "The associated error is", this.logPrefix, this.sessionId); // no need to notify the user's error handler since rhea guarantees that session_error
        // will always be emitted before session_close.

      }

      if (receiver && !receiver.isSessionItselfClosed()) {
        _log.receiverLogger.verbose("%s 'session_close' event occurred on the receiver for sessionId '%s' " + "and the sdk did not initiate this. Hence, let's gracefully close the receiver.", this.logPrefix, this.sessionId);

        try {
          yield this.close();
        } catch (err) {
          _log.receiverLogger.logError(err, "%s An error occurred while closing the receiver for sessionId '%s'", this.logPrefix, this.sessionId);
        }
      } else {
        _log.receiverLogger.verbose("%s 'session_close' event occurred on the receiver for sessionId'%s' " + "because the sdk initiated it. Hence no need to gracefully close the receiver", this.logPrefix, this.sessionId);
      }
    });
  }
  /**
   * Denotes if we are currently receiving messages
   */


  get isReceivingMessages() {
    return this._batchingReceiverLite.isReceivingMessages || this._isReceivingMessagesForSubscriber;
  }

  get receiverHelper() {
    return this._receiverHelper;
  }
  /**
   * Ensures that the session lock is renewed before it expires. The lock will not be renewed for
   * more than the configured totalAutoLockRenewDuration.
   */


  _ensureSessionLockRenewal() {
    if (this.autoRenewLock && new Date(this._totalAutoLockRenewDuration) > this.sessionLockedUntilUtc && Date.now() < this._totalAutoLockRenewDuration && this.isOpen()) {
      const nextRenewalTimeout = (0, _utils.calculateRenewAfterDuration)(this.sessionLockedUntilUtc);
      this._sessionLockRenewalTimer = setTimeout(() => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        try {
          _log.receiverLogger.verbose("%s Attempting to renew the session lock for MessageSession '%s' " + "with name '%s'.", this.logPrefix, this.sessionId, this.name);

          this.sessionLockedUntilUtc = yield this._context.getManagementClient(this.entityPath).renewSessionLock(this.sessionId, {
            associatedLinkName: this.name,
            timeoutInMs: 10000
          });

          _log.receiverLogger.verbose("%s Successfully renewed the session lock for MessageSession '%s' " + "with name '%s'.", this.logPrefix, this.sessionId, this.name);

          _log.receiverLogger.verbose("%s Calling _ensureSessionLockRenewal() again for MessageSession '%s'.", this.logPrefix, this.sessionId);

          this._ensureSessionLockRenewal();
        } catch (err) {
          _log.receiverLogger.logError(err, "%s An error occurred while renewing the session lock for MessageSession '%s'", this.logPrefix, this.sessionId);
        }
      }), nextRenewalTimeout);

      _log.receiverLogger.verbose("%s MessageSession '%s' has next session lock renewal in %d milliseconds @(%s).", this.logPrefix, this.sessionId, nextRenewalTimeout, new Date(Date.now() + nextRenewalTimeout).toString());
    }
  }

  createRheaLink(options, _abortSignal) {
    return this._context.connection.createReceiver(options);
  }
  /**
   * Creates a new AMQP receiver under a new AMQP session.
   */


  _init(abortSignal) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      try {
        const options = this._createMessageSessionOptions();

        yield this.initLink(options, abortSignal);

        if (this.link == null) {
          throw new Error("INTERNAL ERROR: failed to create receiver but without an error.");
        }

        const receivedSessionId = this.link.source && this.link.source.filter && this.link.source.filter[_coreAmqp.Constants.sessionFilterName];
        let errorMessage = "";

        if (this._providedSessionId == null && receivedSessionId == null) {
          // Ideally this code path should never be reached as `MessageSession.createReceiver()` should fail instead
          // TODO: https://github.com/Azure/azure-sdk-for-js/issues/9775 to figure out why this code path indeed gets hit.
          errorMessage = `Failed to create a receiver. No unlocked sessions available.`;
        } else if (this._providedSessionId != null && receivedSessionId !== this._providedSessionId) {
          // This code path is reached if the session is already locked by another receiver.
          // TODO: Check why the service would not throw an error or just timeout instead of giving a misleading successful receiver
          errorMessage = `Failed to create a receiver for the requested session '${this._providedSessionId}'. It may be locked by another receiver.`;
        }

        if (errorMessage) {
          const error = (0, _serviceBusError.translateServiceBusError)({
            description: errorMessage,
            condition: _coreAmqp.ErrorNameConditionMapper.SessionCannotBeLockedError
          });

          _log.receiverLogger.logError(error, this.logPrefix);

          throw error;
        }

        if (this._providedSessionId == null) this.sessionId = receivedSessionId;
        this.sessionLockedUntilUtc = (0, _utils.convertTicksToDate)(this.link.properties["com.microsoft:locked-until-utc"]);

        _log.receiverLogger.verbose("%s Session with id '%s' is locked until: '%s'.", this.logPrefix, this.sessionId, this.sessionLockedUntilUtc.toISOString());

        _log.receiverLogger.verbose("%s Receiver created with receiver options: %O", this.logPrefix, options);

        if (!this._context.messageSessions[this.name]) {
          this._context.messageSessions[this.name] = this;
        }

        this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;

        this._ensureSessionLockRenewal();
      } catch (err) {
        const errObj = (0, _serviceBusError.translateServiceBusError)(err);

        _log.receiverLogger.logError(errObj, "%s An error occured while creating the receiver", this.logPrefix); // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.


        if (errObj.code === "OperationTimeoutError") {
          if (this._providedSessionId) {
            errObj.message = `Failed to create a receiver for the requested session '${this._providedSessionId}' within allocated time and retry attempts.`;
          } else {
            errObj.message = "Failed to create a receiver within allocated time and retry attempts.";
          }
        }

        throw errObj;
      }
    });
  }
  /**
   * Creates the options that need to be specified while creating an AMQP receiver link.
   */


  _createMessageSessionOptions() {
    const rcvrOptions = (0, _shared.createReceiverOptions)(this.name, this.receiveMode, {
      address: this.address,
      filter: {
        [_coreAmqp.Constants.sessionFilterName]: this.sessionId
      }
    }, {
      onClose: context => this._onAmqpClose(context).catch(() => {
        /* */
      }),
      onSessionClose: context => this._onSessionClose(context).catch(() => {
        /* */
      }),
      onError: this._onAmqpError,
      onSessionError: this._onSessionError,
      onSettled: this._onSettled
    });
    return rcvrOptions;
  }
  /**
   * Closes the underlying AMQP receiver link.
   */


  close() {
    const _super = Object.create(null, {
      close: {
        get: () => super.close
      }
    });

    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      try {
        this._isReceivingMessagesForSubscriber = false;
        if (this._sessionLockRenewalTimer) clearTimeout(this._sessionLockRenewalTimer);

        _log.receiverLogger.verbose("%s Cleared the timers for 'no new message received' task and " + "'session lock renewal' task.", this.logPrefix);

        yield _super.close.call(this);
        yield this._batchingReceiverLite.close();
      } catch (err) {
        _log.receiverLogger.logError(err, "%s An error occurred while closing the message session with id '%s'", this.logPrefix, this.sessionId);
      }
    });
  }
  /**
   * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
   */


  isOpen() {
    const result = this.link && this.link.isOpen();

    _log.receiverLogger.verbose("%s Receiver for sessionId '%s' is open? -> %s", this.logPrefix, this.sessionId, result);

    return result;
  }
  /**
   * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
   * from a Queue/Subscription.
   * To stop receiving messages, call `close()` on the SessionReceiver or set the property
   * `newMessageWaitTimeoutInMs` in the options to provide a timeout.
   *
   * @param onMessage - Handler for processing each incoming message.
   * @param onError - Handler for any error that occurs while receiving or processing messages.
   * @param options - Options to control whether messages should be automatically completed. You can
   * also provide a timeout in milliseconds to denote the amount of time to wait for a new message
   * before closing the receiver.
   *
   * @returns void
   */


  subscribe(onMessage, onError, options) {
    var _a;

    if (!options) options = {};

    if ((_a = options.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {
      throw new _abortController.AbortError(_utils.StandardAbortMessage);
    }

    this._isReceivingMessagesForSubscriber = true;

    if (typeof options.maxConcurrentCalls === "number" && options.maxConcurrentCalls > 0) {
      this.maxConcurrentCalls = options.maxConcurrentCalls;
    } // If explicitly set to false then autoComplete is false else true (default).


    this.autoComplete = options.autoCompleteMessages === false ? options.autoCompleteMessages : true;
    this._onMessage = onMessage;
    this._onError = onError;

    if (this.link && this.link.isOpen()) {
      const onSessionMessage = context => (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
        // If the receiver got closed in PeekLock mode, avoid processing the message as we
        // cannot settle the message.
        if (this.receiveMode === "peekLock" && (!this.link || !this.link.isOpen())) {
          _log.receiverLogger.verbose("%s Not calling the user's message handler for the current message " + "as the receiver is closed", this.logPrefix);

          return;
        }

        const bMessage = new _serviceBusMessage.ServiceBusMessageImpl(context.message, context.delivery, true, this.receiveMode);

        try {
          yield this._onMessage(bMessage);
        } catch (err) {
          _log.receiverLogger.logError(err, "%s An error occurred while running user's message handler for the message " + "with id '%s' on the receiver", this.logPrefix, bMessage.messageId);

          this._onError({
            error: err,
            errorSource: "processMessageCallback",
            entityPath: this.entityPath,
            fullyQualifiedNamespace: this._context.config.host
          });

          const error = (0, _serviceBusError.translateServiceBusError)(err); // Nothing much to do if user's message handler throws. Let us try abandoning the message.

          if (!bMessage.delivery.remote_settled && this.receiveMode === "peekLock" && this.isOpen() // only try to abandon the messages if the connection is still open
          ) {
              try {
                _log.receiverLogger.logError(error, "%s Abandoning the message with id '%s' on the receiver since an error occured", this.logPrefix, bMessage.messageId);

                yield (0, _shared2.abandonMessage)(bMessage, this._context, this.entityPath);
              } catch (abandonError) {
                const translatedError = (0, _serviceBusError.translateServiceBusError)(abandonError);

                _log.receiverLogger.logError(translatedError, "%s An error occurred while abandoning the message with id '%s' on the " + "receiver", this.logPrefix, bMessage.messageId, translatedError);

                this._notifyError({
                  error: translatedError,
                  errorSource: "abandon",
                  entityPath: this.entityPath,
                  fullyQualifiedNamespace: this._context.config.host
                });
              }
            }

          return;
        } finally {
          this.receiverHelper.addCredit(1);
        } // If we've made it this far, then user's message handler completed fine. Let us try
        // completing the message.


        if (this.autoComplete && this.receiveMode === "peekLock" && !bMessage.delivery.remote_settled) {
          try {
            _log.receiverLogger.verbose("%s Auto completing the message with id '%s' on the receiver.", this.logPrefix, bMessage.messageId);

            yield (0, _shared2.completeMessage)(bMessage, this._context, this.entityPath);
          } catch (completeError) {
            const translatedError = (0, _serviceBusError.translateServiceBusError)(completeError);

            _log.receiverLogger.logError(translatedError, "%s An error occurred while completing the message with id '%s' on the " + "receiver", this.logPrefix, bMessage.messageId);

            this._notifyError({
              error: translatedError,
              errorSource: "complete",
              entityPath: this.entityPath,
              fullyQualifiedNamespace: this._context.config.host
            });
          }
        }
      }); // setting the "message" event listener.


      this.link.on(_rheaPromise.ReceiverEvents.message, onSessionMessage); // adding credit

      this.receiverHelper.addCredit(this.maxConcurrentCalls);
    } else {
      this._isReceivingMessagesForSubscriber = false;
      const msg = `MessageSession with sessionId '${this.sessionId}' and name '${this.name}' ` + `has either not been created or is not open.`;

      _log.receiverLogger.verbose("[%s] %s", this._context.connectionId, msg);

      this._notifyError({
        error: new Error(msg),
        // This is _probably_ the right error code since we require that
        // the message session is created before we even give back the receiver. So it not
        // being open at this point is either:
        //
        // 1. we didn't acquire the lock
        // 2. the connection was broken (we don't reconnect)
        //
        // If any of these becomes untrue you'll probably want to re-evaluate this classification.
        errorSource: "receive",
        entityPath: this.entityPath,
        fullyQualifiedNamespace: this._context.config.host
      });
    }
  }
  /**
   * Returns a batch of messages based on given count and timeout over an AMQP receiver link
   * from a Queue/Subscription.
   *
   * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.
   * @param maxWaitTimeInMs The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.
   * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
   * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.
   */


  receiveMessages(maxMessageCount, maxWaitTimeInMs, maxTimeAfterFirstMessageInMs, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      try {
        return yield this._batchingReceiverLite.receiveMessages(Object.assign({
          maxMessageCount,
          maxWaitTimeInMs,
          maxTimeAfterFirstMessageInMs
        }, options));
      } catch (error) {
        _log.receiverLogger.logError(error, `${this.logPrefix} Rejecting receiveMessages() with error`);

        throw error;
      }
    });
  }
  /**
   * Settles the message with the specified disposition.
   * @param message The ServiceBus Message that needs to be settled.
   * @param operation The disposition type.
   * @param options Optional parameters that can be provided while disposing the message.
   */


  settleMessage(message, operation, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return new Promise((resolve, reject) => {
        if (!options) options = {};

        if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {
          return reject(new Error(`operation: '${operation}' is not a valid operation.`));
        }

        const delivery = message.delivery;
        const timer = setTimeout(() => {
          this._deliveryDispositionMap.delete(delivery.id);

          _log.receiverLogger.verbose("[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. " + "Hence rejecting the promise with timeout error", this._context.connectionId, delivery.id, _coreAmqp.Constants.defaultOperationTimeoutInMs);

          const e = {
            condition: _coreAmqp.ErrorNameConditionMapper.ServiceUnavailableError,
            description: "Operation to settle the message has timed out. The disposition of the " + "message may or may not be successful"
          };
          return reject((0, _serviceBusError.translateServiceBusError)(e));
        }, _coreAmqp.Constants.defaultOperationTimeoutInMs);

        this._deliveryDispositionMap.set(delivery.id, {
          resolve: resolve,
          reject: reject,
          timer: timer
        });

        if (operation === _serviceBusMessage.DispositionType.complete) {
          delivery.accept();
        } else if (operation === _serviceBusMessage.DispositionType.abandon) {
          const params = {
            undeliverable_here: false
          };
          if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;
          delivery.modified(params);
        } else if (operation === _serviceBusMessage.DispositionType.defer) {
          const params = {
            undeliverable_here: true
          };
          if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;
          delivery.modified(params);
        } else if (operation === _serviceBusMessage.DispositionType.deadletter) {
          const error = {
            condition: _coreAmqp.Constants.deadLetterName,
            info: Object.assign(Object.assign({}, options.propertiesToModify), {
              DeadLetterReason: options.deadLetterReason,
              DeadLetterErrorDescription: options.deadLetterDescription
            })
          };
          delivery.reject(error);
        }
      });
    });
  }
  /**
   * Creates a new instance of the MessageSession based on the provided parameters.
   * @param context The client entity context
   * @param options Options that can be provided while creating the MessageSession.
   */


  static create(context, entityPath, sessionId, options) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _errors.throwErrorIfConnectionClosed)(context);
      const messageSession = new MessageSession(context, entityPath, sessionId, options);
      yield messageSession._init(options === null || options === void 0 ? void 0 : options.abortSignal);
      return messageSession;
    });
  }

}

exports.MessageSession = MessageSession;
},{"tslib":"CvJj","@azure/core-amqp":"n95d","rhea-promise":"fxSK","../core/linkEntity":"tkX2","../log":"IupI","../serviceBusMessage":"jl8f","../util/errors":"TKJx","../util/utils":"RXMg","../core/batchingReceiver":"LTH6","../core/shared":"Kut1","@azure/abort-controller":"wyb9","../core/receiverHelper":"pEjc","../serviceBusError":"tdxx","../receivers/shared":"i7Sv"}],"lqM8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractReceiverArguments = extractReceiverArguments;
exports.ServiceBusClient = void 0;

var _tslib = require("tslib");

var _coreAuth = require("@azure/core-auth");

var _constructorHelpers = require("./constructorHelpers");

var _connectionContext = require("./connectionContext");

var _receiver = require("./receivers/receiver");

var _sessionReceiver = require("./receivers/sessionReceiver");

var _sender = require("./sender");

var _errors = require("./util/errors");

var _messageSession = require("./session/messageSession");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * A client that can create Sender instances for sending messages to queues and
 * topics as well as Receiver instances to receive messages from queues and subscriptions.
 */
class ServiceBusClient {
  constructor(fullyQualifiedNamespaceOrConnectionString1, credentialOrOptions2, options3) {
    if ((0, _coreAuth.isTokenCredential)(credentialOrOptions2)) {
      const fullyQualifiedNamespace = fullyQualifiedNamespaceOrConnectionString1;
      const credential = credentialOrOptions2;
      this._clientOptions = options3 || {};
      this._connectionContext = (0, _constructorHelpers.createConnectionContextForTokenCredential)(credential, fullyQualifiedNamespace, this._clientOptions);
    } else {
      const connectionString = fullyQualifiedNamespaceOrConnectionString1;
      this._clientOptions = credentialOrOptions2 || {};
      this._connectionContext = (0, _constructorHelpers.createConnectionContextForConnectionString)(connectionString, this._clientOptions);
    }

    this.fullyQualifiedNamespace = this._connectionContext.config.host;
    this._clientOptions.retryOptions = this._clientOptions.retryOptions || {};
    const timeoutInMs = this._clientOptions.retryOptions.timeoutInMs;

    if (timeoutInMs != undefined && (typeof timeoutInMs !== "number" || !isFinite(timeoutInMs) || timeoutInMs <= 0)) {
      throw new Error(`${timeoutInMs} is an invalid value for retryOptions.timeoutInMs`);
    }
  }

  createReceiver(queueOrTopicName1, optionsOrSubscriptionName2, options3) {
    validateEntityPath(this._connectionContext.config, queueOrTopicName1); // NOTE: we don't currently have any options for this kind of receiver but
    // when we do make sure you pass them in and extract them.

    const {
      entityPath,
      receiveMode,
      options
    } = extractReceiverArguments(queueOrTopicName1, optionsOrSubscriptionName2, options3);
    let entityPathWithSubQueue = entityPath;

    if (options === null || options === void 0 ? void 0 : options.subQueueType) {
      switch (options === null || options === void 0 ? void 0 : options.subQueueType) {
        case "deadLetter":
          entityPathWithSubQueue += "/$DeadLetterQueue";
          break;

        case "transferDeadLetter":
          entityPathWithSubQueue += "/$Transfer/$DeadLetterQueue";
          break;

        default:
          throw new Error(`Invalid subQueueType '${options === null || options === void 0 ? void 0 : options.subQueueType}' provided. Valid values are 'deadLetter' and 'transferDeadLetter'`);
      }
    }

    const maxLockAutoRenewDurationInMs = (options === null || options === void 0 ? void 0 : options.maxAutoLockRenewalDurationInMs) != null ? options.maxAutoLockRenewalDurationInMs : 5 * 60 * 1000;
    return new _receiver.ServiceBusReceiverImpl(this._connectionContext, entityPathWithSubQueue, receiveMode, maxLockAutoRenewDurationInMs, this._clientOptions.retryOptions);
  }

  acceptSession(queueOrTopicName1, optionsOrSubscriptionNameOrSessionId2, optionsOrSessionId3, options4) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      validateEntityPath(this._connectionContext.config, queueOrTopicName1);
      let sessionId;
      let entityPath;
      let receiveMode;
      let options;

      if (typeof queueOrTopicName1 === "string" && typeof optionsOrSubscriptionNameOrSessionId2 === "string" && typeof optionsOrSessionId3 === "string") {
        // subscription constructor
        sessionId = optionsOrSessionId3;
        ({
          entityPath,
          receiveMode,
          options
        } = extractReceiverArguments(queueOrTopicName1, optionsOrSubscriptionNameOrSessionId2, // skip the session ID parameter (3)
        options4));
      } else if (typeof queueOrTopicName1 === "string" && typeof optionsOrSubscriptionNameOrSessionId2 === "string" && typeof optionsOrSessionId3 !== "string") {
        // queue constructor (but only because we know we're not a subscription constructor)
        sessionId = optionsOrSubscriptionNameOrSessionId2;
        ({
          entityPath,
          receiveMode,
          options
        } = extractReceiverArguments(queueOrTopicName1, // skip the session ID parameter (2)
        optionsOrSessionId3, undefined));
      } else {
        throw new Error("Unhandled set of parameters");
      }

      const messageSession = yield _messageSession.MessageSession.create(this._connectionContext, entityPath, sessionId, {
        maxAutoLockRenewalDurationInMs: options === null || options === void 0 ? void 0 : options.maxAutoLockRenewalDurationInMs,
        receiveMode,
        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
      });
      const sessionReceiver = new _sessionReceiver.ServiceBusSessionReceiverImpl(messageSession, this._connectionContext, entityPath, receiveMode, this._clientOptions.retryOptions);
      return sessionReceiver;
    });
  }

  acceptNextSession(queueOrTopicName1, optionsOrSubscriptionName2, options3) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      validateEntityPath(this._connectionContext.config, queueOrTopicName1);
      const {
        entityPath,
        receiveMode,
        options
      } = extractReceiverArguments(queueOrTopicName1, optionsOrSubscriptionName2, options3);
      const messageSession = yield _messageSession.MessageSession.create(this._connectionContext, entityPath, undefined, {
        maxAutoLockRenewalDurationInMs: options === null || options === void 0 ? void 0 : options.maxAutoLockRenewalDurationInMs,
        receiveMode,
        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
      });
      const sessionReceiver = new _sessionReceiver.ServiceBusSessionReceiverImpl(messageSession, this._connectionContext, entityPath, receiveMode, this._clientOptions.retryOptions);
      return sessionReceiver;
    });
  }
  /**
   * Creates a Sender which can be used to send messages, schedule messages to be
   * sent at a later time and cancel such scheduled messages. No connection is made
   * to the service until one of the methods on the sender is called.
   * @param queueOrTopicName The name of a queue or topic to send messages to.
   */


  createSender(queueOrTopicName) {
    validateEntityPath(this._connectionContext.config, queueOrTopicName);
    return new _sender.ServiceBusSenderImpl(this._connectionContext, queueOrTopicName, this._clientOptions.retryOptions);
  }
  /**
   * Closes the underlying AMQP connection.
   * NOTE: this will also disconnect any Receiver or Sender instances created from this
   * instance.
   */


  close() {
    return _connectionContext.ConnectionContext.close(this._connectionContext);
  }

}
/**
 * Helper to validate and extract the common arguments from both the create*Receiver() overloads that
 * have this pattern:
 *
 * queue, options
 * topic, subscription, options
 *
 * @internal
 * @hidden
 */


exports.ServiceBusClient = ServiceBusClient;

function extractReceiverArguments(queueOrTopicName1, optionsOrSubscriptionName2, definitelyOptions3) {
  let entityPath;
  let options;

  if (typeof optionsOrSubscriptionName2 === "string") {
    const topic = queueOrTopicName1;
    const subscription = optionsOrSubscriptionName2;
    entityPath = `${topic}/Subscriptions/${subscription}`;
    options = definitelyOptions3;
  } else {
    entityPath = queueOrTopicName1;
    options = optionsOrSubscriptionName2;
  }

  let receiveMode;

  if ((options === null || options === void 0 ? void 0 : options.receiveMode) == undefined || options.receiveMode === "peekLock") {
    receiveMode = "peekLock";
  } else if (options.receiveMode === "receiveAndDelete") {
    receiveMode = "receiveAndDelete";
  } else {
    throw new TypeError(`Invalid receiveMode '${options === null || options === void 0 ? void 0 : options.receiveMode}' provided. Valid values are 'peekLock' and 'receiveAndDelete'`);
  }

  options === null || options === void 0 ? true : delete options.receiveMode;
  return {
    entityPath,
    receiveMode,
    options
  };
}
/**
 * Validates that the EntityPath in the connection string (if any) matches with the
 * queue or topic name passed to the methods that create senders and receivers.
 *
 * @internal
 * @hidden
 */


function validateEntityPath(connectionConfig, queueOrTopicName) {
  if (connectionConfig.entityPath && connectionConfig.entityPath !== queueOrTopicName) {
    throw new Error(_errors.entityPathMisMatchError);
  }
}
},{"tslib":"CvJj","@azure/core-auth":"Ujm9","./constructorHelpers":"lfFE","./connectionContext":"VwcI","./receivers/receiver":"T1eE","./receivers/sessionReceiver":"oNPM","./sender":"x6kC","./util/errors":"TKJx","./session/messageSession":"p5Ip"}],"KgMV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseServiceBusConnectionString = parseServiceBusConnectionString;

var _coreAmqp = require("@azure/core-amqp");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Parses given connection string into the different properties applicable to Azure Service Bus.
 * The properties are useful to then construct a ServiceBusClient.
 * @param connectionString The connection string associated with the Shared Access Policy created
 * for the Service Bus namespace, queue or topic.
 */
function parseServiceBusConnectionString(connectionString) {
  const parsedResult = (0, _coreAmqp.parseConnectionString)(connectionString);

  if (!parsedResult.Endpoint) {
    throw new Error("Connection string should have an Endpoint key.");
  }

  if (parsedResult.SharedAccessSignature) {
    if (parsedResult.SharedAccessKey || parsedResult.SharedAccessKeyName) {
      throw new Error("Connection string cannot have both SharedAccessSignature and SharedAccessKey keys.");
    }
  } else if (parsedResult.SharedAccessKey && !parsedResult.SharedAccessKeyName) {
    throw new Error("Connection string with SharedAccessKey should have SharedAccessKeyName.");
  } else if (!parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {
    throw new Error("Connection string with SharedAccessKeyName should have SharedAccessKey as well.");
  }

  const output = {
    fullyQualifiedNamespace: (parsedResult.Endpoint.match(".*://([^/]*)") || [])[1],
    endpoint: parsedResult.Endpoint
  };

  if (parsedResult.EntityPath) {
    output.entityPath = parsedResult.EntityPath;
  }

  if (parsedResult.SharedAccessSignature) {
    output.sharedAccessSignature = parsedResult.SharedAccessSignature;
  }

  if (parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {
    output.sharedAccessKey = parsedResult.SharedAccessKey;
    output.sharedAccessKeyName = parsedResult.SharedAccessKeyName;
  }

  return output;
}
},{"@azure/core-amqp":"n95d"}],"yEP6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "delay", {
  enumerable: true,
  get: function () {
    return _coreAmqp.delay;
  }
});
Object.defineProperty(exports, "MessagingError", {
  enumerable: true,
  get: function () {
    return _coreAmqp.MessagingError;
  }
});
Object.defineProperty(exports, "TokenType", {
  enumerable: true,
  get: function () {
    return _coreAmqp.TokenType;
  }
});
Object.defineProperty(exports, "ServiceBusAdministrationClient", {
  enumerable: true,
  get: function () {
    return _serviceBusAtomManagementClient.ServiceBusAdministrationClient;
  }
});
Object.defineProperty(exports, "ServiceBusClient", {
  enumerable: true,
  get: function () {
    return _serviceBusClient.ServiceBusClient;
  }
});
Object.defineProperty(exports, "isServiceBusError", {
  enumerable: true,
  get: function () {
    return _serviceBusError.isServiceBusError;
  }
});
Object.defineProperty(exports, "ServiceBusError", {
  enumerable: true,
  get: function () {
    return _serviceBusError.ServiceBusError;
  }
});
Object.defineProperty(exports, "parseServiceBusConnectionString", {
  enumerable: true,
  get: function () {
    return _connectionStringUtils.parseServiceBusConnectionString;
  }
});

var _coreAmqp = require("@azure/core-amqp");

var _serviceBusAtomManagementClient = require("./serviceBusAtomManagementClient");

var _serviceBusClient = require("./serviceBusClient");

var _serviceBusError = require("./serviceBusError");

var _connectionStringUtils = require("./util/connectionStringUtils");
},{"@azure/core-amqp":"n95d","./serviceBusAtomManagementClient":"XwmX","./serviceBusClient":"lqM8","./serviceBusError":"tdxx","./util/connectionStringUtils":"KgMV"}],"THws":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAdminClient = exports.getClient = void 0;

var service_bus_1 = require("@azure/service-bus");

function getClient(connection) {
  switch (connection.connectionType) {
    case 0:
      var connectionDetails = connection.connectionDetails;
      return new service_bus_1.ServiceBusClient(connectionDetails.connectionString);

    default:
      throw new Error("Connection type not supported yet, cannot create client");
  }
}

exports.getClient = getClient;

function getAdminClient(connection) {
  switch (connection.connectionType) {
    case 0:
      var connectionDetails = connection.connectionDetails;
      return new service_bus_1.ServiceBusAdministrationClient(connectionDetails.connectionString);

    default:
      throw new Error("Connection type not supported yet, cannot create client");
  }
}

exports.getAdminClient = getAdminClient;
},{"@azure/service-bus":"yEP6"}]},{},["THws"], "servicebusConnections")
//# sourceMappingURL=/servicebus.js.map