(() => {
var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequirea7fb"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequirea7fb"] = parcelRequire;
}
parcelRequire.register("5uO90", function(module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var $gDDBB = parcelRequire("gDDBB");
var $4006a6b5a4b55f24$var$getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for(var i = 0; i < keys.length; i++)descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    return descriptors;
};
var $4006a6b5a4b55f24$var$formatRegExp = /%[sdj%]/g;
module.exports.format = function(f) {
    if (!$4006a6b5a4b55f24$var$isString(f)) {
        var objects = [];
        for(var i = 0; i < arguments.length; i++)objects.push($4006a6b5a4b55f24$var$inspect(arguments[i]));
        return objects.join(" ");
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace($4006a6b5a4b55f24$var$formatRegExp, function(x) {
        if (x === "%%") return "%";
        if (i >= len) return x;
        switch(x){
            case "%s":
                return String(args[i++]);
            case "%d":
                return Number(args[i++]);
            case "%j":
                try {
                    return JSON.stringify(args[i++]);
                } catch (_) {
                    return "[Circular]";
                }
            default:
                return x;
        }
    });
    for(var x = args[i]; i < len; x = args[++i])if ($4006a6b5a4b55f24$var$isNull(x) || !$4006a6b5a4b55f24$var$isObject(x)) str += " " + x;
    else str += " " + $4006a6b5a4b55f24$var$inspect(x);
    return str;
};
// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
module.exports.deprecate = function(fn, msg) {
    if (typeof $gDDBB !== "undefined" && $gDDBB.noDeprecation === true) return fn;
    // Allow for deprecating things in the process of starting up.
    if (typeof $gDDBB === "undefined") return function() {
        return module.exports.deprecate(fn, msg).apply(this, arguments);
    };
    var warned = false;
    function deprecated() {
        if (!warned) {
            if ($gDDBB.throwDeprecation) throw new Error(msg);
            else if ($gDDBB.traceDeprecation) console.trace(msg);
            else console.error(msg);
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
};
var $4006a6b5a4b55f24$var$debugs = {};
var $4006a6b5a4b55f24$var$debugEnvRegex = /^$/;
var $4006a6b5a4b55f24$var$debugEnv;
module.exports.debuglog = function(set) {
    set = set.toUpperCase();
    if (!$4006a6b5a4b55f24$var$debugs[set]) {
        if ($4006a6b5a4b55f24$var$debugEnvRegex.test(set)) {
            var pid = $gDDBB.pid;
            $4006a6b5a4b55f24$var$debugs[set] = function() {
                var msg = module.exports.format.apply(module.exports, arguments);
                console.error("%s %d: %s", set, pid, msg);
            };
        } else $4006a6b5a4b55f24$var$debugs[set] = function() {};
    }
    return $4006a6b5a4b55f24$var$debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function $4006a6b5a4b55f24$var$inspect(obj, opts) {
    // default options
    var ctx = {
        seen: [],
        stylize: $4006a6b5a4b55f24$var$stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if ($4006a6b5a4b55f24$var$isBoolean(opts)) // legacy...
    ctx.showHidden = opts;
    else if (opts) // got an "options" object
    module.exports._extend(ctx, opts);
    // set default options
    if ($4006a6b5a4b55f24$var$isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if ($4006a6b5a4b55f24$var$isUndefined(ctx.depth)) ctx.depth = 2;
    if ($4006a6b5a4b55f24$var$isUndefined(ctx.colors)) ctx.colors = false;
    if ($4006a6b5a4b55f24$var$isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = $4006a6b5a4b55f24$var$stylizeWithColor;
    return $4006a6b5a4b55f24$var$formatValue(ctx, obj, ctx.depth);
}
module.exports.inspect = $4006a6b5a4b55f24$var$inspect;
// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
$4006a6b5a4b55f24$var$inspect.colors = {
    "bold": [
        1,
        22
    ],
    "italic": [
        3,
        23
    ],
    "underline": [
        4,
        24
    ],
    "inverse": [
        7,
        27
    ],
    "white": [
        37,
        39
    ],
    "grey": [
        90,
        39
    ],
    "black": [
        30,
        39
    ],
    "blue": [
        34,
        39
    ],
    "cyan": [
        36,
        39
    ],
    "green": [
        32,
        39
    ],
    "magenta": [
        35,
        39
    ],
    "red": [
        31,
        39
    ],
    "yellow": [
        33,
        39
    ]
};
// Don't use 'blue' not visible on cmd.exe
$4006a6b5a4b55f24$var$inspect.styles = {
    "special": "cyan",
    "number": "yellow",
    "boolean": "yellow",
    "undefined": "grey",
    "null": "bold",
    "string": "green",
    "date": "magenta",
    // "name": intentionally not styling
    "regexp": "red"
};
function $4006a6b5a4b55f24$var$stylizeWithColor(str, styleType) {
    var style = $4006a6b5a4b55f24$var$inspect.styles[styleType];
    if (style) return "\x1b[" + $4006a6b5a4b55f24$var$inspect.colors[style][0] + "m" + str + "\x1b[" + $4006a6b5a4b55f24$var$inspect.colors[style][1] + "m";
    else return str;
}
function $4006a6b5a4b55f24$var$stylizeNoColor(str, styleType) {
    return str;
}
function $4006a6b5a4b55f24$var$arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
        hash[val] = true;
    });
    return hash;
}
function $4006a6b5a4b55f24$var$formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect && value && $4006a6b5a4b55f24$var$isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== module.exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!$4006a6b5a4b55f24$var$isString(ret)) ret = $4006a6b5a4b55f24$var$formatValue(ctx, ret, recurseTimes);
        return ret;
    }
    // Primitive types cannot have properties
    var primitive = $4006a6b5a4b55f24$var$formatPrimitive(ctx, value);
    if (primitive) return primitive;
    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = $4006a6b5a4b55f24$var$arrayToHash(keys);
    if (ctx.showHidden) keys = Object.getOwnPropertyNames(value);
    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if ($4006a6b5a4b55f24$var$isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) return $4006a6b5a4b55f24$var$formatError(value);
    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
        if ($4006a6b5a4b55f24$var$isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
        }
        if ($4006a6b5a4b55f24$var$isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        if ($4006a6b5a4b55f24$var$isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), "date");
        if ($4006a6b5a4b55f24$var$isError(value)) return $4006a6b5a4b55f24$var$formatError(value);
    }
    var base = "", array = false, braces = [
        "{",
        "}"
    ];
    // Make Array say that they are Array
    if ($4006a6b5a4b55f24$var$isArray(value)) {
        array = true;
        braces = [
            "[",
            "]"
        ];
    }
    // Make functions say that they are functions
    if ($4006a6b5a4b55f24$var$isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
    }
    // Make RegExps say that they are RegExps
    if ($4006a6b5a4b55f24$var$isRegExp(value)) base = " " + RegExp.prototype.toString.call(value);
    // Make dates with properties first say the date
    if ($4006a6b5a4b55f24$var$isDate(value)) base = " " + Date.prototype.toUTCString.call(value);
    // Make error with message first say the error
    if ($4006a6b5a4b55f24$var$isError(value)) base = " " + $4006a6b5a4b55f24$var$formatError(value);
    if (keys.length === 0 && (!array || value.length == 0)) return braces[0] + base + braces[1];
    if (recurseTimes < 0) {
        if ($4006a6b5a4b55f24$var$isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        else return ctx.stylize("[Object]", "special");
    }
    ctx.seen.push(value);
    var output;
    if (array) output = $4006a6b5a4b55f24$var$formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    else output = keys.map(function(key) {
        return $4006a6b5a4b55f24$var$formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
    ctx.seen.pop();
    return $4006a6b5a4b55f24$var$reduceToSingleString(output, base, braces);
}
function $4006a6b5a4b55f24$var$formatPrimitive(ctx, value) {
    if ($4006a6b5a4b55f24$var$isUndefined(value)) return ctx.stylize("undefined", "undefined");
    if ($4006a6b5a4b55f24$var$isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
    }
    if ($4006a6b5a4b55f24$var$isNumber(value)) return ctx.stylize("" + value, "number");
    if ($4006a6b5a4b55f24$var$isBoolean(value)) return ctx.stylize("" + value, "boolean");
    // For some reason typeof null is "object", so special case here.
    if ($4006a6b5a4b55f24$var$isNull(value)) return ctx.stylize("null", "null");
}
function $4006a6b5a4b55f24$var$formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
}
function $4006a6b5a4b55f24$var$formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for(var i = 0, l = value.length; i < l; ++i)if ($4006a6b5a4b55f24$var$hasOwnProperty(value, String(i))) output.push($4006a6b5a4b55f24$var$formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    else output.push("");
    keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) output.push($4006a6b5a4b55f24$var$formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    });
    return output;
}
function $4006a6b5a4b55f24$var$formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
    };
    if (desc.get) {
        if (desc.set) str = ctx.stylize("[Getter/Setter]", "special");
        else str = ctx.stylize("[Getter]", "special");
    } else if (desc.set) str = ctx.stylize("[Setter]", "special");
    if (!$4006a6b5a4b55f24$var$hasOwnProperty(visibleKeys, key)) name = "[" + key + "]";
    if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
            if ($4006a6b5a4b55f24$var$isNull(recurseTimes)) str = $4006a6b5a4b55f24$var$formatValue(ctx, desc.value, null);
            else str = $4006a6b5a4b55f24$var$formatValue(ctx, desc.value, recurseTimes - 1);
            if (str.indexOf("\n") > -1) {
                if (array) str = str.split("\n").map(function(line) {
                    return "  " + line;
                }).join("\n").substr(2);
                else str = "\n" + str.split("\n").map(function(line) {
                    return "   " + line;
                }).join("\n");
            }
        } else str = ctx.stylize("[Circular]", "special");
    }
    if ($4006a6b5a4b55f24$var$isUndefined(name)) {
        if (array && key.match(/^\d+$/)) return str;
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, "name");
        } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
        }
    }
    return name + ": " + str;
}
function $4006a6b5a4b55f24$var$reduceToSingleString(output, base, braces) {
    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
module.exports.types = (parcelRequire("8Adqr"));
function $4006a6b5a4b55f24$var$isArray(ar) {
    return Array.isArray(ar);
}
module.exports.isArray = $4006a6b5a4b55f24$var$isArray;
function $4006a6b5a4b55f24$var$isBoolean(arg) {
    return typeof arg === "boolean";
}
module.exports.isBoolean = $4006a6b5a4b55f24$var$isBoolean;
function $4006a6b5a4b55f24$var$isNull(arg) {
    return arg === null;
}
module.exports.isNull = $4006a6b5a4b55f24$var$isNull;
function $4006a6b5a4b55f24$var$isNullOrUndefined(arg) {
    return arg == null;
}
module.exports.isNullOrUndefined = $4006a6b5a4b55f24$var$isNullOrUndefined;
function $4006a6b5a4b55f24$var$isNumber(arg) {
    return typeof arg === "number";
}
module.exports.isNumber = $4006a6b5a4b55f24$var$isNumber;
function $4006a6b5a4b55f24$var$isString(arg) {
    return typeof arg === "string";
}
module.exports.isString = $4006a6b5a4b55f24$var$isString;
function $4006a6b5a4b55f24$var$isSymbol(arg) {
    return typeof arg === "symbol";
}
module.exports.isSymbol = $4006a6b5a4b55f24$var$isSymbol;
function $4006a6b5a4b55f24$var$isUndefined(arg) {
    return arg === void 0;
}
module.exports.isUndefined = $4006a6b5a4b55f24$var$isUndefined;
function $4006a6b5a4b55f24$var$isRegExp(re) {
    return $4006a6b5a4b55f24$var$isObject(re) && $4006a6b5a4b55f24$var$objectToString(re) === "[object RegExp]";
}
module.exports.isRegExp = $4006a6b5a4b55f24$var$isRegExp;
module.exports.types.isRegExp = $4006a6b5a4b55f24$var$isRegExp;
function $4006a6b5a4b55f24$var$isObject(arg) {
    return typeof arg === "object" && arg !== null;
}
module.exports.isObject = $4006a6b5a4b55f24$var$isObject;
function $4006a6b5a4b55f24$var$isDate(d) {
    return $4006a6b5a4b55f24$var$isObject(d) && $4006a6b5a4b55f24$var$objectToString(d) === "[object Date]";
}
module.exports.isDate = $4006a6b5a4b55f24$var$isDate;
module.exports.types.isDate = $4006a6b5a4b55f24$var$isDate;
function $4006a6b5a4b55f24$var$isError(e) {
    return $4006a6b5a4b55f24$var$isObject(e) && ($4006a6b5a4b55f24$var$objectToString(e) === "[object Error]" || e instanceof Error);
}
module.exports.isError = $4006a6b5a4b55f24$var$isError;
module.exports.types.isNativeError = $4006a6b5a4b55f24$var$isError;
function $4006a6b5a4b55f24$var$isFunction(arg) {
    return typeof arg === "function";
}
module.exports.isFunction = $4006a6b5a4b55f24$var$isFunction;
function $4006a6b5a4b55f24$var$isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
}
module.exports.isPrimitive = $4006a6b5a4b55f24$var$isPrimitive;

module.exports.isBuffer = (parcelRequire("dGKaU"));
function $4006a6b5a4b55f24$var$objectToString(o) {
    return Object.prototype.toString.call(o);
}
function $4006a6b5a4b55f24$var$pad(n) {
    return n < 10 ? "0" + n.toString(10) : n.toString(10);
}
var $4006a6b5a4b55f24$var$months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
];
// 26 Feb 16:19:34
function $4006a6b5a4b55f24$var$timestamp() {
    var d = new Date();
    var time = [
        $4006a6b5a4b55f24$var$pad(d.getHours()),
        $4006a6b5a4b55f24$var$pad(d.getMinutes()),
        $4006a6b5a4b55f24$var$pad(d.getSeconds())
    ].join(":");
    return [
        d.getDate(),
        $4006a6b5a4b55f24$var$months[d.getMonth()],
        time
    ].join(" ");
}
// log is just a thin wrapper to console.log that prepends a timestamp
module.exports.log = function() {
    console.log("%s - %s", $4006a6b5a4b55f24$var$timestamp(), module.exports.format.apply(module.exports, arguments));
};

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ module.exports.inherits = (parcelRequire("4gnOs"));
module.exports._extend = function(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !$4006a6b5a4b55f24$var$isObject(add)) return origin;
    var keys = Object.keys(add);
    var i = keys.length;
    while(i--)origin[keys[i]] = add[keys[i]];
    return origin;
};
function $4006a6b5a4b55f24$var$hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
var $4006a6b5a4b55f24$var$kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : undefined;
module.exports.promisify = function promisify(original) {
    if (typeof original !== "function") throw new TypeError('The "original" argument must be of type Function');
    if ($4006a6b5a4b55f24$var$kCustomPromisifiedSymbol && original[$4006a6b5a4b55f24$var$kCustomPromisifiedSymbol]) {
        var fn = original[$4006a6b5a4b55f24$var$kCustomPromisifiedSymbol];
        if (typeof fn !== "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        Object.defineProperty(fn, $4006a6b5a4b55f24$var$kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
        return fn;
    }
    function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
        });
        var args = [];
        for(var i = 0; i < arguments.length; i++)args.push(arguments[i]);
        args.push(function(err, value) {
            if (err) promiseReject(err);
            else promiseResolve(value);
        });
        try {
            original.apply(this, args);
        } catch (err) {
            promiseReject(err);
        }
        return promise;
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    if ($4006a6b5a4b55f24$var$kCustomPromisifiedSymbol) Object.defineProperty(fn, $4006a6b5a4b55f24$var$kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn, $4006a6b5a4b55f24$var$getOwnPropertyDescriptors(original));
};
module.exports.promisify.custom = $4006a6b5a4b55f24$var$kCustomPromisifiedSymbol;
function $4006a6b5a4b55f24$var$callbackifyOnRejected(reason, cb) {
    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
    // Because `null` is a special error value in callbacks which means "no error
    // occurred", we error-wrap so the callback consumer can distinguish between
    // "the promise rejected with null" or "the promise fulfilled with undefined".
    if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
    }
    return cb(reason);
}
function $4006a6b5a4b55f24$var$callbackify(original) {
    if (typeof original !== "function") throw new TypeError('The "original" argument must be of type Function');
    // We DO NOT return the promise as it gives the user a false sense that
    // the promise is actually somehow related to the callback's execution
    // and that the callback throwing will reject the promise.
    function callbackified() {
        var args = [];
        for(var i = 0; i < arguments.length; i++)args.push(arguments[i]);
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") throw new TypeError("The last argument must be of type Function");
        var self = this;
        var cb = function() {
            return maybeCb.apply(self, arguments);
        };
        // In true node style we process the callback on `nextTick` with all the
        // implications (stack, `uncaughtException`, `async_hooks`)
        original.apply(this, args).then(function(ret) {
            $gDDBB.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
            $gDDBB.nextTick($4006a6b5a4b55f24$var$callbackifyOnRejected.bind(null, rej, cb));
        });
    }
    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(callbackified, $4006a6b5a4b55f24$var$getOwnPropertyDescriptors(original));
    return callbackified;
}
module.exports.callbackify = $4006a6b5a4b55f24$var$callbackify;

});
parcelRequire.register("gDDBB", function(module, exports) {
// shim for using process in browser
var $c1cf02b2ac1bf11f$var$process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var $c1cf02b2ac1bf11f$var$cachedSetTimeout;
var $c1cf02b2ac1bf11f$var$cachedClearTimeout;
function $c1cf02b2ac1bf11f$var$defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function $c1cf02b2ac1bf11f$var$defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") $c1cf02b2ac1bf11f$var$cachedSetTimeout = setTimeout;
        else $c1cf02b2ac1bf11f$var$cachedSetTimeout = $c1cf02b2ac1bf11f$var$defaultSetTimout;
    } catch (e) {
        $c1cf02b2ac1bf11f$var$cachedSetTimeout = $c1cf02b2ac1bf11f$var$defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") $c1cf02b2ac1bf11f$var$cachedClearTimeout = clearTimeout;
        else $c1cf02b2ac1bf11f$var$cachedClearTimeout = $c1cf02b2ac1bf11f$var$defaultClearTimeout;
    } catch (e) {
        $c1cf02b2ac1bf11f$var$cachedClearTimeout = $c1cf02b2ac1bf11f$var$defaultClearTimeout;
    }
})();
function $c1cf02b2ac1bf11f$var$runTimeout(fun) {
    if ($c1cf02b2ac1bf11f$var$cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if (($c1cf02b2ac1bf11f$var$cachedSetTimeout === $c1cf02b2ac1bf11f$var$defaultSetTimout || !$c1cf02b2ac1bf11f$var$cachedSetTimeout) && setTimeout) {
        $c1cf02b2ac1bf11f$var$cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return $c1cf02b2ac1bf11f$var$cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return $c1cf02b2ac1bf11f$var$cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return $c1cf02b2ac1bf11f$var$cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function $c1cf02b2ac1bf11f$var$runClearTimeout(marker) {
    if ($c1cf02b2ac1bf11f$var$cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if (($c1cf02b2ac1bf11f$var$cachedClearTimeout === $c1cf02b2ac1bf11f$var$defaultClearTimeout || !$c1cf02b2ac1bf11f$var$cachedClearTimeout) && clearTimeout) {
        $c1cf02b2ac1bf11f$var$cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return $c1cf02b2ac1bf11f$var$cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return $c1cf02b2ac1bf11f$var$cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return $c1cf02b2ac1bf11f$var$cachedClearTimeout.call(this, marker);
        }
    }
}
var $c1cf02b2ac1bf11f$var$queue = [];
var $c1cf02b2ac1bf11f$var$draining = false;
var $c1cf02b2ac1bf11f$var$currentQueue;
var $c1cf02b2ac1bf11f$var$queueIndex = -1;
function $c1cf02b2ac1bf11f$var$cleanUpNextTick() {
    if (!$c1cf02b2ac1bf11f$var$draining || !$c1cf02b2ac1bf11f$var$currentQueue) return;
    $c1cf02b2ac1bf11f$var$draining = false;
    if ($c1cf02b2ac1bf11f$var$currentQueue.length) $c1cf02b2ac1bf11f$var$queue = $c1cf02b2ac1bf11f$var$currentQueue.concat($c1cf02b2ac1bf11f$var$queue);
    else $c1cf02b2ac1bf11f$var$queueIndex = -1;
    if ($c1cf02b2ac1bf11f$var$queue.length) $c1cf02b2ac1bf11f$var$drainQueue();
}
function $c1cf02b2ac1bf11f$var$drainQueue() {
    if ($c1cf02b2ac1bf11f$var$draining) return;
    var timeout = $c1cf02b2ac1bf11f$var$runTimeout($c1cf02b2ac1bf11f$var$cleanUpNextTick);
    $c1cf02b2ac1bf11f$var$draining = true;
    var len = $c1cf02b2ac1bf11f$var$queue.length;
    while(len){
        $c1cf02b2ac1bf11f$var$currentQueue = $c1cf02b2ac1bf11f$var$queue;
        $c1cf02b2ac1bf11f$var$queue = [];
        while(++$c1cf02b2ac1bf11f$var$queueIndex < len)if ($c1cf02b2ac1bf11f$var$currentQueue) $c1cf02b2ac1bf11f$var$currentQueue[$c1cf02b2ac1bf11f$var$queueIndex].run();
        $c1cf02b2ac1bf11f$var$queueIndex = -1;
        len = $c1cf02b2ac1bf11f$var$queue.length;
    }
    $c1cf02b2ac1bf11f$var$currentQueue = null;
    $c1cf02b2ac1bf11f$var$draining = false;
    $c1cf02b2ac1bf11f$var$runClearTimeout(timeout);
}
$c1cf02b2ac1bf11f$var$process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    $c1cf02b2ac1bf11f$var$queue.push(new $c1cf02b2ac1bf11f$var$Item(fun, args));
    if ($c1cf02b2ac1bf11f$var$queue.length === 1 && !$c1cf02b2ac1bf11f$var$draining) $c1cf02b2ac1bf11f$var$runTimeout($c1cf02b2ac1bf11f$var$drainQueue);
};
// v8 likes predictible objects
function $c1cf02b2ac1bf11f$var$Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
$c1cf02b2ac1bf11f$var$Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
$c1cf02b2ac1bf11f$var$process.title = "browser";
$c1cf02b2ac1bf11f$var$process.browser = true;
$c1cf02b2ac1bf11f$var$process.env = {};
$c1cf02b2ac1bf11f$var$process.argv = [];
$c1cf02b2ac1bf11f$var$process.version = ""; // empty string to avoid regexp issues
$c1cf02b2ac1bf11f$var$process.versions = {};
function $c1cf02b2ac1bf11f$var$noop() {}
$c1cf02b2ac1bf11f$var$process.on = $c1cf02b2ac1bf11f$var$noop;
$c1cf02b2ac1bf11f$var$process.addListener = $c1cf02b2ac1bf11f$var$noop;
$c1cf02b2ac1bf11f$var$process.once = $c1cf02b2ac1bf11f$var$noop;
$c1cf02b2ac1bf11f$var$process.off = $c1cf02b2ac1bf11f$var$noop;
$c1cf02b2ac1bf11f$var$process.removeListener = $c1cf02b2ac1bf11f$var$noop;
$c1cf02b2ac1bf11f$var$process.removeAllListeners = $c1cf02b2ac1bf11f$var$noop;
$c1cf02b2ac1bf11f$var$process.emit = $c1cf02b2ac1bf11f$var$noop;
$c1cf02b2ac1bf11f$var$process.prependListener = $c1cf02b2ac1bf11f$var$noop;
$c1cf02b2ac1bf11f$var$process.prependOnceListener = $c1cf02b2ac1bf11f$var$noop;
$c1cf02b2ac1bf11f$var$process.listeners = function(name) {
    return [];
};
$c1cf02b2ac1bf11f$var$process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
$c1cf02b2ac1bf11f$var$process.cwd = function() {
    return "/";
};
$c1cf02b2ac1bf11f$var$process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
$c1cf02b2ac1bf11f$var$process.umask = function() {
    return 0;
};

});

parcelRequire.register("8Adqr", function(module, exports) {
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
"use strict";

var $hMRtu = parcelRequire("hMRtu");

var $6F5wy = parcelRequire("6F5wy");

var $7QxyU = parcelRequire("7QxyU");

var $bH9aY = parcelRequire("bH9aY");
function $63fc198d8b06806e$var$uncurryThis(f) {
    return f.call.bind(f);
}
var $63fc198d8b06806e$var$BigIntSupported = typeof BigInt !== "undefined";
var $63fc198d8b06806e$var$SymbolSupported = typeof Symbol !== "undefined";
var $63fc198d8b06806e$var$ObjectToString = $63fc198d8b06806e$var$uncurryThis(Object.prototype.toString);
var $63fc198d8b06806e$var$numberValue = $63fc198d8b06806e$var$uncurryThis(Number.prototype.valueOf);
var $63fc198d8b06806e$var$stringValue = $63fc198d8b06806e$var$uncurryThis(String.prototype.valueOf);
var $63fc198d8b06806e$var$booleanValue = $63fc198d8b06806e$var$uncurryThis(Boolean.prototype.valueOf);
if ($63fc198d8b06806e$var$BigIntSupported) var $63fc198d8b06806e$var$bigIntValue = $63fc198d8b06806e$var$uncurryThis(BigInt.prototype.valueOf);
if ($63fc198d8b06806e$var$SymbolSupported) var $63fc198d8b06806e$var$symbolValue = $63fc198d8b06806e$var$uncurryThis(Symbol.prototype.valueOf);
function $63fc198d8b06806e$var$checkBoxedPrimitive(value, prototypeValueOf) {
    if (typeof value !== "object") return false;
    try {
        prototypeValueOf(value);
        return true;
    } catch (e) {
        return false;
    }
}
module.exports.isArgumentsObject = $hMRtu;
module.exports.isGeneratorFunction = $6F5wy;
module.exports.isTypedArray = $bH9aY;
// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function $63fc198d8b06806e$var$isPromise(input) {
    return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
}
module.exports.isPromise = $63fc198d8b06806e$var$isPromise;
function $63fc198d8b06806e$var$isArrayBufferView(value) {
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) return ArrayBuffer.isView(value);
    return $bH9aY(value) || $63fc198d8b06806e$var$isDataView(value);
}
module.exports.isArrayBufferView = $63fc198d8b06806e$var$isArrayBufferView;
function $63fc198d8b06806e$var$isUint8Array(value) {
    return $7QxyU(value) === "Uint8Array";
}
module.exports.isUint8Array = $63fc198d8b06806e$var$isUint8Array;
function $63fc198d8b06806e$var$isUint8ClampedArray(value) {
    return $7QxyU(value) === "Uint8ClampedArray";
}
module.exports.isUint8ClampedArray = $63fc198d8b06806e$var$isUint8ClampedArray;
function $63fc198d8b06806e$var$isUint16Array(value) {
    return $7QxyU(value) === "Uint16Array";
}
module.exports.isUint16Array = $63fc198d8b06806e$var$isUint16Array;
function $63fc198d8b06806e$var$isUint32Array(value) {
    return $7QxyU(value) === "Uint32Array";
}
module.exports.isUint32Array = $63fc198d8b06806e$var$isUint32Array;
function $63fc198d8b06806e$var$isInt8Array(value) {
    return $7QxyU(value) === "Int8Array";
}
module.exports.isInt8Array = $63fc198d8b06806e$var$isInt8Array;
function $63fc198d8b06806e$var$isInt16Array(value) {
    return $7QxyU(value) === "Int16Array";
}
module.exports.isInt16Array = $63fc198d8b06806e$var$isInt16Array;
function $63fc198d8b06806e$var$isInt32Array(value) {
    return $7QxyU(value) === "Int32Array";
}
module.exports.isInt32Array = $63fc198d8b06806e$var$isInt32Array;
function $63fc198d8b06806e$var$isFloat32Array(value) {
    return $7QxyU(value) === "Float32Array";
}
module.exports.isFloat32Array = $63fc198d8b06806e$var$isFloat32Array;
function $63fc198d8b06806e$var$isFloat64Array(value) {
    return $7QxyU(value) === "Float64Array";
}
module.exports.isFloat64Array = $63fc198d8b06806e$var$isFloat64Array;
function $63fc198d8b06806e$var$isBigInt64Array(value) {
    return $7QxyU(value) === "BigInt64Array";
}
module.exports.isBigInt64Array = $63fc198d8b06806e$var$isBigInt64Array;
function $63fc198d8b06806e$var$isBigUint64Array(value) {
    return $7QxyU(value) === "BigUint64Array";
}
module.exports.isBigUint64Array = $63fc198d8b06806e$var$isBigUint64Array;
function $63fc198d8b06806e$var$isMapToString(value) {
    return $63fc198d8b06806e$var$ObjectToString(value) === "[object Map]";
}
$63fc198d8b06806e$var$isMapToString.working = typeof Map !== "undefined" && $63fc198d8b06806e$var$isMapToString(new Map());
function $63fc198d8b06806e$var$isMap(value) {
    if (typeof Map === "undefined") return false;
    return $63fc198d8b06806e$var$isMapToString.working ? $63fc198d8b06806e$var$isMapToString(value) : value instanceof Map;
}
module.exports.isMap = $63fc198d8b06806e$var$isMap;
function $63fc198d8b06806e$var$isSetToString(value) {
    return $63fc198d8b06806e$var$ObjectToString(value) === "[object Set]";
}
$63fc198d8b06806e$var$isSetToString.working = typeof Set !== "undefined" && $63fc198d8b06806e$var$isSetToString(new Set());
function $63fc198d8b06806e$var$isSet(value) {
    if (typeof Set === "undefined") return false;
    return $63fc198d8b06806e$var$isSetToString.working ? $63fc198d8b06806e$var$isSetToString(value) : value instanceof Set;
}
module.exports.isSet = $63fc198d8b06806e$var$isSet;
function $63fc198d8b06806e$var$isWeakMapToString(value) {
    return $63fc198d8b06806e$var$ObjectToString(value) === "[object WeakMap]";
}
$63fc198d8b06806e$var$isWeakMapToString.working = typeof WeakMap !== "undefined" && $63fc198d8b06806e$var$isWeakMapToString(new WeakMap());
function $63fc198d8b06806e$var$isWeakMap(value) {
    if (typeof WeakMap === "undefined") return false;
    return $63fc198d8b06806e$var$isWeakMapToString.working ? $63fc198d8b06806e$var$isWeakMapToString(value) : value instanceof WeakMap;
}
module.exports.isWeakMap = $63fc198d8b06806e$var$isWeakMap;
function $63fc198d8b06806e$var$isWeakSetToString(value) {
    return $63fc198d8b06806e$var$ObjectToString(value) === "[object WeakSet]";
}
$63fc198d8b06806e$var$isWeakSetToString.working = typeof WeakSet !== "undefined" && $63fc198d8b06806e$var$isWeakSetToString(new WeakSet());
function $63fc198d8b06806e$var$isWeakSet(value) {
    return $63fc198d8b06806e$var$isWeakSetToString(value);
}
module.exports.isWeakSet = $63fc198d8b06806e$var$isWeakSet;
function $63fc198d8b06806e$var$isArrayBufferToString(value) {
    return $63fc198d8b06806e$var$ObjectToString(value) === "[object ArrayBuffer]";
}
$63fc198d8b06806e$var$isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && $63fc198d8b06806e$var$isArrayBufferToString(new ArrayBuffer());
function $63fc198d8b06806e$var$isArrayBuffer(value) {
    if (typeof ArrayBuffer === "undefined") return false;
    return $63fc198d8b06806e$var$isArrayBufferToString.working ? $63fc198d8b06806e$var$isArrayBufferToString(value) : value instanceof ArrayBuffer;
}
module.exports.isArrayBuffer = $63fc198d8b06806e$var$isArrayBuffer;
function $63fc198d8b06806e$var$isDataViewToString(value) {
    return $63fc198d8b06806e$var$ObjectToString(value) === "[object DataView]";
}
$63fc198d8b06806e$var$isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && $63fc198d8b06806e$var$isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
function $63fc198d8b06806e$var$isDataView(value) {
    if (typeof DataView === "undefined") return false;
    return $63fc198d8b06806e$var$isDataViewToString.working ? $63fc198d8b06806e$var$isDataViewToString(value) : value instanceof DataView;
}
module.exports.isDataView = $63fc198d8b06806e$var$isDataView;
// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var $63fc198d8b06806e$var$SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : undefined;
function $63fc198d8b06806e$var$isSharedArrayBufferToString(value) {
    return $63fc198d8b06806e$var$ObjectToString(value) === "[object SharedArrayBuffer]";
}
function $63fc198d8b06806e$var$isSharedArrayBuffer(value) {
    if (typeof $63fc198d8b06806e$var$SharedArrayBufferCopy === "undefined") return false;
    if (typeof $63fc198d8b06806e$var$isSharedArrayBufferToString.working === "undefined") $63fc198d8b06806e$var$isSharedArrayBufferToString.working = $63fc198d8b06806e$var$isSharedArrayBufferToString(new $63fc198d8b06806e$var$SharedArrayBufferCopy());
    return $63fc198d8b06806e$var$isSharedArrayBufferToString.working ? $63fc198d8b06806e$var$isSharedArrayBufferToString(value) : value instanceof $63fc198d8b06806e$var$SharedArrayBufferCopy;
}
module.exports.isSharedArrayBuffer = $63fc198d8b06806e$var$isSharedArrayBuffer;
function $63fc198d8b06806e$var$isAsyncFunction(value) {
    return $63fc198d8b06806e$var$ObjectToString(value) === "[object AsyncFunction]";
}
module.exports.isAsyncFunction = $63fc198d8b06806e$var$isAsyncFunction;
function $63fc198d8b06806e$var$isMapIterator(value) {
    return $63fc198d8b06806e$var$ObjectToString(value) === "[object Map Iterator]";
}
module.exports.isMapIterator = $63fc198d8b06806e$var$isMapIterator;
function $63fc198d8b06806e$var$isSetIterator(value) {
    return $63fc198d8b06806e$var$ObjectToString(value) === "[object Set Iterator]";
}
module.exports.isSetIterator = $63fc198d8b06806e$var$isSetIterator;
function $63fc198d8b06806e$var$isGeneratorObject(value) {
    return $63fc198d8b06806e$var$ObjectToString(value) === "[object Generator]";
}
module.exports.isGeneratorObject = $63fc198d8b06806e$var$isGeneratorObject;
function $63fc198d8b06806e$var$isWebAssemblyCompiledModule(value) {
    return $63fc198d8b06806e$var$ObjectToString(value) === "[object WebAssembly.Module]";
}
module.exports.isWebAssemblyCompiledModule = $63fc198d8b06806e$var$isWebAssemblyCompiledModule;
function $63fc198d8b06806e$var$isNumberObject(value) {
    return $63fc198d8b06806e$var$checkBoxedPrimitive(value, $63fc198d8b06806e$var$numberValue);
}
module.exports.isNumberObject = $63fc198d8b06806e$var$isNumberObject;
function $63fc198d8b06806e$var$isStringObject(value) {
    return $63fc198d8b06806e$var$checkBoxedPrimitive(value, $63fc198d8b06806e$var$stringValue);
}
module.exports.isStringObject = $63fc198d8b06806e$var$isStringObject;
function $63fc198d8b06806e$var$isBooleanObject(value) {
    return $63fc198d8b06806e$var$checkBoxedPrimitive(value, $63fc198d8b06806e$var$booleanValue);
}
module.exports.isBooleanObject = $63fc198d8b06806e$var$isBooleanObject;
function $63fc198d8b06806e$var$isBigIntObject(value) {
    return $63fc198d8b06806e$var$BigIntSupported && $63fc198d8b06806e$var$checkBoxedPrimitive(value, $63fc198d8b06806e$var$bigIntValue);
}
module.exports.isBigIntObject = $63fc198d8b06806e$var$isBigIntObject;
function $63fc198d8b06806e$var$isSymbolObject(value) {
    return $63fc198d8b06806e$var$SymbolSupported && $63fc198d8b06806e$var$checkBoxedPrimitive(value, $63fc198d8b06806e$var$symbolValue);
}
module.exports.isSymbolObject = $63fc198d8b06806e$var$isSymbolObject;
function $63fc198d8b06806e$var$isBoxedPrimitive(value) {
    return $63fc198d8b06806e$var$isNumberObject(value) || $63fc198d8b06806e$var$isStringObject(value) || $63fc198d8b06806e$var$isBooleanObject(value) || $63fc198d8b06806e$var$isBigIntObject(value) || $63fc198d8b06806e$var$isSymbolObject(value);
}
module.exports.isBoxedPrimitive = $63fc198d8b06806e$var$isBoxedPrimitive;
function $63fc198d8b06806e$var$isAnyArrayBuffer(value) {
    return typeof Uint8Array !== "undefined" && ($63fc198d8b06806e$var$isArrayBuffer(value) || $63fc198d8b06806e$var$isSharedArrayBuffer(value));
}
module.exports.isAnyArrayBuffer = $63fc198d8b06806e$var$isAnyArrayBuffer;
[
    "isProxy",
    "isExternal",
    "isModuleNamespaceObject"
].forEach(function(method) {
    Object.defineProperty(module.exports, method, {
        enumerable: false,
        value: function() {
            throw new Error(method + " is not supported in userland");
        }
    });
});

});
parcelRequire.register("hMRtu", function(module, exports) {
"use strict";

var $cf30664cf33adf73$var$hasToStringTag = (parcelRequire("3U2NC"))();

var $jiywP = parcelRequire("jiywP");
var $cf30664cf33adf73$var$$toString = $jiywP("Object.prototype.toString");
var $cf30664cf33adf73$var$isStandardArguments = function isArguments(value) {
    if ($cf30664cf33adf73$var$hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) return false;
    return $cf30664cf33adf73$var$$toString(value) === "[object Arguments]";
};
var $cf30664cf33adf73$var$isLegacyArguments = function isArguments(value) {
    if ($cf30664cf33adf73$var$isStandardArguments(value)) return true;
    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $cf30664cf33adf73$var$$toString(value) !== "[object Array]" && $cf30664cf33adf73$var$$toString(value.callee) === "[object Function]";
};
var $cf30664cf33adf73$var$supportsStandardArguments = function() {
    return $cf30664cf33adf73$var$isStandardArguments(arguments);
}();
$cf30664cf33adf73$var$isStandardArguments.isLegacyArguments = $cf30664cf33adf73$var$isLegacyArguments; // for tests
module.exports = $cf30664cf33adf73$var$supportsStandardArguments ? $cf30664cf33adf73$var$isStandardArguments : $cf30664cf33adf73$var$isLegacyArguments;

});
parcelRequire.register("3U2NC", function(module, exports) {
"use strict";

var $5n7tR = parcelRequire("5n7tR");
module.exports = function hasToStringTagShams() {
    return $5n7tR() && !!Symbol.toStringTag;
};

});
parcelRequire.register("5n7tR", function(module, exports) {
"use strict";
/* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") return false;
    if (typeof Symbol.iterator === "symbol") return true;
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") return false;
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") return false;
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") return false;
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(sym in obj)return false;
     // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) return false;
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) return false;
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) return false;
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
    if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) return false;
    }
    return true;
};

});


parcelRequire.register("jiywP", function(module, exports) {
"use strict";

var $i6jPy = parcelRequire("i6jPy");

var $3cyqP = parcelRequire("3cyqP");
var $e0ca7b631796827b$var$$indexOf = $3cyqP($i6jPy("String.prototype.indexOf"));
module.exports = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = $i6jPy(name, !!allowMissing);
    if (typeof intrinsic === "function" && $e0ca7b631796827b$var$$indexOf(name, ".prototype.") > -1) return $3cyqP(intrinsic);
    return intrinsic;
};

});
parcelRequire.register("i6jPy", function(module, exports) {
"use strict";
var $d2d82b7a83f890ad$var$undefined;
var $d2d82b7a83f890ad$var$$SyntaxError = SyntaxError;
var $d2d82b7a83f890ad$var$$Function = Function;
var $d2d82b7a83f890ad$var$$TypeError = TypeError;
// eslint-disable-next-line consistent-return
var $d2d82b7a83f890ad$var$getEvalledConstructor = function(expressionSyntax) {
    try {
        return $d2d82b7a83f890ad$var$$Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {}
};
var $d2d82b7a83f890ad$var$$gOPD = Object.getOwnPropertyDescriptor;
if ($d2d82b7a83f890ad$var$$gOPD) try {
    $d2d82b7a83f890ad$var$$gOPD({}, "");
} catch (e) {
    $d2d82b7a83f890ad$var$$gOPD = null; // this is IE 8, which has a broken gOPD
}
var $d2d82b7a83f890ad$var$throwTypeError = function() {
    throw new $d2d82b7a83f890ad$var$$TypeError();
};
var $d2d82b7a83f890ad$var$ThrowTypeError = $d2d82b7a83f890ad$var$$gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return $d2d82b7a83f890ad$var$throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $d2d82b7a83f890ad$var$$gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
            return $d2d82b7a83f890ad$var$throwTypeError;
        }
    }
}() : $d2d82b7a83f890ad$var$throwTypeError;

var $d2d82b7a83f890ad$var$hasSymbols = (parcelRequire("iPGsQ"))();
var $d2d82b7a83f890ad$var$getProto = Object.getPrototypeOf || function(x) {
    return x.__proto__;
}; // eslint-disable-line no-proto
var $d2d82b7a83f890ad$var$needsEval = {};
var $d2d82b7a83f890ad$var$TypedArray = typeof Uint8Array === "undefined" ? $d2d82b7a83f890ad$var$undefined : $d2d82b7a83f890ad$var$getProto(Uint8Array);
var $d2d82b7a83f890ad$var$INTRINSICS = {
    "%AggregateError%": typeof AggregateError === "undefined" ? $d2d82b7a83f890ad$var$undefined : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? $d2d82b7a83f890ad$var$undefined : ArrayBuffer,
    "%ArrayIteratorPrototype%": $d2d82b7a83f890ad$var$hasSymbols ? $d2d82b7a83f890ad$var$getProto([][Symbol.iterator]()) : $d2d82b7a83f890ad$var$undefined,
    "%AsyncFromSyncIteratorPrototype%": $d2d82b7a83f890ad$var$undefined,
    "%AsyncFunction%": $d2d82b7a83f890ad$var$needsEval,
    "%AsyncGenerator%": $d2d82b7a83f890ad$var$needsEval,
    "%AsyncGeneratorFunction%": $d2d82b7a83f890ad$var$needsEval,
    "%AsyncIteratorPrototype%": $d2d82b7a83f890ad$var$needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? $d2d82b7a83f890ad$var$undefined : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? $d2d82b7a83f890ad$var$undefined : BigInt,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? $d2d82b7a83f890ad$var$undefined : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? $d2d82b7a83f890ad$var$undefined : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? $d2d82b7a83f890ad$var$undefined : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? $d2d82b7a83f890ad$var$undefined : FinalizationRegistry,
    "%Function%": $d2d82b7a83f890ad$var$$Function,
    "%GeneratorFunction%": $d2d82b7a83f890ad$var$needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? $d2d82b7a83f890ad$var$undefined : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? $d2d82b7a83f890ad$var$undefined : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? $d2d82b7a83f890ad$var$undefined : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": $d2d82b7a83f890ad$var$hasSymbols ? $d2d82b7a83f890ad$var$getProto($d2d82b7a83f890ad$var$getProto([][Symbol.iterator]())) : $d2d82b7a83f890ad$var$undefined,
    "%JSON%": typeof JSON === "object" ? JSON : $d2d82b7a83f890ad$var$undefined,
    "%Map%": typeof Map === "undefined" ? $d2d82b7a83f890ad$var$undefined : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !$d2d82b7a83f890ad$var$hasSymbols ? $d2d82b7a83f890ad$var$undefined : $d2d82b7a83f890ad$var$getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? $d2d82b7a83f890ad$var$undefined : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? $d2d82b7a83f890ad$var$undefined : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? $d2d82b7a83f890ad$var$undefined : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? $d2d82b7a83f890ad$var$undefined : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !$d2d82b7a83f890ad$var$hasSymbols ? $d2d82b7a83f890ad$var$undefined : $d2d82b7a83f890ad$var$getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? $d2d82b7a83f890ad$var$undefined : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": $d2d82b7a83f890ad$var$hasSymbols ? $d2d82b7a83f890ad$var$getProto(""[Symbol.iterator]()) : $d2d82b7a83f890ad$var$undefined,
    "%Symbol%": $d2d82b7a83f890ad$var$hasSymbols ? Symbol : $d2d82b7a83f890ad$var$undefined,
    "%SyntaxError%": $d2d82b7a83f890ad$var$$SyntaxError,
    "%ThrowTypeError%": $d2d82b7a83f890ad$var$ThrowTypeError,
    "%TypedArray%": $d2d82b7a83f890ad$var$TypedArray,
    "%TypeError%": $d2d82b7a83f890ad$var$$TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? $d2d82b7a83f890ad$var$undefined : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? $d2d82b7a83f890ad$var$undefined : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? $d2d82b7a83f890ad$var$undefined : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? $d2d82b7a83f890ad$var$undefined : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? $d2d82b7a83f890ad$var$undefined : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? $d2d82b7a83f890ad$var$undefined : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? $d2d82b7a83f890ad$var$undefined : WeakSet
};
var $d2d82b7a83f890ad$var$doEval = function doEval(name) {
    var value;
    if (name === "%AsyncFunction%") value = $d2d82b7a83f890ad$var$getEvalledConstructor("async function () {}");
    else if (name === "%GeneratorFunction%") value = $d2d82b7a83f890ad$var$getEvalledConstructor("function* () {}");
    else if (name === "%AsyncGeneratorFunction%") value = $d2d82b7a83f890ad$var$getEvalledConstructor("async function* () {}");
    else if (name === "%AsyncGenerator%") {
        var fn = doEval("%AsyncGeneratorFunction%");
        if (fn) value = fn.prototype;
    } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval("%AsyncGenerator%");
        if (gen) value = $d2d82b7a83f890ad$var$getProto(gen.prototype);
    }
    $d2d82b7a83f890ad$var$INTRINSICS[name] = value;
    return value;
};
var $d2d82b7a83f890ad$var$LEGACY_ALIASES = {
    "%ArrayBufferPrototype%": [
        "ArrayBuffer",
        "prototype"
    ],
    "%ArrayPrototype%": [
        "Array",
        "prototype"
    ],
    "%ArrayProto_entries%": [
        "Array",
        "prototype",
        "entries"
    ],
    "%ArrayProto_forEach%": [
        "Array",
        "prototype",
        "forEach"
    ],
    "%ArrayProto_keys%": [
        "Array",
        "prototype",
        "keys"
    ],
    "%ArrayProto_values%": [
        "Array",
        "prototype",
        "values"
    ],
    "%AsyncFunctionPrototype%": [
        "AsyncFunction",
        "prototype"
    ],
    "%AsyncGenerator%": [
        "AsyncGeneratorFunction",
        "prototype"
    ],
    "%AsyncGeneratorPrototype%": [
        "AsyncGeneratorFunction",
        "prototype",
        "prototype"
    ],
    "%BooleanPrototype%": [
        "Boolean",
        "prototype"
    ],
    "%DataViewPrototype%": [
        "DataView",
        "prototype"
    ],
    "%DatePrototype%": [
        "Date",
        "prototype"
    ],
    "%ErrorPrototype%": [
        "Error",
        "prototype"
    ],
    "%EvalErrorPrototype%": [
        "EvalError",
        "prototype"
    ],
    "%Float32ArrayPrototype%": [
        "Float32Array",
        "prototype"
    ],
    "%Float64ArrayPrototype%": [
        "Float64Array",
        "prototype"
    ],
    "%FunctionPrototype%": [
        "Function",
        "prototype"
    ],
    "%Generator%": [
        "GeneratorFunction",
        "prototype"
    ],
    "%GeneratorPrototype%": [
        "GeneratorFunction",
        "prototype",
        "prototype"
    ],
    "%Int8ArrayPrototype%": [
        "Int8Array",
        "prototype"
    ],
    "%Int16ArrayPrototype%": [
        "Int16Array",
        "prototype"
    ],
    "%Int32ArrayPrototype%": [
        "Int32Array",
        "prototype"
    ],
    "%JSONParse%": [
        "JSON",
        "parse"
    ],
    "%JSONStringify%": [
        "JSON",
        "stringify"
    ],
    "%MapPrototype%": [
        "Map",
        "prototype"
    ],
    "%NumberPrototype%": [
        "Number",
        "prototype"
    ],
    "%ObjectPrototype%": [
        "Object",
        "prototype"
    ],
    "%ObjProto_toString%": [
        "Object",
        "prototype",
        "toString"
    ],
    "%ObjProto_valueOf%": [
        "Object",
        "prototype",
        "valueOf"
    ],
    "%PromisePrototype%": [
        "Promise",
        "prototype"
    ],
    "%PromiseProto_then%": [
        "Promise",
        "prototype",
        "then"
    ],
    "%Promise_all%": [
        "Promise",
        "all"
    ],
    "%Promise_reject%": [
        "Promise",
        "reject"
    ],
    "%Promise_resolve%": [
        "Promise",
        "resolve"
    ],
    "%RangeErrorPrototype%": [
        "RangeError",
        "prototype"
    ],
    "%ReferenceErrorPrototype%": [
        "ReferenceError",
        "prototype"
    ],
    "%RegExpPrototype%": [
        "RegExp",
        "prototype"
    ],
    "%SetPrototype%": [
        "Set",
        "prototype"
    ],
    "%SharedArrayBufferPrototype%": [
        "SharedArrayBuffer",
        "prototype"
    ],
    "%StringPrototype%": [
        "String",
        "prototype"
    ],
    "%SymbolPrototype%": [
        "Symbol",
        "prototype"
    ],
    "%SyntaxErrorPrototype%": [
        "SyntaxError",
        "prototype"
    ],
    "%TypedArrayPrototype%": [
        "TypedArray",
        "prototype"
    ],
    "%TypeErrorPrototype%": [
        "TypeError",
        "prototype"
    ],
    "%Uint8ArrayPrototype%": [
        "Uint8Array",
        "prototype"
    ],
    "%Uint8ClampedArrayPrototype%": [
        "Uint8ClampedArray",
        "prototype"
    ],
    "%Uint16ArrayPrototype%": [
        "Uint16Array",
        "prototype"
    ],
    "%Uint32ArrayPrototype%": [
        "Uint32Array",
        "prototype"
    ],
    "%URIErrorPrototype%": [
        "URIError",
        "prototype"
    ],
    "%WeakMapPrototype%": [
        "WeakMap",
        "prototype"
    ],
    "%WeakSetPrototype%": [
        "WeakSet",
        "prototype"
    ]
};

var $8JvAP = parcelRequire("8JvAP");

var $87p7K = parcelRequire("87p7K");
var $d2d82b7a83f890ad$var$$concat = $8JvAP.call(Function.call, Array.prototype.concat);
var $d2d82b7a83f890ad$var$$spliceApply = $8JvAP.call(Function.apply, Array.prototype.splice);
var $d2d82b7a83f890ad$var$$replace = $8JvAP.call(Function.call, String.prototype.replace);
var $d2d82b7a83f890ad$var$$strSlice = $8JvAP.call(Function.call, String.prototype.slice);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var $d2d82b7a83f890ad$var$rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var $d2d82b7a83f890ad$var$reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var $d2d82b7a83f890ad$var$stringToPath = function stringToPath(string) {
    var first = $d2d82b7a83f890ad$var$$strSlice(string, 0, 1);
    var last = $d2d82b7a83f890ad$var$$strSlice(string, -1);
    if (first === "%" && last !== "%") throw new $d2d82b7a83f890ad$var$$SyntaxError("invalid intrinsic syntax, expected closing `%`");
    else if (last === "%" && first !== "%") throw new $d2d82b7a83f890ad$var$$SyntaxError("invalid intrinsic syntax, expected opening `%`");
    var result = [];
    $d2d82b7a83f890ad$var$$replace(string, $d2d82b7a83f890ad$var$rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $d2d82b7a83f890ad$var$$replace(subString, $d2d82b7a83f890ad$var$reEscapeChar, "$1") : number || match;
    });
    return result;
};
/* end adaptation */ var $d2d82b7a83f890ad$var$getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if ($87p7K($d2d82b7a83f890ad$var$LEGACY_ALIASES, intrinsicName)) {
        alias = $d2d82b7a83f890ad$var$LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
    }
    if ($87p7K($d2d82b7a83f890ad$var$INTRINSICS, intrinsicName)) {
        var value = $d2d82b7a83f890ad$var$INTRINSICS[intrinsicName];
        if (value === $d2d82b7a83f890ad$var$needsEval) value = $d2d82b7a83f890ad$var$doEval(intrinsicName);
        if (typeof value === "undefined" && !allowMissing) throw new $d2d82b7a83f890ad$var$$TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $d2d82b7a83f890ad$var$$SyntaxError("intrinsic " + name + " does not exist!");
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) throw new $d2d82b7a83f890ad$var$$TypeError("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof allowMissing !== "boolean") throw new $d2d82b7a83f890ad$var$$TypeError('"allowMissing" argument must be a boolean');
    var parts = $d2d82b7a83f890ad$var$stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = $d2d82b7a83f890ad$var$getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $d2d82b7a83f890ad$var$$spliceApply(parts, $d2d82b7a83f890ad$var$$concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $d2d82b7a83f890ad$var$$strSlice(part, 0, 1);
        var last = $d2d82b7a83f890ad$var$$strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") && first !== last) throw new $d2d82b7a83f890ad$var$$SyntaxError("property names with quotes must have matching quotes");
        if (part === "constructor" || !isOwn) skipFurtherCaching = true;
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if ($87p7K($d2d82b7a83f890ad$var$INTRINSICS, intrinsicRealName)) value = $d2d82b7a83f890ad$var$INTRINSICS[intrinsicRealName];
        else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) throw new $d2d82b7a83f890ad$var$$TypeError("base intrinsic for " + name + " exists, but the property is not available.");
                return void 0;
            }
            if ($d2d82b7a83f890ad$var$$gOPD && i + 1 >= parts.length) {
                var desc = $d2d82b7a83f890ad$var$$gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && "get" in desc && !("originalValue" in desc.get)) value = desc.get;
                else value = value[part];
            } else {
                isOwn = $87p7K(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) $d2d82b7a83f890ad$var$INTRINSICS[intrinsicRealName] = value;
        }
    }
    return value;
};

});
parcelRequire.register("iPGsQ", function(module, exports) {
"use strict";
var $db5dedede3b7f2c4$var$origSymbol = typeof Symbol !== "undefined" && Symbol;

var $5n7tR = parcelRequire("5n7tR");
module.exports = function hasNativeSymbols() {
    if (typeof $db5dedede3b7f2c4$var$origSymbol !== "function") return false;
    if (typeof Symbol !== "function") return false;
    if (typeof $db5dedede3b7f2c4$var$origSymbol("foo") !== "symbol") return false;
    if (typeof Symbol("bar") !== "symbol") return false;
    return $5n7tR();
};

});

parcelRequire.register("8JvAP", function(module, exports) {
"use strict";

var $9lfFZ = parcelRequire("9lfFZ");
module.exports = Function.prototype.bind || $9lfFZ;

});
parcelRequire.register("9lfFZ", function(module, exports) {
"use strict";
/* eslint no-invalid-this: 1 */ var $6cd23c3894c0c7c7$var$ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var $6cd23c3894c0c7c7$var$slice = Array.prototype.slice;
var $6cd23c3894c0c7c7$var$toStr = Object.prototype.toString;
var $6cd23c3894c0c7c7$var$funcType = "[object Function]";
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || $6cd23c3894c0c7c7$var$toStr.call(target) !== $6cd23c3894c0c7c7$var$funcType) throw new TypeError($6cd23c3894c0c7c7$var$ERROR_MESSAGE + target);
    var args = $6cd23c3894c0c7c7$var$slice.call(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, args.concat($6cd23c3894c0c7c7$var$slice.call(arguments)));
            if (Object(result) === result) return result;
            return this;
        } else return target.apply(that, args.concat($6cd23c3894c0c7c7$var$slice.call(arguments)));
    };
    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++)boundArgs.push("$" + i);
    bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};

});


parcelRequire.register("87p7K", function(module, exports) {
"use strict";

var $8JvAP = parcelRequire("8JvAP");
module.exports = $8JvAP.call(Function.call, Object.prototype.hasOwnProperty);

});


parcelRequire.register("3cyqP", function(module, exports) {
"use strict";

var $8JvAP = parcelRequire("8JvAP");

var $i6jPy = parcelRequire("i6jPy");
var $254d3383e533b4f7$var$$apply = $i6jPy("%Function.prototype.apply%");
var $254d3383e533b4f7$var$$call = $i6jPy("%Function.prototype.call%");
var $254d3383e533b4f7$var$$reflectApply = $i6jPy("%Reflect.apply%", true) || $8JvAP.call($254d3383e533b4f7$var$$call, $254d3383e533b4f7$var$$apply);
var $254d3383e533b4f7$var$$gOPD = $i6jPy("%Object.getOwnPropertyDescriptor%", true);
var $254d3383e533b4f7$var$$defineProperty = $i6jPy("%Object.defineProperty%", true);
var $254d3383e533b4f7$var$$max = $i6jPy("%Math.max%");
if ($254d3383e533b4f7$var$$defineProperty) try {
    $254d3383e533b4f7$var$$defineProperty({}, "a", {
        value: 1
    });
} catch (e) {
    // IE 8 has a broken defineProperty
    $254d3383e533b4f7$var$$defineProperty = null;
}
module.exports = function callBind(originalFunction) {
    var func = $254d3383e533b4f7$var$$reflectApply($8JvAP, $254d3383e533b4f7$var$$call, arguments);
    if ($254d3383e533b4f7$var$$gOPD && $254d3383e533b4f7$var$$defineProperty) {
        var desc = $254d3383e533b4f7$var$$gOPD(func, "length");
        if (desc.configurable) // original length, plus the receiver, minus any additional arguments (after the receiver)
        $254d3383e533b4f7$var$$defineProperty(func, "length", {
            value: 1 + $254d3383e533b4f7$var$$max(0, originalFunction.length - (arguments.length - 1))
        });
    }
    return func;
};
var $254d3383e533b4f7$var$applyBind = function applyBind() {
    return $254d3383e533b4f7$var$$reflectApply($8JvAP, $254d3383e533b4f7$var$$apply, arguments);
};
if ($254d3383e533b4f7$var$$defineProperty) $254d3383e533b4f7$var$$defineProperty(module.exports, "apply", {
    value: $254d3383e533b4f7$var$applyBind
});
else module.exports.apply = $254d3383e533b4f7$var$applyBind;

});



parcelRequire.register("6F5wy", function(module, exports) {
"use strict";
var $4d9adb6675cb2f47$var$toStr = Object.prototype.toString;
var $4d9adb6675cb2f47$var$fnToStr = Function.prototype.toString;
var $4d9adb6675cb2f47$var$isFnRegex = /^\s*(?:function)?\*/;

var $4d9adb6675cb2f47$var$hasToStringTag = (parcelRequire("3U2NC"))();
var $4d9adb6675cb2f47$var$getProto = Object.getPrototypeOf;
var $4d9adb6675cb2f47$var$getGeneratorFunc = function() {
    if (!$4d9adb6675cb2f47$var$hasToStringTag) return false;
    try {
        return Function("return function*() {}")();
    } catch (e) {}
};
var $4d9adb6675cb2f47$var$GeneratorFunction;
module.exports = function isGeneratorFunction(fn) {
    if (typeof fn !== "function") return false;
    if ($4d9adb6675cb2f47$var$isFnRegex.test($4d9adb6675cb2f47$var$fnToStr.call(fn))) return true;
    if (!$4d9adb6675cb2f47$var$hasToStringTag) {
        var str = $4d9adb6675cb2f47$var$toStr.call(fn);
        return str === "[object GeneratorFunction]";
    }
    if (!$4d9adb6675cb2f47$var$getProto) return false;
    if (typeof $4d9adb6675cb2f47$var$GeneratorFunction === "undefined") {
        var generatorFunc = $4d9adb6675cb2f47$var$getGeneratorFunc();
        $4d9adb6675cb2f47$var$GeneratorFunction = generatorFunc ? $4d9adb6675cb2f47$var$getProto(generatorFunc) : false;
    }
    return $4d9adb6675cb2f47$var$getProto(fn) === $4d9adb6675cb2f47$var$GeneratorFunction;
};

});

parcelRequire.register("7QxyU", function(module, exports) {
"use strict";

var $cg9fx = parcelRequire("cg9fx");

var $9x1Am = parcelRequire("9x1Am");

var $jiywP = parcelRequire("jiywP");
var $5b676c7805ba69ad$var$$toString = $jiywP("Object.prototype.toString");

var $5b676c7805ba69ad$var$hasToStringTag = (parcelRequire("3U2NC"))();
var $5b676c7805ba69ad$var$g = typeof globalThis === "undefined" ? $parcel$global : globalThis;
var $5b676c7805ba69ad$var$typedArrays = $9x1Am();
var $5b676c7805ba69ad$var$$slice = $jiywP("String.prototype.slice");
var $5b676c7805ba69ad$var$toStrTags = {};

var $2aUWV = parcelRequire("2aUWV");
var $5b676c7805ba69ad$var$getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if ($5b676c7805ba69ad$var$hasToStringTag && $2aUWV && $5b676c7805ba69ad$var$getPrototypeOf) $cg9fx($5b676c7805ba69ad$var$typedArrays, function(typedArray) {
    if (typeof $5b676c7805ba69ad$var$g[typedArray] === "function") {
        var arr = new $5b676c7805ba69ad$var$g[typedArray]();
        if (Symbol.toStringTag in arr) {
            var proto = $5b676c7805ba69ad$var$getPrototypeOf(arr);
            var descriptor = $2aUWV(proto, Symbol.toStringTag);
            if (!descriptor) {
                var superProto = $5b676c7805ba69ad$var$getPrototypeOf(proto);
                descriptor = $2aUWV(superProto, Symbol.toStringTag);
            }
            $5b676c7805ba69ad$var$toStrTags[typedArray] = descriptor.get;
        }
    }
});
var $5b676c7805ba69ad$var$tryTypedArrays = function tryAllTypedArrays(value) {
    var foundName = false;
    $cg9fx($5b676c7805ba69ad$var$toStrTags, function(getter, typedArray) {
        if (!foundName) try {
            var name = getter.call(value);
            if (name === typedArray) foundName = name;
        } catch (e) {}
    });
    return foundName;
};

var $bH9aY = parcelRequire("bH9aY");
module.exports = function whichTypedArray(value) {
    if (!$bH9aY(value)) return false;
    if (!$5b676c7805ba69ad$var$hasToStringTag || !(Symbol.toStringTag in value)) return $5b676c7805ba69ad$var$$slice($5b676c7805ba69ad$var$$toString(value), 8, -1);
    return $5b676c7805ba69ad$var$tryTypedArrays(value);
};

});
parcelRequire.register("cg9fx", function(module, exports) {
"use strict";

var $9FEAa = parcelRequire("9FEAa");
var $8ece277686ef770f$var$toStr = Object.prototype.toString;
var $8ece277686ef770f$var$hasOwnProperty = Object.prototype.hasOwnProperty;
var $8ece277686ef770f$var$forEachArray = function forEachArray(array, iterator, receiver) {
    for(var i = 0, len = array.length; i < len; i++)if ($8ece277686ef770f$var$hasOwnProperty.call(array, i)) {
        if (receiver == null) iterator(array[i], i, array);
        else iterator.call(receiver, array[i], i, array);
    }
};
var $8ece277686ef770f$var$forEachString = function forEachString(string, iterator, receiver) {
    for(var i = 0, len = string.length; i < len; i++)// no such thing as a sparse string.
    if (receiver == null) iterator(string.charAt(i), i, string);
    else iterator.call(receiver, string.charAt(i), i, string);
};
var $8ece277686ef770f$var$forEachObject = function forEachObject(object, iterator, receiver) {
    for(var k in object)if ($8ece277686ef770f$var$hasOwnProperty.call(object, k)) {
        if (receiver == null) iterator(object[k], k, object);
        else iterator.call(receiver, object[k], k, object);
    }
};
var $8ece277686ef770f$var$forEach = function forEach(list, iterator, thisArg) {
    if (!$9FEAa(iterator)) throw new TypeError("iterator must be a function");
    var receiver;
    if (arguments.length >= 3) receiver = thisArg;
    if ($8ece277686ef770f$var$toStr.call(list) === "[object Array]") $8ece277686ef770f$var$forEachArray(list, iterator, receiver);
    else if (typeof list === "string") $8ece277686ef770f$var$forEachString(list, iterator, receiver);
    else $8ece277686ef770f$var$forEachObject(list, iterator, receiver);
};
module.exports = $8ece277686ef770f$var$forEach;

});
parcelRequire.register("9FEAa", function(module, exports) {
"use strict";
var $70a76c390446f1b5$var$fnToStr = Function.prototype.toString;
var $70a76c390446f1b5$var$reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
var $70a76c390446f1b5$var$badArrayLike;
var $70a76c390446f1b5$var$isCallableMarker;
if (typeof $70a76c390446f1b5$var$reflectApply === "function" && typeof Object.defineProperty === "function") try {
    $70a76c390446f1b5$var$badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
            throw $70a76c390446f1b5$var$isCallableMarker;
        }
    });
    $70a76c390446f1b5$var$isCallableMarker = {};
    // eslint-disable-next-line no-throw-literal
    $70a76c390446f1b5$var$reflectApply(function() {
        throw 42;
    }, null, $70a76c390446f1b5$var$badArrayLike);
} catch (_) {
    if (_ !== $70a76c390446f1b5$var$isCallableMarker) $70a76c390446f1b5$var$reflectApply = null;
}
else $70a76c390446f1b5$var$reflectApply = null;
var $70a76c390446f1b5$var$constructorRegex = /^\s*class\b/;
var $70a76c390446f1b5$var$isES6ClassFn = function isES6ClassFunction(value) {
    try {
        var fnStr = $70a76c390446f1b5$var$fnToStr.call(value);
        return $70a76c390446f1b5$var$constructorRegex.test(fnStr);
    } catch (e) {
        return false; // not a function
    }
};
var $70a76c390446f1b5$var$tryFunctionObject = function tryFunctionToStr(value) {
    try {
        if ($70a76c390446f1b5$var$isES6ClassFn(value)) return false;
        $70a76c390446f1b5$var$fnToStr.call(value);
        return true;
    } catch (e) {
        return false;
    }
};
var $70a76c390446f1b5$var$toStr = Object.prototype.toString;
var $70a76c390446f1b5$var$fnClass = "[object Function]";
var $70a76c390446f1b5$var$genClass = "[object GeneratorFunction]";
var $70a76c390446f1b5$var$hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag; // better: use `has-tostringtag`
/* globals document: false */ var $70a76c390446f1b5$var$documentDotAll = typeof document === "object" && typeof document.all === "undefined" && document.all !== undefined ? document.all : {};
module.exports = $70a76c390446f1b5$var$reflectApply ? function isCallable(value) {
    if (value === $70a76c390446f1b5$var$documentDotAll) return true;
    if (!value) return false;
    if (typeof value !== "function" && typeof value !== "object") return false;
    if (typeof value === "function" && !value.prototype) return true;
    try {
        $70a76c390446f1b5$var$reflectApply(value, null, $70a76c390446f1b5$var$badArrayLike);
    } catch (e) {
        if (e !== $70a76c390446f1b5$var$isCallableMarker) return false;
    }
    return !$70a76c390446f1b5$var$isES6ClassFn(value);
} : function isCallable(value) {
    if (value === $70a76c390446f1b5$var$documentDotAll) return true;
    if (!value) return false;
    if (typeof value !== "function" && typeof value !== "object") return false;
    if (typeof value === "function" && !value.prototype) return true;
    if ($70a76c390446f1b5$var$hasToStringTag) return $70a76c390446f1b5$var$tryFunctionObject(value);
    if ($70a76c390446f1b5$var$isES6ClassFn(value)) return false;
    var strClass = $70a76c390446f1b5$var$toStr.call(value);
    return strClass === $70a76c390446f1b5$var$fnClass || strClass === $70a76c390446f1b5$var$genClass;
};

});


parcelRequire.register("9x1Am", function(module, exports) {
"use strict";
var $6f086cf362cf713f$var$possibleNames = [
    "BigInt64Array",
    "BigUint64Array",
    "Float32Array",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray"
];
var $6f086cf362cf713f$var$g = typeof globalThis === "undefined" ? $parcel$global : globalThis;
module.exports = function availableTypedArrays() {
    var out = [];
    for(var i = 0; i < $6f086cf362cf713f$var$possibleNames.length; i++)if (typeof $6f086cf362cf713f$var$g[$6f086cf362cf713f$var$possibleNames[i]] === "function") out[out.length] = $6f086cf362cf713f$var$possibleNames[i];
    return out;
};

});

parcelRequire.register("2aUWV", function(module, exports) {
"use strict";

var $i6jPy = parcelRequire("i6jPy");
var $1958b0ef596ef429$var$$gOPD = $i6jPy("%Object.getOwnPropertyDescriptor%", true);
if ($1958b0ef596ef429$var$$gOPD) try {
    $1958b0ef596ef429$var$$gOPD([], "length");
} catch (e) {
    // IE 8 has a broken gOPD
    $1958b0ef596ef429$var$$gOPD = null;
}
module.exports = $1958b0ef596ef429$var$$gOPD;

});

parcelRequire.register("bH9aY", function(module, exports) {
"use strict";

var $cg9fx = parcelRequire("cg9fx");

var $9x1Am = parcelRequire("9x1Am");

var $jiywP = parcelRequire("jiywP");
var $883ad403067d4362$var$$toString = $jiywP("Object.prototype.toString");

var $883ad403067d4362$var$hasToStringTag = (parcelRequire("3U2NC"))();
var $883ad403067d4362$var$g = typeof globalThis === "undefined" ? $parcel$global : globalThis;
var $883ad403067d4362$var$typedArrays = $9x1Am();
var $883ad403067d4362$var$$indexOf = $jiywP("Array.prototype.indexOf", true) || function indexOf(array, value) {
    for(var i = 0; i < array.length; i += 1){
        if (array[i] === value) return i;
    }
    return -1;
};
var $883ad403067d4362$var$$slice = $jiywP("String.prototype.slice");
var $883ad403067d4362$var$toStrTags = {};

var $2aUWV = parcelRequire("2aUWV");
var $883ad403067d4362$var$getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if ($883ad403067d4362$var$hasToStringTag && $2aUWV && $883ad403067d4362$var$getPrototypeOf) $cg9fx($883ad403067d4362$var$typedArrays, function(typedArray) {
    var arr = new $883ad403067d4362$var$g[typedArray]();
    if (Symbol.toStringTag in arr) {
        var proto = $883ad403067d4362$var$getPrototypeOf(arr);
        var descriptor = $2aUWV(proto, Symbol.toStringTag);
        if (!descriptor) {
            var superProto = $883ad403067d4362$var$getPrototypeOf(proto);
            descriptor = $2aUWV(superProto, Symbol.toStringTag);
        }
        $883ad403067d4362$var$toStrTags[typedArray] = descriptor.get;
    }
});
var $883ad403067d4362$var$tryTypedArrays = function tryAllTypedArrays(value) {
    var anyTrue = false;
    $cg9fx($883ad403067d4362$var$toStrTags, function(getter, typedArray) {
        if (!anyTrue) try {
            anyTrue = getter.call(value) === typedArray;
        } catch (e) {}
    });
    return anyTrue;
};
module.exports = function isTypedArray(value) {
    if (!value || typeof value !== "object") return false;
    if (!$883ad403067d4362$var$hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag = $883ad403067d4362$var$$slice($883ad403067d4362$var$$toString(value), 8, -1);
        return $883ad403067d4362$var$$indexOf($883ad403067d4362$var$typedArrays, tag) > -1;
    }
    if (!$2aUWV) return false;
    return $883ad403067d4362$var$tryTypedArrays(value);
};

});



parcelRequire.register("dGKaU", function(module, exports) {
module.exports = function isBuffer(arg) {
    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
};

});

parcelRequire.register("4gnOs", function(module, exports) {
if (typeof Object.create === "function") // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

});


parcelRequire.register("2Kc0N", function(module, exports) {
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ 
var $6FDNW = parcelRequire("6FDNW");
var $1ff931f6606192f9$require$Buffer = $6FDNW.Buffer;
"use strict";

var $17709 = parcelRequire("17709");

var $3hLdt = parcelRequire("3hLdt");
var $1ff931f6606192f9$var$CAT_FIXED = 1;
var $1ff931f6606192f9$var$CAT_VARIABLE = 2;
var $1ff931f6606192f9$var$CAT_COMPOUND = 3;
var $1ff931f6606192f9$var$CAT_ARRAY = 4;
function $1ff931f6606192f9$var$Typed(type, value, code, descriptor) {
    this.type = type;
    this.value = value;
    if (code) {
        this.array_constructor = {
            "typecode": code
        };
        if (descriptor) this.array_constructor.descriptor = descriptor;
    }
}
$1ff931f6606192f9$var$Typed.prototype.toString = function() {
    return this.value ? this.value.toString() : null;
};
$1ff931f6606192f9$var$Typed.prototype.toLocaleString = function() {
    return this.value ? this.value.toLocaleString() : null;
};
$1ff931f6606192f9$var$Typed.prototype.valueOf = function() {
    return this.value;
};
$1ff931f6606192f9$var$Typed.prototype.toJSON = function() {
    return this.value && this.value.toJSON ? this.value.toJSON() : this.value;
};
$1ff931f6606192f9$var$Typed.prototype.toRheaTyped = function() {
    return this;
};
function $1ff931f6606192f9$var$TypeDesc(name, typecode, props, empty_value) {
    this.name = name;
    this.typecode = typecode;
    var subcategory = typecode >>> 4;
    switch(subcategory){
        case 0x4:
            this.width = 0;
            this.category = $1ff931f6606192f9$var$CAT_FIXED;
            break;
        case 0x5:
            this.width = 1;
            this.category = $1ff931f6606192f9$var$CAT_FIXED;
            break;
        case 0x6:
            this.width = 2;
            this.category = $1ff931f6606192f9$var$CAT_FIXED;
            break;
        case 0x7:
            this.width = 4;
            this.category = $1ff931f6606192f9$var$CAT_FIXED;
            break;
        case 0x8:
            this.width = 8;
            this.category = $1ff931f6606192f9$var$CAT_FIXED;
            break;
        case 0x9:
            this.width = 16;
            this.category = $1ff931f6606192f9$var$CAT_FIXED;
            break;
        case 0xA:
            this.width = 1;
            this.category = $1ff931f6606192f9$var$CAT_VARIABLE;
            break;
        case 0xB:
            this.width = 4;
            this.category = $1ff931f6606192f9$var$CAT_VARIABLE;
            break;
        case 0xC:
            this.width = 1;
            this.category = $1ff931f6606192f9$var$CAT_COMPOUND;
            break;
        case 0xD:
            this.width = 4;
            this.category = $1ff931f6606192f9$var$CAT_COMPOUND;
            break;
        case 0xE:
            this.width = 1;
            this.category = $1ff931f6606192f9$var$CAT_ARRAY;
            break;
        case 0xF:
            this.width = 4;
            this.category = $1ff931f6606192f9$var$CAT_ARRAY;
            break;
        default:
            break;
    }
    if (props) {
        if (props.read) this.read = props.read;
        if (props.write) this.write = props.write;
        if (props.encoding) this.encoding = props.encoding;
    }
    var t = this;
    if (subcategory === 0x4) // 'empty' types don't take a value
    this.create = function() {
        return new $1ff931f6606192f9$var$Typed(t, empty_value);
    };
    else if (subcategory === 0xE || subcategory === 0xF) this.create = function(v, code, descriptor) {
        return new $1ff931f6606192f9$var$Typed(t, v, code, descriptor);
    };
    else this.create = function(v) {
        return new $1ff931f6606192f9$var$Typed(t, v);
    };
}
$1ff931f6606192f9$var$TypeDesc.prototype.toString = function() {
    return this.name + "#" + $1ff931f6606192f9$var$hex(this.typecode);
};
function $1ff931f6606192f9$var$hex(i) {
    return Number(i).toString(16);
}
var $1ff931f6606192f9$var$types = {
    "by_code": {}
};
Object.defineProperty($1ff931f6606192f9$var$types, "MAX_UINT", {
    value: 4294967295,
    writable: false,
    configurable: false
});
Object.defineProperty($1ff931f6606192f9$var$types, "MAX_USHORT", {
    value: 65535,
    writable: false,
    configurable: false
});
function $1ff931f6606192f9$var$define_type(name, typecode, annotations, empty_value) {
    var t = new $1ff931f6606192f9$var$TypeDesc(name, typecode, annotations, empty_value);
    t.create.typecode = t.typecode; //hack
    $1ff931f6606192f9$var$types.by_code[t.typecode] = t;
    $1ff931f6606192f9$var$types[name] = t.create;
}
function $1ff931f6606192f9$var$buffer_uint8_ops() {
    return {
        "read": function(buffer, offset) {
            return buffer.readUInt8(offset);
        },
        "write": function(buffer, value, offset) {
            buffer.writeUInt8(value, offset);
        }
    };
}
function $1ff931f6606192f9$var$buffer_uint16be_ops() {
    return {
        "read": function(buffer, offset) {
            return buffer.readUInt16BE(offset);
        },
        "write": function(buffer, value, offset) {
            buffer.writeUInt16BE(value, offset);
        }
    };
}
function $1ff931f6606192f9$var$buffer_uint32be_ops() {
    return {
        "read": function(buffer, offset) {
            return buffer.readUInt32BE(offset);
        },
        "write": function(buffer, value, offset) {
            buffer.writeUInt32BE(value, offset);
        }
    };
}
function $1ff931f6606192f9$var$buffer_int8_ops() {
    return {
        "read": function(buffer, offset) {
            return buffer.readInt8(offset);
        },
        "write": function(buffer, value, offset) {
            buffer.writeInt8(value, offset);
        }
    };
}
function $1ff931f6606192f9$var$buffer_int16be_ops() {
    return {
        "read": function(buffer, offset) {
            return buffer.readInt16BE(offset);
        },
        "write": function(buffer, value, offset) {
            buffer.writeInt16BE(value, offset);
        }
    };
}
function $1ff931f6606192f9$var$buffer_int32be_ops() {
    return {
        "read": function(buffer, offset) {
            return buffer.readInt32BE(offset);
        },
        "write": function(buffer, value, offset) {
            buffer.writeInt32BE(value, offset);
        }
    };
}
function $1ff931f6606192f9$var$buffer_floatbe_ops() {
    return {
        "read": function(buffer, offset) {
            return buffer.readFloatBE(offset);
        },
        "write": function(buffer, value, offset) {
            buffer.writeFloatBE(value, offset);
        }
    };
}
function $1ff931f6606192f9$var$buffer_doublebe_ops() {
    return {
        "read": function(buffer, offset) {
            return buffer.readDoubleBE(offset);
        },
        "write": function(buffer, value, offset) {
            buffer.writeDoubleBE(value, offset);
        }
    };
}
var $1ff931f6606192f9$var$MAX_UINT = 4294967296; // 2^32
var $1ff931f6606192f9$var$MIN_INT = -2147483647;
function $1ff931f6606192f9$var$write_ulong(buffer, value, offset) {
    if (typeof value === "number" || value instanceof Number) {
        var hi = Math.floor(value / $1ff931f6606192f9$var$MAX_UINT);
        var lo = value % $1ff931f6606192f9$var$MAX_UINT;
        buffer.writeUInt32BE(hi, offset);
        buffer.writeUInt32BE(lo, offset + 4);
    } else value.copy(buffer, offset);
}
function $1ff931f6606192f9$var$read_ulong(buffer, offset) {
    var hi = buffer.readUInt32BE(offset);
    var lo = buffer.readUInt32BE(offset + 4);
    if (hi < 2097153) return hi * $1ff931f6606192f9$var$MAX_UINT + lo;
    else return buffer.slice(offset, offset + 8);
}
function $1ff931f6606192f9$var$write_long(buffer, value, offset) {
    if (typeof value === "number" || value instanceof Number) {
        var abs = Math.abs(value);
        var hi = Math.floor(abs / $1ff931f6606192f9$var$MAX_UINT);
        var lo = abs % $1ff931f6606192f9$var$MAX_UINT;
        buffer.writeInt32BE(hi, offset);
        buffer.writeUInt32BE(lo, offset + 4);
        if (value < 0) {
            var carry = 1;
            for(var i = 0; i < 8; i++){
                var index = offset + (7 - i);
                var v = (buffer[index] ^ 0xFF) + carry;
                buffer[index] = v & 0xFF;
                carry = v >> 8;
            }
        }
    } else value.copy(buffer, offset);
}
function $1ff931f6606192f9$var$write_timestamp(buffer, value, offset) {
    if (typeof value === "object" && value !== null && typeof value.getTime === "function") value = value.getTime();
    return $1ff931f6606192f9$var$write_long(buffer, value, offset);
}
function $1ff931f6606192f9$var$read_long(buffer, offset) {
    var hi = buffer.readInt32BE(offset);
    var lo = buffer.readUInt32BE(offset + 4);
    if (hi < 2097153 && hi > -2097153) return hi * $1ff931f6606192f9$var$MAX_UINT + lo;
    else return buffer.slice(offset, offset + 8);
}
function $1ff931f6606192f9$var$read_timestamp(buffer, offset) {
    const l = $1ff931f6606192f9$var$read_long(buffer, offset);
    return new Date(l);
}
$1ff931f6606192f9$var$define_type("Null", 0x40, undefined, null);
$1ff931f6606192f9$var$define_type("Boolean", 0x56, $1ff931f6606192f9$var$buffer_uint8_ops());
$1ff931f6606192f9$var$define_type("True", 0x41, undefined, true);
$1ff931f6606192f9$var$define_type("False", 0x42, undefined, false);
$1ff931f6606192f9$var$define_type("Ubyte", 0x50, $1ff931f6606192f9$var$buffer_uint8_ops());
$1ff931f6606192f9$var$define_type("Ushort", 0x60, $1ff931f6606192f9$var$buffer_uint16be_ops());
$1ff931f6606192f9$var$define_type("Uint", 0x70, $1ff931f6606192f9$var$buffer_uint32be_ops());
$1ff931f6606192f9$var$define_type("SmallUint", 0x52, $1ff931f6606192f9$var$buffer_uint8_ops());
$1ff931f6606192f9$var$define_type("Uint0", 0x43, undefined, 0);
$1ff931f6606192f9$var$define_type("Ulong", 0x80, {
    "write": $1ff931f6606192f9$var$write_ulong,
    "read": $1ff931f6606192f9$var$read_ulong
});
$1ff931f6606192f9$var$define_type("SmallUlong", 0x53, $1ff931f6606192f9$var$buffer_uint8_ops());
$1ff931f6606192f9$var$define_type("Ulong0", 0x44, undefined, 0);
$1ff931f6606192f9$var$define_type("Byte", 0x51, $1ff931f6606192f9$var$buffer_int8_ops());
$1ff931f6606192f9$var$define_type("Short", 0x61, $1ff931f6606192f9$var$buffer_int16be_ops());
$1ff931f6606192f9$var$define_type("Int", 0x71, $1ff931f6606192f9$var$buffer_int32be_ops());
$1ff931f6606192f9$var$define_type("SmallInt", 0x54, $1ff931f6606192f9$var$buffer_int8_ops());
$1ff931f6606192f9$var$define_type("Long", 0x81, {
    "write": $1ff931f6606192f9$var$write_long,
    "read": $1ff931f6606192f9$var$read_long
});
$1ff931f6606192f9$var$define_type("SmallLong", 0x55, $1ff931f6606192f9$var$buffer_int8_ops());
$1ff931f6606192f9$var$define_type("Float", 0x72, $1ff931f6606192f9$var$buffer_floatbe_ops());
$1ff931f6606192f9$var$define_type("Double", 0x82, $1ff931f6606192f9$var$buffer_doublebe_ops());
$1ff931f6606192f9$var$define_type("Decimal32", 0x74);
$1ff931f6606192f9$var$define_type("Decimal64", 0x84);
$1ff931f6606192f9$var$define_type("Decimal128", 0x94);
$1ff931f6606192f9$var$define_type("CharUTF32", 0x73, $1ff931f6606192f9$var$buffer_uint32be_ops());
$1ff931f6606192f9$var$define_type("Timestamp", 0x83, {
    "write": $1ff931f6606192f9$var$write_timestamp,
    "read": $1ff931f6606192f9$var$read_timestamp
});
$1ff931f6606192f9$var$define_type("Uuid", 0x98); //TODO: convert to/from stringified form?
$1ff931f6606192f9$var$define_type("Vbin8", 0xa0);
$1ff931f6606192f9$var$define_type("Vbin32", 0xb0);
$1ff931f6606192f9$var$define_type("Str8", 0xa1, {
    "encoding": "utf8"
});
$1ff931f6606192f9$var$define_type("Str32", 0xb1, {
    "encoding": "utf8"
});
$1ff931f6606192f9$var$define_type("Sym8", 0xa3, {
    "encoding": "ascii"
});
$1ff931f6606192f9$var$define_type("Sym32", 0xb3, {
    "encoding": "ascii"
});
$1ff931f6606192f9$var$define_type("List0", 0x45, undefined, []);
$1ff931f6606192f9$var$define_type("List8", 0xc0);
$1ff931f6606192f9$var$define_type("List32", 0xd0);
$1ff931f6606192f9$var$define_type("Map8", 0xc1);
$1ff931f6606192f9$var$define_type("Map32", 0xd1);
$1ff931f6606192f9$var$define_type("Array8", 0xe0);
$1ff931f6606192f9$var$define_type("Array32", 0xf0);
function $1ff931f6606192f9$var$is_one_of(o, typelist) {
    for(var i = 0; i < typelist.length; i++){
        if (o.type.typecode === typelist[i].typecode) return true;
    }
    return false;
}
function $1ff931f6606192f9$var$buffer_zero(b, len, neg) {
    for(var i = 0; i < len && i < b.length; i++){
        if (b[i] !== (neg ? 0xff : 0)) return false;
    }
    return true;
}
$1ff931f6606192f9$var$types.is_ulong = function(o) {
    return $1ff931f6606192f9$var$is_one_of(o, [
        $1ff931f6606192f9$var$types.Ulong,
        $1ff931f6606192f9$var$types.Ulong0,
        $1ff931f6606192f9$var$types.SmallUlong
    ]);
};
$1ff931f6606192f9$var$types.is_string = function(o) {
    return $1ff931f6606192f9$var$is_one_of(o, [
        $1ff931f6606192f9$var$types.Str8,
        $1ff931f6606192f9$var$types.Str32
    ]);
};
$1ff931f6606192f9$var$types.is_symbol = function(o) {
    return $1ff931f6606192f9$var$is_one_of(o, [
        $1ff931f6606192f9$var$types.Sym8,
        $1ff931f6606192f9$var$types.Sym32
    ]);
};
$1ff931f6606192f9$var$types.is_list = function(o) {
    return $1ff931f6606192f9$var$is_one_of(o, [
        $1ff931f6606192f9$var$types.List0,
        $1ff931f6606192f9$var$types.List8,
        $1ff931f6606192f9$var$types.List32
    ]);
};
$1ff931f6606192f9$var$types.is_map = function(o) {
    return $1ff931f6606192f9$var$is_one_of(o, [
        $1ff931f6606192f9$var$types.Map8,
        $1ff931f6606192f9$var$types.Map32
    ]);
};
$1ff931f6606192f9$var$types.wrap_boolean = function(v) {
    return v ? $1ff931f6606192f9$var$types.True() : $1ff931f6606192f9$var$types.False();
};
$1ff931f6606192f9$var$types.wrap_ulong = function(l) {
    if ($1ff931f6606192f9$require$Buffer.isBuffer(l)) {
        if ($1ff931f6606192f9$var$buffer_zero(l, 8, false)) return $1ff931f6606192f9$var$types.Ulong0();
        return $1ff931f6606192f9$var$buffer_zero(l, 7, false) ? $1ff931f6606192f9$var$types.SmallUlong(l[7]) : $1ff931f6606192f9$var$types.Ulong(l);
    } else {
        if (l === 0) return $1ff931f6606192f9$var$types.Ulong0();
        else return l > 255 ? $1ff931f6606192f9$var$types.Ulong(l) : $1ff931f6606192f9$var$types.SmallUlong(l);
    }
};
$1ff931f6606192f9$var$types.wrap_uint = function(l) {
    if (l === 0) return $1ff931f6606192f9$var$types.Uint0();
    else return l > 255 ? $1ff931f6606192f9$var$types.Uint(l) : $1ff931f6606192f9$var$types.SmallUint(l);
};
$1ff931f6606192f9$var$types.wrap_ushort = function(l) {
    return $1ff931f6606192f9$var$types.Ushort(l);
};
$1ff931f6606192f9$var$types.wrap_ubyte = function(l) {
    return $1ff931f6606192f9$var$types.Ubyte(l);
};
$1ff931f6606192f9$var$types.wrap_long = function(l) {
    if ($1ff931f6606192f9$require$Buffer.isBuffer(l)) {
        var negFlag = (l[0] & 0x80) !== 0;
        if ($1ff931f6606192f9$var$buffer_zero(l, 7, negFlag) && (l[7] & 0x80) === (negFlag ? 0x80 : 0)) return $1ff931f6606192f9$var$types.SmallLong(negFlag ? -((l[7] ^ 0xff) + 1) : l[7]);
        return $1ff931f6606192f9$var$types.Long(l);
    } else return l > 127 || l < -128 ? $1ff931f6606192f9$var$types.Long(l) : $1ff931f6606192f9$var$types.SmallLong(l);
};
$1ff931f6606192f9$var$types.wrap_int = function(l) {
    return l > 127 || l < -128 ? $1ff931f6606192f9$var$types.Int(l) : $1ff931f6606192f9$var$types.SmallInt(l);
};
$1ff931f6606192f9$var$types.wrap_short = function(l) {
    return $1ff931f6606192f9$var$types.Short(l);
};
$1ff931f6606192f9$var$types.wrap_byte = function(l) {
    return $1ff931f6606192f9$var$types.Byte(l);
};
$1ff931f6606192f9$var$types.wrap_float = function(l) {
    return $1ff931f6606192f9$var$types.Float(l);
};
$1ff931f6606192f9$var$types.wrap_double = function(l) {
    return $1ff931f6606192f9$var$types.Double(l);
};
$1ff931f6606192f9$var$types.wrap_timestamp = function(l) {
    return $1ff931f6606192f9$var$types.Timestamp(l);
};
$1ff931f6606192f9$var$types.wrap_char = function(v) {
    return $1ff931f6606192f9$var$types.CharUTF32(v);
};
$1ff931f6606192f9$var$types.wrap_uuid = function(v) {
    return $1ff931f6606192f9$var$types.Uuid(v);
};
$1ff931f6606192f9$var$types.wrap_binary = function(s) {
    return s.length > 255 ? $1ff931f6606192f9$var$types.Vbin32(s) : $1ff931f6606192f9$var$types.Vbin8(s);
};
$1ff931f6606192f9$var$types.wrap_string = function(s) {
    return $1ff931f6606192f9$require$Buffer.byteLength(s) > 255 ? $1ff931f6606192f9$var$types.Str32(s) : $1ff931f6606192f9$var$types.Str8(s);
};
$1ff931f6606192f9$var$types.wrap_symbol = function(s) {
    return $1ff931f6606192f9$require$Buffer.byteLength(s) > 255 ? $1ff931f6606192f9$var$types.Sym32(s) : $1ff931f6606192f9$var$types.Sym8(s);
};
$1ff931f6606192f9$var$types.wrap_list = function(l) {
    if (l.length === 0) return $1ff931f6606192f9$var$types.List0();
    var items = l.map($1ff931f6606192f9$var$types.wrap);
    return $1ff931f6606192f9$var$types.List32(items);
};
$1ff931f6606192f9$var$types.wrap_set_as_list = function(l) {
    if (l.size === 0) return $1ff931f6606192f9$var$types.List0();
    var items = Array.from(l, $1ff931f6606192f9$var$types.wrap);
    return $1ff931f6606192f9$var$types.List32(items);
};
$1ff931f6606192f9$var$types.wrap_map = function(m, key_wrapper) {
    var items = [];
    for(var k in m){
        items.push(key_wrapper ? key_wrapper(k) : $1ff931f6606192f9$var$types.wrap(k));
        items.push($1ff931f6606192f9$var$types.wrap(m[k]));
    }
    return $1ff931f6606192f9$var$types.Map32(items);
};
$1ff931f6606192f9$var$types.wrap_map_as_map = function(m) {
    var items = [];
    for (var [k, v] of m){
        items.push($1ff931f6606192f9$var$types.wrap(k));
        items.push($1ff931f6606192f9$var$types.wrap(v));
    }
    return $1ff931f6606192f9$var$types.Map32(items);
};
$1ff931f6606192f9$var$types.wrap_symbolic_map = function(m) {
    return $1ff931f6606192f9$var$types.wrap_map(m, $1ff931f6606192f9$var$types.wrap_symbol);
};
$1ff931f6606192f9$var$types.wrap_array = function(l, code, descriptors) {
    if (code) return $1ff931f6606192f9$var$types.Array32(l, code, descriptors);
    else {
        console.trace("An array must specify a type for its elements");
        throw new $17709.TypeError("An array must specify a type for its elements");
    }
};
$1ff931f6606192f9$var$types.wrap = function(o) {
    var t = typeof o;
    if (t === "object" && o !== null && typeof o.toRheaTyped === "function") return o.toRheaTyped();
    else if (t === "string") return $1ff931f6606192f9$var$types.wrap_string(o);
    else if (t === "boolean") return o ? $1ff931f6606192f9$var$types.True() : $1ff931f6606192f9$var$types.False();
    else if (t === "number" || o instanceof Number) {
        if (isNaN(o)) return $1ff931f6606192f9$var$types.Null();
        else if (Math.floor(o) - o !== 0) return $1ff931f6606192f9$var$types.Double(o);
        else if (o > 0) {
            if (o < $1ff931f6606192f9$var$MAX_UINT) return $1ff931f6606192f9$var$types.wrap_uint(o);
            else return $1ff931f6606192f9$var$types.wrap_ulong(o);
        } else {
            if (o > $1ff931f6606192f9$var$MIN_INT) return $1ff931f6606192f9$var$types.wrap_int(o);
            else return $1ff931f6606192f9$var$types.wrap_long(o);
        }
    } else if (o instanceof Date) return $1ff931f6606192f9$var$types.wrap_timestamp(o.getTime());
    else if (o instanceof $1ff931f6606192f9$require$Buffer || o instanceof Uint8Array) return $1ff931f6606192f9$var$types.wrap_binary(o);
    else if (t === "undefined" || o === null) return $1ff931f6606192f9$var$types.Null();
    else if (Array.isArray(o)) return $1ff931f6606192f9$var$types.wrap_list(o);
    else if (o instanceof Map) return $1ff931f6606192f9$var$types.wrap_map_as_map(o);
    else if (o instanceof Set) return $1ff931f6606192f9$var$types.wrap_set_as_list(o);
    else return $1ff931f6606192f9$var$types.wrap_map(o);
};
$1ff931f6606192f9$var$types.wrap_described = function(value, descriptor) {
    var result = $1ff931f6606192f9$var$types.wrap(value);
    if (descriptor) {
        if (typeof descriptor === "string") result = $1ff931f6606192f9$var$types.described($1ff931f6606192f9$var$types.wrap_symbol(descriptor), result);
        else if (typeof descriptor === "number" || descriptor instanceof Number) result = $1ff931f6606192f9$var$types.described($1ff931f6606192f9$var$types.wrap_ulong(descriptor), result);
    }
    return result;
};
$1ff931f6606192f9$var$types.wrap_message_id = function(o) {
    var t = typeof o;
    if (t === "string") return $1ff931f6606192f9$var$types.wrap_string(o);
    else if (t === "number" || o instanceof Number) return $1ff931f6606192f9$var$types.wrap_ulong(o);
    else if ($1ff931f6606192f9$require$Buffer.isBuffer(o)) return $1ff931f6606192f9$var$types.wrap_uuid(o);
    else //TODO handle uuids
    throw new $17709.TypeError("invalid message id:" + o);
};
/**
 * Converts the list of keys and values that comprise an AMQP encoded
 * map into a proper javascript map/object.
 */ function $1ff931f6606192f9$var$mapify(elements) {
    var result = {};
    for(var i = 0; i + 1 < elements.length;)result[elements[i++]] = elements[i++];
    return result;
}
var $1ff931f6606192f9$var$by_descriptor = {};
$1ff931f6606192f9$var$types.unwrap_map_simple = function(o) {
    return $1ff931f6606192f9$var$mapify(o.value.map(function(i) {
        return $1ff931f6606192f9$var$types.unwrap(i, true);
    }));
};
$1ff931f6606192f9$var$types.unwrap = function(o, leave_described) {
    if (o instanceof $1ff931f6606192f9$var$Typed) {
        if (o.descriptor) {
            var c = $1ff931f6606192f9$var$by_descriptor[o.descriptor.value];
            if (c) return new c(o.value);
            else if (leave_described) return o;
        }
        var u = $1ff931f6606192f9$var$types.unwrap(o.value, true);
        return $1ff931f6606192f9$var$types.is_map(o) ? $1ff931f6606192f9$var$mapify(u) : u;
    } else if (Array.isArray(o)) return o.map(function(i) {
        return $1ff931f6606192f9$var$types.unwrap(i, true);
    });
    else return o;
};
/*
types.described = function (descriptor, typedvalue) {
    var o = Object.create(typedvalue);
    if (descriptor.length) {
        o.descriptor = descriptor.shift();
        return types.described(descriptor, o);
    } else {
        o.descriptor = descriptor;
        return o;
    }
};
*/ $1ff931f6606192f9$var$types.described_nc = function(descriptor, o) {
    if (descriptor.length) {
        o.descriptor = descriptor.shift();
        return $1ff931f6606192f9$var$types.described(descriptor, o);
    } else {
        o.descriptor = descriptor;
        return o;
    }
};
$1ff931f6606192f9$var$types.described = $1ff931f6606192f9$var$types.described_nc;
function $1ff931f6606192f9$var$get_type(code) {
    var type = $1ff931f6606192f9$var$types.by_code[code];
    if (!type) throw new $17709.TypeError("Unrecognised typecode: " + $1ff931f6606192f9$var$hex(code));
    return type;
}
$1ff931f6606192f9$var$types.Reader = function(buffer) {
    this.buffer = buffer;
    this.position = 0;
};
$1ff931f6606192f9$var$types.Reader.prototype.read_typecode = function() {
    return this.read_uint(1);
};
$1ff931f6606192f9$var$types.Reader.prototype.read_uint = function(width) {
    var current = this.position;
    this.position += width;
    if (width === 1) return this.buffer.readUInt8(current);
    else if (width === 2) return this.buffer.readUInt16BE(current);
    else if (width === 4) return this.buffer.readUInt32BE(current);
    else throw new $17709.TypeError("Unexpected width for uint " + width);
};
$1ff931f6606192f9$var$types.Reader.prototype.read_fixed_width = function(type) {
    var current = this.position;
    this.position += type.width;
    if (type.read) return type.read(this.buffer, current);
    else return this.buffer.slice(current, this.position);
};
$1ff931f6606192f9$var$types.Reader.prototype.read_variable_width = function(type) {
    var size = this.read_uint(type.width);
    var slice = this.read_bytes(size);
    return type.encoding ? slice.toString(type.encoding) : slice;
};
$1ff931f6606192f9$var$types.Reader.prototype.read = function() {
    var constructor = this.read_constructor();
    var value = this.read_value($1ff931f6606192f9$var$get_type(constructor.typecode));
    return constructor.descriptor ? $1ff931f6606192f9$var$types.described_nc(constructor.descriptor, value) : value;
};
$1ff931f6606192f9$var$types.Reader.prototype.read_constructor = function(descriptors) {
    var code = this.read_typecode();
    if (code === 0x00) {
        if (descriptors === undefined) descriptors = [];
        descriptors.push(this.read());
        return this.read_constructor(descriptors);
    } else {
        if (descriptors === undefined) return {
            "typecode": code
        };
        else if (descriptors.length === 1) return {
            "typecode": code,
            "descriptor": descriptors[0]
        };
        else return {
            "typecode": code,
            "descriptor": descriptors[0],
            "descriptors": descriptors
        };
    }
};
$1ff931f6606192f9$var$types.Reader.prototype.read_value = function(type) {
    if (type.width === 0) return type.create();
    else if (type.category === $1ff931f6606192f9$var$CAT_FIXED) return type.create(this.read_fixed_width(type));
    else if (type.category === $1ff931f6606192f9$var$CAT_VARIABLE) return type.create(this.read_variable_width(type));
    else if (type.category === $1ff931f6606192f9$var$CAT_COMPOUND) return this.read_compound(type);
    else if (type.category === $1ff931f6606192f9$var$CAT_ARRAY) return this.read_array(type);
    else throw new $17709.TypeError("Invalid category for type: " + type);
};
$1ff931f6606192f9$var$types.Reader.prototype.read_array_items = function(n, type) {
    var items = [];
    while(items.length < n)items.push(this.read_value(type));
    return items;
};
$1ff931f6606192f9$var$types.Reader.prototype.read_n = function(n) {
    var items = new Array(n);
    for(var i = 0; i < n; i++)items[i] = this.read();
    return items;
};
$1ff931f6606192f9$var$types.Reader.prototype.read_size_count = function(width) {
    return {
        "size": this.read_uint(width),
        "count": this.read_uint(width)
    };
};
$1ff931f6606192f9$var$types.Reader.prototype.read_compound = function(type) {
    var limits = this.read_size_count(type.width);
    return type.create(this.read_n(limits.count));
};
$1ff931f6606192f9$var$types.Reader.prototype.read_array = function(type) {
    var limits = this.read_size_count(type.width);
    var constructor = this.read_constructor();
    return type.create(this.read_array_items(limits.count, $1ff931f6606192f9$var$get_type(constructor.typecode)), constructor.typecode, constructor.descriptor);
};
$1ff931f6606192f9$var$types.Reader.prototype.toString = function() {
    var s = "buffer@" + this.position;
    if (this.position) s += ": ";
    for(var i = this.position; i < this.buffer.length; i++){
        if (i > 0) s += ",";
        s += "0x" + Number(this.buffer[i]).toString(16);
    }
    return s;
};
$1ff931f6606192f9$var$types.Reader.prototype.reset = function() {
    this.position = 0;
};
$1ff931f6606192f9$var$types.Reader.prototype.skip = function(bytes) {
    this.position += bytes;
};
$1ff931f6606192f9$var$types.Reader.prototype.read_bytes = function(bytes) {
    var current = this.position;
    this.position += bytes;
    return this.buffer.slice(current, this.position);
};
$1ff931f6606192f9$var$types.Reader.prototype.remaining = function() {
    return this.buffer.length - this.position;
};
$1ff931f6606192f9$var$types.Writer = function(buffer) {
    this.buffer = buffer ? buffer : $3hLdt.allocate_buffer(1024);
    this.position = 0;
};
$1ff931f6606192f9$var$types.Writer.prototype.toBuffer = function() {
    return this.buffer.slice(0, this.position);
};
function $1ff931f6606192f9$var$max(a, b) {
    return a > b ? a : b;
}
$1ff931f6606192f9$var$types.Writer.prototype.ensure = function(length) {
    if (this.buffer.length < length) {
        var bigger = $3hLdt.allocate_buffer($1ff931f6606192f9$var$max(this.buffer.length * 2, length));
        this.buffer.copy(bigger);
        this.buffer = bigger;
    }
};
$1ff931f6606192f9$var$types.Writer.prototype.write_typecode = function(code) {
    this.write_uint(code, 1);
};
$1ff931f6606192f9$var$types.Writer.prototype.write_uint = function(value, width) {
    var current = this.position;
    this.ensure(this.position + width);
    this.position += width;
    if (width === 1) return this.buffer.writeUInt8(value, current);
    else if (width === 2) return this.buffer.writeUInt16BE(value, current);
    else if (width === 4) return this.buffer.writeUInt32BE(value, current);
    else throw new $17709.TypeError("Unexpected width for uint " + width);
};
$1ff931f6606192f9$var$types.Writer.prototype.write_fixed_width = function(type, value) {
    var current = this.position;
    this.ensure(this.position + type.width);
    this.position += type.width;
    if (type.write) type.write(this.buffer, value, current);
    else if (value.copy) value.copy(this.buffer, current);
    else throw new $17709.TypeError("Cannot handle write for " + type);
};
$1ff931f6606192f9$var$types.Writer.prototype.write_variable_width = function(type, value) {
    var source = type.encoding ? $1ff931f6606192f9$require$Buffer.from(value, type.encoding) : $1ff931f6606192f9$require$Buffer.from(value); //TODO: avoid creating new buffers
    this.write_uint(source.length, type.width);
    this.write_bytes(source);
};
$1ff931f6606192f9$var$types.Writer.prototype.write_bytes = function(source) {
    var current = this.position;
    this.ensure(this.position + source.length);
    this.position += source.length;
    source.copy(this.buffer, current);
};
$1ff931f6606192f9$var$types.Writer.prototype.write_constructor = function(typecode, descriptor) {
    if (descriptor) {
        this.write_typecode(0x00);
        this.write(descriptor);
    }
    this.write_typecode(typecode);
};
$1ff931f6606192f9$var$types.Writer.prototype.write = function(o) {
    if (o.type === undefined) {
        if (o.described) this.write(o.described());
        else throw new $17709.TypeError("Cannot write " + JSON.stringify(o));
    } else {
        this.write_constructor(o.type.typecode, o.descriptor);
        this.write_value(o.type, o.value, o.array_constructor);
    }
};
$1ff931f6606192f9$var$types.Writer.prototype.write_value = function(type, value, constructor /*for arrays only*/ ) {
    if (type.width === 0) return; //nothing further to do
    else if (type.category === $1ff931f6606192f9$var$CAT_FIXED) this.write_fixed_width(type, value);
    else if (type.category === $1ff931f6606192f9$var$CAT_VARIABLE) this.write_variable_width(type, value);
    else if (type.category === $1ff931f6606192f9$var$CAT_COMPOUND) this.write_compound(type, value);
    else if (type.category === $1ff931f6606192f9$var$CAT_ARRAY) this.write_array(type, value, constructor);
    else throw new $17709.TypeError("Invalid category " + type.category + " for type: " + type);
};
$1ff931f6606192f9$var$types.Writer.prototype.backfill_size = function(width, saved) {
    var gap = this.position - saved;
    this.position = saved;
    this.write_uint(gap - width, width);
    this.position += gap - width;
};
$1ff931f6606192f9$var$types.Writer.prototype.write_compound = function(type, value) {
    var saved = this.position;
    this.position += type.width; //skip size field
    this.write_uint(value.length, type.width); //count field
    for(var i = 0; i < value.length; i++)if (value[i] === undefined || value[i] === null) this.write($1ff931f6606192f9$var$types.Null());
    else this.write(value[i]);
    this.backfill_size(type.width, saved);
};
$1ff931f6606192f9$var$types.Writer.prototype.write_array = function(type, value, constructor) {
    var saved = this.position;
    this.position += type.width; //skip size field
    this.write_uint(value.length, type.width); //count field
    this.write_constructor(constructor.typecode, constructor.descriptor);
    var ctype = $1ff931f6606192f9$var$get_type(constructor.typecode);
    for(var i = 0; i < value.length; i++)this.write_value(ctype, value[i]);
    this.backfill_size(type.width, saved);
};
$1ff931f6606192f9$var$types.Writer.prototype.toString = function() {
    var s = "buffer@" + this.position;
    if (this.position) s += ": ";
    for(var i = 0; i < this.position; i++){
        if (i > 0) s += ",";
        s += ("00" + Number(this.buffer[i]).toString(16)).slice(-2);
    }
    return s;
};
$1ff931f6606192f9$var$types.Writer.prototype.skip = function(bytes) {
    this.ensure(this.position + bytes);
    this.position += bytes;
};
$1ff931f6606192f9$var$types.Writer.prototype.clear = function() {
    this.buffer.fill(0x00);
    this.position = 0;
};
$1ff931f6606192f9$var$types.Writer.prototype.remaining = function() {
    return this.buffer.length - this.position;
};
function $1ff931f6606192f9$var$get_constructor(typename) {
    if (typename === "symbol") return {
        typecode: $1ff931f6606192f9$var$types.Sym8.typecode
    };
    throw new $17709.TypeError("TODO: Array of type " + typename + " not yet supported");
}
function $1ff931f6606192f9$var$wrap_field(definition, instance) {
    if (instance !== undefined && instance !== null) {
        if (Array.isArray(instance)) {
            if (!definition.multiple) throw new $17709.TypeError("Field " + definition.name + " does not support multiple values, got " + JSON.stringify(instance));
            var constructor = $1ff931f6606192f9$var$get_constructor(definition.type);
            return $1ff931f6606192f9$var$types.wrap_array(instance, constructor.typecode, constructor.descriptor);
        } else if (definition.type === "*") return instance;
        else {
            var wrapper = $1ff931f6606192f9$var$types["wrap_" + definition.type];
            if (wrapper) return wrapper(instance);
            else throw new $17709.TypeError("No wrapper for field " + definition.name + " of type " + definition.type);
        }
    } else if (definition.mandatory) throw new $17709.TypeError("Field " + definition.name + " is mandatory");
    else return $1ff931f6606192f9$var$types.Null();
}
function $1ff931f6606192f9$var$get_accessors(index, field_definition) {
    var getter;
    if (field_definition.type === "*") getter = function() {
        return this.value[index];
    };
    else getter = function() {
        return $1ff931f6606192f9$var$types.unwrap(this.value[index]);
    };
    var setter = function(o) {
        this.value[index] = $1ff931f6606192f9$var$wrap_field(field_definition, o);
    };
    return {
        "get": getter,
        "set": setter,
        "enumerable": true,
        "configurable": false
    };
}
$1ff931f6606192f9$var$types.define_composite = function(def) {
    var c = function(fields) {
        this.value = fields ? fields : [];
    };
    c.descriptor = {
        numeric: def.code,
        symbolic: "amqp:" + def.name + ":list"
    };
    c.prototype.dispatch = function(target, frame) {
        target["on_" + def.name](frame);
    };
    //c.prototype.descriptor = c.descriptor.numeric;
    //c.prototype = Object.create(types.List8.prototype);
    for(var i = 0; i < def.fields.length; i++){
        var f = def.fields[i];
        Object.defineProperty(c.prototype, f.name, $1ff931f6606192f9$var$get_accessors(i, f));
    }
    c.toString = function() {
        return def.name + "#" + Number(def.code).toString(16);
    };
    c.prototype.toJSON = function() {
        var o = {};
        for(var f in this)if (f !== "value" && this[f]) o[f] = this[f];
        return o;
    };
    c.create = function(fields) {
        var o = new c;
        for(var f in fields)o[f] = fields[f];
        return o;
    };
    c.prototype.described = function() {
        return $1ff931f6606192f9$var$types.described_nc($1ff931f6606192f9$var$types.wrap_ulong(c.descriptor.numeric), $1ff931f6606192f9$var$types.wrap_list(this.value));
    };
    return c;
};
function $1ff931f6606192f9$var$add_type(def) {
    var c = $1ff931f6606192f9$var$types.define_composite(def);
    $1ff931f6606192f9$var$types["wrap_" + def.name] = function(fields) {
        return c.create(fields).described();
    };
    $1ff931f6606192f9$var$by_descriptor[Number(c.descriptor.numeric).toString(10)] = c;
    $1ff931f6606192f9$var$by_descriptor[c.descriptor.symbolic] = c;
}
$1ff931f6606192f9$var$add_type({
    name: "error",
    code: 0x1d,
    fields: [
        {
            name: "condition",
            type: "symbol",
            mandatory: true
        },
        {
            name: "description",
            type: "string"
        },
        {
            name: "info",
            type: "map"
        }
    ]
});
module.exports = $1ff931f6606192f9$var$types;

});
parcelRequire.register("6FDNW", function(module, exports) {

$parcel$export(module.exports, "Buffer", () => $4db572bf2ce0589b$export$a143d493d941bafc, (v) => $4db572bf2ce0589b$export$a143d493d941bafc = v);
$parcel$export(module.exports, "INSPECT_MAX_BYTES", () => $4db572bf2ce0589b$export$f99ded8fe4b79145, (v) => $4db572bf2ce0589b$export$f99ded8fe4b79145 = v);
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ var $4db572bf2ce0589b$export$a143d493d941bafc;
var $4db572bf2ce0589b$export$e4cf37d7f6fb9e0a;
var $4db572bf2ce0589b$export$f99ded8fe4b79145;
var $4db572bf2ce0589b$export$599f31c3813fae4d;
"use strict";

var $bpgzY = parcelRequire("bpgzY");

var $5Q6n3 = parcelRequire("5Q6n3");
var $4db572bf2ce0589b$var$customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
$4db572bf2ce0589b$export$a143d493d941bafc = $4db572bf2ce0589b$var$Buffer;
$4db572bf2ce0589b$export$e4cf37d7f6fb9e0a = $4db572bf2ce0589b$var$SlowBuffer;
$4db572bf2ce0589b$export$f99ded8fe4b79145 = 50;
var $4db572bf2ce0589b$var$K_MAX_LENGTH = 0x7fffffff;
$4db572bf2ce0589b$export$599f31c3813fae4d = $4db572bf2ce0589b$var$K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ $4db572bf2ce0589b$var$Buffer.TYPED_ARRAY_SUPPORT = $4db572bf2ce0589b$var$typedArraySupport();
if (!$4db572bf2ce0589b$var$Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function $4db572bf2ce0589b$var$typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty($4db572bf2ce0589b$var$Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!$4db572bf2ce0589b$var$Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty($4db572bf2ce0589b$var$Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!$4db572bf2ce0589b$var$Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function $4db572bf2ce0589b$var$createBuffer(length) {
    if (length > $4db572bf2ce0589b$var$K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, $4db572bf2ce0589b$var$Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function $4db572bf2ce0589b$var$Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return $4db572bf2ce0589b$var$allocUnsafe(arg);
    }
    return $4db572bf2ce0589b$var$from(arg, encodingOrOffset, length);
}
$4db572bf2ce0589b$var$Buffer.poolSize = 8192 // not used by this implementation
;
function $4db572bf2ce0589b$var$from(value, encodingOrOffset, length) {
    if (typeof value === "string") return $4db572bf2ce0589b$var$fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return $4db572bf2ce0589b$var$fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if ($4db572bf2ce0589b$var$isInstance(value, ArrayBuffer) || value && $4db572bf2ce0589b$var$isInstance(value.buffer, ArrayBuffer)) return $4db572bf2ce0589b$var$fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && ($4db572bf2ce0589b$var$isInstance(value, SharedArrayBuffer) || value && $4db572bf2ce0589b$var$isInstance(value.buffer, SharedArrayBuffer))) return $4db572bf2ce0589b$var$fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return $4db572bf2ce0589b$var$Buffer.from(valueOf, encodingOrOffset, length);
    var b = $4db572bf2ce0589b$var$fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return $4db572bf2ce0589b$var$Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ $4db572bf2ce0589b$var$Buffer.from = function(value, encodingOrOffset, length) {
    return $4db572bf2ce0589b$var$from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf($4db572bf2ce0589b$var$Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf($4db572bf2ce0589b$var$Buffer, Uint8Array);
function $4db572bf2ce0589b$var$assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function $4db572bf2ce0589b$var$alloc(size, fill, encoding) {
    $4db572bf2ce0589b$var$assertSize(size);
    if (size <= 0) return $4db572bf2ce0589b$var$createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? $4db572bf2ce0589b$var$createBuffer(size).fill(fill, encoding) : $4db572bf2ce0589b$var$createBuffer(size).fill(fill);
    return $4db572bf2ce0589b$var$createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ $4db572bf2ce0589b$var$Buffer.alloc = function(size, fill, encoding) {
    return $4db572bf2ce0589b$var$alloc(size, fill, encoding);
};
function $4db572bf2ce0589b$var$allocUnsafe(size) {
    $4db572bf2ce0589b$var$assertSize(size);
    return $4db572bf2ce0589b$var$createBuffer(size < 0 ? 0 : $4db572bf2ce0589b$var$checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ $4db572bf2ce0589b$var$Buffer.allocUnsafe = function(size) {
    return $4db572bf2ce0589b$var$allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ $4db572bf2ce0589b$var$Buffer.allocUnsafeSlow = function(size) {
    return $4db572bf2ce0589b$var$allocUnsafe(size);
};
function $4db572bf2ce0589b$var$fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!$4db572bf2ce0589b$var$Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    var length = $4db572bf2ce0589b$var$byteLength(string, encoding) | 0;
    var buf = $4db572bf2ce0589b$var$createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function $4db572bf2ce0589b$var$fromArrayLike(array) {
    var length = array.length < 0 ? 0 : $4db572bf2ce0589b$var$checked(array.length) | 0;
    var buf = $4db572bf2ce0589b$var$createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function $4db572bf2ce0589b$var$fromArrayView(arrayView) {
    if ($4db572bf2ce0589b$var$isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return $4db572bf2ce0589b$var$fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return $4db572bf2ce0589b$var$fromArrayLike(arrayView);
}
function $4db572bf2ce0589b$var$fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, $4db572bf2ce0589b$var$Buffer.prototype);
    return buf;
}
function $4db572bf2ce0589b$var$fromObject(obj) {
    if ($4db572bf2ce0589b$var$Buffer.isBuffer(obj)) {
        var len = $4db572bf2ce0589b$var$checked(obj.length) | 0;
        var buf = $4db572bf2ce0589b$var$createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || $4db572bf2ce0589b$var$numberIsNaN(obj.length)) return $4db572bf2ce0589b$var$createBuffer(0);
        return $4db572bf2ce0589b$var$fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return $4db572bf2ce0589b$var$fromArrayLike(obj.data);
}
function $4db572bf2ce0589b$var$checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= $4db572bf2ce0589b$var$K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + $4db572bf2ce0589b$var$K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function $4db572bf2ce0589b$var$SlowBuffer(length) {
    if (+length != length) length = 0;
    return $4db572bf2ce0589b$var$Buffer.alloc(+length);
}
$4db572bf2ce0589b$var$Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== $4db572bf2ce0589b$var$Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
$4db572bf2ce0589b$var$Buffer.compare = function compare(a, b) {
    if ($4db572bf2ce0589b$var$isInstance(a, Uint8Array)) a = $4db572bf2ce0589b$var$Buffer.from(a, a.offset, a.byteLength);
    if ($4db572bf2ce0589b$var$isInstance(b, Uint8Array)) b = $4db572bf2ce0589b$var$Buffer.from(b, b.offset, b.byteLength);
    if (!$4db572bf2ce0589b$var$Buffer.isBuffer(a) || !$4db572bf2ce0589b$var$Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
$4db572bf2ce0589b$var$Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
$4db572bf2ce0589b$var$Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return $4db572bf2ce0589b$var$Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = $4db572bf2ce0589b$var$Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if ($4db572bf2ce0589b$var$isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) $4db572bf2ce0589b$var$Buffer.from(buf).copy(buffer, pos);
            else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!$4db572bf2ce0589b$var$Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function $4db572bf2ce0589b$var$byteLength(string, encoding) {
    if ($4db572bf2ce0589b$var$Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || $4db572bf2ce0589b$var$isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return $4db572bf2ce0589b$var$utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return $4db572bf2ce0589b$var$base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : $4db572bf2ce0589b$var$utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
$4db572bf2ce0589b$var$Buffer.byteLength = $4db572bf2ce0589b$var$byteLength;
function $4db572bf2ce0589b$var$slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return $4db572bf2ce0589b$var$hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return $4db572bf2ce0589b$var$utf8Slice(this, start, end);
        case "ascii":
            return $4db572bf2ce0589b$var$asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return $4db572bf2ce0589b$var$latin1Slice(this, start, end);
        case "base64":
            return $4db572bf2ce0589b$var$base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return $4db572bf2ce0589b$var$utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
$4db572bf2ce0589b$var$Buffer.prototype._isBuffer = true;
function $4db572bf2ce0589b$var$swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
$4db572bf2ce0589b$var$Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(var i = 0; i < len; i += 2)$4db572bf2ce0589b$var$swap(this, i, i + 1);
    return this;
};
$4db572bf2ce0589b$var$Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(var i = 0; i < len; i += 4){
        $4db572bf2ce0589b$var$swap(this, i, i + 3);
        $4db572bf2ce0589b$var$swap(this, i + 1, i + 2);
    }
    return this;
};
$4db572bf2ce0589b$var$Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(var i = 0; i < len; i += 8){
        $4db572bf2ce0589b$var$swap(this, i, i + 7);
        $4db572bf2ce0589b$var$swap(this, i + 1, i + 6);
        $4db572bf2ce0589b$var$swap(this, i + 2, i + 5);
        $4db572bf2ce0589b$var$swap(this, i + 3, i + 4);
    }
    return this;
};
$4db572bf2ce0589b$var$Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return $4db572bf2ce0589b$var$utf8Slice(this, 0, length);
    return $4db572bf2ce0589b$var$slowToString.apply(this, arguments);
};
$4db572bf2ce0589b$var$Buffer.prototype.toLocaleString = $4db572bf2ce0589b$var$Buffer.prototype.toString;
$4db572bf2ce0589b$var$Buffer.prototype.equals = function equals(b) {
    if (!$4db572bf2ce0589b$var$Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return $4db572bf2ce0589b$var$Buffer.compare(this, b) === 0;
};
$4db572bf2ce0589b$var$Buffer.prototype.inspect = function inspect() {
    var str = "";
    var max = $4db572bf2ce0589b$export$f99ded8fe4b79145;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if ($4db572bf2ce0589b$var$customInspectSymbol) $4db572bf2ce0589b$var$Buffer.prototype[$4db572bf2ce0589b$var$customInspectSymbol] = $4db572bf2ce0589b$var$Buffer.prototype.inspect;
$4db572bf2ce0589b$var$Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if ($4db572bf2ce0589b$var$isInstance(target, Uint8Array)) target = $4db572bf2ce0589b$var$Buffer.from(target, target.offset, target.byteLength);
    if (!$4db572bf2ce0589b$var$Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function $4db572bf2ce0589b$var$bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if ($4db572bf2ce0589b$var$numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = $4db572bf2ce0589b$var$Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if ($4db572bf2ce0589b$var$Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return $4db572bf2ce0589b$var$arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return $4db572bf2ce0589b$var$arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function $4db572bf2ce0589b$var$arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
$4db572bf2ce0589b$var$Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
$4db572bf2ce0589b$var$Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return $4db572bf2ce0589b$var$bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
$4db572bf2ce0589b$var$Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return $4db572bf2ce0589b$var$bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function $4db572bf2ce0589b$var$hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if ($4db572bf2ce0589b$var$numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function $4db572bf2ce0589b$var$utf8Write(buf, string, offset, length) {
    return $4db572bf2ce0589b$var$blitBuffer($4db572bf2ce0589b$var$utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function $4db572bf2ce0589b$var$asciiWrite(buf, string, offset, length) {
    return $4db572bf2ce0589b$var$blitBuffer($4db572bf2ce0589b$var$asciiToBytes(string), buf, offset, length);
}
function $4db572bf2ce0589b$var$base64Write(buf, string, offset, length) {
    return $4db572bf2ce0589b$var$blitBuffer($4db572bf2ce0589b$var$base64ToBytes(string), buf, offset, length);
}
function $4db572bf2ce0589b$var$ucs2Write(buf, string, offset, length) {
    return $4db572bf2ce0589b$var$blitBuffer($4db572bf2ce0589b$var$utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
$4db572bf2ce0589b$var$Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    var loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return $4db572bf2ce0589b$var$hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return $4db572bf2ce0589b$var$utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return $4db572bf2ce0589b$var$asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return $4db572bf2ce0589b$var$base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return $4db572bf2ce0589b$var$ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
$4db572bf2ce0589b$var$Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function $4db572bf2ce0589b$var$base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return $bpgzY.fromByteArray(buf);
    else return $bpgzY.fromByteArray(buf.slice(start, end));
}
function $4db572bf2ce0589b$var$utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return $4db572bf2ce0589b$var$decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var $4db572bf2ce0589b$var$MAX_ARGUMENTS_LENGTH = 0x1000;
function $4db572bf2ce0589b$var$decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= $4db572bf2ce0589b$var$MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = "";
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += $4db572bf2ce0589b$var$MAX_ARGUMENTS_LENGTH));
    return res;
}
function $4db572bf2ce0589b$var$asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function $4db572bf2ce0589b$var$latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function $4db572bf2ce0589b$var$hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for(var i = start; i < end; ++i)out += $4db572bf2ce0589b$var$hexSliceLookupTable[buf[i]];
    return out;
}
function $4db572bf2ce0589b$var$utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
$4db572bf2ce0589b$var$Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, $4db572bf2ce0589b$var$Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function $4db572bf2ce0589b$var$checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
$4db572bf2ce0589b$var$Buffer.prototype.readUintLE = $4db572bf2ce0589b$var$Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
$4db572bf2ce0589b$var$Buffer.prototype.readUintBE = $4db572bf2ce0589b$var$Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
$4db572bf2ce0589b$var$Buffer.prototype.readUint8 = $4db572bf2ce0589b$var$Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, 1, this.length);
    return this[offset];
};
$4db572bf2ce0589b$var$Buffer.prototype.readUint16LE = $4db572bf2ce0589b$var$Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
$4db572bf2ce0589b$var$Buffer.prototype.readUint16BE = $4db572bf2ce0589b$var$Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
$4db572bf2ce0589b$var$Buffer.prototype.readUint32LE = $4db572bf2ce0589b$var$Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
$4db572bf2ce0589b$var$Buffer.prototype.readUint32BE = $4db572bf2ce0589b$var$Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
$4db572bf2ce0589b$var$Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
$4db572bf2ce0589b$var$Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
$4db572bf2ce0589b$var$Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
$4db572bf2ce0589b$var$Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
$4db572bf2ce0589b$var$Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
$4db572bf2ce0589b$var$Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
$4db572bf2ce0589b$var$Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
$4db572bf2ce0589b$var$Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, 4, this.length);
    return $5Q6n3.read(this, offset, true, 23, 4);
};
$4db572bf2ce0589b$var$Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, 4, this.length);
    return $5Q6n3.read(this, offset, false, 23, 4);
};
$4db572bf2ce0589b$var$Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, 8, this.length);
    return $5Q6n3.read(this, offset, true, 52, 8);
};
$4db572bf2ce0589b$var$Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkOffset(offset, 8, this.length);
    return $5Q6n3.read(this, offset, false, 52, 8);
};
function $4db572bf2ce0589b$var$checkInt(buf, value, offset, ext, max, min) {
    if (!$4db572bf2ce0589b$var$Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
$4db572bf2ce0589b$var$Buffer.prototype.writeUintLE = $4db572bf2ce0589b$var$Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        $4db572bf2ce0589b$var$checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
$4db572bf2ce0589b$var$Buffer.prototype.writeUintBE = $4db572bf2ce0589b$var$Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        $4db572bf2ce0589b$var$checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
$4db572bf2ce0589b$var$Buffer.prototype.writeUint8 = $4db572bf2ce0589b$var$Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
$4db572bf2ce0589b$var$Buffer.prototype.writeUint16LE = $4db572bf2ce0589b$var$Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
$4db572bf2ce0589b$var$Buffer.prototype.writeUint16BE = $4db572bf2ce0589b$var$Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
$4db572bf2ce0589b$var$Buffer.prototype.writeUint32LE = $4db572bf2ce0589b$var$Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
$4db572bf2ce0589b$var$Buffer.prototype.writeUint32BE = $4db572bf2ce0589b$var$Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
$4db572bf2ce0589b$var$Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        $4db572bf2ce0589b$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
$4db572bf2ce0589b$var$Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        $4db572bf2ce0589b$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
$4db572bf2ce0589b$var$Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
$4db572bf2ce0589b$var$Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
$4db572bf2ce0589b$var$Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
$4db572bf2ce0589b$var$Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
$4db572bf2ce0589b$var$Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function $4db572bf2ce0589b$var$checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function $4db572bf2ce0589b$var$writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    $5Q6n3.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
$4db572bf2ce0589b$var$Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return $4db572bf2ce0589b$var$writeFloat(this, value, offset, true, noAssert);
};
$4db572bf2ce0589b$var$Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return $4db572bf2ce0589b$var$writeFloat(this, value, offset, false, noAssert);
};
function $4db572bf2ce0589b$var$writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $4db572bf2ce0589b$var$checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    $5Q6n3.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
$4db572bf2ce0589b$var$Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return $4db572bf2ce0589b$var$writeDouble(this, value, offset, true, noAssert);
};
$4db572bf2ce0589b$var$Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return $4db572bf2ce0589b$var$writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
$4db572bf2ce0589b$var$Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!$4db572bf2ce0589b$var$Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
$4db572bf2ce0589b$var$Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !$4db572bf2ce0589b$var$Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = $4db572bf2ce0589b$var$Buffer.isBuffer(val) ? val : $4db572bf2ce0589b$var$Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var $4db572bf2ce0589b$var$INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function $4db572bf2ce0589b$var$base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace($4db572bf2ce0589b$var$INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function $4db572bf2ce0589b$var$utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function $4db572bf2ce0589b$var$asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function $4db572bf2ce0589b$var$utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function $4db572bf2ce0589b$var$base64ToBytes(str) {
    return $bpgzY.toByteArray($4db572bf2ce0589b$var$base64clean(str));
}
function $4db572bf2ce0589b$var$blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function $4db572bf2ce0589b$var$isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function $4db572bf2ce0589b$var$numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var $4db572bf2ce0589b$var$hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();

});
parcelRequire.register("bpgzY", function(module, exports) {

$parcel$export(module.exports, "toByteArray", () => $84dee3c89e895ac5$export$d622b2ad8d90c771, (v) => $84dee3c89e895ac5$export$d622b2ad8d90c771 = v);
$parcel$export(module.exports, "fromByteArray", () => $84dee3c89e895ac5$export$6100ba28696e12de, (v) => $84dee3c89e895ac5$export$6100ba28696e12de = v);
var $84dee3c89e895ac5$export$a48f0734ac7c2329;
var $84dee3c89e895ac5$export$d622b2ad8d90c771;
var $84dee3c89e895ac5$export$6100ba28696e12de;
"use strict";
$84dee3c89e895ac5$export$a48f0734ac7c2329 = $84dee3c89e895ac5$var$byteLength;
$84dee3c89e895ac5$export$d622b2ad8d90c771 = $84dee3c89e895ac5$var$toByteArray;
$84dee3c89e895ac5$export$6100ba28696e12de = $84dee3c89e895ac5$var$fromByteArray;
var $84dee3c89e895ac5$var$lookup = [];
var $84dee3c89e895ac5$var$revLookup = [];
var $84dee3c89e895ac5$var$Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var $84dee3c89e895ac5$var$code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var $84dee3c89e895ac5$var$i = 0, $84dee3c89e895ac5$var$len = $84dee3c89e895ac5$var$code.length; $84dee3c89e895ac5$var$i < $84dee3c89e895ac5$var$len; ++$84dee3c89e895ac5$var$i){
    $84dee3c89e895ac5$var$lookup[$84dee3c89e895ac5$var$i] = $84dee3c89e895ac5$var$code[$84dee3c89e895ac5$var$i];
    $84dee3c89e895ac5$var$revLookup[$84dee3c89e895ac5$var$code.charCodeAt($84dee3c89e895ac5$var$i)] = $84dee3c89e895ac5$var$i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
$84dee3c89e895ac5$var$revLookup["-".charCodeAt(0)] = 62;
$84dee3c89e895ac5$var$revLookup["_".charCodeAt(0)] = 63;
function $84dee3c89e895ac5$var$getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function $84dee3c89e895ac5$var$byteLength(b64) {
    var lens = $84dee3c89e895ac5$var$getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function $84dee3c89e895ac5$var$_byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function $84dee3c89e895ac5$var$toByteArray(b64) {
    var tmp;
    var lens = $84dee3c89e895ac5$var$getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new $84dee3c89e895ac5$var$Arr($84dee3c89e895ac5$var$_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = $84dee3c89e895ac5$var$revLookup[b64.charCodeAt(i)] << 18 | $84dee3c89e895ac5$var$revLookup[b64.charCodeAt(i + 1)] << 12 | $84dee3c89e895ac5$var$revLookup[b64.charCodeAt(i + 2)] << 6 | $84dee3c89e895ac5$var$revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = $84dee3c89e895ac5$var$revLookup[b64.charCodeAt(i)] << 2 | $84dee3c89e895ac5$var$revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = $84dee3c89e895ac5$var$revLookup[b64.charCodeAt(i)] << 10 | $84dee3c89e895ac5$var$revLookup[b64.charCodeAt(i + 1)] << 4 | $84dee3c89e895ac5$var$revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function $84dee3c89e895ac5$var$tripletToBase64(num) {
    return $84dee3c89e895ac5$var$lookup[num >> 18 & 0x3F] + $84dee3c89e895ac5$var$lookup[num >> 12 & 0x3F] + $84dee3c89e895ac5$var$lookup[num >> 6 & 0x3F] + $84dee3c89e895ac5$var$lookup[num & 0x3F];
}
function $84dee3c89e895ac5$var$encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push($84dee3c89e895ac5$var$tripletToBase64(tmp));
    }
    return output.join("");
}
function $84dee3c89e895ac5$var$fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push($84dee3c89e895ac5$var$encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push($84dee3c89e895ac5$var$lookup[tmp >> 2] + $84dee3c89e895ac5$var$lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push($84dee3c89e895ac5$var$lookup[tmp >> 10] + $84dee3c89e895ac5$var$lookup[tmp >> 4 & 0x3F] + $84dee3c89e895ac5$var$lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

});

parcelRequire.register("5Q6n3", function(module, exports) {

$parcel$export(module.exports, "read", () => $4406c0362df198fd$export$aafa59e2e03f2942, (v) => $4406c0362df198fd$export$aafa59e2e03f2942 = v);
$parcel$export(module.exports, "write", () => $4406c0362df198fd$export$68d8715fc104d294, (v) => $4406c0362df198fd$export$68d8715fc104d294 = v);
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ var $4406c0362df198fd$export$aafa59e2e03f2942;
var $4406c0362df198fd$export$68d8715fc104d294;
$4406c0362df198fd$export$aafa59e2e03f2942 = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
$4406c0362df198fd$export$68d8715fc104d294 = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

});


parcelRequire.register("17709", function(module, exports) {
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ "use strict";

var $5uO90 = parcelRequire("5uO90");
function $0cfbe034fa696f8c$var$ProtocolError(message) {
    Error.call(this);
    this.message = message;
    this.name = "ProtocolError";
}
$5uO90.inherits($0cfbe034fa696f8c$var$ProtocolError, Error);
function $0cfbe034fa696f8c$var$TypeError(message) {
    $0cfbe034fa696f8c$var$ProtocolError.call(this, message);
    this.message = message;
    this.name = "TypeError";
}
$5uO90.inherits($0cfbe034fa696f8c$var$TypeError, $0cfbe034fa696f8c$var$ProtocolError);
function $0cfbe034fa696f8c$var$ConnectionError(message, condition, connection) {
    Error.call(this, message);
    this.message = message;
    this.name = "ConnectionError";
    this.condition = condition;
    this.description = message;
    Object.defineProperty(this, "connection", {
        value: connection
    });
}
$5uO90.inherits($0cfbe034fa696f8c$var$ConnectionError, Error);
$0cfbe034fa696f8c$var$ConnectionError.prototype.toJSON = function() {
    return {
        type: this.name,
        code: this.condition,
        message: this.description
    };
};
module.exports = {
    ProtocolError: $0cfbe034fa696f8c$var$ProtocolError,
    TypeError: $0cfbe034fa696f8c$var$TypeError,
    ConnectionError: $0cfbe034fa696f8c$var$ConnectionError
};

});

parcelRequire.register("3hLdt", function(module, exports) {
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ 
var $6FDNW = parcelRequire("6FDNW");
var $264795c8044df3a7$require$Buffer = $6FDNW.Buffer;
"use strict";

var $17709 = parcelRequire("17709");
var $264795c8044df3a7$var$util = {};
$264795c8044df3a7$var$util.allocate_buffer = function(size) {
    return $264795c8044df3a7$require$Buffer.alloc ? $264795c8044df3a7$require$Buffer.alloc(size) : new $264795c8044df3a7$require$Buffer(size);
};
$264795c8044df3a7$var$util.generate_uuid = function() {
    return $264795c8044df3a7$var$util.uuid_to_string($264795c8044df3a7$var$util.uuid4());
};
$264795c8044df3a7$var$util.uuid4 = function() {
    var bytes = $264795c8044df3a7$var$util.allocate_buffer(16);
    for(var i = 0; i < bytes.length; i++)bytes[i] = Math.random() * 255 | 0;
    // From RFC4122, the version bits are set to 0100
    bytes[7] &= 0x0F;
    bytes[7] |= 0x40;
    // From RFC4122, the top two bits of byte 8 get set to 01
    bytes[8] &= 0x3F;
    bytes[8] |= 0x80;
    return bytes;
};
$264795c8044df3a7$var$util.uuid_to_string = function(buffer) {
    if (buffer.length === 16) {
        var chunks = [
            buffer.slice(0, 4),
            buffer.slice(4, 6),
            buffer.slice(6, 8),
            buffer.slice(8, 10),
            buffer.slice(10, 16)
        ];
        return chunks.map(function(b) {
            return b.toString("hex");
        }).join("-");
    } else throw new $17709.TypeError("Not a UUID, expecting 16 byte buffer");
};
var $264795c8044df3a7$var$parse_uuid = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/;
$264795c8044df3a7$var$util.string_to_uuid = function(uuid_string) {
    var parts = $264795c8044df3a7$var$parse_uuid.exec(uuid_string.toLowerCase());
    if (parts) return $264795c8044df3a7$require$Buffer.from(parts.slice(1).join(""), "hex");
    else throw new $17709.TypeError("Not a valid UUID string: " + uuid_string);
};
$264795c8044df3a7$var$util.clone = function(o) {
    var copy = Object.create(o.prototype || {});
    var names = Object.getOwnPropertyNames(o);
    for(var i = 0; i < names.length; i++){
        var key = names[i];
        copy[key] = o[key];
    }
    return copy;
};
$264795c8044df3a7$var$util.and = function(f, g) {
    if (g === undefined) return f;
    return function(o) {
        return f(o) && g(o);
    };
};
$264795c8044df3a7$var$util.is_sender = function(o) {
    return o.is_sender();
};
$264795c8044df3a7$var$util.is_receiver = function(o) {
    return o.is_receiver();
};
$264795c8044df3a7$var$util.sender_filter = function(filter) {
    return $264795c8044df3a7$var$util.and($264795c8044df3a7$var$util.is_sender, filter);
};
$264795c8044df3a7$var$util.receiver_filter = function(filter) {
    return $264795c8044df3a7$var$util.and($264795c8044df3a7$var$util.is_receiver, filter);
};
$264795c8044df3a7$var$util.is_defined = function(field) {
    return field !== undefined && field !== null;
};
module.exports = $264795c8044df3a7$var$util;

});


parcelRequire.register("9nTQW", function(module, exports) {
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function $6d519643fa2fc4f9$var$setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = (parcelRequire("7qFZi"));
    Object.keys(env).forEach(function(key) {
        createDebug[key] = env[key];
    });
    /**
  * Active `debug` instances.
  */ createDebug.instances = [];
    /**
  * The currently active debug mode names, and names to skip.
  */ createDebug.names = [];
    createDebug.skips = [];
    /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */ createDebug.formatters = {};
    /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */ function selectColor(namespace) {
        var hash = 0;
        for(var i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */ function createDebug(namespace) {
        var prevTime;
        function debug() {
            // Disabled?
            if (!debug.enabled) return;
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
            var self = debug; // Set `diff` timestamp
            var curr = Number(new Date());
            var ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") // Anything else let's inspect with %O
            args.unshift("%O");
             // Apply any `formatters` transformations
            var index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
                // If we encounter an escaped % then don't increase the array index
                if (match === "%%") return match;
                index++;
                var formatter = createDebug.formatters[format];
                if (typeof formatter === "function") {
                    var val = args[index];
                    match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            }); // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            var logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.enabled = createDebug.enabled(namespace);
        debug.useColors = createDebug.useColors();
        debug.color = selectColor(namespace);
        debug.destroy = destroy;
        debug.extend = extend; // Debug.formatArgs = formatArgs;
        // debug.rawLog = rawLog;
        // env-specific initialization logic for debug instances
        if (typeof createDebug.init === "function") createDebug.init(debug);
        createDebug.instances.push(debug);
        return debug;
    }
    function destroy() {
        var index = createDebug.instances.indexOf(this);
        if (index !== -1) {
            createDebug.instances.splice(index, 1);
            return true;
        }
        return false;
    }
    function extend(namespace, delimiter) {
        return createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    }
    /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        var i;
        var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        var len = split.length;
        for(i = 0; i < len; i++){
            if (!split[i]) continue;
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
            else createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
        for(i = 0; i < createDebug.instances.length; i++){
            var instance = createDebug.instances[i];
            instance.enabled = createDebug.enabled(instance.namespace);
        }
    }
    /**
  * Disable debug output.
  *
  * @api public
  */ function disable() {
        createDebug.enable("");
    }
    /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */ function enabled(name) {
        if (name[name.length - 1] === "*") return true;
        var i;
        var len;
        for(i = 0, len = createDebug.skips.length; i < len; i++){
            if (createDebug.skips[i].test(name)) return false;
        }
        for(i = 0, len = createDebug.names.length; i < len; i++){
            if (createDebug.names[i].test(name)) return true;
        }
        return false;
    }
    /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */ function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = $6d519643fa2fc4f9$var$setup;

});
parcelRequire.register("7qFZi", function(module, exports) {
/**
 * Helpers.
 */ var $568b88022ed5f756$var$s = 1000;
var $568b88022ed5f756$var$m = $568b88022ed5f756$var$s * 60;
var $568b88022ed5f756$var$h = $568b88022ed5f756$var$m * 60;
var $568b88022ed5f756$var$d = $568b88022ed5f756$var$h * 24;
var $568b88022ed5f756$var$w = $568b88022ed5f756$var$d * 7;
var $568b88022ed5f756$var$y = $568b88022ed5f756$var$d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) return $568b88022ed5f756$var$parse(val);
    else if (type === "number" && isFinite(val)) return options.long ? $568b88022ed5f756$var$fmtLong(val) : $568b88022ed5f756$var$fmtShort(val);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function $568b88022ed5f756$var$parse(str) {
    str = String(str);
    if (str.length > 100) return;
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) return;
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch(type){
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
            return n * $568b88022ed5f756$var$y;
        case "weeks":
        case "week":
        case "w":
            return n * $568b88022ed5f756$var$w;
        case "days":
        case "day":
        case "d":
            return n * $568b88022ed5f756$var$d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
            return n * $568b88022ed5f756$var$h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
            return n * $568b88022ed5f756$var$m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
            return n * $568b88022ed5f756$var$s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function $568b88022ed5f756$var$fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= $568b88022ed5f756$var$d) return Math.round(ms / $568b88022ed5f756$var$d) + "d";
    if (msAbs >= $568b88022ed5f756$var$h) return Math.round(ms / $568b88022ed5f756$var$h) + "h";
    if (msAbs >= $568b88022ed5f756$var$m) return Math.round(ms / $568b88022ed5f756$var$m) + "m";
    if (msAbs >= $568b88022ed5f756$var$s) return Math.round(ms / $568b88022ed5f756$var$s) + "s";
    return ms + "ms";
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function $568b88022ed5f756$var$fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= $568b88022ed5f756$var$d) return $568b88022ed5f756$var$plural(ms, msAbs, $568b88022ed5f756$var$d, "day");
    if (msAbs >= $568b88022ed5f756$var$h) return $568b88022ed5f756$var$plural(ms, msAbs, $568b88022ed5f756$var$h, "hour");
    if (msAbs >= $568b88022ed5f756$var$m) return $568b88022ed5f756$var$plural(ms, msAbs, $568b88022ed5f756$var$m, "minute");
    if (msAbs >= $568b88022ed5f756$var$s) return $568b88022ed5f756$var$plural(ms, msAbs, $568b88022ed5f756$var$s, "second");
    return ms + " ms";
}
/**
 * Pluralization helper.
 */ function $568b88022ed5f756$var$plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
}

});


parcelRequire.register("bdeu2", function(module, exports) {
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ "use strict";

var $5Avaz = parcelRequire("5Avaz");

var $2Kc0N = parcelRequire("2Kc0N");
var $829c24b6f03dad02$var$by_descriptor = {};
var $829c24b6f03dad02$var$unwrappers = {};
var $829c24b6f03dad02$var$wrappers = [];
var $829c24b6f03dad02$var$message = {};
function $829c24b6f03dad02$var$define_section(descriptor, unwrap, wrap) {
    unwrap.descriptor = descriptor;
    $829c24b6f03dad02$var$unwrappers[descriptor.symbolic] = unwrap;
    $829c24b6f03dad02$var$unwrappers[Number(descriptor.numeric).toString(10)] = unwrap;
    if (wrap) $829c24b6f03dad02$var$wrappers.push(wrap);
}
function $829c24b6f03dad02$var$define_composite_section(def) {
    var c = $2Kc0N.define_composite(def);
    $829c24b6f03dad02$var$message[def.name] = c.create;
    $829c24b6f03dad02$var$by_descriptor[Number(c.descriptor.numeric).toString(10)] = c;
    $829c24b6f03dad02$var$by_descriptor[c.descriptor.symbolic] = c;
    var unwrap = function(msg, section) {
        var composite = new c(section.value);
        for(var i = 0; i < def.fields.length; i++){
            var f = def.fields[i];
            var v = composite[f.name];
            if (v !== undefined && v !== null) msg[f.name] = v;
        }
    };
    var wrap = function(sections, msg) {
        sections.push(c.create(msg).described());
    };
    $829c24b6f03dad02$var$define_section(c.descriptor, unwrap, wrap);
}
function $829c24b6f03dad02$var$define_map_section(def, symbolic) {
    var wrapper = symbolic ? $2Kc0N.wrap_symbolic_map : $2Kc0N.wrap_map;
    var descriptor = {
        numeric: def.code
    };
    descriptor.symbolic = "amqp:" + def.name.replace(/_/g, "-") + ":map";
    var unwrap = function(msg, section) {
        msg[def.name] = $2Kc0N.unwrap_map_simple(section);
    };
    var wrap = function(sections, msg) {
        if (msg[def.name]) sections.push($2Kc0N.described_nc($2Kc0N.wrap_ulong(descriptor.numeric), wrapper(msg[def.name])));
    };
    $829c24b6f03dad02$var$define_section(descriptor, unwrap, wrap);
}
function $829c24b6f03dad02$var$Section(typecode, content, multiple) {
    this.typecode = typecode;
    this.content = content;
    this.multiple = multiple;
}
$829c24b6f03dad02$var$Section.prototype.described = function(item) {
    return $2Kc0N.described($2Kc0N.wrap_ulong(this.typecode), $2Kc0N.wrap(item || this.content));
};
$829c24b6f03dad02$var$Section.prototype.collect_sections = function(sections) {
    if (this.multiple) for(var i = 0; i < this.content.length; i++)sections.push(this.described(this.content[i]));
    else sections.push(this.described());
};
$829c24b6f03dad02$var$define_composite_section({
    name: "header",
    code: 0x70,
    fields: [
        {
            name: "durable",
            type: "boolean",
            default_value: false
        },
        {
            name: "priority",
            type: "ubyte",
            default_value: 4
        },
        {
            name: "ttl",
            type: "uint"
        },
        {
            name: "first_acquirer",
            type: "boolean",
            default_value: false
        },
        {
            name: "delivery_count",
            type: "uint",
            default_value: 0
        }
    ]
});
$829c24b6f03dad02$var$define_map_section({
    name: "delivery_annotations",
    code: 0x71
}, true);
$829c24b6f03dad02$var$define_map_section({
    name: "message_annotations",
    code: 0x72
}, true);
$829c24b6f03dad02$var$define_composite_section({
    name: "properties",
    code: 0x73,
    fields: [
        {
            name: "message_id",
            type: "message_id"
        },
        {
            name: "user_id",
            type: "binary"
        },
        {
            name: "to",
            type: "string"
        },
        {
            name: "subject",
            type: "string"
        },
        {
            name: "reply_to",
            type: "string"
        },
        {
            name: "correlation_id",
            type: "message_id"
        },
        {
            name: "content_type",
            type: "symbol"
        },
        {
            name: "content_encoding",
            type: "symbol"
        },
        {
            name: "absolute_expiry_time",
            type: "timestamp"
        },
        {
            name: "creation_time",
            type: "timestamp"
        },
        {
            name: "group_id",
            type: "string"
        },
        {
            name: "group_sequence",
            type: "uint"
        },
        {
            name: "reply_to_group_id",
            type: "string"
        }
    ]
});
$829c24b6f03dad02$var$define_map_section({
    name: "application_properties",
    code: 0x74
});
function $829c24b6f03dad02$var$unwrap_body_section(msg, section, typecode) {
    if (msg.body === undefined) msg.body = new $829c24b6f03dad02$var$Section(typecode, $2Kc0N.unwrap(section));
    else if (msg.body.constructor === $829c24b6f03dad02$var$Section && msg.body.typecode === typecode) {
        if (msg.body.multiple) msg.body.content.push($2Kc0N.unwrap(section));
        else {
            msg.body.multiple = true;
            msg.body.content = [
                msg.body.content,
                $2Kc0N.unwrap(section)
            ];
        }
    }
}
$829c24b6f03dad02$var$define_section({
    numeric: 0x75,
    symbolic: "amqp:data:binary"
}, function(msg, section) {
    $829c24b6f03dad02$var$unwrap_body_section(msg, section, 0x75);
});
$829c24b6f03dad02$var$define_section({
    numeric: 0x76,
    symbolic: "amqp:amqp-sequence:list"
}, function(msg, section) {
    $829c24b6f03dad02$var$unwrap_body_section(msg, section, 0x76);
});
$829c24b6f03dad02$var$define_section({
    numeric: 0x77,
    symbolic: "amqp:value:*"
}, function(msg, section) {
    msg.body = $2Kc0N.unwrap(section);
});
$829c24b6f03dad02$var$define_map_section({
    name: "footer",
    code: 0x78
});
function $829c24b6f03dad02$var$wrap_body(sections, msg) {
    if (msg.body && msg.body.collect_sections) msg.body.collect_sections(sections);
    else sections.push($2Kc0N.described($2Kc0N.wrap_ulong(0x77), $2Kc0N.wrap(msg.body)));
}
$829c24b6f03dad02$var$wrappers.push($829c24b6f03dad02$var$wrap_body);
$829c24b6f03dad02$var$message.data_section = function(data) {
    return new $829c24b6f03dad02$var$Section(0x75, data);
};
$829c24b6f03dad02$var$message.sequence_section = function(list) {
    return new $829c24b6f03dad02$var$Section(0x76, list);
};
$829c24b6f03dad02$var$message.data_sections = function(data_elements) {
    return new $829c24b6f03dad02$var$Section(0x75, data_elements, true);
};
$829c24b6f03dad02$var$message.sequence_sections = function(lists) {
    return new $829c24b6f03dad02$var$Section(0x76, lists, true);
};
function $829c24b6f03dad02$var$copy(src, tgt) {
    for(var k in src){
        var v = src[k];
        if (typeof v === "object") $829c24b6f03dad02$var$copy(v, tgt[k]);
        else tgt[k] = v;
    }
}
function $829c24b6f03dad02$var$Message(o) {
    if (o) $829c24b6f03dad02$var$copy(o, this);
}
$829c24b6f03dad02$var$Message.prototype.toJSON = function() {
    var o = {};
    for(var key in this){
        if (typeof this[key] === "function") continue;
        o[key] = this[key];
    }
    return o;
};
$829c24b6f03dad02$var$Message.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
};
$829c24b6f03dad02$var$message.encode = function(msg) {
    var sections = [];
    $829c24b6f03dad02$var$wrappers.forEach(function(wrapper_fn) {
        wrapper_fn(sections, msg);
    });
    var writer = new $2Kc0N.Writer();
    for(var i = 0; i < sections.length; i++){
        $5Avaz.message("Encoding section %d of %d: %o", i + 1, sections.length, sections[i]);
        writer.write(sections[i]);
    }
    var data = writer.toBuffer();
    $5Avaz.message("encoded %d bytes", data.length);
    return data;
};
$829c24b6f03dad02$var$message.decode = function(buffer) {
    var msg = new $829c24b6f03dad02$var$Message();
    var reader = new $2Kc0N.Reader(buffer);
    while(reader.remaining()){
        var s = reader.read();
        $5Avaz.message("decoding section: %o of type: %o", s, s.descriptor);
        if (s.descriptor) {
            var unwrap = $829c24b6f03dad02$var$unwrappers[s.descriptor.value];
            if (unwrap) unwrap(msg, s);
            else console.warn("WARNING: did not recognise message section with descriptor " + s.descriptor);
        } else console.warn("WARNING: expected described message section got " + JSON.stringify(s));
    }
    return msg;
};
var $829c24b6f03dad02$var$outcomes = {};
function $829c24b6f03dad02$var$define_outcome(def) {
    var c = $2Kc0N.define_composite(def);
    c.composite_type = def.name;
    $829c24b6f03dad02$var$message[def.name] = c.create;
    $829c24b6f03dad02$var$outcomes[Number(c.descriptor.numeric).toString(10)] = c;
    $829c24b6f03dad02$var$outcomes[c.descriptor.symbolic] = c;
    $829c24b6f03dad02$var$message["is_" + def.name] = function(o) {
        if (o && o.descriptor) {
            var c = $829c24b6f03dad02$var$outcomes[o.descriptor.value];
            if (c) return c.descriptor.numeric === def.code;
        }
        return false;
    };
}
$829c24b6f03dad02$var$message.unwrap_outcome = function(outcome) {
    if (outcome && outcome.descriptor) {
        var c = $829c24b6f03dad02$var$outcomes[outcome.descriptor.value];
        if (c) return new c(outcome.value);
    }
    console.error("unrecognised outcome: " + JSON.stringify(outcome));
    return outcome;
};
$829c24b6f03dad02$var$message.are_outcomes_equivalent = function(a, b) {
    if (a === undefined && b === undefined) return true;
    else if (a === undefined || b === undefined) return false;
    else return a.descriptor.value === b.descriptor.value && a.descriptor.value === 0x24; //only batch accepted
};
$829c24b6f03dad02$var$define_outcome({
    name: "received",
    code: 0x23,
    fields: [
        {
            name: "section_number",
            type: "uint",
            mandatory: true
        },
        {
            name: "section_offset",
            type: "ulong",
            mandatory: true
        }
    ]
});
$829c24b6f03dad02$var$define_outcome({
    name: "accepted",
    code: 0x24,
    fields: []
});
$829c24b6f03dad02$var$define_outcome({
    name: "rejected",
    code: 0x25,
    fields: [
        {
            name: "error",
            type: "error"
        }
    ]
});
$829c24b6f03dad02$var$define_outcome({
    name: "released",
    code: 0x26,
    fields: []
});
$829c24b6f03dad02$var$define_outcome({
    name: "modified",
    code: 0x27,
    fields: [
        {
            name: "delivery_failed",
            type: "boolean"
        },
        {
            name: "undeliverable_here",
            type: "boolean"
        },
        {
            name: "message_annotations",
            type: "map"
        }
    ]
});
module.exports = $829c24b6f03dad02$var$message;

});
parcelRequire.register("5Avaz", function(module, exports) {
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ "use strict";

var $cAqLr = parcelRequire("cAqLr");
if ($cAqLr.formatters) $cAqLr.formatters.h = function(v) {
    return v.toString("hex");
};
module.exports = {
    "config": $cAqLr("rhea:config"),
    "frames": $cAqLr("rhea:frames"),
    "raw": $cAqLr("rhea:raw"),
    "reconnect": $cAqLr("rhea:reconnect"),
    "events": $cAqLr("rhea:events"),
    "message": $cAqLr("rhea:message"),
    "flow": $cAqLr("rhea:flow"),
    "io": $cAqLr("rhea:io")
};

});
parcelRequire.register("cAqLr", function(module, exports) {

var $gDDBB = parcelRequire("gDDBB");
"use strict";
function $929d9ba927b19aca$var$_typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") $929d9ba927b19aca$var$_typeof = function _typeof(obj) {
        return typeof obj;
    };
    else $929d9ba927b19aca$var$_typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return $929d9ba927b19aca$var$_typeof(obj);
}
/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ module.exports.log = $929d9ba927b19aca$var$log;
module.exports.formatArgs = $929d9ba927b19aca$var$formatArgs;
module.exports.save = $929d9ba927b19aca$var$save;
module.exports.load = $929d9ba927b19aca$var$load;
module.exports.useColors = $929d9ba927b19aca$var$useColors;
module.exports.storage = $929d9ba927b19aca$var$localstorage();
/**
 * Colors.
 */ module.exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function $929d9ba927b19aca$var$useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
     // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
     // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function $929d9ba927b19aca$var$formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit"); // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%") return;
        index++;
        if (match === "%c") // We only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */ function $929d9ba927b19aca$var$log() {
    var _console;
    // This hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return (typeof console === "undefined" ? "undefined" : $929d9ba927b19aca$var$_typeof(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function $929d9ba927b19aca$var$save(namespaces) {
    try {
        if (namespaces) module.exports.storage.setItem("debug", namespaces);
        else module.exports.storage.removeItem("debug");
    } catch (error) {
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function $929d9ba927b19aca$var$load() {
    var r;
    try {
        r = module.exports.storage.getItem("debug");
    } catch (error) {} // Swallow
    // XXX (@Qix-) should we be logging these?
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof $gDDBB !== "undefined" && "env" in $gDDBB) r = undefined;
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function $929d9ba927b19aca$var$localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // XXX (@Qix-) should we be logging these?
    }
}

module.exports = (parcelRequire("9nTQW"))(module.exports);
var $929d9ba927b19aca$var$formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ $929d9ba927b19aca$var$formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
    }
};

});



parcelRequire.register("9OYYn", function(module, exports) {
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ "use strict";

var $2Kc0N = parcelRequire("2Kc0N");
module.exports = {
    selector: function(s) {
        return {
            "jms-selector": $2Kc0N.wrap_described(s, 0x468C00000004)
        };
    }
};

});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise */ var $9187fda58d09cc70$var$extendStatics = function(d, b) {
    $9187fda58d09cc70$var$extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return $9187fda58d09cc70$var$extendStatics(d, b);
};
function $9187fda58d09cc70$export$a8ba968b8961cb8a(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    $9187fda58d09cc70$var$extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var $9187fda58d09cc70$export$18ce0697a983be9b = function() {
    $9187fda58d09cc70$export$18ce0697a983be9b = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return $9187fda58d09cc70$export$18ce0697a983be9b.apply(this, arguments);
};
function $9187fda58d09cc70$export$3c9a16f847548506(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function $9187fda58d09cc70$export$29e00dfd3077644b(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function $9187fda58d09cc70$export$d5ad3fd78186038f(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function $9187fda58d09cc70$export$f1db080c865becb9(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function $9187fda58d09cc70$export$1050f835b63b671e(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function $9187fda58d09cc70$export$67ebef60e6f28a6(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var $9187fda58d09cc70$export$45d3717a4c69092e = Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function $9187fda58d09cc70$export$f33643c0debef087(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) $9187fda58d09cc70$export$45d3717a4c69092e(o, m, p);
}
function $9187fda58d09cc70$export$19a8beecd37a4c45(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function $9187fda58d09cc70$export$8d051b38c9118094(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function $9187fda58d09cc70$export$afc72e2116322959() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat($9187fda58d09cc70$export$8d051b38c9118094(arguments[i]));
    return ar;
}
function $9187fda58d09cc70$export$6388937ca91ccae8() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function $9187fda58d09cc70$export$1216008129fb82ed(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function $9187fda58d09cc70$export$10c90e4f7922046c(v) {
    return this instanceof $9187fda58d09cc70$export$10c90e4f7922046c ? (this.v = v, this) : new $9187fda58d09cc70$export$10c90e4f7922046c(v);
}
function $9187fda58d09cc70$export$e427f37a30a4de9b(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    function verb(n) {
        if (g[n]) i[n] = function(v) {
            return new Promise(function(a, b) {
                q.push([
                    n,
                    v,
                    a,
                    b
                ]) > 1 || resume(n, v);
            });
        };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof $9187fda58d09cc70$export$10c90e4f7922046c ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function $9187fda58d09cc70$export$bbd80228419bb833(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: $9187fda58d09cc70$export$10c90e4f7922046c(o[n](v)),
                done: n === "return"
            } : f ? f(v) : v;
        } : f;
    }
}
function $9187fda58d09cc70$export$e3b29a3d6162315f(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof $9187fda58d09cc70$export$19a8beecd37a4c45 === "function" ? $9187fda58d09cc70$export$19a8beecd37a4c45(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function $9187fda58d09cc70$export$4fb47efe1390b86f(cooked, raw) {
    if (Object.defineProperty) Object.defineProperty(cooked, "raw", {
        value: raw
    });
    else cooked.raw = raw;
    return cooked;
}
var $9187fda58d09cc70$var$__setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
function $9187fda58d09cc70$export$c21735bcef00d192(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) $9187fda58d09cc70$export$45d3717a4c69092e(result, mod, k);
    }
    $9187fda58d09cc70$var$__setModuleDefault(result, mod);
    return result;
}
function $9187fda58d09cc70$export$da59b14a69baef04(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function $9187fda58d09cc70$export$d5dcaf168c640c35(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function $9187fda58d09cc70$export$d40a35129aaff81f(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function $9187fda58d09cc70$export$81fdc39f203e4e04(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const $807770c0815ec6f8$export$a002182e51710d39 = {
    associatedLinkName: "associated-link-name",
    partitionKey: "x-opt-partition-key",
    sequenceNumber: "x-opt-sequence-number",
    enqueueSequenceNumber: "x-opt-enqueue-sequence-number",
    enqueuedTime: "x-opt-enqueued-time",
    scheduledEnqueueTime: "x-opt-scheduled-enqueue-time",
    offset: "x-opt-offset",
    lockedUntil: "x-opt-locked-until",
    partitionIdName: "x-opt-partition-id",
    publisher: "x-opt-publisher-name",
    viaPartitionKey: "x-opt-via-partition-key",
    deadLetterSource: "x-opt-deadletter-source",
    messageState: "x-opt-message-state",
    enqueuedTimeAnnotation: `amqp.annotation.x-opt-enqueued-time`,
    offsetAnnotation: `amqp.annotation.x-opt-offset`,
    sequenceNumberAnnotation: `amqp.annotation.x-opt-sequence-number`,
    guidSize: 16,
    message: "message",
    error: "error",
    statusCode: "status-code",
    statusDescription: "status-description",
    errorCondition: "error-condition",
    management: "$management",
    partition: "partition",
    partitionId: "partitionId",
    readOperation: "READ",
    TLS: "tls",
    establishConnection: "establishConnection",
    defaultConsumerGroup: "$default",
    eventHub: "eventhub",
    cbsEndpoint: "$cbs",
    cbsReplyTo: "cbs",
    operationPutToken: "put-token",
    aadEventHubsAudience: "https://eventhubs.azure.net/",
    aadEventHubsScope: "https://eventhubs.azure.net//.default",
    aadServiceBusAudience: "https://servicebus.azure.net/",
    aadServiceBusScope: "https://servicebus.azure.net//.default",
    maxUserAgentLength: 512,
    vendorString: "com.microsoft",
    attachEpoch: `com.microsoft:epoch`,
    receiverIdentifierName: `com.microsoft:receiver-name`,
    enableReceiverRuntimeMetricName: `com.microsoft:enable-receiver-runtime-metric`,
    timespan: `com.microsoft:timespan`,
    uri: `com.microsoft:uri`,
    dateTimeOffset: `com.microsoft:datetime-offset`,
    sessionFilterName: `com.microsoft:session-filter`,
    receiverError: "receiver_error",
    senderError: "sender_error",
    sessionError: "session_error",
    connectionError: "connection_error",
    defaultOperationTimeoutInMs: 60000,
    defaultConnectionIdleTimeoutInMs: 60000,
    managementRequestKey: "managementRequest",
    negotiateCbsKey: "negotiateCbs",
    negotiateClaim: "negotiateClaim",
    ensureContainerAndBlob: "ensureContainerAndBlob",
    defaultPrefetchCount: 1000,
    reconnectLimit: 100,
    maxMessageIdLength: 128,
    maxPartitionKeyLength: 128,
    maxSessionIdLength: 128,
    pathDelimiter: "/",
    ruleNameMaximumLength: 50,
    maximumSqlFilterStatementLength: 1024,
    maximumSqlRuleActionStatementLength: 1024,
    maxDeadLetterReasonLength: 4096,
    // https://stackoverflow.com/questions/11526504/minimum-and-maximum-date for js
    // However we are setting this to the TimeSpan.MaxValue of C#.
    maxDurationValue: 922337203685477,
    minDurationValue: -922337203685477,
    // https://github.com/Azure/azure-amqp/blob/master/Microsoft.Azure.Amqp/Amqp/AmqpConstants.cs#L47
    maxAbsoluteExpiryTime: new Date("9999-12-31T07:59:59.000Z").getTime(),
    aadTokenValidityMarginInMs: 5000,
    connectionReconnectDelay: 300,
    defaultMaxRetries: 3,
    defaultMaxRetriesForConnection: 150,
    defaultDelayBetweenOperationRetriesInMs: 30000,
    defaultMaxDelayForExponentialRetryInMs: 90000,
    receiverSettleMode: "receiver-settle-mode",
    dispositionStatus: "disposition-status",
    fromSequenceNumber: "from-sequence-number",
    messageCount: "message-count",
    lockTokens: "lock-tokens",
    messageIdMapKey: "message-id",
    sequenceNumberMapKey: "sequence-number",
    lockTokenMapKey: "lock-token",
    sessionIdMapKey: "session-id",
    sequenceNumbers: "sequence-numbers",
    deadLetterReason: "deadletter-reason",
    deadLetterDescription: "deadletter-description",
    propertiesToModify: "properties-to-modify",
    deadLetterName: "com.microsoft:dead-letter",
    trackingId: "com.microsoft:tracking-id",
    serverTimeout: "com.microsoft:server-timeout",
    operations: {
        putToken: "put-token",
        read: "READ",
        cancelScheduledMessage: "com.microsoft:cancel-scheduled-message",
        scheduleMessage: "com.microsoft:schedule-message",
        renewLock: "com.microsoft:renew-lock",
        peekMessage: "com.microsoft:peek-message",
        receiveBySequenceNumber: "com.microsoft:receive-by-sequence-number",
        updateDisposition: "com.microsoft:update-disposition",
        renewSessionLock: "com.microsoft:renew-session-lock",
        setSessionState: "com.microsoft:set-session-state",
        getSessionState: "com.microsoft:get-session-state",
        enumerateSessions: "com.microsoft:get-message-sessions",
        addRule: "com.microsoft:add-rule",
        removeRule: "com.microsoft:remove-rule",
        enumerateRules: "com.microsoft:enumerate-rules"
    },
    descriptorCodes: {
        ruleDescriptionList: 1335734829060,
        sqlFilterList: 83483426822,
        correlationFilterList: 83483426825,
        sqlRuleActionList: 1335734829062,
        trueFilterList: 83483426823,
        falseFilterList: 83483426824
    }
};
const $807770c0815ec6f8$export$ec529641dbabb04c = "The operation was aborted.";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/// <reference path="../shims-public.d.ts" />
const $76df965b0942e10d$var$listenersMap = new WeakMap();
const $76df965b0942e10d$var$abortedMap = new WeakMap();
class $76df965b0942e10d$export$e42c54032314dc1d {
    constructor(){
        /**
         * onabort event listener.
         */ this.onabort = null;
        $76df965b0942e10d$var$listenersMap.set(this, []);
        $76df965b0942e10d$var$abortedMap.set(this, false);
    }
    /**
     * Status of whether aborted or not.
     *
     * @readonly
     */ get aborted() {
        if (!$76df965b0942e10d$var$abortedMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        return $76df965b0942e10d$var$abortedMap.get(this);
    }
    /**
     * Creates a new AbortSignal instance that will never be aborted.
     *
     * @readonly
     */ static get none() {
        return new $76df965b0942e10d$export$e42c54032314dc1d();
    }
    /**
     * Added new "abort" event listener, only support "abort" event.
     *
     * @param _type - Only support "abort" event
     * @param listener - The listener to be added
     */ addEventListener(// tslint:disable-next-line:variable-name
    _type, listener) {
        if (!$76df965b0942e10d$var$listenersMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        const listeners = $76df965b0942e10d$var$listenersMap.get(this);
        listeners.push(listener);
    }
    /**
     * Remove "abort" event listener, only support "abort" event.
     *
     * @param _type - Only support "abort" event
     * @param listener - The listener to be removed
     */ removeEventListener(// tslint:disable-next-line:variable-name
    _type, listener) {
        if (!$76df965b0942e10d$var$listenersMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        const listeners = $76df965b0942e10d$var$listenersMap.get(this);
        const index = listeners.indexOf(listener);
        if (index > -1) listeners.splice(index, 1);
    }
    /**
     * Dispatches a synthetic event to the AbortSignal.
     */ dispatchEvent(_event) {
        throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
    }
}
function $76df965b0942e10d$export$b751923f1dabd654(signal) {
    if (signal.aborted) return;
    if (signal.onabort) signal.onabort.call(signal);
    const listeners = $76df965b0942e10d$var$listenersMap.get(signal);
    if (listeners) // Create a copy of listeners so mutations to the array
    // (e.g. via removeListener calls) don't affect the listeners
    // we invoke.
    listeners.slice().forEach((listener)=>{
        listener.call(signal, {
            type: "abort"
        });
    });
    $76df965b0942e10d$var$abortedMap.set(signal, true);
}


class $d8f75e1baa6fdbda$export$18b052ffd8c84d7 extends Error {
    constructor(message){
        super(message);
        this.name = "AbortError";
    }
}
class $d8f75e1baa6fdbda$export$48f7e099c149af88 {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    constructor(parentSignals){
        this._signal = new (0, $76df965b0942e10d$export$e42c54032314dc1d)();
        if (!parentSignals) return;
        // coerce parentSignals into an array
        if (!Array.isArray(parentSignals)) // eslint-disable-next-line prefer-rest-params
        parentSignals = arguments;
        for (const parentSignal of parentSignals)// if the parent signal has already had abort() called,
        // then call abort on this signal as well.
        if (parentSignal.aborted) this.abort();
        else // when the parent signal aborts, this signal should as well.
        parentSignal.addEventListener("abort", ()=>{
            this.abort();
        });
    }
    /**
     * The AbortSignal associated with this controller that will signal aborted
     * when the abort method is called on this controller.
     *
     * @readonly
     */ get signal() {
        return this._signal;
    }
    /**
     * Signal that any operations passed this controller's associated abort signal
     * to cancel any remaining work and throw an `AbortError`.
     */ abort() {
        (0, $76df965b0942e10d$export$b751923f1dabd654)(this._signal);
    }
    /**
     * Creates a new AbortSignal instance that will abort after the provided ms.
     * @param ms - Elapsed time in milliseconds to trigger an abort.
     */ static timeout(ms) {
        const signal = new (0, $76df965b0942e10d$export$e42c54032314dc1d)();
        const timer = setTimeout((0, $76df965b0942e10d$export$b751923f1dabd654), ms, signal);
        // Prevent the active Timer from keeping the Node.js event loop active.
        if (typeof timer.unref === "function") timer.unref();
        return signal;
    }
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

var $4973e2e602c1cc10$exports = {};
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty($4973e2e602c1cc10$exports, "__esModule", {
    value: true
});
var $c1c4913cc434c78b$exports = {};
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ 
var $gDDBB = parcelRequire("gDDBB");
"use strict";
var $b44b5920d931e66c$exports = {};
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ 
var $gDDBB = parcelRequire("gDDBB");

var $6FDNW = parcelRequire("6FDNW");
var $b44b5920d931e66c$require$Buffer = $6FDNW.Buffer;
"use strict";

var $17709 = parcelRequire("17709");
var $c5287fda22d925cb$exports = {};
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ "use strict";

var $2Kc0N = parcelRequire("2Kc0N");

var $17709 = parcelRequire("17709");
var $c5287fda22d925cb$var$frames = {};
var $c5287fda22d925cb$var$by_descriptor = {};
$c5287fda22d925cb$var$frames.read_header = function(buffer) {
    var offset = 4;
    var header = {};
    var name = buffer.toString("ascii", 0, offset);
    if (name !== "AMQP") // output name in hex (null-bytes can be tough to deal with in ascii)
    throw new $17709.ProtocolError("Invalid protocol header for AMQP: " + buffer.toString("hex", 0, offset));
    header.protocol_id = buffer.readUInt8(offset++);
    header.major = buffer.readUInt8(offset++);
    header.minor = buffer.readUInt8(offset++);
    header.revision = buffer.readUInt8(offset++);
    //the protocol header is interpreted in different ways for
    //different versions(!); check some special cases to give clearer
    //error messages:
    if (header.protocol_id === 0 && header.major === 0 && header.minor === 9 && header.revision === 1) throw new $17709.ProtocolError("Unsupported AMQP version: 0-9-1");
    if (header.protocol_id === 1 && header.major === 1 && header.minor === 0 && header.revision === 10) throw new $17709.ProtocolError("Unsupported AMQP version: 0-10");
    if (header.major !== 1 || header.minor !== 0) throw new $17709.ProtocolError("Unsupported AMQP version: " + JSON.stringify(header));
    return header;
};
$c5287fda22d925cb$var$frames.write_header = function(buffer, header) {
    var offset = 4;
    buffer.write("AMQP", 0, offset, "ascii");
    buffer.writeUInt8(header.protocol_id, offset++);
    buffer.writeUInt8(header.major, offset++);
    buffer.writeUInt8(header.minor, offset++);
    buffer.writeUInt8(header.revision, offset++);
    return 8;
};
//todo: define enumeration for frame types
$c5287fda22d925cb$var$frames.TYPE_AMQP = 0x00;
$c5287fda22d925cb$var$frames.TYPE_SASL = 0x01;
$c5287fda22d925cb$var$frames.read_frame = function(buffer) {
    var reader = new $2Kc0N.Reader(buffer);
    var frame = {};
    frame.size = reader.read_uint(4);
    if (reader.remaining() < frame.size - 4) return null;
    var doff = reader.read_uint(1);
    if (doff < 2) throw new $17709.ProtocolError("Invalid data offset, must be at least 2 was " + doff);
    frame.type = reader.read_uint(1);
    if (frame.type === $c5287fda22d925cb$var$frames.TYPE_AMQP) frame.channel = reader.read_uint(2);
    else if (frame.type === $c5287fda22d925cb$var$frames.TYPE_SASL) {
        reader.skip(2);
        frame.channel = 0;
    } else throw new $17709.ProtocolError("Unknown frame type " + frame.type);
    if (doff > 1) //ignore any extended header
    reader.skip(doff * 4 - 8);
    if (reader.remaining()) {
        frame.performative = reader.read();
        var c = $c5287fda22d925cb$var$by_descriptor[frame.performative.descriptor.value];
        if (c) frame.performative = new c(frame.performative.value);
        if (reader.remaining()) frame.payload = reader.read_bytes(reader.remaining());
    }
    return frame;
};
$c5287fda22d925cb$var$frames.write_frame = function(frame) {
    var writer = new $2Kc0N.Writer();
    writer.skip(4); //skip size until we know how much we have written
    writer.write_uint(2, 1); //doff
    writer.write_uint(frame.type, 1);
    if (frame.type === $c5287fda22d925cb$var$frames.TYPE_AMQP) writer.write_uint(frame.channel, 2);
    else if (frame.type === $c5287fda22d925cb$var$frames.TYPE_SASL) writer.write_uint(0, 2);
    else throw new $17709.ProtocolError("Unknown frame type " + frame.type);
    if (frame.performative) {
        writer.write(frame.performative);
        if (frame.payload) writer.write_bytes(frame.payload);
    }
    var buffer = writer.toBuffer();
    buffer.writeUInt32BE(buffer.length, 0); //fill in the size
    return buffer;
};
$c5287fda22d925cb$var$frames.amqp_frame = function(channel, performative, payload) {
    return {
        "channel": channel || 0,
        "type": $c5287fda22d925cb$var$frames.TYPE_AMQP,
        "performative": performative,
        "payload": payload
    };
};
$c5287fda22d925cb$var$frames.sasl_frame = function(performative) {
    return {
        "channel": 0,
        "type": $c5287fda22d925cb$var$frames.TYPE_SASL,
        "performative": performative
    };
};
function $c5287fda22d925cb$var$define_frame(type, def) {
    var c = $2Kc0N.define_composite(def);
    $c5287fda22d925cb$var$frames[def.name] = c.create;
    $c5287fda22d925cb$var$by_descriptor[Number(c.descriptor.numeric).toString(10)] = c;
    $c5287fda22d925cb$var$by_descriptor[c.descriptor.symbolic] = c;
}
var $c5287fda22d925cb$var$open = {
    name: "open",
    code: 0x10,
    fields: [
        {
            name: "container_id",
            type: "string",
            mandatory: true
        },
        {
            name: "hostname",
            type: "string"
        },
        {
            name: "max_frame_size",
            type: "uint",
            default_value: 4294967295
        },
        {
            name: "channel_max",
            type: "ushort",
            default_value: 65535
        },
        {
            name: "idle_time_out",
            type: "uint"
        },
        {
            name: "outgoing_locales",
            type: "symbol",
            multiple: true
        },
        {
            name: "incoming_locales",
            type: "symbol",
            multiple: true
        },
        {
            name: "offered_capabilities",
            type: "symbol",
            multiple: true
        },
        {
            name: "desired_capabilities",
            type: "symbol",
            multiple: true
        },
        {
            name: "properties",
            type: "symbolic_map"
        }
    ]
};
var $c5287fda22d925cb$var$begin = {
    name: "begin",
    code: 0x11,
    fields: [
        {
            name: "remote_channel",
            type: "ushort"
        },
        {
            name: "next_outgoing_id",
            type: "uint",
            mandatory: true
        },
        {
            name: "incoming_window",
            type: "uint",
            mandatory: true
        },
        {
            name: "outgoing_window",
            type: "uint",
            mandatory: true
        },
        {
            name: "handle_max",
            type: "uint",
            default_value: "4294967295"
        },
        {
            name: "offered_capabilities",
            type: "symbol",
            multiple: true
        },
        {
            name: "desired_capabilities",
            type: "symbol",
            multiple: true
        },
        {
            name: "properties",
            type: "symbolic_map"
        }
    ]
};
var $c5287fda22d925cb$var$attach = {
    name: "attach",
    code: 0x12,
    fields: [
        {
            name: "name",
            type: "string",
            mandatory: true
        },
        {
            name: "handle",
            type: "uint",
            mandatory: true
        },
        {
            name: "role",
            type: "boolean",
            mandatory: true
        },
        {
            name: "snd_settle_mode",
            type: "ubyte",
            default_value: 2
        },
        {
            name: "rcv_settle_mode",
            type: "ubyte",
            default_value: 0
        },
        {
            name: "source",
            type: "*"
        },
        {
            name: "target",
            type: "*"
        },
        {
            name: "unsettled",
            type: "map"
        },
        {
            name: "incomplete_unsettled",
            type: "boolean",
            default_value: false
        },
        {
            name: "initial_delivery_count",
            type: "uint"
        },
        {
            name: "max_message_size",
            type: "ulong"
        },
        {
            name: "offered_capabilities",
            type: "symbol",
            multiple: true
        },
        {
            name: "desired_capabilities",
            type: "symbol",
            multiple: true
        },
        {
            name: "properties",
            type: "symbolic_map"
        }
    ]
};
var $c5287fda22d925cb$var$flow = {
    name: "flow",
    code: 0x13,
    fields: [
        {
            name: "next_incoming_id",
            type: "uint"
        },
        {
            name: "incoming_window",
            type: "uint",
            mandatory: true
        },
        {
            name: "next_outgoing_id",
            type: "uint",
            mandatory: true
        },
        {
            name: "outgoing_window",
            type: "uint",
            mandatory: true
        },
        {
            name: "handle",
            type: "uint"
        },
        {
            name: "delivery_count",
            type: "uint"
        },
        {
            name: "link_credit",
            type: "uint"
        },
        {
            name: "available",
            type: "uint"
        },
        {
            name: "drain",
            type: "boolean",
            default_value: false
        },
        {
            name: "echo",
            type: "boolean",
            default_value: false
        },
        {
            name: "properties",
            type: "symbolic_map"
        }
    ]
};
var $c5287fda22d925cb$var$transfer = {
    name: "transfer",
    code: 0x14,
    fields: [
        {
            name: "handle",
            type: "uint",
            mandatory: true
        },
        {
            name: "delivery_id",
            type: "uint"
        },
        {
            name: "delivery_tag",
            type: "binary"
        },
        {
            name: "message_format",
            type: "uint"
        },
        {
            name: "settled",
            type: "boolean"
        },
        {
            name: "more",
            type: "boolean",
            default_value: false
        },
        {
            name: "rcv_settle_mode",
            type: "ubyte"
        },
        {
            name: "state",
            type: "delivery_state"
        },
        {
            name: "resume",
            type: "boolean",
            default_value: false
        },
        {
            name: "aborted",
            type: "boolean",
            default_value: false
        },
        {
            name: "batchable",
            type: "boolean",
            default_value: false
        }
    ]
};
var $c5287fda22d925cb$var$disposition = {
    name: "disposition",
    code: 0x15,
    fields: [
        {
            name: "role",
            type: "boolean",
            mandatory: true
        },
        {
            name: "first",
            type: "uint",
            mandatory: true
        },
        {
            name: "last",
            type: "uint"
        },
        {
            name: "settled",
            type: "boolean",
            default_value: false
        },
        {
            name: "state",
            type: "*"
        },
        {
            name: "batchable",
            type: "boolean",
            default_value: false
        }
    ]
};
var $c5287fda22d925cb$var$detach = {
    name: "detach",
    code: 0x16,
    fields: [
        {
            name: "handle",
            type: "uint",
            mandatory: true
        },
        {
            name: "closed",
            type: "boolean",
            default_value: false
        },
        {
            name: "error",
            type: "error"
        }
    ]
};
var $c5287fda22d925cb$var$end = {
    name: "end",
    code: 0x17,
    fields: [
        {
            name: "error",
            type: "error"
        }
    ]
};
var $c5287fda22d925cb$var$close = {
    name: "close",
    code: 0x18,
    fields: [
        {
            name: "error",
            type: "error"
        }
    ]
};
$c5287fda22d925cb$var$define_frame($c5287fda22d925cb$var$frames.TYPE_AMQP, $c5287fda22d925cb$var$open);
$c5287fda22d925cb$var$define_frame($c5287fda22d925cb$var$frames.TYPE_AMQP, $c5287fda22d925cb$var$begin);
$c5287fda22d925cb$var$define_frame($c5287fda22d925cb$var$frames.TYPE_AMQP, $c5287fda22d925cb$var$attach);
$c5287fda22d925cb$var$define_frame($c5287fda22d925cb$var$frames.TYPE_AMQP, $c5287fda22d925cb$var$flow);
$c5287fda22d925cb$var$define_frame($c5287fda22d925cb$var$frames.TYPE_AMQP, $c5287fda22d925cb$var$transfer);
$c5287fda22d925cb$var$define_frame($c5287fda22d925cb$var$frames.TYPE_AMQP, $c5287fda22d925cb$var$disposition);
$c5287fda22d925cb$var$define_frame($c5287fda22d925cb$var$frames.TYPE_AMQP, $c5287fda22d925cb$var$detach);
$c5287fda22d925cb$var$define_frame($c5287fda22d925cb$var$frames.TYPE_AMQP, $c5287fda22d925cb$var$end);
$c5287fda22d925cb$var$define_frame($c5287fda22d925cb$var$frames.TYPE_AMQP, $c5287fda22d925cb$var$close);
var $c5287fda22d925cb$var$sasl_mechanisms = {
    name: "sasl_mechanisms",
    code: 0x40,
    fields: [
        {
            name: "sasl_server_mechanisms",
            type: "symbol",
            multiple: true,
            mandatory: true
        }
    ]
};
var $c5287fda22d925cb$var$sasl_init = {
    name: "sasl_init",
    code: 0x41,
    fields: [
        {
            name: "mechanism",
            type: "symbol",
            mandatory: true
        },
        {
            name: "initial_response",
            type: "binary"
        },
        {
            name: "hostname",
            type: "string"
        }
    ]
};
var $c5287fda22d925cb$var$sasl_challenge = {
    name: "sasl_challenge",
    code: 0x42,
    fields: [
        {
            name: "challenge",
            type: "binary",
            mandatory: true
        }
    ]
};
var $c5287fda22d925cb$var$sasl_response = {
    name: "sasl_response",
    code: 0x43,
    fields: [
        {
            name: "response",
            type: "binary",
            mandatory: true
        }
    ]
};
var $c5287fda22d925cb$var$sasl_outcome = {
    name: "sasl_outcome",
    code: 0x44,
    fields: [
        {
            name: "code",
            type: "ubyte",
            mandatory: true
        },
        {
            name: "additional_data",
            type: "binary"
        }
    ]
};
$c5287fda22d925cb$var$define_frame($c5287fda22d925cb$var$frames.TYPE_SASL, $c5287fda22d925cb$var$sasl_mechanisms);
$c5287fda22d925cb$var$define_frame($c5287fda22d925cb$var$frames.TYPE_SASL, $c5287fda22d925cb$var$sasl_init);
$c5287fda22d925cb$var$define_frame($c5287fda22d925cb$var$frames.TYPE_SASL, $c5287fda22d925cb$var$sasl_challenge);
$c5287fda22d925cb$var$define_frame($c5287fda22d925cb$var$frames.TYPE_SASL, $c5287fda22d925cb$var$sasl_response);
$c5287fda22d925cb$var$define_frame($c5287fda22d925cb$var$frames.TYPE_SASL, $c5287fda22d925cb$var$sasl_outcome);
$c5287fda22d925cb$exports = $c5287fda22d925cb$var$frames;



var $5Avaz = parcelRequire("5Avaz");
var $8bb9bbeef89e875e$exports = {};
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ "use strict";

var $17709 = parcelRequire("17709");

var $9d7c9efacf6b8c06$exports = {};
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ "use strict";

var $17709 = parcelRequire("17709");


var $5Avaz = parcelRequire("5Avaz");

var $3hLdt = parcelRequire("3hLdt");
var $9d7c9efacf6b8c06$var$Transport = function(identifier, protocol_id, frame_type, handler) {
    this.identifier = identifier;
    this.protocol_id = protocol_id;
    this.frame_type = frame_type;
    this.handler = handler;
    this.pending = [];
    this.header_sent = undefined;
    this.header_received = undefined;
    this.write_complete = false;
    this.read_complete = false;
};
$9d7c9efacf6b8c06$var$Transport.prototype.has_writes_pending = function() {
    return this.pending.length > 0 || !this.header_sent;
};
$9d7c9efacf6b8c06$var$Transport.prototype.encode = function(frame) {
    this.pending.push(frame);
};
$9d7c9efacf6b8c06$var$Transport.prototype.write = function(socket) {
    if (!this.header_sent) {
        var buffer = $3hLdt.allocate_buffer(8);
        var header = {
            protocol_id: this.protocol_id,
            major: 1,
            minor: 0,
            revision: 0
        };
        $5Avaz.frames("[%s] -> %o", this.identifier, header);
        $c5287fda22d925cb$exports.write_header(buffer, header);
        socket.write(buffer);
        this.header_sent = header;
    }
    for(var i = 0; i < this.pending.length; i++){
        var frame = this.pending[i];
        var buffer = $c5287fda22d925cb$exports.write_frame(frame);
        socket.write(buffer);
        if (frame.performative) $5Avaz.frames("[%s]:%s -> %s %j", this.identifier, frame.channel, frame.performative.constructor, frame.performative, frame.payload || "");
        else $5Avaz.frames("[%s]:%s -> empty", this.identifier, frame.channel);
        $5Avaz.raw("[%s] SENT: %d %h", this.identifier, buffer.length, buffer);
    }
    this.pending = [];
};
$9d7c9efacf6b8c06$var$Transport.prototype.read = function(buffer) {
    var offset = 0;
    if (!this.header_received) {
        if (buffer.length < 8) return offset;
        else {
            this.header_received = $c5287fda22d925cb$exports.read_header(buffer);
            $5Avaz.frames("[%s] <- %o", this.identifier, this.header_received);
            if (this.header_received.protocol_id !== this.protocol_id) {
                if (this.protocol_id === 3 && this.header_received.protocol_id === 0) throw new $17709.ProtocolError("Expecting SASL layer");
                else if (this.protocol_id === 0 && this.header_received.protocol_id === 3) throw new $17709.ProtocolError("SASL layer not enabled");
                else throw new $17709.ProtocolError("Invalid AMQP protocol id " + this.header_received.protocol_id + " expecting: " + this.protocol_id);
            }
            offset = 8;
        }
    }
    while(offset < buffer.length - 4 && !this.read_complete){
        var frame_size = buffer.readUInt32BE(offset);
        $5Avaz.io("[%s] got frame of size %d", this.identifier, frame_size);
        if (buffer.length < offset + frame_size) {
            $5Avaz.io("[%s] incomplete frame; have only %d of %d", this.identifier, buffer.length - offset, frame_size);
            break;
        } else {
            var slice = buffer.slice(offset, offset + frame_size);
            $5Avaz.raw("[%s] RECV: %d %h", this.identifier, slice.length, slice);
            var frame = $c5287fda22d925cb$exports.read_frame(slice);
            if (frame.performative) $5Avaz.frames("[%s]:%s <- %s %j", this.identifier, frame.channel, frame.performative.constructor, frame.performative, frame.payload || "");
            else $5Avaz.frames("[%s]:%s <- empty", this.identifier, frame.channel);
            if (frame.type !== this.frame_type) throw new $17709.ProtocolError("Invalid frame type: " + frame.type);
            offset += frame_size;
            if (frame.performative) frame.performative.dispatch(this.handler, frame);
        }
    }
    return offset;
};
$9d7c9efacf6b8c06$exports = $9d7c9efacf6b8c06$var$Transport;



var $3hLdt = parcelRequire("3hLdt");
var $8bb9bbeef89e875e$var$sasl_codes = {
    "OK": 0,
    "AUTH": 1,
    "SYS": 2,
    "SYS_PERM": 3,
    "SYS_TEMP": 4
};
var $8bb9bbeef89e875e$var$SASL_PROTOCOL_ID = 0x03;
function $8bb9bbeef89e875e$var$extract(buffer) {
    var results = [];
    var start = 0;
    var i = 0;
    while(i < buffer.length)if (buffer[i] === 0x00) {
        if (i > start) results.push(buffer.toString("utf8", start, i));
        else results.push(null);
        start = ++i;
    } else ++i;
    if (i > start) results.push(buffer.toString("utf8", start, i));
    else results.push(null);
    return results;
}
var $8bb9bbeef89e875e$var$PlainServer = function(callback) {
    this.callback = callback;
    this.outcome = undefined;
    this.username = undefined;
};
$8bb9bbeef89e875e$var$PlainServer.prototype.start = function(response, hostname) {
    var fields = $8bb9bbeef89e875e$var$extract(response);
    if (fields.length !== 3) return Promise.reject("Unexpected response in PLAIN, got " + fields.length + " fields, expected 3");
    var self = this;
    return Promise.resolve(this.callback(fields[1], fields[2], hostname)).then(function(result) {
        if (result) {
            self.outcome = true;
            self.username = fields[1];
        } else self.outcome = false;
    });
};
var $8bb9bbeef89e875e$var$PlainClient = function(username, password) {
    this.username = username;
    this.password = password;
};
$8bb9bbeef89e875e$var$PlainClient.prototype.start = function(callback) {
    var response = $3hLdt.allocate_buffer(1 + this.username.length + 1 + this.password.length);
    response.writeUInt8(0, 0);
    response.write(this.username, 1);
    response.writeUInt8(0, 1 + this.username.length);
    response.write(this.password, 1 + this.username.length + 1);
    callback(undefined, response);
};
var $8bb9bbeef89e875e$var$AnonymousServer = function() {
    this.outcome = undefined;
    this.username = undefined;
};
$8bb9bbeef89e875e$var$AnonymousServer.prototype.start = function(response) {
    this.outcome = true;
    this.username = response ? response.toString("utf8") : "anonymous";
};
var $8bb9bbeef89e875e$var$AnonymousClient = function(name) {
    this.username = name ? name : "anonymous";
};
$8bb9bbeef89e875e$var$AnonymousClient.prototype.start = function(callback) {
    var response = $3hLdt.allocate_buffer(1 + this.username.length);
    response.writeUInt8(0, 0);
    response.write(this.username, 1);
    callback(undefined, response);
};
var $8bb9bbeef89e875e$var$ExternalServer = function() {
    this.outcome = undefined;
    this.username = undefined;
};
$8bb9bbeef89e875e$var$ExternalServer.prototype.start = function() {
    this.outcome = true;
};
var $8bb9bbeef89e875e$var$ExternalClient = function() {
    this.username = undefined;
};
$8bb9bbeef89e875e$var$ExternalClient.prototype.start = function(callback) {
    callback(undefined, "");
};
$8bb9bbeef89e875e$var$ExternalClient.prototype.step = function(callback) {
    callback(undefined, "");
};
var $8bb9bbeef89e875e$var$XOAuth2Client = function(username, token) {
    this.username = username;
    this.token = token;
};
$8bb9bbeef89e875e$var$XOAuth2Client.prototype.start = function(callback) {
    var response = $3hLdt.allocate_buffer(this.username.length + this.token.length + 5 + 12 + 3);
    var count = 0;
    response.write("user=", count);
    count += 5;
    response.write(this.username, count);
    count += this.username.length;
    response.writeUInt8(1, count);
    count += 1;
    response.write("auth=Bearer ", count);
    count += 12;
    response.write(this.token, count);
    count += this.token.length;
    response.writeUInt8(1, count);
    count += 1;
    response.writeUInt8(1, count);
    count += 1;
    callback(undefined, response);
};
/**
 * The mechanisms argument is a map of mechanism names to factory
 * functions for objects that implement that mechanism.
 */ var $8bb9bbeef89e875e$var$SaslServer = function(connection, mechanisms) {
    this.connection = connection;
    this.transport = new $9d7c9efacf6b8c06$exports(connection.amqp_transport.identifier, $8bb9bbeef89e875e$var$SASL_PROTOCOL_ID, $c5287fda22d925cb$exports.TYPE_SASL, this);
    this.next = connection.amqp_transport;
    this.mechanisms = mechanisms;
    this.mechanism = undefined;
    this.outcome = undefined;
    this.username = undefined;
    var mechlist = Object.getOwnPropertyNames(mechanisms);
    this.transport.encode($c5287fda22d925cb$exports.sasl_frame($c5287fda22d925cb$exports.sasl_mechanisms({
        sasl_server_mechanisms: mechlist
    })));
};
$8bb9bbeef89e875e$var$SaslServer.prototype.do_step = function(challenge) {
    if (this.mechanism.outcome === undefined) {
        this.transport.encode($c5287fda22d925cb$exports.sasl_frame($c5287fda22d925cb$exports.sasl_challenge({
            "challenge": challenge
        })));
        this.connection.output();
    } else {
        this.outcome = this.mechanism.outcome ? $8bb9bbeef89e875e$var$sasl_codes.OK : $8bb9bbeef89e875e$var$sasl_codes.AUTH;
        var frame = $c5287fda22d925cb$exports.sasl_frame($c5287fda22d925cb$exports.sasl_outcome({
            code: this.outcome
        }));
        this.transport.encode(frame);
        this.connection.output();
        if (this.outcome === $8bb9bbeef89e875e$var$sasl_codes.OK) {
            this.username = this.mechanism.username;
            this.transport.write_complete = true;
            this.transport.read_complete = true;
        }
    }
};
$8bb9bbeef89e875e$var$SaslServer.prototype.on_sasl_init = function(frame) {
    var saslctor = this.mechanisms[frame.performative.mechanism];
    if (saslctor) {
        this.mechanism = saslctor();
        Promise.resolve(this.mechanism.start(frame.performative.initial_response, frame.performative.hostname)).then(this.do_step.bind(this)).catch(this.do_fail.bind(this));
    } else {
        this.outcome = $8bb9bbeef89e875e$var$sasl_codes.AUTH;
        this.transport.encode($c5287fda22d925cb$exports.sasl_frame($c5287fda22d925cb$exports.sasl_outcome({
            code: this.outcome
        })));
    }
};
$8bb9bbeef89e875e$var$SaslServer.prototype.on_sasl_response = function(frame) {
    Promise.resolve(this.mechanism.step(frame.performative.response)).then(this.do_step.bind(this)).catch(this.do_fail.bind(this));
};
$8bb9bbeef89e875e$var$SaslServer.prototype.do_fail = function(e) {
    var frame = $c5287fda22d925cb$exports.sasl_frame($c5287fda22d925cb$exports.sasl_outcome({
        code: $8bb9bbeef89e875e$var$sasl_codes.SYS
    }));
    this.transport.encode(frame);
    this.connection.output();
    try {
        this.connection.sasl_failed("Sasl callback promise failed with " + e, "amqp:internal-error");
    } catch (e) {
        console.error("Uncaught error: ", e.message);
    }
};
$8bb9bbeef89e875e$var$SaslServer.prototype.has_writes_pending = function() {
    return this.transport.has_writes_pending() || this.next.has_writes_pending();
};
$8bb9bbeef89e875e$var$SaslServer.prototype.write = function(socket) {
    if (this.transport.write_complete && this.transport.pending.length === 0) return this.next.write(socket);
    else return this.transport.write(socket);
};
$8bb9bbeef89e875e$var$SaslServer.prototype.read = function(buffer) {
    if (this.transport.read_complete) return this.next.read(buffer);
    else return this.transport.read(buffer);
};
var $8bb9bbeef89e875e$var$SaslClient = function(connection, mechanisms, hostname) {
    this.connection = connection;
    this.transport = new $9d7c9efacf6b8c06$exports(connection.amqp_transport.identifier, $8bb9bbeef89e875e$var$SASL_PROTOCOL_ID, $c5287fda22d925cb$exports.TYPE_SASL, this);
    this.next = connection.amqp_transport;
    this.mechanisms = mechanisms;
    this.mechanism = undefined;
    this.mechanism_name = undefined;
    this.hostname = hostname;
    this.failed = false;
};
$8bb9bbeef89e875e$var$SaslClient.prototype.on_sasl_mechanisms = function(frame) {
    var offered_mechanisms = [];
    if (Array.isArray(frame.performative.sasl_server_mechanisms)) offered_mechanisms = frame.performative.sasl_server_mechanisms;
    else if (frame.performative.sasl_server_mechanisms) offered_mechanisms = [
        frame.performative.sasl_server_mechanisms
    ];
    for(var i = 0; this.mechanism === undefined && i < offered_mechanisms.length; i++){
        var mech = offered_mechanisms[i];
        var f = this.mechanisms[mech];
        if (f) {
            this.mechanism = typeof f === "function" ? f() : f;
            this.mechanism_name = mech;
        }
    }
    if (this.mechanism) {
        var self = this;
        this.mechanism.start(function(err, response) {
            if (err) {
                self.failed = true;
                self.connection.sasl_failed("SASL mechanism init failed: " + err);
            } else {
                var init = {
                    "mechanism": self.mechanism_name,
                    "initial_response": response
                };
                if (self.hostname) init.hostname = self.hostname;
                self.transport.encode($c5287fda22d925cb$exports.sasl_frame($c5287fda22d925cb$exports.sasl_init(init)));
                self.connection.output();
            }
        });
    } else {
        this.failed = true;
        this.connection.sasl_failed("No suitable mechanism; server supports " + frame.performative.sasl_server_mechanisms);
    }
};
$8bb9bbeef89e875e$var$SaslClient.prototype.on_sasl_challenge = function(frame) {
    var self = this;
    this.mechanism.step(frame.performative.challenge, function(err, response) {
        if (err) {
            self.failed = true;
            self.connection.sasl_failed("SASL mechanism challenge failed: " + err);
        } else {
            self.transport.encode($c5287fda22d925cb$exports.sasl_frame($c5287fda22d925cb$exports.sasl_response({
                "response": response
            })));
            self.connection.output();
        }
    });
};
$8bb9bbeef89e875e$var$SaslClient.prototype.on_sasl_outcome = function(frame) {
    switch(frame.performative.code){
        case $8bb9bbeef89e875e$var$sasl_codes.OK:
            this.transport.read_complete = true;
            this.transport.write_complete = true;
            break;
        case $8bb9bbeef89e875e$var$sasl_codes.SYS:
        case $8bb9bbeef89e875e$var$sasl_codes.SYS_PERM:
        case $8bb9bbeef89e875e$var$sasl_codes.SYS_TEMP:
            this.transport.write_complete = true;
            this.connection.sasl_failed("Failed to authenticate: " + frame.performative.code, "amqp:internal-error");
            break;
        default:
            this.transport.write_complete = true;
            this.connection.sasl_failed("Failed to authenticate: " + frame.performative.code);
    }
};
$8bb9bbeef89e875e$var$SaslClient.prototype.has_writes_pending = function() {
    return this.transport.has_writes_pending() || this.next.has_writes_pending();
};
$8bb9bbeef89e875e$var$SaslClient.prototype.write = function(socket) {
    if (this.transport.write_complete) return this.next.write(socket);
    else return this.transport.write(socket);
};
$8bb9bbeef89e875e$var$SaslClient.prototype.read = function(buffer) {
    if (this.transport.read_complete) return this.next.read(buffer);
    else return this.transport.read(buffer);
};
var $8bb9bbeef89e875e$var$SelectiveServer = function(connection, mechanisms) {
    this.header_received = false;
    this.transports = {
        0: connection.amqp_transport,
        3: new $8bb9bbeef89e875e$var$SaslServer(connection, mechanisms)
    };
    this.selected = undefined;
};
$8bb9bbeef89e875e$var$SelectiveServer.prototype.has_writes_pending = function() {
    return this.header_received && this.selected.has_writes_pending();
};
$8bb9bbeef89e875e$var$SelectiveServer.prototype.write = function(socket) {
    if (this.selected) return this.selected.write(socket);
    else return 0;
};
$8bb9bbeef89e875e$var$SelectiveServer.prototype.read = function(buffer) {
    if (!this.header_received) {
        if (buffer.length < 8) return 0;
        else {
            this.header_received = $c5287fda22d925cb$exports.read_header(buffer);
            this.selected = this.transports[this.header_received.protocol_id];
            if (this.selected === undefined) throw new $17709.ProtocolError("Invalid AMQP protocol id " + this.header_received.protocol_id);
        }
    }
    return this.selected.read(buffer);
};
var $8bb9bbeef89e875e$var$default_server_mechanisms = {
    enable_anonymous: function() {
        this["ANONYMOUS"] = function() {
            return new $8bb9bbeef89e875e$var$AnonymousServer();
        };
    },
    enable_plain: function(callback) {
        this["PLAIN"] = function() {
            return new $8bb9bbeef89e875e$var$PlainServer(callback);
        };
    }
};
var $8bb9bbeef89e875e$var$default_client_mechanisms = {
    enable_anonymous: function(name) {
        this["ANONYMOUS"] = function() {
            return new $8bb9bbeef89e875e$var$AnonymousClient(name);
        };
    },
    enable_plain: function(username, password) {
        this["PLAIN"] = function() {
            return new $8bb9bbeef89e875e$var$PlainClient(username, password);
        };
    },
    enable_external: function() {
        this["EXTERNAL"] = function() {
            return new $8bb9bbeef89e875e$var$ExternalClient();
        };
    },
    enable_xoauth2: function(username, token) {
        if (username && token) this["XOAUTH2"] = function() {
            return new $8bb9bbeef89e875e$var$XOAuth2Client(username, token);
        };
        else if (token === undefined) throw Error("token must be specified");
        else if (username === undefined) throw Error("username must be specified");
    }
};
$8bb9bbeef89e875e$exports = {
    Client: $8bb9bbeef89e875e$var$SaslClient,
    Server: $8bb9bbeef89e875e$var$SaslServer,
    Selective: $8bb9bbeef89e875e$var$SelectiveServer,
    server_mechanisms: function() {
        return Object.create($8bb9bbeef89e875e$var$default_server_mechanisms);
    },
    client_mechanisms: function() {
        return Object.create($8bb9bbeef89e875e$var$default_client_mechanisms);
    },
    server_add_external: function(mechs) {
        mechs["EXTERNAL"] = function() {
            return new $8bb9bbeef89e875e$var$ExternalServer();
        };
        return mechs;
    }
};



var $3hLdt = parcelRequire("3hLdt");
var $f4a171f5da3e65d3$exports = {};
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ "use strict";
var $f4a171f5da3e65d3$var$EndpointState = function() {
    this.init();
};
$f4a171f5da3e65d3$var$EndpointState.prototype.init = function() {
    this.local_open = false;
    this.remote_open = false;
    this.open_requests = 0;
    this.close_requests = 0;
    this.initialised = false;
    this.marker = undefined;
};
$f4a171f5da3e65d3$var$EndpointState.prototype.mark = function(o) {
    this.marker = o || Date.now();
    return this.marker;
};
$f4a171f5da3e65d3$var$EndpointState.prototype.open = function() {
    this.marker = undefined;
    this.initialised = true;
    if (!this.local_open) {
        this.local_open = true;
        this.open_requests++;
        return true;
    } else return false;
};
$f4a171f5da3e65d3$var$EndpointState.prototype.close = function() {
    this.marker = undefined;
    if (this.local_open) {
        this.local_open = false;
        this.close_requests++;
        return true;
    } else return false;
};
$f4a171f5da3e65d3$var$EndpointState.prototype.disconnected = function() {
    var was_initialised = this.initialised;
    this.was_open = this.local_open;
    this.init();
    this.initialised = was_initialised;
};
$f4a171f5da3e65d3$var$EndpointState.prototype.reconnect = function() {
    if (this.was_open) {
        this.open();
        this.was_open = undefined;
    }
};
$f4a171f5da3e65d3$var$EndpointState.prototype.remote_opened = function() {
    if (!this.remote_open) {
        this.remote_open = true;
        return true;
    } else return false;
};
$f4a171f5da3e65d3$var$EndpointState.prototype.remote_closed = function() {
    if (this.remote_open) {
        this.remote_open = false;
        return true;
    } else return false;
};
$f4a171f5da3e65d3$var$EndpointState.prototype.is_open = function() {
    return this.local_open && this.remote_open;
};
$f4a171f5da3e65d3$var$EndpointState.prototype.is_closed = function() {
    return this.initialised && !(this.local_open || this.was_open) && !this.remote_open;
};
$f4a171f5da3e65d3$var$EndpointState.prototype.has_settled = function() {
    return this.open_requests === 0 && this.close_requests === 0;
};
$f4a171f5da3e65d3$var$EndpointState.prototype.need_open = function() {
    if (this.open_requests > 0) {
        this.open_requests--;
        return true;
    } else return false;
};
$f4a171f5da3e65d3$var$EndpointState.prototype.need_close = function() {
    if (this.close_requests > 0) {
        this.close_requests--;
        return true;
    } else return false;
};
$f4a171f5da3e65d3$exports = $f4a171f5da3e65d3$var$EndpointState;


var $93cc2cd2cca3866c$exports = {};
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ 
var $6FDNW = parcelRequire("6FDNW");
var $93cc2cd2cca3866c$require$Buffer = $6FDNW.Buffer;

var $gDDBB = parcelRequire("gDDBB");
"use strict";

var $dfcbcc836d886fe6$exports = {};
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ 
var $gDDBB = parcelRequire("gDDBB");

var $6FDNW = parcelRequire("6FDNW");
var $dfcbcc836d886fe6$require$Buffer = $6FDNW.Buffer;
"use strict";


var $5Avaz = parcelRequire("5Avaz");

var $bdeu2 = parcelRequire("bdeu2");
var $83405004bc535d23$exports = {};
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ "use strict";

var $2Kc0N = parcelRequire("2Kc0N");
var $83405004bc535d23$var$terminus = {};
var $83405004bc535d23$var$by_descriptor = {};
function $83405004bc535d23$var$define_terminus(def) {
    var c = $2Kc0N.define_composite(def);
    $83405004bc535d23$var$terminus[def.name] = c.create;
    $83405004bc535d23$var$by_descriptor[Number(c.descriptor.numeric).toString(10)] = c;
    $83405004bc535d23$var$by_descriptor[c.descriptor.symbolic] = c;
}
$83405004bc535d23$var$terminus.unwrap = function(field) {
    if (field && field.descriptor) {
        var c = $83405004bc535d23$var$by_descriptor[field.descriptor.value];
        if (c) return new c(field.value);
        else console.warn("Unknown terminus: " + field.descriptor);
    }
    return null;
};
$83405004bc535d23$var$define_terminus({
    name: "source",
    code: 0x28,
    fields: [
        {
            name: "address",
            type: "string"
        },
        {
            name: "durable",
            type: "uint",
            default_value: 0
        },
        {
            name: "expiry_policy",
            type: "symbol",
            default_value: "session-end"
        },
        {
            name: "timeout",
            type: "uint",
            default_value: 0
        },
        {
            name: "dynamic",
            type: "boolean",
            default_value: false
        },
        {
            name: "dynamic_node_properties",
            type: "symbolic_map"
        },
        {
            name: "distribution_mode",
            type: "symbol"
        },
        {
            name: "filter",
            type: "symbolic_map"
        },
        {
            name: "default_outcome",
            type: "*"
        },
        {
            name: "outcomes",
            type: "symbol",
            multiple: true
        },
        {
            name: "capabilities",
            type: "symbol",
            multiple: true
        }
    ]
});
$83405004bc535d23$var$define_terminus({
    name: "target",
    code: 0x29,
    fields: [
        {
            name: "address",
            type: "string"
        },
        {
            name: "durable",
            type: "uint",
            default_value: 0
        },
        {
            name: "expiry_policy",
            type: "symbol",
            default_value: "session-end"
        },
        {
            name: "timeout",
            type: "uint",
            default_value: 0
        },
        {
            name: "dynamic",
            type: "boolean",
            default_value: false
        },
        {
            name: "dynamic_node_properties",
            type: "symbolic_map"
        },
        {
            name: "capabilities",
            type: "symbol",
            multiple: true
        }
    ]
});
$83405004bc535d23$exports = $83405004bc535d23$var$terminus;



var $dfcbcc836d886fe6$var$FlowController = function(window) {
    this.window = window;
};
$dfcbcc836d886fe6$var$FlowController.prototype.update = function(context) {
    var delta = this.window - context.receiver.credit;
    if (delta >= this.window / 4) context.receiver.flow(delta);
};
function $dfcbcc836d886fe6$var$auto_settle(context) {
    context.delivery.settled = true;
}
function $dfcbcc836d886fe6$var$auto_accept(context) {
    context.delivery.update(undefined, $bdeu2.accepted().described());
}
function $dfcbcc836d886fe6$var$LinkError(message, condition, link) {
    Error.call(this);
    Error.captureStackTrace(this, this.constructor);
    this.message = message;
    this.condition = condition;
    this.description = message;
    Object.defineProperty(this, "link", {
        value: link
    });
}

(parcelRequire("5uO90")).inherits($dfcbcc836d886fe6$var$LinkError, Error);
var $ac8e2c1b8bfc4b37$exports = {};
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
var $ac8e2c1b8bfc4b37$var$R = typeof Reflect === "object" ? Reflect : null;
var $ac8e2c1b8bfc4b37$var$ReflectApply = $ac8e2c1b8bfc4b37$var$R && typeof $ac8e2c1b8bfc4b37$var$R.apply === "function" ? $ac8e2c1b8bfc4b37$var$R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
};
var $ac8e2c1b8bfc4b37$var$ReflectOwnKeys;
if ($ac8e2c1b8bfc4b37$var$R && typeof $ac8e2c1b8bfc4b37$var$R.ownKeys === "function") $ac8e2c1b8bfc4b37$var$ReflectOwnKeys = $ac8e2c1b8bfc4b37$var$R.ownKeys;
else if (Object.getOwnPropertySymbols) $ac8e2c1b8bfc4b37$var$ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
};
else $ac8e2c1b8bfc4b37$var$ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
};
function $ac8e2c1b8bfc4b37$var$ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
}
var $ac8e2c1b8bfc4b37$var$NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function $ac8e2c1b8bfc4b37$var$EventEmitter() {
    $ac8e2c1b8bfc4b37$var$EventEmitter.init.call(this);
}
$ac8e2c1b8bfc4b37$exports = $ac8e2c1b8bfc4b37$var$EventEmitter;
$ac8e2c1b8bfc4b37$exports.once = $ac8e2c1b8bfc4b37$var$once;
// Backwards-compat with node 0.10.x
$ac8e2c1b8bfc4b37$var$EventEmitter.EventEmitter = $ac8e2c1b8bfc4b37$var$EventEmitter;
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype._events = undefined;
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype._eventsCount = 0;
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var $ac8e2c1b8bfc4b37$var$defaultMaxListeners = 10;
function $ac8e2c1b8bfc4b37$var$checkListener(listener) {
    if (typeof listener !== "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
}
Object.defineProperty($ac8e2c1b8bfc4b37$var$EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return $ac8e2c1b8bfc4b37$var$defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || $ac8e2c1b8bfc4b37$var$NumberIsNaN(arg)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        $ac8e2c1b8bfc4b37$var$defaultMaxListeners = arg;
    }
});
$ac8e2c1b8bfc4b37$var$EventEmitter.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || $ac8e2c1b8bfc4b37$var$NumberIsNaN(n)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    this._maxListeners = n;
    return this;
};
function $ac8e2c1b8bfc4b37$var$_getMaxListeners(that) {
    if (that._maxListeners === undefined) return $ac8e2c1b8bfc4b37$var$EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return $ac8e2c1b8bfc4b37$var$_getMaxListeners(this);
};
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
    var doError = type === "error";
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;
    else if (!doError) return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
        // At least give some kind of context to the user
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === "function") $ac8e2c1b8bfc4b37$var$ReflectApply(handler, this, args);
    else {
        var len = handler.length;
        var listeners = $ac8e2c1b8bfc4b37$var$arrayClone(handler, len);
        for(var i = 0; i < len; ++i)$ac8e2c1b8bfc4b37$var$ReflectApply(listeners[i], this, args);
    }
    return true;
};
function $ac8e2c1b8bfc4b37$var$_addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    $ac8e2c1b8bfc4b37$var$checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [
            listener,
            existing
        ] : [
            existing,
            listener
        ];
        else if (prepend) existing.unshift(listener);
        else existing.push(listener);
        // Check for listener leak
        m = $ac8e2c1b8bfc4b37$var$_getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners " + "added. Use emitter.setMaxListeners() to " + "increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            $ac8e2c1b8bfc4b37$var$ProcessEmitWarning(w);
        }
    }
    return target;
}
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype.addListener = function addListener(type, listener) {
    return $ac8e2c1b8bfc4b37$var$_addListener(this, type, listener, false);
};
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype.on = $ac8e2c1b8bfc4b37$var$EventEmitter.prototype.addListener;
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return $ac8e2c1b8bfc4b37$var$_addListener(this, type, listener, true);
};
function $ac8e2c1b8bfc4b37$var$onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function $ac8e2c1b8bfc4b37$var$_onceWrap(target, type, listener) {
    var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener
    };
    var wrapped = $ac8e2c1b8bfc4b37$var$onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype.once = function once(type, listener) {
    $ac8e2c1b8bfc4b37$var$checkListener(listener);
    this.on(type, $ac8e2c1b8bfc4b37$var$_onceWrap(this, type, listener));
    return this;
};
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    $ac8e2c1b8bfc4b37$var$checkListener(listener);
    this.prependListener(type, $ac8e2c1b8bfc4b37$var$_onceWrap(this, type, listener));
    return this;
};
// Emits a 'removeListener' event if and only if the listener was removed.
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    $ac8e2c1b8bfc4b37$var$checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
            delete events[type];
            if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
        }
    } else if (typeof list !== "function") {
        position = -1;
        for(i = list.length - 1; i >= 0; i--)if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else $ac8e2c1b8bfc4b37$var$spliceOne(list, position);
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined) this.emit("removeListener", type, originalListener || listener);
    }
    return this;
};
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype.off = $ac8e2c1b8bfc4b37$var$EventEmitter.prototype.removeListener;
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;
    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else delete events[type];
        }
        return this;
    }
    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for(i = 0; i < keys.length; ++i){
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    listeners = events[type];
    if (typeof listeners === "function") this.removeListener(type, listeners);
    else if (listeners !== undefined) // LIFO order
    for(i = listeners.length - 1; i >= 0; i--)this.removeListener(type, listeners[i]);
    return this;
};
function $ac8e2c1b8bfc4b37$var$_listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === "function") return unwrap ? [
        evlistener.listener || evlistener
    ] : [
        evlistener
    ];
    return unwrap ? $ac8e2c1b8bfc4b37$var$unwrapListeners(evlistener) : $ac8e2c1b8bfc4b37$var$arrayClone(evlistener, evlistener.length);
}
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype.listeners = function listeners(type) {
    return $ac8e2c1b8bfc4b37$var$_listeners(this, type, true);
};
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return $ac8e2c1b8bfc4b37$var$_listeners(this, type, false);
};
$ac8e2c1b8bfc4b37$var$EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") return emitter.listenerCount(type);
    else return $ac8e2c1b8bfc4b37$var$listenerCount.call(emitter, type);
};
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype.listenerCount = $ac8e2c1b8bfc4b37$var$listenerCount;
function $ac8e2c1b8bfc4b37$var$listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === "function") return 1;
        else if (evlistener !== undefined) return evlistener.length;
    }
    return 0;
}
$ac8e2c1b8bfc4b37$var$EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? $ac8e2c1b8bfc4b37$var$ReflectOwnKeys(this._events) : [];
};
function $ac8e2c1b8bfc4b37$var$arrayClone(arr, n) {
    var copy = new Array(n);
    for(var i = 0; i < n; ++i)copy[i] = arr[i];
    return copy;
}
function $ac8e2c1b8bfc4b37$var$spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function $ac8e2c1b8bfc4b37$var$unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for(var i = 0; i < ret.length; ++i)ret[i] = arr[i].listener || arr[i];
    return ret;
}
function $ac8e2c1b8bfc4b37$var$once(emitter, name) {
    return new Promise(function(resolve, reject) {
        function eventListener() {
            if (errorListener !== undefined) emitter.removeListener("error", errorListener);
            resolve([].slice.call(arguments));
        }
        var errorListener;
        // Adding an error listener is not optional because
        // if an error is thrown on an event emitter we cannot
        // guarantee that the actual event we are waiting will
        // be fired. The result could be a silent way to create
        // memory or file descriptor leaks, which is something
        // we should avoid.
        if (name !== "error") {
            errorListener = function errorListener(err) {
                emitter.removeListener(name, eventListener);
                reject(err);
            };
            emitter.once("error", errorListener);
        }
        emitter.once(name, eventListener);
    });
}


var $dfcbcc836d886fe6$require$EventEmitter = $ac8e2c1b8bfc4b37$exports.EventEmitter;
var $dfcbcc836d886fe6$var$link = Object.create($dfcbcc836d886fe6$require$EventEmitter.prototype);
$dfcbcc836d886fe6$var$link.dispatch = function(name) {
    $5Avaz.events("[%s] Link got event: %s", this.connection.options.id, name);
    $dfcbcc836d886fe6$require$EventEmitter.prototype.emit.apply(this.observers, arguments);
    if (this.listeners(name).length) {
        $dfcbcc836d886fe6$require$EventEmitter.prototype.emit.apply(this, arguments);
        return true;
    } else return this.session.dispatch.apply(this.session, arguments);
};
$dfcbcc836d886fe6$var$link.set_source = function(fields) {
    this.local.attach.source = $83405004bc535d23$exports.source(fields).described();
};
$dfcbcc836d886fe6$var$link.set_target = function(fields) {
    this.local.attach.target = $83405004bc535d23$exports.target(fields).described();
};
$dfcbcc836d886fe6$var$link.attach = function() {
    if (this.state.open()) this.connection._register();
};
$dfcbcc836d886fe6$var$link.open = $dfcbcc836d886fe6$var$link.attach;
$dfcbcc836d886fe6$var$link.detach = function() {
    this.local.detach.closed = false;
    if (this.state.close()) this.connection._register();
};
$dfcbcc836d886fe6$var$link.close = function(error) {
    if (error) this.local.detach.error = error;
    this.local.detach.closed = true;
    if (this.state.close()) this.connection._register();
};
/**
 * This forcibly removes the link from the parent session. It should
 * not be called for a link on an active session/connection, where
 * close() should be used instead.
 */ $dfcbcc836d886fe6$var$link.remove = function() {
    this.session.remove_link(this);
};
$dfcbcc836d886fe6$var$link.is_open = function() {
    return this.session.is_open() && this.state.is_open();
};
$dfcbcc836d886fe6$var$link.is_remote_open = function() {
    return this.session.is_remote_open() && this.state.remote_open;
};
$dfcbcc836d886fe6$var$link.is_itself_closed = function() {
    return this.state.is_closed();
};
$dfcbcc836d886fe6$var$link.is_closed = function() {
    return this.session.is_closed() || this.is_itself_closed();
};
$dfcbcc836d886fe6$var$link._process = function() {
    do {
        if (this.state.need_open()) this.session.output(this.local.attach);
        if (this.issue_flow && this.state.local_open) {
            this.session._write_flow(this);
            this.issue_flow = false;
        }
        if (this.state.need_close()) this.session.output(this.local.detach);
    }while (!this.state.has_settled());
};
$dfcbcc836d886fe6$var$link.on_attach = function(frame) {
    if (this.state.remote_opened()) {
        if (!this.remote.handle) this.remote.handle = frame.handle;
        frame.performative.source = $83405004bc535d23$exports.unwrap(frame.performative.source);
        frame.performative.target = $83405004bc535d23$exports.unwrap(frame.performative.target);
        this.remote.attach = frame.performative;
        this.open();
        this.dispatch(this.is_receiver() ? "receiver_open" : "sender_open", this._context());
    } else throw Error("Attach already received");
};
$dfcbcc836d886fe6$var$link.prefix_event = function(event) {
    return (this.local.attach.role ? "receiver_" : "sender_") + event;
};
$dfcbcc836d886fe6$var$link.on_detach = function(frame) {
    if (this.state.remote_closed()) {
        if (this._incomplete) this._incomplete.settled = true;
        this.remote.detach = frame.performative;
        var error = this.remote.detach.error;
        if (error) {
            var handled = this.dispatch(this.prefix_event("error"), this._context());
            handled = this.dispatch(this.prefix_event("close"), this._context()) || handled;
            if (!handled) $dfcbcc836d886fe6$require$EventEmitter.prototype.emit.call(this.connection.container, "error", new $dfcbcc836d886fe6$var$LinkError(error.description, error.condition, this));
        } else this.dispatch(this.prefix_event("close"), this._context());
        var self = this;
        var token = this.state.mark();
        $gDDBB.nextTick(function() {
            if (self.state.marker === token) {
                self.close();
                $gDDBB.nextTick(function() {
                    self.remove();
                });
            }
        });
    } else throw Error("Detach already received");
};
function $dfcbcc836d886fe6$var$is_internal(name) {
    switch(name){
        case "name":
        case "handle":
        case "role":
        case "initial_delivery_count":
            return true;
        default:
            return false;
    }
}
var $dfcbcc836d886fe6$var$aliases = [
    "snd_settle_mode",
    "rcv_settle_mode",
    "source",
    "target",
    "max_message_size",
    "offered_capabilities",
    "desired_capabilities",
    "properties"
];
function $dfcbcc836d886fe6$var$remote_property_shortcut(name) {
    return function() {
        return this.remote.attach ? this.remote.attach[name] : undefined;
    };
}
$dfcbcc836d886fe6$var$link.init = function(session, name, local_handle, opts, is_receiver) {
    this.session = session;
    this.connection = session.connection;
    this.name = name;
    this.options = opts === undefined ? {} : opts;
    this.state = new $f4a171f5da3e65d3$exports();
    this.issue_flow = false;
    this.local = {
        "handle": local_handle
    };
    this.local.attach = $c5287fda22d925cb$exports.attach({
        "handle": local_handle,
        "name": name,
        role: is_receiver
    });
    for(var field in this.local.attach)if (!$dfcbcc836d886fe6$var$is_internal(field) && this.options[field] !== undefined) this.local.attach[field] = this.options[field];
    this.local.detach = $c5287fda22d925cb$exports.detach({
        "handle": local_handle,
        "closed": true
    });
    this.remote = {
        "handle": undefined
    };
    this.delivery_count = 0;
    this.credit = 0;
    this.observers = new $dfcbcc836d886fe6$require$EventEmitter();
    var self = this;
    $dfcbcc836d886fe6$var$aliases.forEach(function(alias) {
        Object.defineProperty(self, alias, {
            get: $dfcbcc836d886fe6$var$remote_property_shortcut(alias)
        });
    });
    Object.defineProperty(this, "error", {
        get: function() {
            return this.remote.detach ? this.remote.detach.error : undefined;
        }
    });
};
$dfcbcc836d886fe6$var$link._disconnect = function() {
    this.state.disconnected();
    if (!this.state.was_open) this.remove();
};
$dfcbcc836d886fe6$var$link._reconnect = function() {
    this.state.reconnect();
    this.remote = {
        "handle": undefined
    };
    this.delivery_count = 0;
    this.credit = 0;
};
$dfcbcc836d886fe6$var$link.has_credit = function() {
    return this.credit > 0;
};
$dfcbcc836d886fe6$var$link.is_receiver = function() {
    return this.local.attach.role;
};
$dfcbcc836d886fe6$var$link.is_sender = function() {
    return !this.is_receiver();
};
$dfcbcc836d886fe6$var$link._context = function(c) {
    var context = c ? c : {};
    if (this.is_receiver()) context.receiver = this;
    else context.sender = this;
    return this.session._context(context);
};
$dfcbcc836d886fe6$var$link.get_option = function(name, default_value) {
    if (this.options[name] !== undefined) return this.options[name];
    else return this.session.get_option(name, default_value);
};
var $dfcbcc836d886fe6$var$Sender = function(session, name, local_handle, opts) {
    this.init(session, name, local_handle, opts, false);
    this._draining = false;
    this._drained = false;
    this.local.attach.initial_delivery_count = 0;
    this.tag = 0;
    if (this.get_option("autosettle", true)) this.observers.on("settled", $dfcbcc836d886fe6$var$auto_settle);
    var sender = this;
    if (this.get_option("treat_modified_as_released", true)) this.observers.on("modified", function(context) {
        sender.dispatch("released", context);
    });
};
$dfcbcc836d886fe6$var$Sender.prototype = Object.create($dfcbcc836d886fe6$var$link);
$dfcbcc836d886fe6$var$Sender.prototype.constructor = $dfcbcc836d886fe6$var$Sender;
$dfcbcc836d886fe6$var$Sender.prototype._get_drain = function() {
    if (this._draining && this._drained && this.credit) {
        while(this.credit){
            ++this.delivery_count;
            --this.credit;
        }
        return true;
    } else return false;
};
$dfcbcc836d886fe6$var$Sender.prototype.set_drained = function(drained) {
    this._drained = drained;
    if (this._draining && this._drained) this.issue_flow = true;
};
$dfcbcc836d886fe6$var$Sender.prototype.next_tag = function() {
    return $dfcbcc836d886fe6$require$Buffer.from(new String(this.tag++));
};
$dfcbcc836d886fe6$var$Sender.prototype.sendable = function() {
    return Boolean(this.credit && this.session.outgoing.available());
};
$dfcbcc836d886fe6$var$Sender.prototype.on_flow = function(frame) {
    var flow = frame.performative;
    this.credit = flow.delivery_count + flow.link_credit - this.delivery_count;
    this._draining = flow.drain;
    this._drained = this.credit > 0;
    if (this.is_open()) {
        this.dispatch("sender_flow", this._context());
        if (this._draining) this.dispatch("sender_draining", this._context());
        if (this.sendable()) this.dispatch("sendable", this._context());
    }
};
$dfcbcc836d886fe6$var$Sender.prototype.on_transfer = function() {
    throw Error("got transfer on sending link");
};
$dfcbcc836d886fe6$var$Sender.prototype.send = function(msg, tag, format) {
    var payload = format === undefined ? $bdeu2.encode(msg) : msg;
    var delivery = this.session.send(this, tag ? tag : this.next_tag(), payload, format);
    if (this.local.attach.snd_settle_mode === 1) delivery.settled = true;
    return delivery;
};
var $dfcbcc836d886fe6$var$Receiver = function(session, name, local_handle, opts) {
    this.init(session, name, local_handle, opts, true);
    this.drain = false;
    this.set_credit_window(this.get_option("credit_window", 1000));
    if (this.get_option("autoaccept", true)) this.observers.on("message", $dfcbcc836d886fe6$var$auto_accept);
    if (this.local.attach.rcv_settle_mode === 1 && this.get_option("autosettle", true)) this.observers.on("settled", $dfcbcc836d886fe6$var$auto_settle);
};
$dfcbcc836d886fe6$var$Receiver.prototype = Object.create($dfcbcc836d886fe6$var$link);
$dfcbcc836d886fe6$var$Receiver.prototype.constructor = $dfcbcc836d886fe6$var$Receiver;
$dfcbcc836d886fe6$var$Receiver.prototype.on_flow = function(frame) {
    this.dispatch("receiver_flow", this._context());
    if (frame.performative.drain) {
        this.credit = frame.performative.link_credit;
        this.delivery_count = frame.performative.delivery_count;
        if (frame.performative.link_credit > 0) console.error("ERROR: received flow with drain set, but non zero credit");
        else this.dispatch("receiver_drained", this._context());
    }
};
$dfcbcc836d886fe6$var$Receiver.prototype.flow = function(credit) {
    if (credit > 0) {
        this.credit += credit;
        this.issue_flow = true;
        this.connection._register();
    }
};
$dfcbcc836d886fe6$var$Receiver.prototype.drain_credit = function() {
    this.drain = true;
    this.issue_flow = true;
    this.connection._register();
};
$dfcbcc836d886fe6$var$Receiver.prototype.add_credit = $dfcbcc836d886fe6$var$Receiver.prototype.flow; //alias
$dfcbcc836d886fe6$var$Receiver.prototype._get_drain = function() {
    return this.drain;
};
$dfcbcc836d886fe6$var$Receiver.prototype.set_credit_window = function(credit_window) {
    if (credit_window > 0) {
        var flow_controller = new $dfcbcc836d886fe6$var$FlowController(credit_window);
        var listener = flow_controller.update.bind(flow_controller);
        this.observers.on("message", listener);
        this.observers.on("receiver_open", listener);
    }
};
$dfcbcc836d886fe6$exports = {
    "Sender": $dfcbcc836d886fe6$var$Sender,
    "Receiver": $dfcbcc836d886fe6$var$Receiver
};



var $5Avaz = parcelRequire("5Avaz");

var $bdeu2 = parcelRequire("bdeu2");

var $2Kc0N = parcelRequire("2Kc0N");

var $3hLdt = parcelRequire("3hLdt");


var $93cc2cd2cca3866c$require$EventEmitter = $ac8e2c1b8bfc4b37$exports.EventEmitter;
function $93cc2cd2cca3866c$var$SessionError(message, condition, session) {
    Error.call(this);
    Error.captureStackTrace(this, this.constructor);
    this.message = message;
    this.condition = condition;
    this.description = message;
    Object.defineProperty(this, "session", {
        value: session
    });
}

(parcelRequire("5uO90")).inherits($93cc2cd2cca3866c$var$SessionError, Error);
var $93cc2cd2cca3866c$var$CircularBuffer = function(capacity) {
    this.capacity = capacity;
    this.size = 0;
    this.head = 0;
    this.tail = 0;
    this.entries = [];
};
$93cc2cd2cca3866c$var$CircularBuffer.prototype.available = function() {
    return this.capacity - this.size;
};
$93cc2cd2cca3866c$var$CircularBuffer.prototype.push = function(o) {
    if (this.size < this.capacity) {
        this.entries[this.tail] = o;
        this.tail = (this.tail + 1) % this.capacity;
        this.size++;
    } else throw Error("circular buffer overflow: head=" + this.head + " tail=" + this.tail + " size=" + this.size + " capacity=" + this.capacity);
};
$93cc2cd2cca3866c$var$CircularBuffer.prototype.pop_if = function(f) {
    var count = 0;
    while(this.size && f(this.entries[this.head])){
        this.entries[this.head] = undefined;
        this.head = (this.head + 1) % this.capacity;
        this.size--;
        count++;
    }
    return count;
};
$93cc2cd2cca3866c$var$CircularBuffer.prototype.by_id = function(id) {
    if (this.size > 0) {
        var gap = id - this.entries[this.head].id;
        if (gap < this.size) return this.entries[(this.head + gap) % this.capacity];
    }
    return undefined;
};
$93cc2cd2cca3866c$var$CircularBuffer.prototype.get_head = function() {
    return this.size > 0 ? this.entries[this.head] : undefined;
};
$93cc2cd2cca3866c$var$CircularBuffer.prototype.get_tail = function() {
    return this.size > 0 ? this.entries[(this.head + this.size - 1) % this.capacity] : undefined;
};
function $93cc2cd2cca3866c$var$write_dispositions(deliveries) {
    var first, last, next_id, i, delivery;
    for(i = 0; i < deliveries.length; i++){
        delivery = deliveries[i];
        if (first === undefined) {
            first = delivery;
            last = delivery;
            next_id = delivery.id;
        }
        if (first !== last && !$bdeu2.are_outcomes_equivalent(last.state, delivery.state) || last.settled !== delivery.settled || next_id !== delivery.id) {
            first.link.session.output($c5287fda22d925cb$exports.disposition({
                "role": first.link.is_receiver(),
                "first": first.id,
                "last": last.id,
                "state": first.state,
                "settled": first.settled
            }));
            first = delivery;
            last = delivery;
            next_id = delivery.id;
        } else {
            if (last.id !== delivery.id) last = delivery;
            next_id++;
        }
    }
    if (first !== undefined && last !== undefined) first.link.session.output($c5287fda22d925cb$exports.disposition({
        "role": first.link.is_receiver(),
        "first": first.id,
        "last": last.id,
        "state": first.state,
        "settled": first.settled
    }));
}
var $93cc2cd2cca3866c$var$Outgoing = function(connection) {
    /* TODO: make size configurable? */ this.deliveries = new $93cc2cd2cca3866c$var$CircularBuffer(2048);
    this.updated = [];
    this.pending_dispositions = [];
    this.next_delivery_id = 0;
    this.next_pending_delivery = 0;
    this.next_transfer_id = 0;
    this.window = $2Kc0N.MAX_UINT;
    this.remote_next_transfer_id = undefined;
    this.remote_window = undefined;
    this.connection = connection;
};
$93cc2cd2cca3866c$var$Outgoing.prototype.available = function() {
    return this.deliveries.available();
};
$93cc2cd2cca3866c$var$Outgoing.prototype.compute_max_payload = function(tag) {
    if (this.connection.max_frame_size) return this.connection.max_frame_size - (50 + tag.length);
    else return undefined;
};
$93cc2cd2cca3866c$var$Outgoing.prototype.send = function(sender, tag, data, format) {
    var fragments = [];
    var max_payload = this.compute_max_payload(tag);
    if (max_payload && data.length > max_payload) {
        var start = 0;
        while(start < data.length){
            var end = Math.min(start + max_payload, data.length);
            fragments.push(data.slice(start, end));
            start = end;
        }
    } else fragments.push(data);
    var d = {
        "id": this.next_delivery_id++,
        "tag": tag,
        "link": sender,
        "data": fragments,
        "format": format ? format : 0,
        "sent": false,
        "settled": false,
        "state": undefined,
        "remote_settled": false,
        "remote_state": undefined
    };
    var self = this;
    d.update = function(settled, state) {
        self.update(d, settled, state);
    };
    this.deliveries.push(d);
    return d;
};
$93cc2cd2cca3866c$var$Outgoing.prototype.on_begin = function(fields) {
    this.remote_window = fields.incoming_window;
};
$93cc2cd2cca3866c$var$Outgoing.prototype.on_flow = function(fields) {
    this.remote_next_transfer_id = fields.next_incoming_id;
    this.remote_window = fields.incoming_window;
};
$93cc2cd2cca3866c$var$Outgoing.prototype.on_disposition = function(fields) {
    var last = fields.last ? fields.last : fields.first;
    for(var i = fields.first; i <= last; i++){
        var d = this.deliveries.by_id(i);
        if (d && !d.remote_settled) {
            var updated = false;
            if (fields.settled) {
                d.remote_settled = fields.settled;
                updated = true;
            }
            if (fields.state && fields.state !== d.remote_state) {
                d.remote_state = $bdeu2.unwrap_outcome(fields.state);
                updated = true;
            }
            if (updated) this.updated.push(d);
        }
    }
};
$93cc2cd2cca3866c$var$Outgoing.prototype.update = function(delivery, settled, state) {
    if (delivery) {
        delivery.settled = settled;
        if (state !== undefined) delivery.state = state;
        if (!delivery.remote_settled) this.pending_dispositions.push(delivery);
        delivery.link.connection._register();
    }
};
$93cc2cd2cca3866c$var$Outgoing.prototype.transfer_window = function() {
    if (this.remote_window) return this.remote_window - (this.next_transfer_id - this.remote_next_transfer_id);
    else return 0;
};
$93cc2cd2cca3866c$var$Outgoing.prototype.process = function() {
    var d;
    // send pending deliveries for which there is credit:
    while(this.next_pending_delivery < this.next_delivery_id){
        d = this.deliveries.by_id(this.next_pending_delivery);
        if (d) {
            if (d.link.has_credit()) {
                if (this.transfer_window() >= d.data.length) {
                    this.window -= d.data.length;
                    for(var i = 0; i < d.data.length; i++){
                        this.next_transfer_id++;
                        var more = i + 1 < d.data.length;
                        var transfer = $c5287fda22d925cb$exports.transfer({
                            "handle": d.link.local.handle,
                            "message_format": d.format,
                            "delivery_id": d.id,
                            "delivery_tag": d.tag,
                            "settled": d.settled,
                            "more": more
                        });
                        d.link.session.output(transfer, d.data[i]);
                        if (d.settled) d.remote_settled = true; //if sending presettled, it can now be cleaned up
                    }
                    d.link.credit--;
                    d.link.delivery_count++;
                    this.next_pending_delivery++;
                } else {
                    $5Avaz.flow("[%s] Incoming window of peer preventing sending further transfers: remote_window=%d, remote_next_transfer_id=%d, next_transfer_id=%d", this.connection.options.id, this.remote_window, this.remote_next_transfer_id, this.next_transfer_id);
                    break;
                }
            } else {
                $5Avaz.flow("[%s] Link has no credit", this.connection.options.id);
                break;
            }
        } else {
            console.error("ERROR: Next pending delivery not found: " + this.next_pending_delivery);
            break;
        }
    }
    // notify application of any updated deliveries:
    for(var i = 0; i < this.updated.length; i++){
        d = this.updated[i];
        if (d.remote_state && d.remote_state.constructor.composite_type) d.link.dispatch(d.remote_state.constructor.composite_type, d.link._context({
            "delivery": d
        }));
        if (d.remote_settled) d.link.dispatch("settled", d.link._context({
            "delivery": d
        }));
    }
    this.updated = [];
    if (this.pending_dispositions.length) {
        $93cc2cd2cca3866c$var$write_dispositions(this.pending_dispositions);
        this.pending_dispositions = [];
    }
    // remove any fully settled deliveries:
    this.deliveries.pop_if(function(d) {
        return d.settled && d.remote_settled;
    });
};
var $93cc2cd2cca3866c$var$Incoming = function() {
    this.deliveries = new $93cc2cd2cca3866c$var$CircularBuffer(2048 /*TODO: configurable?*/ );
    this.updated = [];
    this.next_transfer_id = 0;
    this.next_delivery_id = undefined;
    Object.defineProperty(this, "window", {
        get: function() {
            return this.deliveries.available();
        }
    });
    this.remote_next_transfer_id = undefined;
    this.remote_window = undefined;
    this.max_transfer_id = this.next_transfer_id + this.window;
};
$93cc2cd2cca3866c$var$Incoming.prototype.update = function(delivery, settled, state) {
    if (delivery) {
        delivery.settled = settled;
        if (state !== undefined) delivery.state = state;
        if (!delivery.remote_settled) this.updated.push(delivery);
        delivery.link.connection._register();
    }
};
$93cc2cd2cca3866c$var$Incoming.prototype.on_transfer = function(frame, receiver) {
    this.next_transfer_id++;
    if (receiver.is_remote_open()) {
        if (this.next_delivery_id === undefined) this.next_delivery_id = frame.performative.delivery_id;
        var current;
        var data;
        if (receiver._incomplete) {
            current = receiver._incomplete;
            if ($3hLdt.is_defined(frame.performative.delivery_id) && current.id !== frame.performative.delivery_id) throw Error("frame sequence error: delivery " + current.id + " not complete, got " + frame.performative.delivery_id);
            if (frame.payload) data = $93cc2cd2cca3866c$require$Buffer.concat([
                current.data,
                frame.payload
            ], current.data.length + frame.payload.length);
            else data = current.data;
        } else if (this.next_delivery_id === frame.performative.delivery_id) {
            current = {
                "id": frame.performative.delivery_id,
                "tag": frame.performative.delivery_tag,
                "format": frame.performative.message_format,
                "link": receiver,
                "settled": false,
                "state": undefined,
                "remote_settled": frame.performative.settled === undefined ? false : frame.performative.settled,
                "remote_state": frame.performative.state
            };
            var self = this;
            current.update = function(settled, state) {
                var settled_ = settled;
                if (settled_ === undefined) settled_ = receiver.local.attach.rcv_settle_mode !== 1;
                self.update(current, settled_, state);
            };
            current.accept = function() {
                this.update(undefined, $bdeu2.accepted().described());
            };
            current.release = function(params) {
                if (params) this.update(undefined, $bdeu2.modified(params).described());
                else this.update(undefined, $bdeu2.released().described());
            };
            current.reject = function(error) {
                this.update(undefined, $bdeu2.rejected({
                    "error": error
                }).described());
            };
            current.modified = function(params) {
                this.update(undefined, $bdeu2.modified(params).described());
            };
            this.deliveries.push(current);
            this.next_delivery_id++;
            data = frame.payload;
        } else //TODO: better error handling
        throw Error("frame sequence error: expected " + this.next_delivery_id + ", got " + frame.performative.delivery_id);
        current.incomplete = frame.performative.more;
        if (current.incomplete) {
            receiver._incomplete = current;
            current.data = data;
        } else {
            receiver._incomplete = undefined;
            if (receiver.credit > 0) receiver.credit--;
            else console.error("Received transfer when credit was %d", receiver.credit);
            receiver.delivery_count++;
            var msgctxt = current.format === 0 ? {
                "message": $bdeu2.decode(data),
                "delivery": current
            } : {
                "message": data,
                "delivery": current,
                "format": current.format
            };
            receiver.dispatch("message", receiver._context(msgctxt));
        }
    } else throw Error("transfer after detach");
};
$93cc2cd2cca3866c$var$Incoming.prototype.process = function(session) {
    if (this.updated.length > 0) {
        $93cc2cd2cca3866c$var$write_dispositions(this.updated);
        this.updated = [];
    }
    // remove any fully settled deliveries:
    this.deliveries.pop_if(function(d) {
        return d.settled;
    });
    if (this.max_transfer_id - this.next_transfer_id < this.window / 2) session._write_flow();
};
$93cc2cd2cca3866c$var$Incoming.prototype.on_begin = function(fields) {
    this.remote_window = fields.outgoing_window;
    this.remote_next_transfer_id = fields.next_outgoing_id;
};
$93cc2cd2cca3866c$var$Incoming.prototype.on_flow = function(fields) {
    this.remote_next_transfer_id = fields.next_outgoing_id;
    this.remote_window = fields.outgoing_window;
};
$93cc2cd2cca3866c$var$Incoming.prototype.on_disposition = function(fields) {
    var last = fields.last ? fields.last : fields.first;
    for(var i = fields.first; i <= last; i++){
        var d = this.deliveries.by_id(i);
        if (d && !d.remote_settled) {
            if (fields.state && fields.state !== d.remote_state) d.remote_state = $bdeu2.unwrap_outcome(fields.state);
            if (fields.settled) {
                d.remote_settled = fields.settled;
                d.link.dispatch("settled", d.link._context({
                    "delivery": d
                }));
            }
        }
    }
};
var $93cc2cd2cca3866c$var$Session = function(connection, local_channel) {
    this.connection = connection;
    this.outgoing = new $93cc2cd2cca3866c$var$Outgoing(connection);
    this.incoming = new $93cc2cd2cca3866c$var$Incoming();
    this.state = new $f4a171f5da3e65d3$exports();
    this.local = {
        "channel": local_channel,
        "handles": {}
    };
    this.local.begin = $c5287fda22d925cb$exports.begin({
        next_outgoing_id: this.outgoing.next_transfer_id,
        incoming_window: this.incoming.window,
        outgoing_window: this.outgoing.window
    });
    this.local.end = $c5287fda22d925cb$exports.end();
    this.remote = {
        "handles": {}
    };
    this.links = {}; // map by name
    this.options = {};
    Object.defineProperty(this, "error", {
        get: function() {
            return this.remote.end ? this.remote.end.error : undefined;
        }
    });
    this.observers = new $93cc2cd2cca3866c$require$EventEmitter();
};
$93cc2cd2cca3866c$var$Session.prototype = Object.create($93cc2cd2cca3866c$require$EventEmitter.prototype);
$93cc2cd2cca3866c$var$Session.prototype.constructor = $93cc2cd2cca3866c$var$Session;
$93cc2cd2cca3866c$var$Session.prototype._disconnect = function() {
    this.state.disconnected();
    for(var l in this.links)this.links[l]._disconnect();
    if (!this.state.was_open) this.remove();
};
$93cc2cd2cca3866c$var$Session.prototype._reconnect = function() {
    this.state.reconnect();
    this.outgoing = new $93cc2cd2cca3866c$var$Outgoing(this.connection);
    this.incoming = new $93cc2cd2cca3866c$var$Incoming();
    this.remote = {
        "handles": {}
    };
    for(var l in this.links)this.links[l]._reconnect();
};
$93cc2cd2cca3866c$var$Session.prototype.dispatch = function(name) {
    $5Avaz.events("[%s] Session got event: %s", this.connection.options.id, name);
    $93cc2cd2cca3866c$require$EventEmitter.prototype.emit.apply(this.observers, arguments);
    if (this.listeners(name).length) {
        $93cc2cd2cca3866c$require$EventEmitter.prototype.emit.apply(this, arguments);
        return true;
    } else return this.connection.dispatch.apply(this.connection, arguments);
};
$93cc2cd2cca3866c$var$Session.prototype.output = function(frame, payload) {
    this.connection._write_frame(this.local.channel, frame, payload);
};
$93cc2cd2cca3866c$var$Session.prototype.create_sender = function(name, opts) {
    if (!opts) opts = this.get_option("sender_options", {});
    return this.create_link(name, $dfcbcc836d886fe6$exports.Sender, opts);
};
$93cc2cd2cca3866c$var$Session.prototype.create_receiver = function(name, opts) {
    if (!opts) opts = this.get_option("receiver_options", {});
    return this.create_link(name, $dfcbcc836d886fe6$exports.Receiver, opts);
};
function $93cc2cd2cca3866c$var$merge(defaults, specific) {
    for(var f in specific)if (f === "properties" && defaults.properties) $93cc2cd2cca3866c$var$merge(defaults.properties, specific.properties);
    else defaults[f] = specific[f];
}
function $93cc2cd2cca3866c$var$attach(factory, args, remote_terminus, default_args) {
    var opts = Object.create(default_args || {});
    if (typeof args === "string") opts[remote_terminus] = args;
    else if (args) $93cc2cd2cca3866c$var$merge(opts, args);
    if (!opts.name) opts.name = $3hLdt.generate_uuid();
    var l = factory(opts.name, opts);
    for(var t in {
        "source": 0,
        "target": 0
    })if (opts[t]) {
        if (typeof opts[t] === "string") opts[t] = {
            "address": opts[t]
        };
        l["set_" + t](opts[t]);
    }
    if (l.is_sender() && opts.source === undefined) opts.source = l.set_source({});
    if (l.is_receiver() && opts.target === undefined) opts.target = l.set_target({});
    l.attach();
    return l;
}
$93cc2cd2cca3866c$var$Session.prototype.get_option = function(name, default_value) {
    if (this.options[name] !== undefined) return this.options[name];
    else return this.connection.get_option(name, default_value);
};
$93cc2cd2cca3866c$var$Session.prototype.attach_sender = function(args) {
    return $93cc2cd2cca3866c$var$attach(this.create_sender.bind(this), args, "target", this.get_option("sender_options", {}));
};
$93cc2cd2cca3866c$var$Session.prototype.open_sender = $93cc2cd2cca3866c$var$Session.prototype.attach_sender; //alias
$93cc2cd2cca3866c$var$Session.prototype.attach_receiver = function(args) {
    return $93cc2cd2cca3866c$var$attach(this.create_receiver.bind(this), args, "source", this.get_option("receiver_options", {}));
};
$93cc2cd2cca3866c$var$Session.prototype.open_receiver = $93cc2cd2cca3866c$var$Session.prototype.attach_receiver; //alias
$93cc2cd2cca3866c$var$Session.prototype.find_sender = function(filter) {
    return this.find_link($3hLdt.sender_filter(filter));
};
$93cc2cd2cca3866c$var$Session.prototype.find_receiver = function(filter) {
    return this.find_link($3hLdt.receiver_filter(filter));
};
$93cc2cd2cca3866c$var$Session.prototype.find_link = function(filter) {
    for(var name in this.links){
        var link = this.links[name];
        if (filter(link)) return link;
    }
    return undefined;
};
$93cc2cd2cca3866c$var$Session.prototype.each_receiver = function(action, filter) {
    this.each_link(action, $3hLdt.receiver_filter(filter));
};
$93cc2cd2cca3866c$var$Session.prototype.each_sender = function(action, filter) {
    this.each_link(action, $3hLdt.sender_filter(filter));
};
$93cc2cd2cca3866c$var$Session.prototype.each_link = function(action, filter) {
    for(var name in this.links){
        var link = this.links[name];
        if (filter === undefined || filter(link)) action(link);
    }
};
$93cc2cd2cca3866c$var$Session.prototype.create_link = function(name, constructor, opts) {
    var i = 0;
    while(this.local.handles[i])i++;
    var l = new constructor(this, name, i, opts);
    this.links[name] = l;
    this.local.handles[i] = l;
    return l;
};
$93cc2cd2cca3866c$var$Session.prototype.begin = function() {
    if (this.state.open()) this.connection._register();
};
$93cc2cd2cca3866c$var$Session.prototype.open = $93cc2cd2cca3866c$var$Session.prototype.begin;
$93cc2cd2cca3866c$var$Session.prototype.end = function(error) {
    if (error) this.local.end.error = error;
    if (this.state.close()) this.connection._register();
};
$93cc2cd2cca3866c$var$Session.prototype.close = $93cc2cd2cca3866c$var$Session.prototype.end;
$93cc2cd2cca3866c$var$Session.prototype.is_open = function() {
    return this.connection.is_open() && this.state.is_open();
};
$93cc2cd2cca3866c$var$Session.prototype.is_remote_open = function() {
    return this.connection.is_remote_open() && this.state.remote_open;
};
$93cc2cd2cca3866c$var$Session.prototype.is_itself_closed = function() {
    return this.state.is_closed();
};
$93cc2cd2cca3866c$var$Session.prototype.is_closed = function() {
    return this.connection.is_closed() || this.is_itself_closed();
};
function $93cc2cd2cca3866c$var$notify_sendable(sender) {
    sender.dispatch("sendable", sender._context());
}
function $93cc2cd2cca3866c$var$is_sender_sendable(sender) {
    return sender.is_open() && sender.sendable();
}
$93cc2cd2cca3866c$var$Session.prototype._process = function() {
    do {
        if (this.state.need_open()) this.output(this.local.begin);
        var was_blocked = this.outgoing.deliveries.available() === 0;
        this.outgoing.process();
        if (was_blocked && this.outgoing.deliveries.available()) this.each_sender($93cc2cd2cca3866c$var$notify_sendable, $93cc2cd2cca3866c$var$is_sender_sendable);
        this.incoming.process(this);
        for(var k in this.links)this.links[k]._process();
        if (this.state.need_close()) this.output(this.local.end);
    }while (!this.state.has_settled());
};
$93cc2cd2cca3866c$var$Session.prototype.send = function(sender, tag, data, format) {
    var d = this.outgoing.send(sender, tag, data, format);
    this.connection._register();
    return d;
};
$93cc2cd2cca3866c$var$Session.prototype._write_flow = function(link) {
    var fields = {
        "next_incoming_id": this.incoming.next_transfer_id,
        "incoming_window": this.incoming.window,
        "next_outgoing_id": this.outgoing.next_transfer_id,
        "outgoing_window": this.outgoing.window
    };
    this.incoming.max_transfer_id = fields.next_incoming_id + fields.incoming_window;
    if (link) {
        if (link._get_drain()) fields.drain = true;
        fields.delivery_count = link.delivery_count;
        fields.handle = link.local.handle;
        fields.link_credit = link.credit;
    }
    this.output($c5287fda22d925cb$exports.flow(fields));
};
$93cc2cd2cca3866c$var$Session.prototype.on_begin = function(frame) {
    if (this.state.remote_opened()) {
        if (!this.remote.channel) this.remote.channel = frame.channel;
        this.remote.begin = frame.performative;
        this.outgoing.on_begin(frame.performative);
        this.incoming.on_begin(frame.performative);
        this.open();
        this.dispatch("session_open", this._context());
    } else throw Error("Begin already received");
};
$93cc2cd2cca3866c$var$Session.prototype.on_end = function(frame) {
    if (this.state.remote_closed()) {
        this.remote.end = frame.performative;
        var error = this.remote.end.error;
        if (error) {
            var handled = this.dispatch("session_error", this._context());
            handled = this.dispatch("session_close", this._context()) || handled;
            if (!handled) $93cc2cd2cca3866c$require$EventEmitter.prototype.emit.call(this.connection.container, "error", new $93cc2cd2cca3866c$var$SessionError(error.description, error.condition, this));
        } else this.dispatch("session_close", this._context());
        var self = this;
        var token = this.state.mark();
        $gDDBB.nextTick(function() {
            if (self.state.marker === token) {
                self.close();
                $gDDBB.nextTick(function() {
                    self.remove();
                });
            }
        });
    } else throw Error("End already received");
};
$93cc2cd2cca3866c$var$Session.prototype.on_attach = function(frame) {
    var name = frame.performative.name;
    var link = this.links[name];
    if (!link) // if role is true, peer is receiver, so we are sender
    link = frame.performative.role ? this.create_sender(name) : this.create_receiver(name);
    this.remote.handles[frame.performative.handle] = link;
    link.on_attach(frame);
    link.remote.attach = frame.performative;
};
$93cc2cd2cca3866c$var$Session.prototype.on_disposition = function(frame) {
    if (frame.performative.role) {
        $5Avaz.events("[%s] Received disposition for outgoing transfers", this.connection.options.id);
        this.outgoing.on_disposition(frame.performative);
    } else {
        $5Avaz.events("[%s] Received disposition for incoming transfers", this.connection.options.id);
        this.incoming.on_disposition(frame.performative);
    }
    this.connection._register();
};
$93cc2cd2cca3866c$var$Session.prototype.on_flow = function(frame) {
    this.outgoing.on_flow(frame.performative);
    this.incoming.on_flow(frame.performative);
    if ($3hLdt.is_defined(frame.performative.handle)) this._get_link(frame).on_flow(frame);
    this.connection._register();
};
$93cc2cd2cca3866c$var$Session.prototype._context = function(c) {
    var context = c ? c : {};
    context.session = this;
    return this.connection._context(context);
};
$93cc2cd2cca3866c$var$Session.prototype._get_link = function(frame) {
    var handle = frame.performative.handle;
    var link = this.remote.handles[handle];
    if (!link) throw Error("Invalid handle " + handle);
    return link;
};
$93cc2cd2cca3866c$var$Session.prototype.on_detach = function(frame) {
    this._get_link(frame).on_detach(frame);
};
$93cc2cd2cca3866c$var$Session.prototype.remove_link = function(link) {
    delete this.remote.handles[link.remote.handle];
    delete this.local.handles[link.local.handle];
    delete this.links[link.name];
};
/**
 * This forcibly removes the session from the parent connection. It
 * should not be called for a link on an active connection, where
 * close() should be used instead.
 */ $93cc2cd2cca3866c$var$Session.prototype.remove = function() {
    this.connection.remove_session(this);
};
$93cc2cd2cca3866c$var$Session.prototype.on_transfer = function(frame) {
    this.incoming.on_transfer(frame, this._get_link(frame));
};
$93cc2cd2cca3866c$exports = $93cc2cd2cca3866c$var$Session;



var $2276b6e7a55844a8$exports = {};
"use strict";


var $f1eb388ce2dd785d$export$edf525f30916fbb8;
var $f1eb388ce2dd785d$export$640106f6dc7d2706;
var $f1eb388ce2dd785d$export$3ea386628068cf62;
var $f1eb388ce2dd785d$export$749d472264fad440;
var $f1eb388ce2dd785d$export$8b931a48d9488767;
var $f1eb388ce2dd785d$export$9123f37609399513;
var $f1eb388ce2dd785d$export$9b60beb643db4d69;
var $f1eb388ce2dd785d$export$bf9fb029d174d554;
var $f1eb388ce2dd785d$export$23d3fad09dc44362;
var $f1eb388ce2dd785d$export$d2f3c2f7e0c7dcf5;
var $f1eb388ce2dd785d$export$3bf7c33313eba0fe;
var $f1eb388ce2dd785d$export$7925d89f138dad5b;
var $f1eb388ce2dd785d$export$722a64dea1b767dc;
var $f1eb388ce2dd785d$export$9e6c06a7d47f9af7;
var $f1eb388ce2dd785d$export$6b76988456c0292f;
var $f1eb388ce2dd785d$export$266d3b9babd1fc45;
var $f1eb388ce2dd785d$export$c1d46b5ea6262c0b;
$f1eb388ce2dd785d$export$edf525f30916fbb8 = function() {
    return "LE";
};
$f1eb388ce2dd785d$export$640106f6dc7d2706 = function() {
    if (typeof location !== "undefined") return location.hostname;
    else return "";
};
$f1eb388ce2dd785d$export$3ea386628068cf62 = function() {
    return [];
};
$f1eb388ce2dd785d$export$749d472264fad440 = function() {
    return 0;
};
$f1eb388ce2dd785d$export$8b931a48d9488767 = function() {
    return Number.MAX_VALUE;
};
$f1eb388ce2dd785d$export$9123f37609399513 = function() {
    return Number.MAX_VALUE;
};
$f1eb388ce2dd785d$export$9b60beb643db4d69 = function() {
    return [];
};
$f1eb388ce2dd785d$export$bf9fb029d174d554 = function() {
    return "Browser";
};
$f1eb388ce2dd785d$export$23d3fad09dc44362 = function() {
    if (typeof navigator !== "undefined") return navigator.appVersion;
    return "";
};
$f1eb388ce2dd785d$export$d2f3c2f7e0c7dcf5 = $f1eb388ce2dd785d$export$3bf7c33313eba0fe = function() {
    return {};
};
$f1eb388ce2dd785d$export$7925d89f138dad5b = function() {
    return "javascript";
};
$f1eb388ce2dd785d$export$722a64dea1b767dc = function() {
    return "browser";
};
$f1eb388ce2dd785d$export$9e6c06a7d47f9af7 = $f1eb388ce2dd785d$export$6b76988456c0292f = function() {
    return "/tmp";
};
$f1eb388ce2dd785d$export$266d3b9babd1fc45 = "\n";
$f1eb388ce2dd785d$export$c1d46b5ea6262c0b = function() {
    return "/";
};


var $70472df4e7fb8a9b$exports = {};
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var $gDDBB = parcelRequire("gDDBB");
"use strict";
function $70472df4e7fb8a9b$var$assertPath(path) {
    if (typeof path !== "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
}
// Resolves . and .. elements in a path with directory names
function $70472df4e7fb8a9b$var$normalizeStringPosix(path, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for(var i = 0; i <= path.length; ++i){
        if (i < path.length) code = path.charCodeAt(i);
        else if (code === 47 /*/*/ ) break;
        else code = 47 /*/*/ ;
        if (code === 47 /*/*/ ) {
            if (lastSlash === i - 1 || dots === 1) ;
            else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/  || res.charCodeAt(res.length - 2) !== 46 /*.*/ ) {
                    if (res.length > 2) {
                        var lastSlashIndex = res.lastIndexOf("/");
                        if (lastSlashIndex !== res.length - 1) {
                            if (lastSlashIndex === -1) {
                                res = "";
                                lastSegmentLength = 0;
                            } else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += "/..";
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += "/" + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 /*.*/  && dots !== -1) ++dots;
        else dots = -1;
    }
    return res;
}
function $70472df4e7fb8a9b$var$_format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
var $70472df4e7fb8a9b$var$posix = {
    // path.resolve([from ...], to)
    resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for(var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--){
            var path;
            if (i >= 0) path = arguments[i];
            else {
                if (cwd === undefined) cwd = $gDDBB.cwd();
                path = cwd;
            }
            $70472df4e7fb8a9b$var$assertPath(path);
            // Skip empty entries
            if (path.length === 0) continue;
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/ ;
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        // Normalize the path
        resolvedPath = $70472df4e7fb8a9b$var$normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
            if (resolvedPath.length > 0) return "/" + resolvedPath;
            else return "/";
        } else if (resolvedPath.length > 0) return resolvedPath;
        else return ".";
    },
    normalize: function normalize(path) {
        $70472df4e7fb8a9b$var$assertPath(path);
        if (path.length === 0) return ".";
        var isAbsolute = path.charCodeAt(0) === 47 /*/*/ ;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/ ;
        // Normalize the path
        path = $70472df4e7fb8a9b$var$normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute) path = ".";
        if (path.length > 0 && trailingSeparator) path += "/";
        if (isAbsolute) return "/" + path;
        return path;
    },
    isAbsolute: function isAbsolute(path) {
        $70472df4e7fb8a9b$var$assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47 /*/*/ ;
    },
    join: function join() {
        if (arguments.length === 0) return ".";
        var joined;
        for(var i = 0; i < arguments.length; ++i){
            var arg = arguments[i];
            $70472df4e7fb8a9b$var$assertPath(arg);
            if (arg.length > 0) {
                if (joined === undefined) joined = arg;
                else joined += "/" + arg;
            }
        }
        if (joined === undefined) return ".";
        return $70472df4e7fb8a9b$var$posix.normalize(joined);
    },
    relative: function relative(from, to) {
        $70472df4e7fb8a9b$var$assertPath(from);
        $70472df4e7fb8a9b$var$assertPath(to);
        if (from === to) return "";
        from = $70472df4e7fb8a9b$var$posix.resolve(from);
        to = $70472df4e7fb8a9b$var$posix.resolve(to);
        if (from === to) return "";
        // Trim any leading backslashes
        var fromStart = 1;
        for(; fromStart < from.length; ++fromStart){
            if (from.charCodeAt(fromStart) !== 47 /*/*/ ) break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        var toStart = 1;
        for(; toStart < to.length; ++toStart){
            if (to.charCodeAt(toStart) !== 47 /*/*/ ) break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for(; i <= length; ++i){
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === 47 /*/*/ ) // We get here if `from` is the exact base path for `to`.
                    // For example: from='/foo/bar'; to='/foo/bar/baz'
                    return to.slice(toStart + i + 1);
                    else if (i === 0) // We get here if `from` is the root
                    // For example: from='/'; to='/foo'
                    return to.slice(toStart + i);
                } else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === 47 /*/*/ ) // We get here if `to` is the exact base path for `from`.
                    // For example: from='/foo/bar/baz'; to='/foo/bar'
                    lastCommonSep = i;
                    else if (i === 0) // We get here if `to` is the root.
                    // For example: from='/foo'; to='/'
                    lastCommonSep = 0;
                }
                break;
            }
            var fromCode = from.charCodeAt(fromStart + i);
            var toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode) break;
            else if (fromCode === 47 /*/*/ ) lastCommonSep = i;
        }
        var out = "";
        // Generate the relative path based on the path difference between `to`
        // and `from`
        for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i)if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/ ) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
        else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === 47 /*/*/ ) ++toStart;
            return to.slice(toStart);
        }
    },
    _makeLong: function _makeLong(path) {
        return path;
    },
    dirname: function dirname(path) {
        $70472df4e7fb8a9b$var$assertPath(path);
        if (path.length === 0) return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47 /*/*/ ;
        var end = -1;
        var matchedSlash = true;
        for(var i = path.length - 1; i >= 1; --i){
            code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            } else // We saw the first non-path separator
            matchedSlash = false;
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path.slice(0, end);
    },
    basename: function basename(path, ext) {
        if (ext !== undefined && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        $70472df4e7fb8a9b$var$assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path) return "";
            var extIdx = ext.length - 1;
            var firstNonSlashEnd = -1;
            for(i = path.length - 1; i >= 0; --i){
                var code = path.charCodeAt(i);
                if (code === 47 /*/*/ ) // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) // We matched the extension, so mark this as the end of our path
                            // component
                            end = i;
                        } else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end) end = firstNonSlashEnd;
            else if (end === -1) end = path.length;
            return path.slice(start, end);
        } else {
            for(i = path.length - 1; i >= 0; --i){
                if (path.charCodeAt(i) === 47 /*/*/ ) // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1) return "";
            return path.slice(start, end);
        }
    },
    extname: function extname(path) {
        $70472df4e7fb8a9b$var$assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;
        for(var i = path.length - 1; i >= 0; --i){
            var code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46 /*.*/ ) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension
            preDotState = -1;
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) return "";
        return path.slice(startDot, end);
    },
    format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        return $70472df4e7fb8a9b$var$_format("/", pathObject);
    },
    parse: function parse(path) {
        $70472df4e7fb8a9b$var$assertPath(path);
        var ret = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (path.length === 0) return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47 /*/*/ ;
        var start;
        if (isAbsolute) {
            ret.root = "/";
            start = 1;
        } else start = 0;
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;
        // Get non-dir info
        for(; i >= start; --i){
            code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46 /*.*/ ) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension
            preDotState = -1;
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
                else ret.base = ret.name = path.slice(startPart, end);
            }
        } else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
            } else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
};
$70472df4e7fb8a9b$var$posix.posix = $70472df4e7fb8a9b$var$posix;
$70472df4e7fb8a9b$exports = $70472df4e7fb8a9b$var$posix;





var $b44b5920d931e66c$require$EventEmitter = $ac8e2c1b8bfc4b37$exports.EventEmitter;
var $b44b5920d931e66c$var$AMQP_PROTOCOL_ID = 0x00;
function $b44b5920d931e66c$var$find_connect_config() {
    var paths;
    paths = [
        $gDDBB.cwd(),
        $70472df4e7fb8a9b$exports.join($f1eb388ce2dd785d$export$c1d46b5ea6262c0b(), ".config/messaging"),
        "/etc/messaging"
    ].map(function(base) {
        return $70472df4e7fb8a9b$exports.join(base, "/connect.json");
    });
    for(var i = 0; i < paths.length; i++)if ($2276b6e7a55844a8$exports.existsSync(paths[i])) {
        var obj = JSON.parse($2276b6e7a55844a8$exports.readFileSync(paths[i], "utf8"));
        $5Avaz.config("using config from %s: %j", paths[i], obj);
        return obj;
    }
    return {};
}
function $b44b5920d931e66c$var$get_default_connect_config() {
    var config = $b44b5920d931e66c$var$find_connect_config();
    var options = {};
    if (config.scheme === "amqps") options.transport = "tls";
    if (config.host) options.host = config.host;
    if (config.port === "amqp") options.port = 5672;
    else if (config.port === "amqps") options.port = 5671;
    else options.port = config.port;
    if (!(config.sasl && config.sasl.enabled === false)) {
        if (config.user) options.username = config.user;
        else options.username = "anonymous";
        if (config.password) options.password = config.password;
        if (config.sasl_mechanisms) options.sasl_mechanisms = config.sasl_mechanisms;
    }
    if (config.tls) {
        if (config.tls.key) options.key = $2276b6e7a55844a8$exports.readFileSync(config.tls.key);
        if (config.tls.cert) options.cert = $2276b6e7a55844a8$exports.readFileSync(config.tls.cert);
        if (config.tls.ca) options.ca = [
            $2276b6e7a55844a8$exports.readFileSync(config.tls.ca)
        ];
        if (config.verify === false || config.tls.verify === false) options.rejectUnauthorized = false;
    }
    if (options.transport === "tls") options.servername = options.host;
    return options;
}
function $b44b5920d931e66c$var$get_socket_id(socket) {
    if (socket.get_id_string) return socket.get_id_string();
    return socket.localAddress + ":" + socket.localPort + " -> " + socket.remoteAddress + ":" + socket.remotePort;
}
function $b44b5920d931e66c$var$session_per_connection(conn) {
    var ssn = null;
    return {
        "get_session": function() {
            if (!ssn) {
                ssn = conn.create_session();
                ssn.observers.on("session_close", function() {
                    ssn = null;
                });
                ssn.begin();
            }
            return ssn;
        }
    };
}
function $b44b5920d931e66c$var$restrict(count, f) {
    if (count) {
        var current = count;
        var reset;
        return function(successful_attempts) {
            if (reset !== successful_attempts) {
                current = count;
                reset = successful_attempts;
            }
            if (current--) return f(successful_attempts);
            else return -1;
        };
    } else return f;
}
function $b44b5920d931e66c$var$backoff(initial, max) {
    var delay = initial;
    var reset;
    return function(successful_attempts) {
        if (reset !== successful_attempts) {
            delay = initial;
            reset = successful_attempts;
        }
        var current = delay;
        var next = delay * 2;
        delay = max > next ? next : max;
        return current;
    };
}
function $b44b5920d931e66c$var$get_connect_fn(options) {
    if (options.transport === undefined || options.transport === "tcp") return $2276b6e7a55844a8$exports.connect;
    else if (options.transport === "tls" || options.transport === "ssl") return $2276b6e7a55844a8$exports.connect;
    else throw Error("Unrecognised transport: " + options.transport);
}
function $b44b5920d931e66c$var$connection_details(options) {
    var details = {};
    details.connect = options.connect ? options.connect : $b44b5920d931e66c$var$get_connect_fn(options);
    details.host = options.host ? options.host : "localhost";
    details.port = options.port ? options.port : 5672;
    details.options = options;
    return details;
}
var $b44b5920d931e66c$var$aliases = [
    "container_id",
    "hostname",
    "max_frame_size",
    "channel_max",
    "idle_time_out",
    "outgoing_locales",
    "incoming_locales",
    "offered_capabilities",
    "desired_capabilities",
    "properties"
];
function $b44b5920d931e66c$var$remote_property_shortcut(name) {
    return function() {
        return this.remote.open ? this.remote.open[name] : undefined;
    };
}
function $b44b5920d931e66c$var$connection_fields(fields) {
    var o = {};
    $b44b5920d931e66c$var$aliases.forEach(function(name) {
        if (fields[name] !== undefined) o[name] = fields[name];
    });
    return o;
}
function $b44b5920d931e66c$var$set_reconnect(reconnect, connection) {
    if (typeof reconnect === "boolean") {
        if (reconnect) {
            var initial = connection.get_option("initial_reconnect_delay", 100);
            var max = connection.get_option("max_reconnect_delay", 60000);
            connection.options.reconnect = $b44b5920d931e66c$var$restrict(connection.get_option("reconnect_limit"), $b44b5920d931e66c$var$backoff(initial, max));
        } else connection.options.reconnect = false;
    } else if (typeof reconnect === "number") {
        var fixed = connection.options.reconnect;
        connection.options.reconnect = $b44b5920d931e66c$var$restrict(connection.get_option("reconnect_limit"), function() {
            return fixed;
        });
    }
}
var $b44b5920d931e66c$var$conn_counter = 1;
var $b44b5920d931e66c$var$Connection = function(options, container) {
    this.options = {};
    if (options) {
        for(var k in options)this.options[k] = options[k];
        if ((options.transport === "tls" || options.transport === "ssl") && options.servername === undefined && options.host !== undefined) this.options.servername = options.host;
    } else this.options = $b44b5920d931e66c$var$get_default_connect_config();
    this.container = container;
    if (!this.options.id) this.options.id = "connection-" + $b44b5920d931e66c$var$conn_counter++;
    if (!this.options.container_id) this.options.container_id = container ? container.id : $3hLdt.generate_uuid();
    if (!this.options.connection_details) {
        var self = this;
        this.options.connection_details = function() {
            return $b44b5920d931e66c$var$connection_details(self.options);
        };
    }
    var reconnect = this.get_option("reconnect", true);
    $b44b5920d931e66c$var$set_reconnect(reconnect, this);
    this.registered = false;
    this.state = new $f4a171f5da3e65d3$exports();
    this.local_channel_map = {};
    this.remote_channel_map = {};
    this.local = {};
    this.remote = {};
    this.local.open = $c5287fda22d925cb$exports.open($b44b5920d931e66c$var$connection_fields(this.options));
    this.local.close = $c5287fda22d925cb$exports.close({});
    this.session_policy = $b44b5920d931e66c$var$session_per_connection(this);
    this.amqp_transport = new $9d7c9efacf6b8c06$exports(this.options.id, $b44b5920d931e66c$var$AMQP_PROTOCOL_ID, $c5287fda22d925cb$exports.TYPE_AMQP, this);
    this.sasl_transport = undefined;
    this.transport = this.amqp_transport;
    this.conn_established_counter = 0;
    this.heartbeat_out = undefined;
    this.heartbeat_in = undefined;
    this.abort_idle = undefined;
    this.socket_ready = false;
    this.scheduled_reconnect = undefined;
    this.default_sender = undefined;
    this.closed_with_non_fatal_error = false;
    var self = this;
    $b44b5920d931e66c$var$aliases.forEach(function(alias) {
        Object.defineProperty(self, alias, {
            get: $b44b5920d931e66c$var$remote_property_shortcut(alias)
        });
    });
    Object.defineProperty(this, "error", {
        get: function() {
            return this.remote.close ? this.remote.close.error : undefined;
        }
    });
};
$b44b5920d931e66c$var$Connection.prototype = Object.create($b44b5920d931e66c$require$EventEmitter.prototype);
$b44b5920d931e66c$var$Connection.prototype.constructor = $b44b5920d931e66c$var$Connection;
$b44b5920d931e66c$var$Connection.prototype.dispatch = function(name) {
    $5Avaz.events("[%s] Connection got event: %s", this.options.id, name);
    if (this.listeners(name).length) {
        $b44b5920d931e66c$require$EventEmitter.prototype.emit.apply(this, arguments);
        return true;
    } else if (this.container) return this.container.dispatch.apply(this.container, arguments);
    else return false;
};
$b44b5920d931e66c$var$Connection.prototype._disconnect = function() {
    this.state.disconnected();
    for(var k in this.local_channel_map)this.local_channel_map[k]._disconnect();
    this.socket_ready = false;
};
$b44b5920d931e66c$var$Connection.prototype._reconnect = function() {
    if (this.abort_idle) {
        clearTimeout(this.abort_idle);
        this.abort_idle = undefined;
        this.local.close.error = undefined;
        this.state = new $f4a171f5da3e65d3$exports();
        this.state.open();
    }
    this.state.reconnect();
    this._reset_remote_state();
};
$b44b5920d931e66c$var$Connection.prototype._reset_remote_state = function() {
    //reset transport
    this.amqp_transport = new $9d7c9efacf6b8c06$exports(this.options.id, $b44b5920d931e66c$var$AMQP_PROTOCOL_ID, $c5287fda22d925cb$exports.TYPE_AMQP, this);
    this.sasl_transport = undefined;
    this.transport = this.amqp_transport;
    //reset remote endpoint state
    this.remote = {};
    //reset sessions:
    this.remote_channel_map = {};
    var localChannelMap = this.local_channel_map;
    for(var k in localChannelMap)localChannelMap[k]._reconnect();
};
$b44b5920d931e66c$var$Connection.prototype.connect = function() {
    this.is_server = false;
    if (this.abort_idle) {
        clearTimeout(this.abort_idle);
        this.abort_idle = undefined;
    }
    this._reset_remote_state();
    this._connect(this.options.connection_details(this.conn_established_counter));
    this.open();
    return this;
};
$b44b5920d931e66c$var$Connection.prototype.reconnect = function() {
    this.scheduled_reconnect = undefined;
    $5Avaz.reconnect("[%s] reconnecting...", this.options.id);
    this._reconnect();
    this._connect(this.options.connection_details(this.conn_established_counter));
    $gDDBB.nextTick(this._process.bind(this));
    return this;
};
$b44b5920d931e66c$var$Connection.prototype.set_reconnect = function(reconnect) {
    $b44b5920d931e66c$var$set_reconnect(reconnect, this);
};
$b44b5920d931e66c$var$Connection.prototype._connect = function(details) {
    if (details.connect) this.init(details.connect(details.port, details.host, details.options, this.connected.bind(this)));
    else this.init($b44b5920d931e66c$var$get_connect_fn(details)(details.port, details.host, details.options, this.connected.bind(this)));
    return this;
};
$b44b5920d931e66c$var$Connection.prototype.accept = function(socket) {
    this.is_server = true;
    $5Avaz.io("[%s] client accepted: %s", this.id, $b44b5920d931e66c$var$get_socket_id(socket));
    this.socket_ready = true;
    return this.init(socket);
};
$b44b5920d931e66c$var$Connection.prototype.abort_socket = function(socket) {
    if (socket === this.socket) {
        this.abort_idle = undefined;
        $5Avaz.io("[%s] aborting socket", this.options.id);
        this.socket.end();
        if (this.socket.removeAllListeners) {
            this.socket.removeAllListeners("data");
            this.socket.removeAllListeners("error");
            this.socket.removeAllListeners("end");
        }
        if (typeof this.socket.destroy === "function") this.socket.destroy();
        this._disconnected();
    }
};
$b44b5920d931e66c$var$Connection.prototype.init = function(socket) {
    this.socket = socket;
    if (this.get_option("tcp_no_delay", false) && this.socket.setNoDelay) this.socket.setNoDelay(true);
    this.socket.on("data", this.input.bind(this));
    this.socket.on("error", this.on_error.bind(this));
    this.socket.on("end", this.eof.bind(this));
    if (this.is_server) {
        var mechs;
        if (this.container && Object.getOwnPropertyNames(this.container.sasl_server_mechanisms).length) mechs = this.container.sasl_server_mechanisms;
        if (this.socket.encrypted && this.socket.authorized && this.get_option("enable_sasl_external", false)) mechs = $8bb9bbeef89e875e$exports.server_add_external(mechs ? $3hLdt.clone(mechs) : {});
        if (mechs) {
            if (mechs.ANONYMOUS !== undefined && !this.get_option("require_sasl", false)) this.sasl_transport = new $8bb9bbeef89e875e$exports.Selective(this, mechs);
            else this.sasl_transport = new $8bb9bbeef89e875e$exports.Server(this, mechs);
        } else if (!this.get_option("disable_sasl", false)) {
            var anon = $8bb9bbeef89e875e$exports.server_mechanisms();
            anon.enable_anonymous();
            this.sasl_transport = new $8bb9bbeef89e875e$exports.Selective(this, anon);
        }
    } else {
        var mechanisms = this.get_option("sasl_mechanisms");
        if (!mechanisms) {
            var username = this.get_option("username");
            var password = this.get_option("password");
            var token = this.get_option("token");
            if (username) {
                mechanisms = $8bb9bbeef89e875e$exports.client_mechanisms();
                if (password) mechanisms.enable_plain(username, password);
                else if (token) mechanisms.enable_xoauth2(username, token);
                else mechanisms.enable_anonymous(username);
            }
        }
        if (this.socket.encrypted && this.options.cert && this.get_option("enable_sasl_external", false)) {
            if (!mechanisms) mechanisms = $8bb9bbeef89e875e$exports.client_mechanisms();
            mechanisms.enable_external();
        }
        if (mechanisms) this.sasl_transport = new $8bb9bbeef89e875e$exports.Client(this, mechanisms, this.options.sasl_init_hostname || this.options.servername || this.options.host);
    }
    this.transport = this.sasl_transport ? this.sasl_transport : this.amqp_transport;
    return this;
};
$b44b5920d931e66c$var$Connection.prototype.attach_sender = function(options) {
    return this.session_policy.get_session().attach_sender(options);
};
$b44b5920d931e66c$var$Connection.prototype.open_sender = $b44b5920d931e66c$var$Connection.prototype.attach_sender; //alias
$b44b5920d931e66c$var$Connection.prototype.attach_receiver = function(options) {
    if (this.get_option("tcp_no_delay", true) && this.socket.setNoDelay) this.socket.setNoDelay(true);
    return this.session_policy.get_session().attach_receiver(options);
};
$b44b5920d931e66c$var$Connection.prototype.open_receiver = $b44b5920d931e66c$var$Connection.prototype.attach_receiver; //alias
$b44b5920d931e66c$var$Connection.prototype.get_option = function(name, default_value) {
    if (this.options[name] !== undefined) return this.options[name];
    else if (this.container) return this.container.get_option(name, default_value);
    else return default_value;
};
$b44b5920d931e66c$var$Connection.prototype.send = function(msg) {
    if (this.default_sender === undefined) this.default_sender = this.open_sender({
        target: {}
    });
    return this.default_sender.send(msg);
};
$b44b5920d931e66c$var$Connection.prototype.connected = function() {
    this.socket_ready = true;
    this.conn_established_counter++;
    $5Avaz.io("[%s] connected %s", this.options.id, $b44b5920d931e66c$var$get_socket_id(this.socket));
    this.output();
};
$b44b5920d931e66c$var$Connection.prototype.sasl_failed = function(text, condition) {
    this.transport_error = new $17709.ConnectionError(text, condition ? condition : "amqp:unauthorized-access", this);
    this._handle_error();
    this.socket.end();
};
$b44b5920d931e66c$var$Connection.prototype._is_fatal = function(error_condition) {
    var all_errors_non_fatal = this.get_option("all_errors_non_fatal", false);
    if (all_errors_non_fatal) return false;
    else {
        var non_fatal = this.get_option("non_fatal_errors", [
            "amqp:connection:forced"
        ]);
        return non_fatal.indexOf(error_condition) < 0;
    }
};
$b44b5920d931e66c$var$Connection.prototype._handle_error = function() {
    var error = this.get_error();
    if (error) {
        var handled = this.dispatch("connection_error", this._context({
            error: error
        }));
        handled = this.dispatch("connection_close", this._context({
            error: error
        })) || handled;
        if (!this._is_fatal(error.condition)) {
            if (this.state.local_open) this.closed_with_non_fatal_error = true;
        } else if (!handled) this.dispatch("error", new $17709.ConnectionError(error.description, error.condition, this));
        return true;
    } else return false;
};
$b44b5920d931e66c$var$Connection.prototype.get_error = function() {
    if (this.transport_error) return this.transport_error;
    if (this.remote.close && this.remote.close.error) return new $17709.ConnectionError(this.remote.close.error.description, this.remote.close.error.condition, this);
    return undefined;
};
$b44b5920d931e66c$var$Connection.prototype._get_peer_details = function() {
    var s = "";
    if (this.remote.open && this.remote.open.container) s += this.remote.open.container + " ";
    if (this.remote.open && this.remote.open.properties) s += JSON.stringify(this.remote.open.properties);
    return s;
};
$b44b5920d931e66c$var$Connection.prototype.output = function() {
    try {
        if (this.socket && this.socket_ready) {
            if (this.heartbeat_out) clearTimeout(this.heartbeat_out);
            this.transport.write(this.socket);
            if ((this.is_closed() && this.state.has_settled() || this.abort_idle || this.transport_error) && !this.transport.has_writes_pending()) this.socket.end();
            else if (this.is_open() && this.remote.open.idle_time_out) this.heartbeat_out = setTimeout(this._write_frame.bind(this), this.remote.open.idle_time_out / 2);
            if (this.local.open.idle_time_out && this.heartbeat_in === undefined) this.heartbeat_in = setTimeout(this.idle.bind(this), this.local.open.idle_time_out);
        }
    } catch (e) {
        this.saved_error = e;
        if (e.name === "ProtocolError") {
            console.error("[" + this.options.id + "] error on write: " + e + " " + this._get_peer_details() + " " + e.name);
            this.dispatch("protocol_error", e) || console.error("[" + this.options.id + "] error on write: " + e + " " + this._get_peer_details());
        } else this.dispatch("error", e);
        this.socket.end();
    }
};
function $b44b5920d931e66c$var$byte_to_hex(value) {
    if (value < 16) return "0x0" + Number(value).toString(16);
    else return "0x" + Number(value).toString(16);
}
function $b44b5920d931e66c$var$buffer_to_hex(buffer) {
    var bytes = [];
    for(var i = 0; i < buffer.length; i++)bytes.push($b44b5920d931e66c$var$byte_to_hex(buffer[i]));
    return bytes.join(",");
}
$b44b5920d931e66c$var$Connection.prototype.input = function(buff) {
    var buffer;
    try {
        if (this.heartbeat_in) clearTimeout(this.heartbeat_in);
        $5Avaz.io("[%s] read %d bytes", this.options.id, buff.length);
        if (this.previous_input) {
            buffer = $b44b5920d931e66c$require$Buffer.concat([
                this.previous_input,
                buff
            ], this.previous_input.length + buff.length);
            this.previous_input = null;
        } else buffer = buff;
        var read = this.transport.read(buffer, this);
        if (read < buffer.length) this.previous_input = buffer.slice(read);
        if (this.local.open.idle_time_out) this.heartbeat_in = setTimeout(this.idle.bind(this), this.local.open.idle_time_out);
        if (this.transport.has_writes_pending()) this.output();
        else if (this.is_closed() && this.state.has_settled()) this.socket.end();
        else if (this.is_open() && this.remote.open.idle_time_out && !this.heartbeat_out) this.heartbeat_out = setTimeout(this._write_frame.bind(this), this.remote.open.idle_time_out / 2);
    } catch (e) {
        this.saved_error = e;
        if (e.name === "ProtocolError") this.dispatch("protocol_error", e) || console.error("[" + this.options.id + "] error on read: " + e + " " + this._get_peer_details() + " (buffer:" + $b44b5920d931e66c$var$buffer_to_hex(buffer) + ")");
        else this.dispatch("error", e);
        this.socket.end();
    }
};
$b44b5920d931e66c$var$Connection.prototype.idle = function() {
    if (!this.is_closed()) {
        this.closed_with_non_fatal_error = true;
        this.local.close.error = {
            condition: "amqp:resource-limit-exceeded",
            description: "max idle time exceeded"
        };
        this.close();
        this.abort_idle = setTimeout(this.abort_socket.bind(this, this.socket), 1000);
    }
};
$b44b5920d931e66c$var$Connection.prototype.on_error = function(e) {
    this._disconnected(e);
};
$b44b5920d931e66c$var$Connection.prototype.eof = function(e) {
    var error = e || this.saved_error;
    this.saved_error = undefined;
    this._disconnected(error);
};
$b44b5920d931e66c$var$Connection.prototype._disconnected = function(error) {
    if (this.heartbeat_out) {
        clearTimeout(this.heartbeat_out);
        this.heartbeat_out = undefined;
    }
    if (this.heartbeat_in) {
        clearTimeout(this.heartbeat_in);
        this.heartbeat_in = undefined;
    }
    if (this.abort_idle) {
        clearTimeout(this.abort_idle);
        this.abort_idle = undefined;
    }
    var was_closed_with_non_fatal_error = this.closed_with_non_fatal_error;
    if (this.closed_with_non_fatal_error) {
        this.closed_with_non_fatal_error = false;
        if (this.options.reconnect) this.open();
    }
    if ((!this.is_closed() || was_closed_with_non_fatal_error) && this.scheduled_reconnect === undefined) {
        this._disconnect();
        var disconnect_ctxt = {};
        if (error) disconnect_ctxt.error = error;
        if (!this.is_server && !this.transport_error && this.options.reconnect) {
            var delay = this.options.reconnect(this.conn_established_counter);
            if (delay >= 0) {
                $5Avaz.reconnect("[%s] Scheduled reconnect in " + delay + "ms", this.options.id);
                this.scheduled_reconnect = setTimeout(this.reconnect.bind(this), delay);
                disconnect_ctxt.reconnecting = true;
            } else disconnect_ctxt.reconnecting = false;
        }
        if (!this.dispatch("disconnected", this._context(disconnect_ctxt))) console.warn("[" + this.options.id + "] disconnected %s", disconnect_ctxt.error || "");
    }
};
$b44b5920d931e66c$var$Connection.prototype.open = function() {
    if (this.state.open()) this._register();
};
$b44b5920d931e66c$var$Connection.prototype.close = function(error) {
    if (error) this.local.close.error = error;
    if (this.state.close()) this._register();
};
$b44b5920d931e66c$var$Connection.prototype.is_open = function() {
    return this.state.is_open();
};
$b44b5920d931e66c$var$Connection.prototype.is_remote_open = function() {
    return this.state.remote_open;
};
$b44b5920d931e66c$var$Connection.prototype.is_closed = function() {
    return this.state.is_closed();
};
$b44b5920d931e66c$var$Connection.prototype.create_session = function() {
    var i = 0;
    while(this.local_channel_map[i])i++;
    var session = new $93cc2cd2cca3866c$exports(this, i);
    this.local_channel_map[i] = session;
    return session;
};
$b44b5920d931e66c$var$Connection.prototype.find_sender = function(filter) {
    return this.find_link($3hLdt.sender_filter(filter));
};
$b44b5920d931e66c$var$Connection.prototype.find_receiver = function(filter) {
    return this.find_link($3hLdt.receiver_filter(filter));
};
$b44b5920d931e66c$var$Connection.prototype.find_link = function(filter) {
    for(var channel in this.local_channel_map){
        var session = this.local_channel_map[channel];
        var result = session.find_link(filter);
        if (result) return result;
    }
    return undefined;
};
$b44b5920d931e66c$var$Connection.prototype.each_receiver = function(action, filter) {
    this.each_link(action, $3hLdt.receiver_filter(filter));
};
$b44b5920d931e66c$var$Connection.prototype.each_sender = function(action, filter) {
    this.each_link(action, $3hLdt.sender_filter(filter));
};
$b44b5920d931e66c$var$Connection.prototype.each_link = function(action, filter) {
    for(var channel in this.local_channel_map){
        var session = this.local_channel_map[channel];
        session.each_link(action, filter);
    }
};
$b44b5920d931e66c$var$Connection.prototype.on_open = function(frame) {
    if (this.state.remote_opened()) {
        this.remote.open = frame.performative;
        this.open();
        this.dispatch("connection_open", this._context());
    } else throw new $17709.ProtocolError("Open already received");
};
$b44b5920d931e66c$var$Connection.prototype.on_close = function(frame) {
    if (this.state.remote_closed()) {
        this.remote.close = frame.performative;
        if (this.remote.close.error) this._handle_error();
        else this.dispatch("connection_close", this._context());
        if (this.heartbeat_out) clearTimeout(this.heartbeat_out);
        var self = this;
        $gDDBB.nextTick(function() {
            self.close();
        });
    } else throw new $17709.ProtocolError("Close already received");
};
$b44b5920d931e66c$var$Connection.prototype._register = function() {
    if (!this.registered) {
        this.registered = true;
        $gDDBB.nextTick(this._process.bind(this));
    }
};
$b44b5920d931e66c$var$Connection.prototype._process = function() {
    this.registered = false;
    do {
        if (this.state.need_open()) this._write_open();
        var localChannelMap = this.local_channel_map;
        for(var k in localChannelMap)localChannelMap[k]._process();
        if (this.state.need_close()) this._write_close();
    }while (!this.state.has_settled());
};
$b44b5920d931e66c$var$Connection.prototype._write_frame = function(channel, frame, payload) {
    this.amqp_transport.encode($c5287fda22d925cb$exports.amqp_frame(channel, frame, payload));
    this.output();
};
$b44b5920d931e66c$var$Connection.prototype._write_open = function() {
    this._write_frame(0, this.local.open);
};
$b44b5920d931e66c$var$Connection.prototype._write_close = function() {
    this._write_frame(0, this.local.close);
    this.local.close.error = undefined;
};
$b44b5920d931e66c$var$Connection.prototype.on_begin = function(frame) {
    var session;
    if (frame.performative.remote_channel === null || frame.performative.remote_channel === undefined) {
        //peer initiated
        session = this.create_session();
        session.local.begin.remote_channel = frame.channel;
    } else {
        session = this.local_channel_map[frame.performative.remote_channel];
        if (!session) throw new $17709.ProtocolError("Invalid value for remote channel " + frame.performative.remote_channel);
    }
    session.on_begin(frame);
    this.remote_channel_map[frame.channel] = session;
};
$b44b5920d931e66c$var$Connection.prototype.get_peer_certificate = function() {
    if (this.socket && this.socket.getPeerCertificate) return this.socket.getPeerCertificate();
    else return undefined;
};
$b44b5920d931e66c$var$Connection.prototype.get_tls_socket = function() {
    if (this.socket && (this.options.transport === "tls" || this.options.transport === "ssl")) return this.socket;
    else return undefined;
};
$b44b5920d931e66c$var$Connection.prototype._context = function(c) {
    var context = c ? c : {};
    context.connection = this;
    if (this.container) context.container = this.container;
    return context;
};
$b44b5920d931e66c$var$Connection.prototype.remove_session = function(session) {
    if (this.remote_channel_map[session.remote.channel] === session) delete this.remote_channel_map[session.remote.channel];
    if (this.local_channel_map[session.local.channel] === session) delete this.local_channel_map[session.local.channel];
};
$b44b5920d931e66c$var$Connection.prototype.remove_all_sessions = function() {
    $b44b5920d931e66c$var$clearObject(this.remote_channel_map);
    $b44b5920d931e66c$var$clearObject(this.local_channel_map);
};
function $b44b5920d931e66c$var$clearObject(obj) {
    for(var k in obj){
        if (!Object.prototype.hasOwnProperty.call(obj, k)) continue;
        delete obj[k];
    }
}
function $b44b5920d931e66c$var$delegate_to_session(name) {
    $b44b5920d931e66c$var$Connection.prototype["on_" + name] = function(frame) {
        var session = this.remote_channel_map[frame.channel];
        if (!session) throw new $17709.ProtocolError(name + " received on invalid channel " + frame.channel);
        session["on_" + name](frame);
    };
}
$b44b5920d931e66c$var$delegate_to_session("end");
$b44b5920d931e66c$var$delegate_to_session("attach");
$b44b5920d931e66c$var$delegate_to_session("detach");
$b44b5920d931e66c$var$delegate_to_session("transfer");
$b44b5920d931e66c$var$delegate_to_session("disposition");
$b44b5920d931e66c$var$delegate_to_session("flow");
$b44b5920d931e66c$exports = $b44b5920d931e66c$var$Connection;



var $5Avaz = parcelRequire("5Avaz");


var $3hLdt = parcelRequire("3hLdt");
var $0f1fc8edd5a9f7c3$exports = {};
/*
 * Copyright 2018 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ "use strict";
var $0f1fc8edd5a9f7c3$var$ReceiverEvents;
(function(ReceiverEvents) {
    /**
     * @property {string} message Raised when a message is received.
     */ ReceiverEvents["message"] = "message";
    /**
     * @property {string} receiverOpen Raised when the remote peer indicates the link is
     * open (i.e. attached in AMQP parlance).
     */ ReceiverEvents["receiverOpen"] = "receiver_open";
    /**
     * @property {string} receiverDrained Raised when the remote peer
     * indicates that it has drained all credit (and therefore there
     * are no more messages at present that it can send).
     */ ReceiverEvents["receiverDrained"] = "receiver_drained";
    /**
     * @property {string} receiverFlow Raised when a flow is received for receiver.
     */ ReceiverEvents["receiverFlow"] = "receiver_flow";
    /**
     * @property {string} receiverError Raised when the remote peer
     * closes the receiver with an error. The context may also have an
     * error property giving some information about the reason for the
     * error.
     */ ReceiverEvents["receiverError"] = "receiver_error";
    /**
     * @property {string} receiverClose Raised when the remote peer indicates the link is closed.
     */ ReceiverEvents["receiverClose"] = "receiver_close";
    /**
     * @property {string} settled Raised when the receiver link receives a disposition.
     */ ReceiverEvents["settled"] = "settled";
})($0f1fc8edd5a9f7c3$var$ReceiverEvents || ($0f1fc8edd5a9f7c3$var$ReceiverEvents = {}));
var $0f1fc8edd5a9f7c3$var$SenderEvents;
(function(SenderEvents) {
    /**
     * @property {string} sendable Raised when the sender has sufficient credit to be able
     * to transmit messages to its peer.
     */ SenderEvents["sendable"] = "sendable";
    /**
     * @property {string} senderOpen Raised when the remote peer indicates the link is
     * open (i.e. attached in AMQP parlance).
     */ SenderEvents["senderOpen"] = "sender_open";
    /**
     * @property {string} senderDraining Raised when the remote peer
     * requests that the sender drain its credit; sending all
     * available messages within the credit limit and ensuring credit
     * is used up..
     */ SenderEvents["senderDraining"] = "sender_draining";
    /**
     * @property {string} senderFlow Raised when a flow is received for sender.
     */ SenderEvents["senderFlow"] = "sender_flow";
    /**
     * @property {string} senderError Raised when the remote peer
     * closes the sender with an error. The context may also have an
     * error property giving some information about the reason for the
     * error.
     */ SenderEvents["senderError"] = "sender_error";
    /**
     * @property {string} senderClose Raised when the remote peer indicates the link is closed.
     */ SenderEvents["senderClose"] = "sender_close";
    /**
     * @property {string} accepted Raised when a sent message is accepted by the peer.
     */ SenderEvents["accepted"] = "accepted";
    /**
     * @property {string} released Raised when a sent message is released by the peer.
     */ SenderEvents["released"] = "released";
    /**
     * @property {string} rejected Raised when a sent message is rejected by the peer.
     */ SenderEvents["rejected"] = "rejected";
    /**
     * @property {string} modified Raised when a sent message is modified by the peer.
     */ SenderEvents["modified"] = "modified";
    /**
     * @property {string} settled Raised when the sender link receives a disposition.
     */ SenderEvents["settled"] = "settled";
})($0f1fc8edd5a9f7c3$var$SenderEvents || ($0f1fc8edd5a9f7c3$var$SenderEvents = {}));
var $0f1fc8edd5a9f7c3$var$SessionEvents;
(function(SessionEvents) {
    /**
     * @property {string} sessionOpen Raised when the remote peer indicates the session is
     * open (i.e. attached in AMQP parlance).
     */ SessionEvents["sessionOpen"] = "session_open";
    /**
     * @property {string} sessionError Raised when the remote peer receives an error. The context
     * may also have an error property giving some information about the reason for the error.
     */ SessionEvents["sessionError"] = "session_error";
    /**
     * @property {string} sessionClose Raised when the remote peer indicates the session is closed.
     */ SessionEvents["sessionClose"] = "session_close";
    /**
     * @property {string} settled Raised when the session receives a disposition.
     */ SessionEvents["settled"] = "settled";
})($0f1fc8edd5a9f7c3$var$SessionEvents || ($0f1fc8edd5a9f7c3$var$SessionEvents = {}));
var $0f1fc8edd5a9f7c3$var$ConnectionEvents;
(function(ConnectionEvents) {
    /**
     * @property {string} connectionOpen Raised when the remote peer indicates the connection is open.
     */ ConnectionEvents["connectionOpen"] = "connection_open";
    /**
     * @property {string} connectionClose Raised when the remote peer indicates the connection is closed.
     */ ConnectionEvents["connectionClose"] = "connection_close";
    /**
     * @property {string} connectionError Raised when the remote peer indicates an error occurred on
     * the connection.
     */ ConnectionEvents["connectionError"] = "connection_error";
    /**
     * @property {string} protocolError Raised when a protocol error is received on the underlying socket.
     */ ConnectionEvents["protocolError"] = "protocol_error", /**
     * @property {string} error Raised when an error is received on the underlying socket.
     */ ConnectionEvents["error"] = "error", /**
     * @property {string} disconnected Raised when the underlying tcp connection is lost. The context
     * has a reconnecting property which is true if the library is attempting to automatically reconnect
     * and false if it has reached the reconnect limit. If reconnect has not been enabled or if the connection
     * is a tcp server, then the reconnecting property is undefined. The context may also have an error
     * property giving some information about the reason for the disconnect.
     */ ConnectionEvents["disconnected"] = "disconnected";
    /**
     * @property {string} settled Raised when the connection receives a disposition.
     */ ConnectionEvents["settled"] = "settled";
})($0f1fc8edd5a9f7c3$var$ConnectionEvents || ($0f1fc8edd5a9f7c3$var$ConnectionEvents = {}));
$0f1fc8edd5a9f7c3$exports = {
    ReceiverEvents: $0f1fc8edd5a9f7c3$var$ReceiverEvents,
    SenderEvents: $0f1fc8edd5a9f7c3$var$SenderEvents,
    SessionEvents: $0f1fc8edd5a9f7c3$var$SessionEvents,
    ConnectionEvents: $0f1fc8edd5a9f7c3$var$ConnectionEvents
};





var $c1c4913cc434c78b$require$EventEmitter = $ac8e2c1b8bfc4b37$exports.EventEmitter;
var $c1c4913cc434c78b$var$Container = function(options) {
    this.options = options ? Object.create(options) : {};
    if (!this.options.id) this.options.id = $3hLdt.generate_uuid();
    this.id = this.options.id;
    this.sasl_server_mechanisms = $8bb9bbeef89e875e$exports.server_mechanisms();
};
$c1c4913cc434c78b$var$Container.prototype = Object.create($c1c4913cc434c78b$require$EventEmitter.prototype);
$c1c4913cc434c78b$var$Container.prototype.constructor = $c1c4913cc434c78b$var$Container;
$c1c4913cc434c78b$var$Container.prototype.dispatch = function(name) {
    $5Avaz.events("[%s] Container got event: " + name, this.id);
    $c1c4913cc434c78b$require$EventEmitter.prototype.emit.apply(this, arguments);
    if (this.listeners(name).length) return true;
    else return false;
};
$c1c4913cc434c78b$var$Container.prototype.connect = function(options) {
    return new $b44b5920d931e66c$exports(options, this).connect();
};
$c1c4913cc434c78b$var$Container.prototype.create_connection = function(options) {
    return new $b44b5920d931e66c$exports(options, this);
};
$c1c4913cc434c78b$var$Container.prototype.listen = function(options) {
    var container = this;
    var server;
    if (options.transport === undefined || options.transport === "tcp") {
        server = $2276b6e7a55844a8$exports.createServer();
        server.on("connection", function(socket) {
            new $b44b5920d931e66c$exports(options, container).accept(socket);
        });
    } else if (options.transport === "tls" || options.transport === "ssl") {
        server = $2276b6e7a55844a8$exports.createServer(options);
        server.on("secureConnection", function(socket) {
            new $b44b5920d931e66c$exports(options, container).accept(socket);
        });
    } else throw Error("Unrecognised transport: " + options.transport);
    if ($gDDBB.version.match(/v0\.10\.\d+/)) server.listen(options.port, options.host);
    else server.listen(options);
    return server;
};
$c1c4913cc434c78b$var$Container.prototype.create_container = function(options) {
    return new $c1c4913cc434c78b$var$Container(options);
};
$c1c4913cc434c78b$var$Container.prototype.get_option = function(name, default_value) {
    if (this.options[name] !== undefined) return this.options[name];
    else return default_value;
};
$c1c4913cc434c78b$var$Container.prototype.generate_uuid = $3hLdt.generate_uuid;
$c1c4913cc434c78b$var$Container.prototype.string_to_uuid = $3hLdt.string_to_uuid;
$c1c4913cc434c78b$var$Container.prototype.uuid_to_string = $3hLdt.uuid_to_string;
var $d6652b251b621ec5$exports = {};
/*
 * Copyright 2015 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ 
var $6FDNW = parcelRequire("6FDNW");
var $d6652b251b621ec5$require$Buffer = $6FDNW.Buffer;
"use strict";
function $d6652b251b621ec5$var$nulltransform(data) {
    return data;
}
function $d6652b251b621ec5$var$from_arraybuffer(data) {
    if (data instanceof ArrayBuffer) return $d6652b251b621ec5$require$Buffer.from(new Uint8Array(data));
    else return $d6652b251b621ec5$require$Buffer.from(data);
}
function $d6652b251b621ec5$var$to_typedarray(data) {
    return new Uint8Array(data);
}
function $d6652b251b621ec5$var$wrap(ws) {
    var data_recv = $d6652b251b621ec5$var$nulltransform;
    var data_send = $d6652b251b621ec5$var$nulltransform;
    if (ws.binaryType) {
        ws.binaryType = "arraybuffer";
        data_recv = $d6652b251b621ec5$var$from_arraybuffer;
        data_send = $d6652b251b621ec5$var$to_typedarray;
    }
    return {
        end: function() {
            ws.close();
        },
        write: function(data) {
            try {
                ws.send(data_send(data), {
                    binary: true
                });
            } catch (e) {
                ws.onerror(e);
            }
        },
        on: function(event, handler) {
            if (event === "data") ws.onmessage = function(msg_evt) {
                handler(data_recv(msg_evt.data));
            };
            else if (event === "end") ws.onclose = handler;
            else if (event === "error") ws.onerror = handler;
            else console.error("ERROR: Attempt to set unrecognised handler on websocket wrapper: " + event);
        },
        get_id_string: function() {
            return ws.url;
        }
    };
}
$d6652b251b621ec5$exports = {
    "connect": function(Impl) {
        return function(url, protocols, options) {
            return function() {
                return {
                    connect: function(port_ignore, host_ignore, options_ignore, callback) {
                        var c = new Impl(url, protocols, options);
                        c.onopen = callback;
                        return $d6652b251b621ec5$var$wrap(c);
                    }
                };
            };
        };
    },
    "wrap": $d6652b251b621ec5$var$wrap
};


$c1c4913cc434c78b$var$Container.prototype.websocket_accept = function(socket, options) {
    new $b44b5920d931e66c$exports(options, this).accept($d6652b251b621ec5$exports.wrap(socket));
};
$c1c4913cc434c78b$var$Container.prototype.websocket_connect = $d6652b251b621ec5$exports.connect;

$c1c4913cc434c78b$var$Container.prototype.filter = (parcelRequire("9OYYn"));

$c1c4913cc434c78b$var$Container.prototype.types = (parcelRequire("2Kc0N"));

$c1c4913cc434c78b$var$Container.prototype.message = (parcelRequire("bdeu2"));
$c1c4913cc434c78b$var$Container.prototype.sasl = $8bb9bbeef89e875e$exports;
$c1c4913cc434c78b$var$Container.prototype.ReceiverEvents = $0f1fc8edd5a9f7c3$exports.ReceiverEvents;
$c1c4913cc434c78b$var$Container.prototype.SenderEvents = $0f1fc8edd5a9f7c3$exports.SenderEvents;
$c1c4913cc434c78b$var$Container.prototype.SessionEvents = $0f1fc8edd5a9f7c3$exports.SessionEvents;
$c1c4913cc434c78b$var$Container.prototype.ConnectionEvents = $0f1fc8edd5a9f7c3$exports.ConnectionEvents;
$c1c4913cc434c78b$exports = new $c1c4913cc434c78b$var$Container();


$4973e2e602c1cc10$exports.types = $c1c4913cc434c78b$exports.types;
$4973e2e602c1cc10$exports.message = $c1c4913cc434c78b$exports.message;
$4973e2e602c1cc10$exports.filter = $c1c4913cc434c78b$exports.filter;
$4973e2e602c1cc10$exports.uuid_to_string = $c1c4913cc434c78b$exports.uuid_to_string;
$4973e2e602c1cc10$exports.generate_uuid = $c1c4913cc434c78b$exports.generate_uuid;
$4973e2e602c1cc10$exports.string_to_uuid = $c1c4913cc434c78b$exports.string_to_uuid;
$4973e2e602c1cc10$exports.ReceiverEvents = $c1c4913cc434c78b$exports.ReceiverEvents;
$4973e2e602c1cc10$exports.SenderEvents = $c1c4913cc434c78b$exports.SenderEvents;
$4973e2e602c1cc10$exports.ConnectionEvents = $c1c4913cc434c78b$exports.ConnectionEvents;
$4973e2e602c1cc10$exports.SessionEvents = $c1c4913cc434c78b$exports.SessionEvents;
$4973e2e602c1cc10$exports.Typed = $c1c4913cc434c78b$exports.Typed;
var $ace679c422ca35d4$exports = {};
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty($ace679c422ca35d4$exports, "__esModule", {
    value: true
});
var $e4e83c0ff1ef0b2b$exports = {};
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty($e4e83c0ff1ef0b2b$exports, "__esModule", {
    value: true
});

var $24379bbde9c43e27$exports = {};
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty($24379bbde9c43e27$exports, "__esModule", {
    value: true
});

var $cAqLr = parcelRequire("cAqLr");
/**
 * @ignore
 * log statements for container
 */ $24379bbde9c43e27$exports.container = $cAqLr("rhea-promise:container");
/**
 * @ignore
 * log statements for connection
 */ $24379bbde9c43e27$exports.connection = $cAqLr("rhea-promise:connection");
/**
 * @ignore
 * log statements for session
 */ $24379bbde9c43e27$exports.session = $cAqLr("rhea-promise:session");
/**
 * @ignore
 * log statements for sender
 */ $24379bbde9c43e27$exports.sender = $cAqLr("rhea-promise:sender");
/**
 * @ignore
 * log statements for receiver
 */ $24379bbde9c43e27$exports.receiver = $cAqLr("rhea-promise:receiver");
/**
 * @ignore
 * log statements for error
 */ $24379bbde9c43e27$exports.error = $cAqLr("rhea-promise:error");
/**
 * @ignore
 * log statements for error
 */ $24379bbde9c43e27$exports.eventHandler = $cAqLr("rhea-promise:eventhandler");
/**
 * @ignore
 * log statements for error
 */ $24379bbde9c43e27$exports.contextTranslator = $cAqLr("rhea-promise:translate");


var $ce07c524c8dd1ce0$exports = {};
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty($ce07c524c8dd1ce0$exports, "__esModule", {
    value: true
});


var $f1a9f106b246a2d2$exports = {};
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty($f1a9f106b246a2d2$exports, "__esModule", {
    value: true
});
var $0048c4b111559601$exports = {};
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty($0048c4b111559601$exports, "__esModule", {
    value: true
});



var $5627de30fb34dc3f$exports = {};
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty($5627de30fb34dc3f$exports, "__esModule", {
    value: true
});


/**
 * Defines a mapping for Http like response status codes for different status-code values
 * provided by an AMQP broker.
 * @enum AmqpResponseStatusCode
 */ var $5627de30fb34dc3f$var$AmqpResponseStatusCode;
(function(AmqpResponseStatusCode) {
    AmqpResponseStatusCode[AmqpResponseStatusCode["Continue"] = 100] = "Continue";
    AmqpResponseStatusCode[AmqpResponseStatusCode["SwitchingProtocols"] = 101] = "SwitchingProtocols";
    AmqpResponseStatusCode[AmqpResponseStatusCode["OK"] = 200] = "OK";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Created"] = 201] = "Created";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Accepted"] = 202] = "Accepted";
    AmqpResponseStatusCode[AmqpResponseStatusCode["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
    AmqpResponseStatusCode[AmqpResponseStatusCode["NoContent"] = 204] = "NoContent";
    AmqpResponseStatusCode[AmqpResponseStatusCode["ResetContent"] = 205] = "ResetContent";
    AmqpResponseStatusCode[AmqpResponseStatusCode["PartialContent"] = 206] = "PartialContent";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Ambiguous"] = 300] = "Ambiguous";
    AmqpResponseStatusCode[AmqpResponseStatusCode["MultipleChoices"] = 300] = "MultipleChoices";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Moved"] = 301] = "Moved";
    AmqpResponseStatusCode[AmqpResponseStatusCode["MovedPermanently"] = 301] = "MovedPermanently";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Found"] = 302] = "Found";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Redirect"] = 302] = "Redirect";
    AmqpResponseStatusCode[AmqpResponseStatusCode["RedirectMethod"] = 303] = "RedirectMethod";
    AmqpResponseStatusCode[AmqpResponseStatusCode["SeeOther"] = 303] = "SeeOther";
    AmqpResponseStatusCode[AmqpResponseStatusCode["NotModified"] = 304] = "NotModified";
    AmqpResponseStatusCode[AmqpResponseStatusCode["UseProxy"] = 305] = "UseProxy";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Unused"] = 306] = "Unused";
    AmqpResponseStatusCode[AmqpResponseStatusCode["RedirectKeepVerb"] = 307] = "RedirectKeepVerb";
    AmqpResponseStatusCode[AmqpResponseStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    AmqpResponseStatusCode[AmqpResponseStatusCode["BadRequest"] = 400] = "BadRequest";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Unauthorized"] = 401] = "Unauthorized";
    AmqpResponseStatusCode[AmqpResponseStatusCode["PaymentRequired"] = 402] = "PaymentRequired";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Forbidden"] = 403] = "Forbidden";
    AmqpResponseStatusCode[AmqpResponseStatusCode["NotFound"] = 404] = "NotFound";
    AmqpResponseStatusCode[AmqpResponseStatusCode["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    AmqpResponseStatusCode[AmqpResponseStatusCode["NotAcceptable"] = 406] = "NotAcceptable";
    AmqpResponseStatusCode[AmqpResponseStatusCode["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    AmqpResponseStatusCode[AmqpResponseStatusCode["RequestTimeout"] = 408] = "RequestTimeout";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Conflict"] = 409] = "Conflict";
    AmqpResponseStatusCode[AmqpResponseStatusCode["Gone"] = 410] = "Gone";
    AmqpResponseStatusCode[AmqpResponseStatusCode["LengthRequired"] = 411] = "LengthRequired";
    AmqpResponseStatusCode[AmqpResponseStatusCode["PreconditionFailed"] = 412] = "PreconditionFailed";
    AmqpResponseStatusCode[AmqpResponseStatusCode["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
    AmqpResponseStatusCode[AmqpResponseStatusCode["RequestUriTooLong"] = 414] = "RequestUriTooLong";
    AmqpResponseStatusCode[AmqpResponseStatusCode["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    AmqpResponseStatusCode[AmqpResponseStatusCode["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
    AmqpResponseStatusCode[AmqpResponseStatusCode["ExpectationFailed"] = 417] = "ExpectationFailed";
    AmqpResponseStatusCode[AmqpResponseStatusCode["UpgradeRequired"] = 426] = "UpgradeRequired";
    AmqpResponseStatusCode[AmqpResponseStatusCode["InternalServerError"] = 500] = "InternalServerError";
    AmqpResponseStatusCode[AmqpResponseStatusCode["NotImplemented"] = 501] = "NotImplemented";
    AmqpResponseStatusCode[AmqpResponseStatusCode["BadGateway"] = 502] = "BadGateway";
    AmqpResponseStatusCode[AmqpResponseStatusCode["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    AmqpResponseStatusCode[AmqpResponseStatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
    AmqpResponseStatusCode[AmqpResponseStatusCode["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
})($5627de30fb34dc3f$var$AmqpResponseStatusCode = $5627de30fb34dc3f$exports.AmqpResponseStatusCode || ($5627de30fb34dc3f$exports.AmqpResponseStatusCode = {}));
/**
 * Provides a list of predefined (amqp) protocol level properties for an amqp message.
 */ $5627de30fb34dc3f$exports.messageProperties = [
    "message_id",
    "reply_to",
    "to",
    "correlation_id",
    "content_type",
    "absolute_expiry_time",
    "group_id",
    "group_sequence",
    "reply_to_group_id",
    "content_encoding",
    "creation_time",
    "subject",
    "user_id"
];
/**
 * Provides a list of predefined (amqp) protocol level properties for an amqp message header.
 */ $5627de30fb34dc3f$exports.messageHeader = [
    "first_acquirer",
    "delivery_count",
    "ttl",
    "durable",
    "priority"
];
/**
 * Determines whether the given error object is like an AmqpError object.
 * @param {object} err The AmqpError object
 * @returns {boolean} result - `true` if it is an AMQP Error; `false` otherwise.
 */ function $5627de30fb34dc3f$var$isAmqpError(err) {
    if (!err || typeof err !== "object") throw new Error("err is a required parameter and must be of type 'object'.");
    let result = false;
    if (err.condition && typeof err.condition === "string" && err.description && typeof err.description === "string" || err.value && Array.isArray(err.value) || err.constructor && err.constructor.name === "c") result = true;
    return result;
}
$5627de30fb34dc3f$exports.isAmqpError = $5627de30fb34dc3f$var$isAmqpError;
/**
 * A wrapper for setTimeout that resolves a promise after t milliseconds.
 * @param {number} t - The number of milliseconds to be delayed.
 * @param {T} value - The value to be resolved with after a timeout of t milliseconds.
 * @returns {Promise<T>} - Resolved promise
 */ function $5627de30fb34dc3f$var$delay(t, value) {
    return new Promise((resolve)=>setTimeout(()=>resolve(value), t));
}
$5627de30fb34dc3f$exports.delay = $5627de30fb34dc3f$var$delay;
/**
 * Parses the connection string and returns an object of type T.
 * @param {string} connectionString The connection string to be parsed.
 * @returns {ParsedOutput<T>} ParsedOutput<T>.
 */ function $5627de30fb34dc3f$var$parseConnectionString(connectionString, options) {
    if (!options) options = {};
    const entitySeperator = options.entitySeperator || ";";
    const keyValueSeparator = options.keyValueSeparator || "=";
    return connectionString.split(entitySeperator).reduce((acc, part)=>{
        const splitIndex = part.indexOf(keyValueSeparator);
        return Object.assign({}, acc, {
            [part.substring(0, splitIndex)]: part.substring(splitIndex + 1)
        });
    }, {});
}
$5627de30fb34dc3f$exports.parseConnectionString = $5627de30fb34dc3f$var$parseConnectionString;
/**
 * @ignore
 * Emits an event.
 * @param params parameters needed to emit an event from one of the rhea-promise objects.
 * @returns void
 */ function $5627de30fb34dc3f$var$emitEvent(params) {
    const emit = ()=>{
        const id = params.emitter && (params.emitter.id || params.emitter.name);
        $24379bbde9c43e27$exports[params.emitterType]("[%s] %s '%s' got event: '%s'. Re-emitting the translated context.", params.connectionId, params.emitterType, id, params.eventName);
        params.emitter.emit(params.eventName, $ace679c422ca35d4$exports.EventContext.translate(params.rheaContext, params.emitter, params.eventName));
    };
    if (params.eventName.indexOf("error") !== -1 && params.emitter.actionInitiated > 0) {
        $24379bbde9c43e27$exports[params.emitterType]("[%s] %s got event: '%s'. Will re-emit in the next tick, since this happened before the promise for create/close was resolved.", params.connectionId, params.emitterType, params.eventName);
        // setTimeout() without any time is equivalent to process.nextTick() and works in node.js and
        // browsers. We wait for a tick to emit error events in general. This should give enough
        // time for promises to resolve on *_open (create) and *_close (close).
        setTimeout(emit);
    } else emit();
}
$5627de30fb34dc3f$exports.emitEvent = $5627de30fb34dc3f$var$emitEvent;
$5627de30fb34dc3f$exports.abortErrorName = "AbortError";
/**
 * Helper method to return an Error to be used when an operation is cancelled
 * using an AbortSignalLike
 */ function $5627de30fb34dc3f$var$createAbortError() {
    const error = new Error("The operation was aborted.");
    error.name = $5627de30fb34dc3f$exports.abortErrorName;
    return error;
}
$5627de30fb34dc3f$exports.createAbortError = $5627de30fb34dc3f$var$createAbortError;


var $3332e8ae2d20663f$exports = {};
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty($3332e8ae2d20663f$exports, "__esModule", {
    value: true
});

/**
 * Abstract base class for all the entities like Connection, Session, Sender, Receiver in the
 * AMQP protocol.
 * @class Entity
 */ class $3332e8ae2d20663f$var$Entity extends $ac8e2c1b8bfc4b37$exports.EventEmitter {
    constructor(){
        super();
        /**
         * @property actionInitiated Indicates whether the action of creating or closing an entity has
         * been initiated. Whenever an action has been initiated, the count will be incremented by 1.
         * Whenever the action completes (succeeds/fails) the count will be decremented by 1.
         * Default value: `0`.
         */ this.actionInitiated = 0;
    }
}
$3332e8ae2d20663f$exports.Entity = $3332e8ae2d20663f$var$Entity;


var $05c322d0dbecfcc0$exports = {};
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty($05c322d0dbecfcc0$exports, "__esModule", {
    value: true
});
/**
 * Defines the error that occurs when an operation timeout occurs.
 */ class $05c322d0dbecfcc0$var$OperationTimeoutError extends Error {
    constructor(message){
        super(message);
        /**
         * Describes the name of the error.
         */ this.name = "OperationTimeoutError";
    }
}
$05c322d0dbecfcc0$exports.OperationTimeoutError = $05c322d0dbecfcc0$var$OperationTimeoutError;
/**
 * Defines the error that occurs when the Sender does not have enough credit.
 */ class $05c322d0dbecfcc0$var$InsufficientCreditError extends Error {
    constructor(message){
        super(message);
        /**
         * Describes the name of the error.
         */ this.name = "InsufficientCreditError";
    }
}
$05c322d0dbecfcc0$exports.InsufficientCreditError = $05c322d0dbecfcc0$var$InsufficientCreditError;
/**
 * Defines the error that occurs when the Sender fails to send a message.
 */ class $05c322d0dbecfcc0$var$SendOperationFailedError extends Error {
    constructor(/**
     * Provides descriptive information about the error.
     */ message, /**
     * Provides the corresponding event associated with the `SendOperationFailedError`.
     * - If the code is `"sender_error"` | `"session_error"`, then the send operation failed
     * due to the sender link getting disconnected.
     * - If the code is `"rejected"` | `"released"` | `"modified"`, then the send operation failed
     * because the server is currently unable to accept the message being sent. Please take a look
     * at the [AMQP 1.0 specification - "Section 3.4 Delivery State"](http://www.amqp.org/sites/amqp.org/files/amqp.pdf)
     * for details about `"rejected"` | `"released"` | `"modified"` disposition.
     */ code, /**
     * Describes the underlying error that caused the send operation to fail.
     */ innerError){
        super(message);
        this.message = message;
        this.code = code;
        this.innerError = innerError;
        /**
         * Describes the name of the error.
         */ this.name = "SendOperationFailedError";
        this.code = code;
        this.innerError = innerError;
    }
}
$05c322d0dbecfcc0$exports.SendOperationFailedError = $05c322d0dbecfcc0$var$SendOperationFailedError;


var $0048c4b111559601$var$LinkType;
(function(LinkType) {
    LinkType["sender"] = "sender";
    LinkType["receiver"] = "receiver";
})($0048c4b111559601$var$LinkType = $0048c4b111559601$exports.LinkType || ($0048c4b111559601$exports.LinkType = {}));
class $0048c4b111559601$var$Link extends $3332e8ae2d20663f$exports.Entity {
    constructor(type, session, link, options){
        super();
        this.type = type;
        this._session = session;
        this._link = link;
        this.linkOptions = options;
        this._initializeEventListeners();
    }
    get name() {
        return this._link.name;
    }
    get error() {
        return this._link.error;
    }
    get properties() {
        return this._link.properties;
    }
    get sendSettleMode() {
        return this._link.snd_settle_mode;
    }
    get receiveSettleMode() {
        return this._link.rcv_settle_mode;
    }
    get source() {
        return this._link.source;
    }
    set source(fields) {
        this._link.set_source(fields);
    }
    get target() {
        return this._link.target;
    }
    set target(fields) {
        this._link.set_source(fields);
    }
    get maxMessageSize() {
        return this._link.max_message_size;
    }
    get offeredCapabilities() {
        return this._link.offered_capabilities;
    }
    get desiredCapabilities() {
        return this._link.desired_capabilities;
    }
    get address() {
        return this.source.address;
    }
    get credit() {
        return this._link.credit;
    }
    get session() {
        return this._session;
    }
    get connection() {
        return this._session.connection;
    }
    /**
     * Determines whether the sender link and its underlying session is open.
     * @returns {boolean} `true` open. `false` closed.
     */ isOpen() {
        let result = false;
        if (this._session.isOpen() && this._link.is_open()) result = true;
        return result;
    }
    /**
     * Determines whether the remote end of the link is open.
     * @return {boolean} boolean `true` - is open; `false` otherwise.
     */ isRemoteOpen() {
        return this._link.is_remote_open();
    }
    /**
     * Determines whether the link has credit.
     * @return {boolean} boolean `true` - has credit; `false` otherwise.
     */ hasCredit() {
        return this._link.has_credit();
    }
    /**
     * Determines whether the link is a sender.
     * @return {boolean} boolean `true` - sender; `false` otherwise.
     */ isSender() {
        return this._link.is_sender();
    }
    /**
     * Determines whether the link is a receiver.
     * @return {boolean} boolean `true` - receiver; `false` otherwise.
     */ isReceiver() {
        return this._link.is_receiver();
    }
    /**
     * Determines whether both local and remote endpoint for link or it's underlying session
     * or it's underlying connection are closed.
     * Within the "sender_close", "session_close" event handler, if this
     * method returns `false` it means that the local end is still open. It can be useful to
     * determine whether the close was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` if closed, `false` otherwise.
     */ isClosed() {
        return this._link.is_closed();
    }
    /**
     * Determines whether both local and remote endpoint for just the link itself are closed.
     * Within the "sender_close" event handler, if this method returns `false` it
     * means that the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */ isItselfClosed() {
        return this._link.is_itself_closed();
    }
    /**
     * Determines whether both local and remote endpoint for session or it's underlying
     * connection are closed.
     *
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */ isSessionClosed() {
        return this._session.isClosed();
    }
    /**
     * Determines whether both local and remote endpoint for just the session itself are closed.
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */ isSessionItselfClosed() {
        return this._session.isItselfClosed();
    }
    /**
     * Removes the underlying amqp link and it's session from the internal map in rhea. Also removes
     * all the event handlers added in the rhea-promise library on the link and it's session.
     * @returns {void} void
     */ remove() {
        if (this._link) {
            // Remove our listeners and listeners from rhea's link object.
            this.removeAllListeners();
            this._link.removeAllListeners();
            this._link.remove();
        }
        if (this._session) this._session.remove();
    }
    /**
     * Closes the underlying amqp link and optionally the session as well in rhea if open.
     * Also removes all the event handlers added in the rhea-promise library on the link
     * and optionally it's session.
     * @returns Promise<void>
     * - **Resolves** the promise when rhea emits the "sender_close" | "receiver_close" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the
     * "sender_error" | "receiver_error" event while trying to close the amqp link.
     */ close(options) {
        return $9187fda58d09cc70$export$1050f835b63b671e(this, void 0, void 0, function*() {
            if (!options) options = {};
            if (options.closeSession == undefined) options.closeSession = true;
            const closePromise = new Promise((resolve, reject)=>{
                $24379bbde9c43e27$exports.error("[%s] The %s '%s' on amqp session '%s' is open ? -> %s", this.connection.id, this.type, this.name, this.session.id, this.isOpen());
                if (this.isOpen()) {
                    const errorEvent = this.type === $0048c4b111559601$var$LinkType.sender ? $c1c4913cc434c78b$exports.SenderEvents.senderError : $c1c4913cc434c78b$exports.ReceiverEvents.receiverError;
                    const closeEvent = this.type === $0048c4b111559601$var$LinkType.sender ? $c1c4913cc434c78b$exports.SenderEvents.senderClose : $c1c4913cc434c78b$exports.ReceiverEvents.receiverClose;
                    let onError;
                    let onClose;
                    let onDisconnected;
                    let waitTimer;
                    const removeListeners = ()=>{
                        clearTimeout(waitTimer);
                        this.actionInitiated--;
                        this._link.removeListener(errorEvent, onError);
                        this._link.removeListener(closeEvent, onClose);
                        this._link.connection.removeListener($c1c4913cc434c78b$exports.ConnectionEvents.disconnected, onDisconnected);
                    };
                    onClose = (context)=>{
                        removeListeners();
                        $24379bbde9c43e27$exports[this.type]("[%s] Resolving the promise as the %s '%s' on amqp session '%s' has been closed.", this.connection.id, this.type, this.name, this.session.id);
                        return resolve();
                    };
                    onError = (context)=>{
                        removeListeners();
                        let error = context.session.error;
                        if (this.type === $0048c4b111559601$var$LinkType.sender && context.sender && context.sender.error) error = context.sender.error;
                        else if (this.type === $0048c4b111559601$var$LinkType.receiver && context.receiver && context.receiver.error) error = context.receiver.error;
                        $24379bbde9c43e27$exports.error("[%s] Error occurred while closing %s '%s' on amqp session '%s': %O.", this.connection.id, this.type, this.name, this.session.id, error);
                        return reject(error);
                    };
                    onDisconnected = (context)=>{
                        removeListeners();
                        const error = context.connection && context.connection.error ? context.connection.error : context.error;
                        $24379bbde9c43e27$exports.error("[%s] Connection got disconnected while closing amqp %s '%s' on amqp session '%s': %O.", this.connection.id, this.type, this.name, this.session.id, error);
                    };
                    const actionAfterTimeout = ()=>{
                        removeListeners();
                        const msg = `Unable to close the ${this.type} '${this.name}' ` + `on amqp session '${this.session.id}' due to operation timeout.`;
                        $24379bbde9c43e27$exports.error("[%s] %s", this.connection.id, msg);
                        return reject(new $05c322d0dbecfcc0$exports.OperationTimeoutError(msg));
                    };
                    // listeners that we add for completing the operation are added directly to rhea's objects.
                    this._link.once(closeEvent, onClose);
                    this._link.once(errorEvent, onError);
                    this._link.connection.once($c1c4913cc434c78b$exports.ConnectionEvents.disconnected, onDisconnected);
                    waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
                    this._link.close();
                    this.actionInitiated++;
                } else return resolve();
            });
            try {
                yield closePromise;
            } finally{
                this.removeAllListeners();
            }
            if (options.closeSession) {
                $24379bbde9c43e27$exports[this.type]("[%s] %s '%s' has been closed, now closing it's amqp session '%s'.", this.connection.id, this.type, this.name, this.session.id);
                return this._session.close();
            }
        });
    }
    /**
     * Adds event listeners for the possible events that can occur on the link object and
     * re-emits the same event back with the received arguments from rhea's event emitter.
     * @private
     * @returns {void} void
     */ _initializeEventListeners() {
        const events = this.type === $0048c4b111559601$var$LinkType.sender ? $c1c4913cc434c78b$exports.SenderEvents : $c1c4913cc434c78b$exports.ReceiverEvents;
        for (const eventName of Object.keys(events))this._link.on(events[eventName], (context)=>{
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: events[eventName],
                emitterType: this.type,
                connectionId: this.connection.id
            };
            $5627de30fb34dc3f$exports.emitEvent(params);
        });
        if (typeof this._link.eventNames === "function") $24379bbde9c43e27$exports.eventHandler("[%s] rhea-promise '%s' object is listening for events: %o emitted by rhea's '%s' object.", this.connection.id, this.type, this._link.eventNames(), this.type);
        if (typeof this._link.listenerCount === "function") $24379bbde9c43e27$exports.eventHandler("[%s] ListenerCount for event '%s_error' on rhea's '%s' object is: %d.", this.connection.id, this.type, this.type, this._link.listenerCount(`${this.type}_error`));
    }
}
$0048c4b111559601$exports.Link = $0048c4b111559601$var$Link;


/**
 * Describes the receiver that wraps the rhea receiver.
 * @class Receiver.
 */ class $f1a9f106b246a2d2$var$Receiver extends $0048c4b111559601$exports.Link {
    constructor(session, receiver, options){
        super($0048c4b111559601$exports.LinkType.receiver, session, receiver, options);
    }
    get drain() {
        return this._link.drain;
    }
    set drain(value) {
        this._link.drain = value;
    }
    addCredit(credit) {
        this._link.add_credit(credit);
    }
    drainCredit() {
        this._link.drain_credit();
    }
    setCreditWindow(creditWindow) {
        this._link.set_credit_window(creditWindow);
    }
}
$f1a9f106b246a2d2$exports.Receiver = $f1a9f106b246a2d2$var$Receiver;


var $a80de3f150cffa79$exports = {};
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty($a80de3f150cffa79$exports, "__esModule", {
    value: true
});

/**
 * Describes the base sender that wraps the rhea sender.
 * @class BaseSender
 */ class $a80de3f150cffa79$var$BaseSender extends $0048c4b111559601$exports.Link {
    constructor(session, sender, options){
        super($0048c4b111559601$exports.LinkType.sender, session, sender, options);
    }
    setDrained(drained) {
        this._link.set_drained(drained);
    }
    /**
     * Determines whether the message is sendable.
     * @returns {boolean} `true` Sendable. `false` Not Sendable.
     */ sendable() {
        return this._link.sendable();
    }
}
$a80de3f150cffa79$exports.BaseSender = $a80de3f150cffa79$var$BaseSender;
class $a80de3f150cffa79$var$SenderSendOptions {
}
$a80de3f150cffa79$exports.SenderSendOptions = $a80de3f150cffa79$var$SenderSendOptions;
/**
 * Describes the AMQP Sender.
 * @class Sender
 */ class $a80de3f150cffa79$var$Sender extends $a80de3f150cffa79$var$BaseSender {
    constructor(session, sender, options){
        super(session, sender, options);
    }
    /**
     * Sends the message
     * @param {Message | Buffer} msg The message to be sent. For default AMQP format msg parameter
     * should be of type Message interface. For a custom format, the msg parameter should be a Buffer
     * and a valid value should be passed to the `format` argument.
     * @param {SenderSendOptions} [options] Options to configure the tag and message format of the message.
     * @returns {Delivery} Delivery The delivery information about the sent message.
     */ send(msg, options = {}) {
        return this._link.send(msg, options.tag, options.format);
    }
}
$a80de3f150cffa79$exports.Sender = $a80de3f150cffa79$var$Sender;






var $e59ccf10e6a216b6$exports = {};
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty($e59ccf10e6a216b6$exports, "__esModule", {
    value: true
});






/**
 * Describes the sender where one can await on the message being sent.
 * @class AwaitableSender
 */ class $e59ccf10e6a216b6$var$AwaitableSender extends $a80de3f150cffa79$exports.BaseSender {
    constructor(session, sender, options = {}){
        super(session, sender, options);
        /**
         * @property {Map<number, PromiseLike} deliveryDispositionMap Maintains a map of delivery of
         * messages that are being sent. It acts as a store for correlating the dispositions received
         * for sent messages.
         */ this.deliveryDispositionMap = new Map();
        /**
         * The handler that will be added on the Sender for `accepted` event. If the delivery id is
         * present in the disposition map then it will clear the timer and resolve the promise with the
         * delivery.
         * @param delivery Delivery associated with message that was sent.
         */ const onSendSuccess = (delivery)=>{
            const id = delivery.id;
            if (this.deliveryDispositionMap.has(delivery.id)) {
                const promise = this.deliveryDispositionMap.get(id);
                clearTimeout(promise.timer);
                const deleteResult = this.deliveryDispositionMap.delete(id);
                $24379bbde9c43e27$exports.sender("[%s] Event: 'Accepted', Successfully deleted the delivery with id %d from the map of sender '%s' on amqp session '%s' and cleared the timer: %s.", this.connection.id, id, this.name, this.session.id, deleteResult);
                return promise.resolve(delivery);
            }
        };
        /**
         * The handler is added on the Sender for `rejected`, `released` and `modified` events.
         * If the delivery is found in the disposition map then the timer will be cleared and the
         * promise will be rejected with an appropriate error message.
         * @param eventName Name of the event that was raised.
         * @param id Delivery id.
         * @param error Error from the context if any.
         */ const onSendFailure = (eventName, id, error)=>{
            if (this.deliveryDispositionMap.has(id)) {
                const promise = this.deliveryDispositionMap.get(id);
                clearTimeout(promise.timer);
                const deleteResult = this.deliveryDispositionMap.delete(id);
                $24379bbde9c43e27$exports.sender("[%s] Event: '%s', Successfully deleted the delivery with id %d from the  map of sender '%s' on amqp session '%s' and cleared the timer: %s.", this.connection.id, eventName, id, this.name, this.session.id, deleteResult);
                const msg = `Sender '${this.name}' on amqp session '${this.session.id}', received a ` + `'${eventName}' disposition. Hence we are rejecting the promise.`;
                const err = new $05c322d0dbecfcc0$exports.SendOperationFailedError(msg, eventName, error);
                $24379bbde9c43e27$exports.error("[%s] %s", this.connection.id, msg);
                return promise.reject(err);
            }
        };
        /**
         * The handler that will be added on the Sender link for `sender_error` and on it's underlying
         * session for `session_error` event. These events are raised when the sender link or it's
         * underlying session get disconnected.
         * The handler will clear the timer and reject the promise for every pending send in the map.
         * @param eventName Name of the event that was raised.
         * @param error Error from the context if any
         */ const onError = (eventName, error)=>{
            for (const id of this.deliveryDispositionMap.keys())onSendFailure(eventName, id, error);
        };
        this.on($c1c4913cc434c78b$exports.SenderEvents.accepted, (context)=>{
            onSendSuccess(context.delivery);
        });
        this.on($c1c4913cc434c78b$exports.SenderEvents.rejected, (context)=>{
            const delivery = context.delivery;
            onSendFailure($c1c4913cc434c78b$exports.SenderEvents.rejected, delivery.id, delivery.remote_state && delivery.remote_state.error);
        });
        this.on($c1c4913cc434c78b$exports.SenderEvents.released, (context)=>{
            const delivery = context.delivery;
            onSendFailure($c1c4913cc434c78b$exports.SenderEvents.released, delivery.id, delivery.remote_state && delivery.remote_state.error);
        });
        this.on($c1c4913cc434c78b$exports.SenderEvents.modified, (context)=>{
            const delivery = context.delivery;
            onSendFailure($c1c4913cc434c78b$exports.SenderEvents.modified, delivery.id, delivery.remote_state && delivery.remote_state.error);
        });
        // The user may have it's custom reconnect logic for bringing the sender link back online and
        // retry logic for sending messages on failures hence they can provide their error handlers
        // for `sender_error` and `session_error`.
        // If the user did not provide its error handler for `sender_error` and `session_error`,
        // then we add our handlers and make sure we clear the timer and reject the promise for sending
        // messages with appropriate Error.
        if (!options.onError) this.on($c1c4913cc434c78b$exports.SenderEvents.senderError, (context)=>{
            onError($c1c4913cc434c78b$exports.SenderEvents.senderError, context.sender.error);
        });
        if (!options.onSessionError) this.session.on($c1c4913cc434c78b$exports.SessionEvents.sessionError, (context)=>{
            onError($c1c4913cc434c78b$exports.SessionEvents.sessionError, context.session.error);
        });
    }
    /**
     * Sends the message on which one can await to ensure that the message has been successfully
     * delivered.
     * @param {Message | Buffer} msg The message to be sent. For default AMQP format msg parameter
     * should be of type Message interface. For a custom format, the msg parameter should be a Buffer
     * and a valid value should be passed to the `format` argument.
     * @param {AwaitableSendOptions} [options] Options to configure the timeout, cancellation for
     * the send operation and the tag and message format of the message.
     * @returns {Promise<Delivery>} Promise<Delivery> The delivery information about the sent message.
     */ send(msg, options = {}) {
        return new Promise((resolve, reject)=>{
            $24379bbde9c43e27$exports.sender("[%s] Sender '%s' on amqp session '%s', credit: %d available: %d", this.connection.id, this.name, this.session.id, this.credit, this.session.outgoing.available());
            const abortSignal = options && options.abortSignal;
            const timeoutInSeconds = options.timeoutInSeconds || 20;
            if (abortSignal && abortSignal.aborted) {
                const err = $5627de30fb34dc3f$exports.createAbortError();
                $24379bbde9c43e27$exports.error("[%s] %s", this.connection.id, err.message);
                return reject(err);
            }
            if (this.sendable()) {
                const timer = setTimeout(()=>{
                    this.deliveryDispositionMap.delete(delivery.id);
                    const message = `Sender '${this.name}' on amqp session ` + `'${this.session.id}', with address '${this.address}' was not able to send the ` + `message with delivery id ${delivery.id} right now, due to operation timeout.`;
                    $24379bbde9c43e27$exports.error("[%s] %s", this.connection.id, message);
                    return reject(new $05c322d0dbecfcc0$exports.OperationTimeoutError(message));
                }, timeoutInSeconds * 1000);
                const onAbort = ()=>{
                    if (this.deliveryDispositionMap.has(delivery.id)) {
                        const promise = this.deliveryDispositionMap.get(delivery.id);
                        clearTimeout(promise.timer);
                        const deleteResult = this.deliveryDispositionMap.delete(delivery.id);
                        $24379bbde9c43e27$exports.sender("[%s] Event: 'abort', Successfully deleted the delivery with id %d from the  map of sender '%s' on amqp session '%s' and cleared the timer: %s.", this.connection.id, delivery.id, this.name, this.session.id, deleteResult);
                        const err = $5627de30fb34dc3f$exports.createAbortError();
                        $24379bbde9c43e27$exports.error("[%s] %s", this.connection.id, err.message);
                        promise.reject(err);
                    }
                };
                const removeAbortListener = ()=>{
                    if (abortSignal) abortSignal.removeEventListener("abort", onAbort);
                };
                const delivery = this._link.send(msg, options.tag, options.format);
                this.deliveryDispositionMap.set(delivery.id, {
                    resolve: (delivery)=>{
                        resolve(delivery);
                        removeAbortListener();
                    },
                    reject: (reason)=>{
                        reject(reason);
                        removeAbortListener();
                    },
                    timer: timer
                });
                if (abortSignal) abortSignal.addEventListener("abort", onAbort);
            } else {
                // Please send the message after some time.
                const msg = `Sender "${this.name}" on amqp session "${this.session.id}", with address ` + `${this.address} cannot send the message right now as it does not have ` + `enough credit. Please try later.`;
                $24379bbde9c43e27$exports.error("[%s] %s", this.connection.id, msg);
                reject(new $05c322d0dbecfcc0$exports.InsufficientCreditError(msg));
            }
        });
    }
}
$e59ccf10e6a216b6$exports.AwaitableSender = $e59ccf10e6a216b6$var$AwaitableSender;


/**
 * @internal
 */ var $ce07c524c8dd1ce0$var$SenderType;
(function(SenderType) {
    SenderType["sender"] = "sender";
    SenderType["AwaitableSender"] = "AwaitableSender";
})($ce07c524c8dd1ce0$var$SenderType || ($ce07c524c8dd1ce0$var$SenderType = {}));
/**
 * Describes the session that wraps the rhea session.
 * @class Session
 */ class $ce07c524c8dd1ce0$var$Session extends $3332e8ae2d20663f$exports.Entity {
    constructor(connection, session){
        super();
        this._connection = connection;
        this._session = session;
        this._initializeEventListeners();
    }
    /**
     * @property {Connection} connection The underlying AMQP connection.
     * @readonly
     */ get connection() {
        return this._connection;
    }
    get incoming() {
        return this._session.incoming;
    }
    get outgoing() {
        return this._session.outgoing;
    }
    get error() {
        return this._session.error;
    }
    /**
     * Returns the unique identifier for the session in the format:
     * "local_<number>-remote_<number>-<connection-id>" or an empty string if the local channel or
     * remote channel are not yet defined.
     */ get id() {
        let result = "";
        const session = this._session;
        if (session.local) result += `local-${session.local.channel}_`;
        if (session.remote) result += `remote-${session.remote.channel}_`;
        if (result) result += `${this._connection.id}`;
        return result;
    }
    /**
     * Determines whether the session and the underlying connection is open.
     * @returns {boolean} result `true` - is open; `false` otherwise.
     */ isOpen() {
        let result = false;
        if (this._connection.isOpen() && this._session.is_open()) result = true;
        return result;
    }
    /**
     * Determines whether the close from the peer is a response to a locally initiated close request.
     * @returns {boolean} `true` if close was locally initiated, `false` otherwise.
     */ isClosed() {
        return this._session.is_closed();
    }
    /**
     * Determines whether both local and remote endpoint for just the session itself are closed.
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */ isItselfClosed() {
        return this._session.is_itself_closed();
    }
    /**
     * Removes the underlying amqp session from the internal map in rhea.
     * Also removes all the event handlers added in the rhea-promise library on the session.
     */ remove() {
        if (this._session) {
            // Remove our listeners and listeners from rhea's 'session' object.
            this.removeAllListeners();
            this._session.removeAllListeners();
            this._session.remove();
        }
    }
    begin() {
        if (this._session) this._session.begin();
    }
    /**
     * Closes the underlying amqp session in rhea if open. Also removes all the event
     * handlers added in the rhea-promise library on the session
     * @param options A set of options including a signal used to cancel the operation.
     * When the abort signal in the options is fired, the local endpoint is closed.
     * This does not guarantee that the remote has closed as well. It only stops listening for
     * an acknowledgement that the remote endpoint is closed as well.
     * @return {Promise<void>} Promise<void>
     * - **Resolves** the promise when rhea emits the "session_close" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "session_error" event while trying
     * to close an amqp session or with an AbortError if the operation was cancelled.
     */ close(options) {
        return $9187fda58d09cc70$export$1050f835b63b671e(this, void 0, void 0, function*() {
            const closePromise = new Promise((resolve, reject)=>{
                $24379bbde9c43e27$exports.error("[%s] The amqp session '%s' is open ? -> %s", this.connection.id, this.id, this.isOpen());
                if (this.isOpen()) {
                    let onError;
                    let onClose;
                    let onDisconnected;
                    let onAbort;
                    const abortSignal = options && options.abortSignal;
                    let waitTimer;
                    const removeListeners = ()=>{
                        clearTimeout(waitTimer);
                        this.actionInitiated--;
                        this._session.removeListener($c1c4913cc434c78b$exports.SessionEvents.sessionError, onError);
                        this._session.removeListener($c1c4913cc434c78b$exports.SessionEvents.sessionClose, onClose);
                        this._session.connection.removeListener($c1c4913cc434c78b$exports.ConnectionEvents.disconnected, onDisconnected);
                        if (abortSignal) abortSignal.removeEventListener("abort", onAbort);
                    };
                    onClose = (context)=>{
                        removeListeners();
                        $24379bbde9c43e27$exports.session("[%s] Resolving the promise as the amqp session '%s' has been closed.", this.connection.id, this.id);
                        return resolve();
                    };
                    onError = (context)=>{
                        removeListeners();
                        $24379bbde9c43e27$exports.error("[%s] Error occurred while closing amqp session '%s'.", this.connection.id, this.id, context.session.error);
                        reject(context.session.error);
                    };
                    onDisconnected = (context)=>{
                        removeListeners();
                        const error = context.connection && context.connection.error ? context.connection.error : context.error;
                        $24379bbde9c43e27$exports.error("[%s] Connection got disconnected while closing amqp session '%s': %O.", this.connection.id, this.id, error);
                    };
                    onAbort = ()=>{
                        removeListeners();
                        const err = $5627de30fb34dc3f$exports.createAbortError();
                        $24379bbde9c43e27$exports.error("[%s] [%s]", this.connection.id, err.message);
                        return reject(err);
                    };
                    const actionAfterTimeout = ()=>{
                        removeListeners();
                        const msg = `Unable to close the amqp session ${this.id} due to operation timeout.`;
                        $24379bbde9c43e27$exports.error("[%s] %s", this.connection.id, msg);
                        reject(new $05c322d0dbecfcc0$exports.OperationTimeoutError(msg));
                    };
                    // listeners that we add for completing the operation are added directly to rhea's objects.
                    this._session.once($c1c4913cc434c78b$exports.SessionEvents.sessionClose, onClose);
                    this._session.once($c1c4913cc434c78b$exports.SessionEvents.sessionError, onError);
                    this._session.connection.once($c1c4913cc434c78b$exports.ConnectionEvents.disconnected, onDisconnected);
                    $24379bbde9c43e27$exports.session("[%s] Calling session.close() for amqp session '%s'.", this.connection.id, this.id);
                    waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
                    this._session.close();
                    this.actionInitiated++;
                    if (abortSignal) {
                        if (abortSignal.aborted) onAbort();
                        else abortSignal.addEventListener("abort", onAbort);
                    }
                } else return resolve();
            });
            try {
                yield closePromise;
            } finally{
                this.removeAllListeners();
            }
        });
    }
    /**
     * Creates an amqp receiver on this session.
     * @param session The amqp session object on which the receiver link needs to be established.
     * @param options Options that can be provided while creating an amqp receiver.
     * @return Promise<Receiver>
     * - **Resolves** the promise with the Receiver object when rhea emits the "receiver_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "receiver_close" event while trying
     * to create an amqp receiver or the operation timeout occurs.
     */ createReceiver(options) {
        return new Promise((resolve, reject)=>{
            if (options && (options.onMessage && !options.onError || options.onError && !options.onMessage)) {
                if (options.credit_window !== 0) // - If the 'onMessage' handler is not provided and the credit_window is not set to 0,
                // then messages may be lost between the receiver link getting created and the message
                // handler being attached.
                // - It can be possible for a service to initially accept the link attach, which would
                // cause the promise to resolve. However, moments later the service may send a detach
                // due to some internal or configuration issue. If no error handler is attached, then
                // the error may fall through.
                // - Hence it is advised to either provide both 'onMessage' and 'onError' handlers, or
                // please set the credit_window to `0`, if you want to provide only the 'onError' handler.
                return reject(new Error("Either provide both 'onMessage' and 'onError' handlers, or please set the credit_window to 0, if you want to provide only the 'onError' handler. This ensures no messages are lost between the receiver getting created  and the 'onMessage' handler being added."));
            }
            const abortSignal = options && options.abortSignal;
            let onAbort;
            if (abortSignal) {
                const rejectOnAbort = ()=>{
                    const err = $5627de30fb34dc3f$exports.createAbortError();
                    $24379bbde9c43e27$exports.error("[%s] [%s]", this.connection.id, err.message);
                    return reject(err);
                };
                onAbort = ()=>{
                    removeListeners();
                    if (rheaReceiver.is_open()) // This scenario *shouldn't* be possible because if `is_open()` returns true,
                    // our `onOpen` handler should have executed and removed this abort listener.
                    // This is a 'just in case' check in case the operation was cancelled sometime
                    // between when the receiver's state was updated and when the receiverOpen
                    // event was handled.
                    rheaReceiver.close();
                    else if (!rheaReceiver.is_closed()) // If the rheaReceiver isn't closed, then it's possible the peer will still
                    // attempt to attach the link and open our receiver.
                    // We can detect that if it occurs and close our receiver.
                    rheaReceiver.once($c1c4913cc434c78b$exports.ReceiverEvents.receiverOpen, ()=>{
                        rheaReceiver.close();
                    });
                    return rejectOnAbort();
                };
                if (abortSignal.aborted) // Exit early before we do any work.
                return rejectOnAbort();
                else abortSignal.addEventListener("abort", onAbort);
            }
            // Register session handlers for session_error and session_close if provided.
            // listeners provided by the user in the options object should be added
            // to our (rhea-promise) object.
            if (options && options.onSessionError) {
                this.on($c1c4913cc434c78b$exports.SessionEvents.sessionError, options.onSessionError);
                $24379bbde9c43e27$exports.session("[%s] Added event handler for event '%s' on rhea-promise 'session: %s', while creating the 'receiver'.", this.connection.id, $c1c4913cc434c78b$exports.SessionEvents.sessionError, this.id);
            }
            if (options && options.onSessionClose) {
                this.on($c1c4913cc434c78b$exports.SessionEvents.sessionClose, options.onSessionClose);
                $24379bbde9c43e27$exports.session("[%s] Added event handler for event '%s' on rhea-promise 'session: %s',  while creating the 'receiver'.", this.connection.id, $c1c4913cc434c78b$exports.SessionEvents.sessionClose, this.id);
            }
            const rheaReceiver = this._session.attach_receiver(options);
            const receiver = new $f1a9f106b246a2d2$exports.Receiver(this, rheaReceiver, options);
            receiver.actionInitiated++;
            let onOpen;
            let onClose;
            let onDisconnected;
            let waitTimer;
            if (options && options.onMessage) {
                receiver.on($c1c4913cc434c78b$exports.ReceiverEvents.message, options.onMessage);
                $24379bbde9c43e27$exports.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, $c1c4913cc434c78b$exports.ReceiverEvents.message);
            }
            if (options && options.onError) {
                receiver.on($c1c4913cc434c78b$exports.ReceiverEvents.receiverError, options.onError);
                $24379bbde9c43e27$exports.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, $c1c4913cc434c78b$exports.ReceiverEvents.receiverError);
            }
            if (options && options.onClose) {
                receiver.on($c1c4913cc434c78b$exports.ReceiverEvents.receiverClose, options.onClose);
                $24379bbde9c43e27$exports.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, $c1c4913cc434c78b$exports.ReceiverEvents.receiverClose);
            }
            if (options && options.onSettled) {
                receiver.on($c1c4913cc434c78b$exports.ReceiverEvents.settled, options.onSettled);
                $24379bbde9c43e27$exports.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, $c1c4913cc434c78b$exports.ReceiverEvents.settled);
            }
            const removeListeners = ()=>{
                clearTimeout(waitTimer);
                receiver.actionInitiated--;
                rheaReceiver.removeListener($c1c4913cc434c78b$exports.ReceiverEvents.receiverOpen, onOpen);
                rheaReceiver.removeListener($c1c4913cc434c78b$exports.ReceiverEvents.receiverClose, onClose);
                rheaReceiver.session.connection.removeListener($c1c4913cc434c78b$exports.ConnectionEvents.disconnected, onDisconnected);
                if (abortSignal) abortSignal.removeEventListener("abort", onAbort);
            };
            onOpen = (context)=>{
                removeListeners();
                $24379bbde9c43e27$exports.receiver("[%s] Resolving the promise with amqp receiver '%s' on amqp session '%s'.", this.connection.id, receiver.name, this.id);
                return resolve(receiver);
            };
            onClose = (context)=>{
                removeListeners();
                $24379bbde9c43e27$exports.error("[%s] Error occurred while creating the amqp receiver '%s' on amqp session '%s' over amqp connection: %O.", this.connection.id, receiver.name, this.id, context.receiver.error);
                return reject(context.receiver.error);
            };
            onDisconnected = (context)=>{
                removeListeners();
                const error = context.connection && context.connection.error ? context.connection.error : context.error;
                $24379bbde9c43e27$exports.error("[%s] Connection got disconnected while creating amqp receiver '%s' on amqp session '%s': %O.", this.connection.id, receiver.name, this.id, error);
                return reject(error);
            };
            const actionAfterTimeout = ()=>{
                removeListeners();
                const msg = `Unable to create the amqp receiver '${receiver.name}' on amqp ` + `session '${this.id}' due to operation timeout.`;
                $24379bbde9c43e27$exports.error("[%s] %s", this.connection.id, msg);
                return reject(new $05c322d0dbecfcc0$exports.OperationTimeoutError(msg));
            };
            // listeners that we add for completing the operation are added directly to rhea's objects.
            rheaReceiver.once($c1c4913cc434c78b$exports.ReceiverEvents.receiverOpen, onOpen);
            rheaReceiver.once($c1c4913cc434c78b$exports.ReceiverEvents.receiverClose, onClose);
            rheaReceiver.session.connection.on($c1c4913cc434c78b$exports.ConnectionEvents.disconnected, onDisconnected);
            waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
        });
    }
    /**
     * Creates an amqp sender on this session.
     * @param options Options that can be provided while creating an amqp sender.
     * @return Promise<Sender>
     * - **Resolves** the promise with the Sender object when rhea emits the "sender_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "sender_close" event while trying
     * to create an amqp sender or the operation timeout occurs.
     */ createSender(options) {
        return this._createSender($ce07c524c8dd1ce0$var$SenderType.sender, options);
    }
    /**
     * Creates an awaitable amqp sender on this session.
     * @param options Options that can be provided while creating an async amqp sender.
     * - If `onError` and `onSessionError` handlers are not provided then the `AwaitableSender` will
     * clear the timer and reject the Promise for all the entries of inflight send operation in its
     * `deliveryDispositionMap`.
     * - If the user is handling the reconnection of sender link or the underlying connection in it's
     * app, then the `onError` and `onSessionError` handlers must be provided by the user and (s)he
     * shall be responsible of clearing the `deliveryDispotionMap` of inflight `send()` operation.
     *
     * @return Promise<AwaitableSender>
     * - **Resolves** the promise with the Sender object when rhea emits the "sender_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "sender_close" event while trying
     * to create an amqp sender or the operation timeout occurs.
     */ createAwaitableSender(options) {
        return this._createSender($ce07c524c8dd1ce0$var$SenderType.AwaitableSender, options);
    }
    /**
     * Creates the Sender based on the provided type.
     * @internal
     * @param type The type of sender
     * @param options Options to be provided while creating the sender.
     */ _createSender(type, options) {
        return new Promise((resolve, reject)=>{
            const abortSignal = options && options.abortSignal;
            let onAbort;
            if (abortSignal) {
                const rejectOnAbort = ()=>{
                    const err = $5627de30fb34dc3f$exports.createAbortError();
                    $24379bbde9c43e27$exports.error("[%s] [%s]", this.connection.id, err.message);
                    return reject(err);
                };
                onAbort = ()=>{
                    removeListeners();
                    if (rheaSender.is_open()) // This scenario *shouldn't* be possible because if `is_open()` returns true,
                    // our `onOpen` handler should have executed and removed this abort listener.
                    // This is a 'just in case' check in case the operation was cancelled sometime
                    // between when the sender's state was updated and when the senderOpen
                    // event was handled.
                    rheaSender.close();
                    else if (!rheaSender.is_closed()) // If the rheaSender isn't closed, then it's possible the peer will still
                    // attempt to attach the link and open our sender.
                    // We can detect that if it occurs and close our sender.
                    rheaSender.once($c1c4913cc434c78b$exports.SenderEvents.senderOpen, ()=>{
                        rheaSender.close();
                    });
                    return rejectOnAbort();
                };
                if (abortSignal.aborted) // Exit early before we do any work.
                return rejectOnAbort();
                else abortSignal.addEventListener("abort", onAbort);
            }
            // Register session handlers for session_error and session_close if provided.
            if (options && options.onSessionError) {
                this.on($c1c4913cc434c78b$exports.SessionEvents.sessionError, options.onSessionError);
                $24379bbde9c43e27$exports.session("[%s] Added event handler for event '%s' on rhea-promise 'session: %s', while creating the sender.", this.connection.id, $c1c4913cc434c78b$exports.SessionEvents.sessionError, this.id);
            }
            if (options && options.onSessionClose) {
                this.on($c1c4913cc434c78b$exports.SessionEvents.sessionClose, options.onSessionClose);
                $24379bbde9c43e27$exports.session("[%s] Added event handler for event '%s' on rhea-promise 'session: %s', while creating the sender.", this.connection.id, $c1c4913cc434c78b$exports.SessionEvents.sessionClose, this.id);
            }
            const rheaSender = this._session.attach_sender(options);
            let sender;
            if (type === $ce07c524c8dd1ce0$var$SenderType.sender) sender = new $a80de3f150cffa79$exports.Sender(this, rheaSender, options);
            else sender = new $e59ccf10e6a216b6$exports.AwaitableSender(this, rheaSender, options);
            sender.actionInitiated++;
            let onSendable;
            let onClose;
            let onDisconnected;
            let waitTimer;
            // listeners provided by the user in the options object should be added
            // to our (rhea-promise) object.
            if (options) {
                if (options.onError) sender.on($c1c4913cc434c78b$exports.SenderEvents.senderError, options.onError);
                if (options.onClose) sender.on($c1c4913cc434c78b$exports.SenderEvents.senderClose, options.onClose);
                if (type === $ce07c524c8dd1ce0$var$SenderType.sender) {
                    if (options.onAccepted) sender.on($c1c4913cc434c78b$exports.SenderEvents.accepted, options.onAccepted);
                    if (options.onRejected) sender.on($c1c4913cc434c78b$exports.SenderEvents.rejected, options.onRejected);
                    if (options.onReleased) sender.on($c1c4913cc434c78b$exports.SenderEvents.released, options.onReleased);
                    if (options.onModified) sender.on($c1c4913cc434c78b$exports.SenderEvents.modified, options.onModified);
                }
            }
            const removeListeners = ()=>{
                clearTimeout(waitTimer);
                sender.actionInitiated--;
                rheaSender.removeListener($c1c4913cc434c78b$exports.SenderEvents.senderOpen, onSendable);
                rheaSender.removeListener($c1c4913cc434c78b$exports.SenderEvents.senderClose, onClose);
                rheaSender.session.connection.removeListener($c1c4913cc434c78b$exports.ConnectionEvents.disconnected, onDisconnected);
                if (abortSignal) abortSignal.removeEventListener("abort", onAbort);
            };
            onSendable = (context)=>{
                removeListeners();
                $24379bbde9c43e27$exports.sender("[%s] Resolving the promise with amqp sender '%s' on amqp session '%s'.", this.connection.id, sender.name, this.id);
                return resolve(sender);
            };
            onClose = (context)=>{
                removeListeners();
                $24379bbde9c43e27$exports.error("[%s] Error occurred while creating the amqp sender '%s' on amqp session '%s' over amqp connection: %O.", this.connection.id, sender.name, this.id, context.sender.error);
                return reject(context.sender.error);
            };
            onDisconnected = (context)=>{
                removeListeners();
                const error = context.connection && context.connection.error ? context.connection.error : context.error;
                $24379bbde9c43e27$exports.error("[%s] Connection got disconnected while creating amqp sender '%s' on amqp session '%s': %O.", this.connection.id, sender.name, this.id, error);
                return reject(error);
            };
            const actionAfterTimeout = ()=>{
                removeListeners();
                const msg = `Unable to create the amqp sender '${sender.name}' on amqp session ` + `'${this.id}' due to operation timeout.`;
                $24379bbde9c43e27$exports.error("[%s] %s", this.connection.id, msg);
                return reject(new $05c322d0dbecfcc0$exports.OperationTimeoutError(msg));
            };
            // listeners that we add for completing the operation are added directly to rhea's objects.
            rheaSender.once($c1c4913cc434c78b$exports.SenderEvents.sendable, onSendable);
            rheaSender.once($c1c4913cc434c78b$exports.SenderEvents.senderClose, onClose);
            rheaSender.session.connection.on($c1c4913cc434c78b$exports.ConnectionEvents.disconnected, onDisconnected);
            waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
        });
    }
    /**
     * Adds event listeners for the possible events that can occur on the session object and
     * re-emits the same event back with the received arguments from rhea's event emitter.
     * @private
     * @returns {void} void
     */ _initializeEventListeners() {
        for (const eventName of Object.keys($c1c4913cc434c78b$exports.SessionEvents))this._session.on($c1c4913cc434c78b$exports.SessionEvents[eventName], (context)=>{
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: $c1c4913cc434c78b$exports.SessionEvents[eventName],
                emitterType: "session",
                connectionId: this.connection.id
            };
            $5627de30fb34dc3f$exports.emitEvent(params);
        });
        // Add event handlers for *_error and *_close events that can be propagated to the session
        // object, if they are not handled at their level. * denotes - Sender and Receiver.
        // Sender
        this._session.on($c1c4913cc434c78b$exports.SenderEvents.senderError, (context)=>{
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: $c1c4913cc434c78b$exports.SenderEvents.senderError,
                emitterType: "session",
                connectionId: this.connection.id
            };
            $5627de30fb34dc3f$exports.emitEvent(params);
        });
        this._session.on($c1c4913cc434c78b$exports.SenderEvents.senderClose, (context)=>{
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: $c1c4913cc434c78b$exports.SenderEvents.senderClose,
                emitterType: "session",
                connectionId: this.connection.id
            };
            $5627de30fb34dc3f$exports.emitEvent(params);
        });
        // Receiver
        this._session.on($c1c4913cc434c78b$exports.ReceiverEvents.receiverError, (context)=>{
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: $c1c4913cc434c78b$exports.ReceiverEvents.receiverError,
                emitterType: "session",
                connectionId: this.connection.id
            };
            $5627de30fb34dc3f$exports.emitEvent(params);
        });
        this._session.on($c1c4913cc434c78b$exports.ReceiverEvents.receiverClose, (context)=>{
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: $c1c4913cc434c78b$exports.ReceiverEvents.receiverClose,
                emitterType: "session",
                connectionId: this.connection.id
            };
            $5627de30fb34dc3f$exports.emitEvent(params);
        });
        if (typeof this._session.eventNames === "function") $24379bbde9c43e27$exports.eventHandler("[%s] rhea-promise 'session' object '%s' is listening for events: %o emitted by rhea's 'session' object.", this.connection.id, this.id, this._session.eventNames());
    }
}
$ce07c524c8dd1ce0$exports.Session = $ce07c524c8dd1ce0$var$Session;


var $f362171d99100c10$exports = {};
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty($f362171d99100c10$exports, "__esModule", {
    value: true
});




/**
 * An AMQP container from which outgoing connections can be made and/or
 * to which incoming connections can be accepted.
 * @class Container
 */ class $f362171d99100c10$var$Container extends $ac8e2c1b8bfc4b37$exports.EventEmitter {
    constructor(options){
        if (!options) options = {};
        super();
        if (options.createdInstance) {
            this._container = options.createdInstance;
            delete options.createdInstance;
        } else this._container = $c1c4913cc434c78b$exports.create_container(options);
        this.options = this._container.options;
    }
    get id() {
        return this._container.id;
    }
    get filter() {
        return this._container.filter;
    }
    get types() {
        return this._container.types;
    }
    get message() {
        return this._container.message;
    }
    get sasl() {
        return this._container.sasl;
    }
    get saslServerMechanisms() {
        return this._container.sasl_server_mechanisms;
    }
    createConnection(options) {
        const rheaConnection = this._container.create_connection(options);
        return new $e4e83c0ff1ef0b2b$exports.Connection({
            rheaConnection: rheaConnection,
            container: this
        });
    }
    connect(options) {
        return $9187fda58d09cc70$export$1050f835b63b671e(this, void 0, void 0, function*() {
            return this.createConnection(options).open();
        });
    }
    listen(options) {
        return this._container.listen(options);
    }
    generateUUid() {
        return this._container.generate_uuid();
    }
    stringToUuid(uuidString) {
        return this._container.string_to_uuid(uuidString);
    }
    uuidToString(buffer) {
        return this._container.uuid_to_string(buffer);
    }
    websocketAccept(socket, options) {
        return this._container.websocket_accept(socket, options);
    }
    websocketConnect(impl) {
        return this._container.websocket_connect(impl);
    }
    static create(options) {
        return new $f362171d99100c10$var$Container(options);
    }
    static copyFromContainerInstance(instance) {
        return new $f362171d99100c10$var$Container({
            createdInstance: instance
        });
    }
}
$f362171d99100c10$exports.Container = $f362171d99100c10$var$Container;


var $29a484178ac0f5d9$exports = {};
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License. See License in the project root for license information.
Object.defineProperty($29a484178ac0f5d9$exports, "__esModule", {
    value: true
});
/**
 * Describes the default operation timeout in seconds. Value: `60`.
 */ $29a484178ac0f5d9$exports.defaultOperationTimeoutInSeconds = 60;






// Determines whether the given object is a CreatedRheConnectionOptions object.
function $e4e83c0ff1ef0b2b$var$isCreatedRheaConnectionOptions(obj) {
    return obj && typeof obj.container === "object" && typeof obj.rheaConnection === "object";
}
/**
 * Describes the AMQP Connection.
 * @class Connection
 */ class $e4e83c0ff1ef0b2b$var$Connection extends $3332e8ae2d20663f$exports.Entity {
    /**
     * Creates an instance of the Connection object.
     * @constructor
     * @param {Connection} _connection The connection object from rhea library.
     */ constructor(options){
        super();
        if (!options) options = {};
        if (options.operationTimeoutInSeconds == undefined) options.operationTimeoutInSeconds = $29a484178ac0f5d9$exports.defaultOperationTimeoutInSeconds;
        if ($e4e83c0ff1ef0b2b$var$isCreatedRheaConnectionOptions(options)) {
            this._connection = options.rheaConnection;
            this.container = options.container;
        } else {
            const connectionOptions = options;
            if (connectionOptions.webSocketOptions) {
                const ws = $c1c4913cc434c78b$exports.websocket_connect(connectionOptions.webSocketOptions.webSocket);
                connectionOptions.connection_details = ws(connectionOptions.webSocketOptions.url, connectionOptions.webSocketOptions.protocol, connectionOptions.webSocketOptions.options);
            }
            this._connection = $c1c4913cc434c78b$exports.create_connection(connectionOptions);
            this.container = $f362171d99100c10$exports.Container.copyFromContainerInstance(this._connection.container);
        }
        this.options = this._connection.options;
        this.options.operationTimeoutInSeconds = options.operationTimeoutInSeconds;
        this._initializeEventListeners();
    }
    /**
     * @property {string} id Returns the connection id.
     * @readonly
     */ get id() {
        return this._connection.options.id;
    }
    /**
     * @property {Dictionary<any> | undefined} [properties] Provides the connection properties.
     * @readonly
     */ get properties() {
        return this._connection.properties;
    }
    /**
     * @property {number | undefined} [maxFrameSize] Provides the max frame size.
     * @readonly
     */ get maxFrameSize() {
        return this._connection.max_frame_size;
    }
    /**
     * @property {number | undefined} [idleTimeout] Provides the idle timeout for the connection.
     * @readonly
     */ get idleTimeout() {
        return this._connection.idle_time_out;
    }
    /**
     * @property {number | undefined} [channelMax] Provides the maximum number of channels supported.
     * @readonly
     */ get channelMax() {
        return this._connection.channel_max;
    }
    /**
     * @property {AmqpError | Error | undefined} [error] Provides the last error that occurred on the
     * connection.
     */ get error() {
        return this._connection.error;
    }
    /**
     * Removes the provided session from the internal map in rhea.
     * Also removes all the event handlers added in the rhea-promise library on the provided session.
     * @param {Session} session The session to be removed.
     */ removeSession(session) {
        return session.remove();
    }
    /**
     * Creates a new amqp connection.
     * @param options A set of options including a signal used to cancel the operation.
     * @return {Promise<Connection>} Promise<Connection>
     * - **Resolves** the promise with the Connection object when rhea emits the "connection_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "connection_close" event
     * while trying to establish an amqp connection or with an AbortError if the operation was cancelled.
     */ open(options) {
        return new Promise((resolve, reject)=>{
            if (!this.isOpen()) {
                let onOpen;
                let onClose;
                let onAbort;
                const abortSignal = options && options.abortSignal;
                let waitTimer;
                const removeListeners = ()=>{
                    clearTimeout(waitTimer);
                    this.actionInitiated--;
                    this._connection.removeListener($c1c4913cc434c78b$exports.ConnectionEvents.connectionOpen, onOpen);
                    this._connection.removeListener($c1c4913cc434c78b$exports.ConnectionEvents.connectionClose, onClose);
                    this._connection.removeListener($c1c4913cc434c78b$exports.ConnectionEvents.disconnected, onClose);
                    if (abortSignal) abortSignal.removeEventListener("abort", onAbort);
                };
                onOpen = (context)=>{
                    removeListeners();
                    $24379bbde9c43e27$exports.connection("[%s] Resolving the promise with amqp connection.", this.id);
                    return resolve(this);
                };
                onClose = (context)=>{
                    removeListeners();
                    const err = context.error || context.connection.error || Error("Failed to connect");
                    $24379bbde9c43e27$exports.error("[%s] Error occurred while establishing amqp connection: %O", this.id, err);
                    return reject(err);
                };
                onAbort = ()=>{
                    removeListeners();
                    this._connection.close();
                    const err = $5627de30fb34dc3f$exports.createAbortError();
                    $24379bbde9c43e27$exports.error("[%s] [%s]", this.id, err.message);
                    return reject(err);
                };
                const actionAfterTimeout = ()=>{
                    removeListeners();
                    const msg = `Unable to open the amqp connection "${this.id}" due to operation timeout.`;
                    $24379bbde9c43e27$exports.error("[%s] %s", this.id, msg);
                    return reject(new Error(msg));
                };
                // listeners that we add for completing the operation are added directly to rhea's objects.
                this._connection.once($c1c4913cc434c78b$exports.ConnectionEvents.connectionOpen, onOpen);
                this._connection.once($c1c4913cc434c78b$exports.ConnectionEvents.connectionClose, onClose);
                this._connection.once($c1c4913cc434c78b$exports.ConnectionEvents.disconnected, onClose);
                waitTimer = setTimeout(actionAfterTimeout, this.options.operationTimeoutInSeconds * 1000);
                $24379bbde9c43e27$exports.connection("[%s] Trying to create a new amqp connection.", this.id);
                this._connection.connect();
                this.actionInitiated++;
                if (abortSignal) {
                    if (abortSignal.aborted) onAbort();
                    else abortSignal.addEventListener("abort", onAbort);
                }
            } else return resolve(this);
        });
    }
    /**
     * Closes the amqp connection.
     * @param options A set of options including a signal used to cancel the operation.
     * When the abort signal in the options is fired, the local endpoint is closed.
     * This does not guarantee that the remote has closed as well. It only stops listening for
     * an acknowledgement that the remote endpoint is closed as well.
     * @return {Promise<void>} Promise<void>
     * - **Resolves** the promise when rhea emits the "connection_close" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "connection_error" event while
     * trying to close an amqp connection or with an AbortError if the operation was cancelled.
     */ close(options) {
        return new Promise((resolve, reject)=>{
            $24379bbde9c43e27$exports.error("[%s] The connection is open ? -> %s", this.id, this.isOpen());
            if (this.isOpen()) {
                let onClose;
                let onError;
                let onDisconnected;
                let onAbort;
                const abortSignal = options && options.abortSignal;
                let waitTimer;
                const removeListeners = ()=>{
                    clearTimeout(waitTimer);
                    this.actionInitiated--;
                    this._connection.removeListener($c1c4913cc434c78b$exports.ConnectionEvents.connectionError, onError);
                    this._connection.removeListener($c1c4913cc434c78b$exports.ConnectionEvents.connectionClose, onClose);
                    this._connection.removeListener($c1c4913cc434c78b$exports.ConnectionEvents.disconnected, onDisconnected);
                    if (abortSignal) abortSignal.removeEventListener("abort", onAbort);
                };
                onClose = (context)=>{
                    removeListeners();
                    $24379bbde9c43e27$exports.connection("[%s] Resolving the promise as the connection has been successfully closed.", this.id);
                    return resolve();
                };
                onError = (context)=>{
                    removeListeners();
                    $24379bbde9c43e27$exports.error("[%s] Error occurred while closing amqp connection: %O.", this.id, context.connection.error);
                    return reject(context.connection.error);
                };
                onDisconnected = (context)=>{
                    removeListeners();
                    const error = context.connection && context.connection.error ? context.connection.error : context.error;
                    $24379bbde9c43e27$exports.error("[%s] Connection got disconnected while closing itself: %O.", this.id, error);
                };
                onAbort = ()=>{
                    removeListeners();
                    const err = $5627de30fb34dc3f$exports.createAbortError();
                    $24379bbde9c43e27$exports.error("[%s] [%s]", this.id, err.message);
                    return reject(err);
                };
                const actionAfterTimeout = ()=>{
                    removeListeners();
                    const msg = `Unable to close the amqp connection "${this.id}" due to operation timeout.`;
                    $24379bbde9c43e27$exports.error("[%s] %s", this.id, msg);
                    return reject(new Error(msg));
                };
                // listeners that we add for completing the operation are added directly to rhea's objects.
                this._connection.once($c1c4913cc434c78b$exports.ConnectionEvents.connectionClose, onClose);
                this._connection.once($c1c4913cc434c78b$exports.ConnectionEvents.connectionError, onError);
                this._connection.once($c1c4913cc434c78b$exports.ConnectionEvents.disconnected, onDisconnected);
                waitTimer = setTimeout(actionAfterTimeout, this.options.operationTimeoutInSeconds * 1000);
                this._connection.close();
                this.actionInitiated++;
                if (abortSignal) {
                    if (abortSignal.aborted) onAbort();
                    else abortSignal.addEventListener("abort", onAbort);
                }
            } else return resolve();
        });
    }
    /**
     * Determines whether the connection is open.
     * @returns {boolean} result `true` - is open; `false` otherwise.
     */ isOpen() {
        let result = false;
        if (this._connection && this._connection.is_open && this._connection.is_open()) result = true;
        return result;
    }
    /**
     * Clears all the amqp sessions from the internal map maintained in rhea. This does not remove any
     * of the event handlers added in the rhea-promise library. To clear such event handlers, either
     * call remove() or close() on each session
     */ removeAllSessions() {
        if (this._connection) this._connection.remove_all_sessions();
    }
    /**
     * Determines whether the remote end of the connection is open.
     * @returns {boolean} result `true` - is open; `false` otherwise.
     */ isRemoteOpen() {
        return this._connection.is_remote_open();
    }
    /**
     * Gets the connection error if present.
     * @returns {ConnectionError | undefined} ConnectionError | undefined
     */ getError() {
        return this._connection.get_error();
    }
    /**
     * Gets the peer certificate if present.
     * @returns {PeerCertificate | undefined} PeerCertificate | undefined
     */ getPeerCertificate() {
        return this._connection.get_peer_certificate();
    }
    /**
     * Gets the tls socket if present.
     * @returns {Socket | undefined} Socket | undefined
     */ getTlsSocket() {
        return this._connection.get_tls_socket();
    }
    /**
     * Determines whether the close from the peer is a response to a locally initiated close request
     * for the connection.
     * @returns {boolean} `true` if close was locally initiated, `false` otherwise.
     */ wasCloseInitiated() {
        return this._connection.is_closed();
    }
    /**
     * Creates an amqp session on the provided amqp connection.
     * @param options A set of options including a signal used to cancel the operation.
     * @return {Promise<Session>} Promise<Session>
     * - **Resolves** the promise with the Session object when rhea emits the "session_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "session_close" event while
     * trying to create an amqp session or with an AbortError if the operation was cancelled.
     */ createSession(options) {
        return new Promise((resolve, reject)=>{
            const abortSignal = options && options.abortSignal;
            let onAbort;
            if (abortSignal) {
                const rejectOnAbort = ()=>{
                    const err = $5627de30fb34dc3f$exports.createAbortError();
                    $24379bbde9c43e27$exports.error("[%s] [%s]", this.id, err.message);
                    return reject(err);
                };
                onAbort = ()=>{
                    removeListeners();
                    if (rheaSession.is_open()) // This scenario *shouldn't* be possible because if `is_open()` returns true,
                    // our `onOpen` handler should have executed and removed this abort listener.
                    // This is a 'just in case' check in case the operation was cancelled sometime
                    // between when the session's state was updated and when the sessionOpen
                    // event was handled.
                    rheaSession.close();
                    else if (!rheaSession.is_closed()) // If the rheaSession isn't closed, then it's possible the peer will still
                    // attempt to begin the session.
                    // We can detect that if it occurs and close our session.
                    rheaSession.once($c1c4913cc434c78b$exports.SessionEvents.sessionOpen, ()=>{
                        rheaSession.close();
                    });
                    return rejectOnAbort();
                };
                if (abortSignal.aborted) // Exit early before we do any work.
                return rejectOnAbort();
                else abortSignal.addEventListener("abort", onAbort);
            }
            const rheaSession = this._connection.create_session();
            const session = new $ce07c524c8dd1ce0$exports.Session(this, rheaSession);
            session.actionInitiated++;
            let onOpen;
            let onClose;
            let onDisconnected;
            let waitTimer;
            const removeListeners = ()=>{
                clearTimeout(waitTimer);
                session.actionInitiated--;
                rheaSession.removeListener($c1c4913cc434c78b$exports.SessionEvents.sessionOpen, onOpen);
                rheaSession.removeListener($c1c4913cc434c78b$exports.SessionEvents.sessionClose, onClose);
                rheaSession.connection.removeListener($c1c4913cc434c78b$exports.ConnectionEvents.disconnected, onDisconnected);
                if (abortSignal) abortSignal.removeEventListener("abort", onAbort);
            };
            onOpen = (context)=>{
                removeListeners();
                $24379bbde9c43e27$exports.session("[%s] Resolving the promise with amqp session '%s'.", this.id, session.id);
                return resolve(session);
            };
            onClose = (context)=>{
                removeListeners();
                $24379bbde9c43e27$exports.error("[%s] Error occurred while establishing a session over amqp connection: %O.", this.id, context.session.error);
                return reject(context.session.error);
            };
            onDisconnected = (context)=>{
                removeListeners();
                const error = context.connection && context.connection.error ? context.connection.error : context.error;
                $24379bbde9c43e27$exports.error("[%s] Connection got disconnected while creating amqp session '%s': %O.", this.id, session.id, error);
                return reject(error);
            };
            const actionAfterTimeout = ()=>{
                removeListeners();
                const msg = `Unable to create the amqp session due to operation timeout.`;
                $24379bbde9c43e27$exports.error("[%s] %s", this.id, msg);
                return reject(new $05c322d0dbecfcc0$exports.OperationTimeoutError(msg));
            };
            // listeners that we add for completing the operation are added directly to rhea's objects.
            rheaSession.once($c1c4913cc434c78b$exports.SessionEvents.sessionOpen, onOpen);
            rheaSession.once($c1c4913cc434c78b$exports.SessionEvents.sessionClose, onClose);
            rheaSession.connection.once($c1c4913cc434c78b$exports.ConnectionEvents.disconnected, onDisconnected);
            $24379bbde9c43e27$exports.session("[%s] Calling amqp session.begin().", this.id);
            waitTimer = setTimeout(actionAfterTimeout, this.options.operationTimeoutInSeconds * 1000);
            rheaSession.begin();
        });
    }
    /**
     * Creates an amqp sender link. It either uses the provided session or creates a new one.
     * - **Resolves** the promise with the Sender object when rhea emits the "sender_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "sender_close" event while
     * trying to create an amqp session or with an AbortError if the operation was cancelled.
     * @param {CreateSenderOptions} options Optional parameters to create a sender link.
     * @return {Promise<Sender>} Promise<Sender>.
     */ createSender(options) {
        return $9187fda58d09cc70$export$1050f835b63b671e(this, void 0, void 0, function*() {
            if (options && options.session && options.session.createSender) return options.session.createSender(options);
            const session = yield this.createSession({
                abortSignal: options && options.abortSignal
            });
            return session.createSender(options);
        });
    }
    /**
     * Creates an awaitable amqp sender. It either uses the provided session or creates a new one.
     * @param options Optional parameters to create an awaitable sender link.
     * - If `onError` and `onSessionError` handlers are not provided then the `AwaitableSender` will
     * clear the timer and reject the Promise for all the entries of inflight send operation in its
     * `deliveryDispositionMap`.
     * - If the user is handling the reconnection of sender link or the underlying connection in it's
     * app, then the `onError` and `onSessionError` handlers must be provided by the user and (s)he
     * shall be responsible of clearing the `deliveryDispositionMap` of inflight `send()` operation.
     *
     * @return Promise<AwaitableSender>.
     */ createAwaitableSender(options) {
        return $9187fda58d09cc70$export$1050f835b63b671e(this, void 0, void 0, function*() {
            if (options && options.session && options.session.createAwaitableSender) return options.session.createAwaitableSender(options);
            const session = yield this.createSession({
                abortSignal: options && options.abortSignal
            });
            return session.createAwaitableSender(options);
        });
    }
    /**
     * Creates an amqp receiver link. It either uses the provided session or creates a new one.
     * - **Resolves** the promise with the Sender object when rhea emits the "receiver_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "receiver_close" event while
     * trying to create an amqp session or with an AbortError if the operation was cancelled.
     * @param {CreateReceiverOptions} options Optional parameters to create a receiver link.
     * @return {Promise<Receiver>} Promise<Receiver>.
     */ createReceiver(options) {
        return $9187fda58d09cc70$export$1050f835b63b671e(this, void 0, void 0, function*() {
            if (options && options.session && options.session.createReceiver) return options.session.createReceiver(options);
            const session = yield this.createSession({
                abortSignal: options && options.abortSignal
            });
            return session.createReceiver(options);
        });
    }
    /**
     * Creates an amqp sender-receiver link. It either uses the provided session or creates a new one.
     * This method creates a sender-receiver link on the same session. It is useful for management
     * style operations where one may want to send a request and await for response.
     * @param {SenderOptions} senderOptions Parameters to create a sender.
     * @param {ReceiverOptions} receiverOptions Parameters to create a receiver.
     * @param {CreateRequestResponseLinkOptions} [options] Optional parameters to control how sender and receiver link creation.
     * @return {Promise<ReqResLink>} Promise<ReqResLink>
     */ createRequestResponseLink(senderOptions, receiverOptions, options = {}) {
        return $9187fda58d09cc70$export$1050f835b63b671e(this, void 0, void 0, function*() {
            if (!senderOptions) throw new Error(`Please provide sender options.`);
            if (!receiverOptions) throw new Error(`Please provide receiver options.`);
            const { session: providedSession , abortSignal: abortSignal  } = options;
            const session = providedSession || (yield this.createSession({
                abortSignal: abortSignal
            }));
            const [sender, receiver] = yield Promise.all([
                session.createSender(Object.assign({}, senderOptions, {
                    abortSignal: abortSignal
                })),
                session.createReceiver(Object.assign({}, receiverOptions, {
                    abortSignal: abortSignal
                }))
            ]);
            $24379bbde9c43e27$exports.connection("[%s] Successfully created the sender '%s' and receiver '%s' on the same amqp session '%s'.", this.id, sender.name, receiver.name, session.id);
            return {
                session: session,
                sender: sender,
                receiver: receiver
            };
        });
    }
    /**
     * Adds event listeners for the possible events that can occur on the connection object and
     * re-emits the same event back with the received arguments from rhea's event emitter.
     * @private
     * @returns {void} void
     */ _initializeEventListeners() {
        for (const eventName of Object.keys($c1c4913cc434c78b$exports.ConnectionEvents))this._connection.on($c1c4913cc434c78b$exports.ConnectionEvents[eventName], (context)=>{
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: $c1c4913cc434c78b$exports.ConnectionEvents[eventName],
                emitterType: "connection",
                connectionId: this.id
            };
            if ($c1c4913cc434c78b$exports.ConnectionEvents[eventName] === $c1c4913cc434c78b$exports.ConnectionEvents.protocolError) $24379bbde9c43e27$exports.connection("[%s] ProtocolError is: %O.", this.id, context);
            $5627de30fb34dc3f$exports.emitEvent(params);
        });
        // Add event handlers for *_error and *_close events that can be propagated to the connection
        // object, if they are not handled at their level. * denotes - Sender, Receiver, Session
        // Sender
        this._connection.on($c1c4913cc434c78b$exports.SenderEvents.senderError, (context)=>{
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: $c1c4913cc434c78b$exports.SenderEvents.senderError,
                emitterType: "connection",
                connectionId: this.id
            };
            $5627de30fb34dc3f$exports.emitEvent(params);
        });
        this._connection.on($c1c4913cc434c78b$exports.SenderEvents.senderClose, (context)=>{
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: $c1c4913cc434c78b$exports.SenderEvents.senderClose,
                emitterType: "connection",
                connectionId: this.id
            };
            $5627de30fb34dc3f$exports.emitEvent(params);
        });
        // Receiver
        this._connection.on($c1c4913cc434c78b$exports.ReceiverEvents.receiverError, (context)=>{
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: $c1c4913cc434c78b$exports.ReceiverEvents.receiverError,
                emitterType: "connection",
                connectionId: this.id
            };
            $5627de30fb34dc3f$exports.emitEvent(params);
        });
        this._connection.on($c1c4913cc434c78b$exports.ReceiverEvents.receiverClose, (context)=>{
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: $c1c4913cc434c78b$exports.ReceiverEvents.receiverClose,
                emitterType: "connection",
                connectionId: this.id
            };
            $5627de30fb34dc3f$exports.emitEvent(params);
        });
        // Session
        this._connection.on($c1c4913cc434c78b$exports.SessionEvents.sessionError, (context)=>{
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: $c1c4913cc434c78b$exports.SessionEvents.sessionError,
                emitterType: "connection",
                connectionId: this.id
            };
            $5627de30fb34dc3f$exports.emitEvent(params);
        });
        this._connection.on($c1c4913cc434c78b$exports.SessionEvents.sessionClose, (context)=>{
            const params = {
                rheaContext: context,
                emitter: this,
                eventName: $c1c4913cc434c78b$exports.SessionEvents.sessionClose,
                emitterType: "connection",
                connectionId: this.id
            };
            $5627de30fb34dc3f$exports.emitEvent(params);
        });
        if (typeof this._connection.eventNames === "function") $24379bbde9c43e27$exports.eventHandler("[%s] rhea-promise 'connection' object is listening for events: %o emitted by rhea's 'connection' object.", this.id, this._connection.eventNames());
    }
}
$e4e83c0ff1ef0b2b$exports.Connection = $e4e83c0ff1ef0b2b$var$Connection;





var $ace679c422ca35d4$var$EventContext;
(function(EventContext) {
    /**
     * Translates rhea's EventContext into rhea-promise EventContext
     * @param rheaContext The received context from rhea's event emitter
     * @param emitter The rhea-promise equivalent object that is supposed emit the same event
     * @param eventName The name of the event for which the context will be translated
     *
     * @returns EventContext The translated EventContext.
     */ function translate(rheaContext, emitter, eventName) {
        const connection = emitter instanceof $e4e83c0ff1ef0b2b$exports.Connection ? emitter : emitter.connection;
        $24379bbde9c43e27$exports.contextTranslator("[%s] Translating the context for event: '%s'.", connection.id, eventName);
        // initialize the result
        const result = Object.assign({
            _context: rheaContext
        }, rheaContext);
        // set rhea-promise connection and container
        result.connection = connection;
        result.container = connection.container;
        // set rhea-promise session, sender/receiver.
        if (emitter instanceof $0048c4b111559601$exports.Link) {
            result.session = emitter.session;
            if (emitter.type === $0048c4b111559601$exports.LinkType.receiver && rheaContext.receiver) result.receiver = emitter;
            else if (emitter.type === $0048c4b111559601$exports.LinkType.sender && rheaContext.sender) result.sender = emitter;
        } else if (emitter instanceof $ce07c524c8dd1ce0$exports.Session) result.session = emitter;
        return result;
    }
    EventContext.translate = translate;
})($ace679c422ca35d4$var$EventContext = $ace679c422ca35d4$exports.EventContext || ($ace679c422ca35d4$exports.EventContext = {}));


$4973e2e602c1cc10$exports.EventContext = $ace679c422ca35d4$exports.EventContext;

$4973e2e602c1cc10$exports.Container = $f362171d99100c10$exports.Container;

$4973e2e602c1cc10$exports.Connection = $e4e83c0ff1ef0b2b$exports.Connection;

$4973e2e602c1cc10$exports.Session = $ce07c524c8dd1ce0$exports.Session;

$4973e2e602c1cc10$exports.Receiver = $f1a9f106b246a2d2$exports.Receiver;

$4973e2e602c1cc10$exports.Sender = $a80de3f150cffa79$exports.Sender;
$4973e2e602c1cc10$exports.SenderSendOptions = $a80de3f150cffa79$exports.SenderSendOptions;

$4973e2e602c1cc10$exports.AwaitableSender = $e59ccf10e6a216b6$exports.AwaitableSender;

$4973e2e602c1cc10$exports.AmqpResponseStatusCode = $5627de30fb34dc3f$exports.AmqpResponseStatusCode;
$4973e2e602c1cc10$exports.isAmqpError = $5627de30fb34dc3f$exports.isAmqpError;
$4973e2e602c1cc10$exports.delay = $5627de30fb34dc3f$exports.delay;
$4973e2e602c1cc10$exports.messageHeader = $5627de30fb34dc3f$exports.messageHeader;
$4973e2e602c1cc10$exports.messageProperties = $5627de30fb34dc3f$exports.messageProperties;
$4973e2e602c1cc10$exports.parseConnectionString = $5627de30fb34dc3f$exports.parseConnectionString;

$4973e2e602c1cc10$exports.InsufficientCreditError = $05c322d0dbecfcc0$exports.InsufficientCreditError;
$4973e2e602c1cc10$exports.OperationTimeoutError = $05c322d0dbecfcc0$exports.OperationTimeoutError;
$4973e2e602c1cc10$exports.SendOperationFailedError = $05c322d0dbecfcc0$exports.SendOperationFailedError;



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function $2e003a922334442c$export$bef1f36f5486a6a3(...args) {
    if (args.length > 0) {
        const firstArg = String(args[0]);
        if (firstArg.includes(":error")) console.error(...args);
        else if (firstArg.includes(":warning")) console.warn(...args);
        else if (firstArg.includes(":info")) console.info(...args);
        else if (firstArg.includes(":verbose")) console.debug(...args);
        else console.debug(...args);
    }
}



const $c84afcf4270aa80c$var$debugEnvVariable = (typeof $2276b6e7a55844a8$exports !== "undefined" && $2276b6e7a55844a8$exports.env && undefined, undefined);
let $c84afcf4270aa80c$var$enabledString;
let $c84afcf4270aa80c$var$enabledNamespaces = [];
let $c84afcf4270aa80c$var$skippedNamespaces = [];
const $c84afcf4270aa80c$var$debuggers = [];
if ($c84afcf4270aa80c$var$debugEnvVariable) $c84afcf4270aa80c$var$enable($c84afcf4270aa80c$var$debugEnvVariable);
const $c84afcf4270aa80c$var$debugObj = Object.assign((namespace)=>{
    return $c84afcf4270aa80c$var$createDebugger(namespace);
}, {
    enable: $c84afcf4270aa80c$var$enable,
    enabled: $c84afcf4270aa80c$var$enabled,
    disable: $c84afcf4270aa80c$var$disable,
    log: $2e003a922334442c$export$bef1f36f5486a6a3
});
function $c84afcf4270aa80c$var$enable(namespaces) {
    $c84afcf4270aa80c$var$enabledString = namespaces;
    $c84afcf4270aa80c$var$enabledNamespaces = [];
    $c84afcf4270aa80c$var$skippedNamespaces = [];
    const wildcard = /\*/g;
    const namespaceList = namespaces.split(",").map((ns)=>ns.trim().replace(wildcard, ".*?"));
    for (const ns of namespaceList)if (ns.startsWith("-")) $c84afcf4270aa80c$var$skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
    else $c84afcf4270aa80c$var$enabledNamespaces.push(new RegExp(`^${ns}$`));
    for (const instance of $c84afcf4270aa80c$var$debuggers)instance.enabled = $c84afcf4270aa80c$var$enabled(instance.namespace);
}
function $c84afcf4270aa80c$var$enabled(namespace) {
    if (namespace.endsWith("*")) return true;
    for (const skipped of $c84afcf4270aa80c$var$skippedNamespaces){
        if (skipped.test(namespace)) return false;
    }
    for (const enabledNamespace of $c84afcf4270aa80c$var$enabledNamespaces){
        if (enabledNamespace.test(namespace)) return true;
    }
    return false;
}
function $c84afcf4270aa80c$var$disable() {
    const result = $c84afcf4270aa80c$var$enabledString || "";
    $c84afcf4270aa80c$var$enable("");
    return result;
}
function $c84afcf4270aa80c$var$createDebugger(namespace) {
    const newDebugger = Object.assign(debug, {
        enabled: $c84afcf4270aa80c$var$enabled(namespace),
        destroy: $c84afcf4270aa80c$var$destroy,
        log: $c84afcf4270aa80c$var$debugObj.log,
        namespace: namespace,
        extend: $c84afcf4270aa80c$var$extend
    });
    function debug(...args) {
        if (!newDebugger.enabled) return;
        if (args.length > 0) args[0] = `${namespace} ${args[0]}`;
        newDebugger.log(...args);
    }
    $c84afcf4270aa80c$var$debuggers.push(newDebugger);
    return newDebugger;
}
function $c84afcf4270aa80c$var$destroy() {
    const index = $c84afcf4270aa80c$var$debuggers.indexOf(this);
    if (index >= 0) {
        $c84afcf4270aa80c$var$debuggers.splice(index, 1);
        return true;
    }
    return false;
}
function $c84afcf4270aa80c$var$extend(namespace) {
    const newDebugger = $c84afcf4270aa80c$var$createDebugger(`${this.namespace}:${namespace}`);
    newDebugger.log = this.log;
    return newDebugger;
}
var $c84afcf4270aa80c$export$2e2bcd8739ae039 = $c84afcf4270aa80c$var$debugObj;



const $317b6f994b1c7cb4$var$registeredLoggers = new Set();
const $317b6f994b1c7cb4$var$logLevelFromEnv = (typeof $2276b6e7a55844a8$exports !== "undefined" && $2276b6e7a55844a8$exports.env && undefined, undefined);
let $317b6f994b1c7cb4$var$azureLogLevel;
const $317b6f994b1c7cb4$export$e8fb5f2ce3b591d = (0, $c84afcf4270aa80c$export$2e2bcd8739ae039)("azure");
$317b6f994b1c7cb4$export$e8fb5f2ce3b591d.log = (...args)=>{
    (0, $c84afcf4270aa80c$export$2e2bcd8739ae039).log(...args);
};
const $317b6f994b1c7cb4$var$AZURE_LOG_LEVELS = [
    "verbose",
    "info",
    "warning",
    "error"
];
if ($317b6f994b1c7cb4$var$logLevelFromEnv) {
    // avoid calling setLogLevel because we don't want a mis-set environment variable to crash
    if ($317b6f994b1c7cb4$var$isAzureLogLevel($317b6f994b1c7cb4$var$logLevelFromEnv)) $317b6f994b1c7cb4$export$c622e99c0ce7b1c9($317b6f994b1c7cb4$var$logLevelFromEnv);
    else console.error(`AZURE_LOG_LEVEL set to unknown log level '${$317b6f994b1c7cb4$var$logLevelFromEnv}'; logging is not enabled. Acceptable values: ${$317b6f994b1c7cb4$var$AZURE_LOG_LEVELS.join(", ")}.`);
}
function $317b6f994b1c7cb4$export$c622e99c0ce7b1c9(level) {
    if (level && !$317b6f994b1c7cb4$var$isAzureLogLevel(level)) throw new Error(`Unknown log level '${level}'. Acceptable values: ${$317b6f994b1c7cb4$var$AZURE_LOG_LEVELS.join(",")}`);
    $317b6f994b1c7cb4$var$azureLogLevel = level;
    const enabledNamespaces = [];
    for (const logger of $317b6f994b1c7cb4$var$registeredLoggers)if ($317b6f994b1c7cb4$var$shouldEnable(logger)) enabledNamespaces.push(logger.namespace);
    (0, $c84afcf4270aa80c$export$2e2bcd8739ae039).enable(enabledNamespaces.join(","));
}
function $317b6f994b1c7cb4$export$12dbaabc76fb091a() {
    return $317b6f994b1c7cb4$var$azureLogLevel;
}
const $317b6f994b1c7cb4$var$levelMap = {
    verbose: 400,
    info: 300,
    warning: 200,
    error: 100
};
function $317b6f994b1c7cb4$export$6817aa89e2fe44fd(namespace) {
    const clientRootLogger = $317b6f994b1c7cb4$export$e8fb5f2ce3b591d.extend(namespace);
    $317b6f994b1c7cb4$var$patchLogMethod($317b6f994b1c7cb4$export$e8fb5f2ce3b591d, clientRootLogger);
    return {
        error: $317b6f994b1c7cb4$var$createLogger(clientRootLogger, "error"),
        warning: $317b6f994b1c7cb4$var$createLogger(clientRootLogger, "warning"),
        info: $317b6f994b1c7cb4$var$createLogger(clientRootLogger, "info"),
        verbose: $317b6f994b1c7cb4$var$createLogger(clientRootLogger, "verbose")
    };
}
function $317b6f994b1c7cb4$var$patchLogMethod(parent, child) {
    child.log = (...args)=>{
        parent.log(...args);
    };
}
function $317b6f994b1c7cb4$var$createLogger(parent, level) {
    const logger = Object.assign(parent.extend(level), {
        level: level
    });
    $317b6f994b1c7cb4$var$patchLogMethod(parent, logger);
    if ($317b6f994b1c7cb4$var$shouldEnable(logger)) {
        const enabledNamespaces = (0, $c84afcf4270aa80c$export$2e2bcd8739ae039).disable();
        (0, $c84afcf4270aa80c$export$2e2bcd8739ae039).enable(enabledNamespaces + "," + logger.namespace);
    }
    $317b6f994b1c7cb4$var$registeredLoggers.add(logger);
    return logger;
}
function $317b6f994b1c7cb4$var$shouldEnable(logger) {
    if ($317b6f994b1c7cb4$var$azureLogLevel && $317b6f994b1c7cb4$var$levelMap[logger.level] <= $317b6f994b1c7cb4$var$levelMap[$317b6f994b1c7cb4$var$azureLogLevel]) return true;
    else return false;
}
function $317b6f994b1c7cb4$var$isAzureLogLevel(logLevel) {
    return $317b6f994b1c7cb4$var$AZURE_LOG_LEVELS.includes(logLevel);
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper TypeGuard that checks if something is defined or not.
 * @param thing - Anything
 * @internal
 */ function $6a6c5885a1b92eeb$export$4e62c701997796c1(thing) {
    return typeof thing !== "undefined" && thing !== null;
}
function $6a6c5885a1b92eeb$export$44aa3a8a1abdb9b6(thing, properties) {
    if (!$6a6c5885a1b92eeb$export$4e62c701997796c1(thing) || typeof thing !== "object") return false;
    for (const property of properties){
        if (!$6a6c5885a1b92eeb$export$48d753fb7585d4bb(thing, property)) return false;
    }
    return true;
}
function $6a6c5885a1b92eeb$export$48d753fb7585d4bb(thing, property) {
    return typeof thing === "object" && property in thing;
}
function $6a6c5885a1b92eeb$export$5bb8cb442c22efaf(thing) {
    return $6a6c5885a1b92eeb$export$44aa3a8a1abdb9b6(thing, [
        "isSasTokenProvider"
    ]) && thing.isSasTokenProvider === true;
}


const $36f34de7efabe9df$export$af88d00dbe7f521 = (0, $317b6f994b1c7cb4$export$6817aa89e2fe44fd)("core-amqp");
function $36f34de7efabe9df$export$6fe26fa55e239433(error) {
    if ((0, $6a6c5885a1b92eeb$export$44aa3a8a1abdb9b6)(error, [
        "stack"
    ])) $36f34de7efabe9df$export$af88d00dbe7f521.verbose(error.stack);
}


class $cfad84535b4c01ce$export$cc076a32292037e1 {
    constructor(){
        this._keyMap = new Map();
        this._executionRunningSet = new Set();
    }
    /**
     * Returns a promise that resolves to the value returned by the provided task function.
     * Only 1 task can be invoked at a time for a given `key` value.
     *
     * An acquire call can be cancelled via an `abortSignal`.
     * If cancelled, the promise will be rejected with an `AbortError`.
     *
     * `acquireTimeoutInMs` can also be provided to properties.
     * If the timeout is reached before the provided `task` is invoked,
     * then the promise will be rejected with an Error stating the task
     * timed out waiting to acquire a lock.
     *
     * @param key - All `acquire` calls are grouped by the provided `key`.
     * @param task - The function to invoke once the lock has been acquired.
     * @param properties - Additional properties to control the behavior of `acquire`.
     */ acquire(key, task, properties) {
        var _a;
        const { abortSignal: abortSignal , timeoutInMs: timeoutInMs  } = properties;
        // Fast exit if the operation is already cancelled.
        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) return Promise.reject(new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)((0, $807770c0815ec6f8$export$ec529641dbabb04c)));
        // Ensure we've got a task queue for the given key.
        const taskQueue = (_a = this._keyMap.get(key)) !== null && _a !== void 0 ? _a : [];
        this._keyMap.set(key, taskQueue);
        // This method will return a promise that will be fulfilled outside this function.
        const { promise: promise , rejecter: rejecter , resolver: resolver  } = $cfad84535b4c01ce$var$getPromiseParts();
        const taskDetails = {
            reject: rejecter,
            resolve: resolver,
            task: task
        };
        // Handle timeouts by removing the task from the queue when hit.
        if (typeof timeoutInMs === "number") {
            const tid = setTimeout(()=>{
                this._removeTaskDetails(key, taskDetails);
                rejecter(new (0, $4973e2e602c1cc10$exports.OperationTimeoutError)(`The task timed out waiting to acquire a lock for ${key}`));
            }, timeoutInMs);
            taskDetails.tid = tid;
        }
        // Handle cancellation by removing the task from the queue when cancelled.
        if (abortSignal) {
            const abortListener = ()=>{
                this._removeTaskDetails(key, taskDetails);
                rejecter(new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)((0, $807770c0815ec6f8$export$ec529641dbabb04c)));
            };
            abortSignal.addEventListener("abort", abortListener);
            taskDetails.abortSignal = abortSignal;
            taskDetails.abortListener = abortListener;
        }
        // Enqueue the task!
        taskQueue.push(taskDetails);
        (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose(`Called acquire() for lock "${key}". Lock "${key}" has ${taskQueue.length} pending tasks.`);
        // Start a loop to iterate over the task queue.
        // This will run asynchronously and won't allow
        // more than 1 concurrent execution per key at a time.
        this._execute(key);
        return promise;
    }
    /**
     * Iterates over all the pending tasks for a given `key` serially.
     *
     * Note: If the pending tasks are already being iterated by an early
     * _execute invocation, this returns immediately.
     * @returns
     */ async _execute(key) {
        // If the key already exists in the set, then exit because
        // tasks are already being processed.
        if (this._executionRunningSet.has(key)) return;
        const taskQueue = this._keyMap.get(key);
        // If the queue is empty, exit early!
        if (!taskQueue || !taskQueue.length) return;
        // Add the key to the set so we can tell the
        // task queue is already being processed.
        this._executionRunningSet.add(key);
        while(taskQueue.length){
            // Remove tasks from the front of the queue.
            // Order matters!
            const taskDetails = taskQueue.shift();
            if (!taskDetails) continue;
            try {
                (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose(`Acquired lock for "${key}", invoking task.`);
                $cfad84535b4c01ce$var$cleanupTaskDetails(taskDetails);
                const value = await taskDetails.task();
                taskDetails.resolve(value);
            } catch (err) {
                taskDetails.reject(err);
            }
            (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose(`Task completed for lock "${key}". Lock "${key}" has ${taskQueue.length} pending tasks.`);
        }
        // Indicate that the task queue for the key is empty
        // and we're done processing it.
        this._executionRunningSet.delete(key);
    }
    _removeTaskDetails(key, taskDetails) {
        const taskQueue = this._keyMap.get(key);
        if (!taskQueue || !taskQueue.length) // The task is already gone from the queue, so our work here is done!
        return;
        const index = taskQueue.indexOf(taskDetails);
        if (index !== -1) {
            const [details] = taskQueue.splice(index, 1);
            // Cleanup the task rejection code paths.
            $cfad84535b4c01ce$var$cleanupTaskDetails(details);
        }
    }
}
/**
 * @internal
 * Returns a promise and the promise's resolve and reject methods.
 */ function $cfad84535b4c01ce$var$getPromiseParts() {
    let resolver;
    let rejecter;
    const promise = new Promise((resolve, reject)=>{
        resolver = resolve;
        rejecter = reject;
    });
    return {
        promise: promise,
        resolver: resolver,
        rejecter: rejecter
    };
}
/**
 * @internal
 * Removes any abort listener or pending timeout from a task.
 */ function $cfad84535b4c01ce$var$cleanupTaskDetails(taskDetails) {
    // Cleanup the task rejection code paths.
    if (taskDetails.tid) clearTimeout(taskDetails.tid);
    if (taskDetails.abortSignal && taskDetails.abortListener) taskDetails.abortSignal.removeEventListener("abort", taskDetails.abortListener);
}





var $gDDBB = parcelRequire("gDDBB");
var $29b64d391bfe12b4$var$_a;
const $29b64d391bfe12b4$export$8ee0fc9ee280b4ee = typeof $gDDBB !== "undefined" && Boolean($gDDBB.version) && Boolean(($29b64d391bfe12b4$var$_a = $gDDBB.versions) === null || $29b64d391bfe12b4$var$_a === void 0 ? void 0 : $29b64d391bfe12b4$var$_a.node);
function $29b64d391bfe12b4$export$6369f286b474466d(connectionString) {
    const output = {};
    const parts = connectionString.trim().split(";");
    for (let part of parts){
        part = part.trim();
        if (part === "") continue;
        const splitIndex = part.indexOf("=");
        if (splitIndex === -1) throw new Error("Connection string malformed: each part of the connection string must have an `=` assignment.");
        const key = part.substring(0, splitIndex).trim();
        if (key === "") throw new Error("Connection string malformed: missing key for assignment");
        const value = part.substring(splitIndex + 1).trim();
        output[key] = value;
    }
    return output;
}
const $29b64d391bfe12b4$export$47162a90c11c56c9 = new (0, $cfad84535b4c01ce$export$cc076a32292037e1)();
class $29b64d391bfe12b4$export$786b4da70f00938b {
    set(t, value) {
        return new Promise((resolve, reject)=>{
            this.clear();
            const callback = value ? ()=>reject(new Error(`${value}`)) : resolve;
            this._timer = setTimeout(callback, t);
        });
    }
    clear() {
        if (this._timer) clearTimeout(this._timer);
    }
    wrap(promise, t, value) {
        const wrappedPromise = this._promiseFinally(promise, ()=>this.clear());
        const timer = this.set(t, value);
        return Promise.race([
            wrappedPromise,
            timer
        ]);
    }
    _promiseFinally(promise, fn) {
        const success = (result)=>{
            fn();
            return result;
        };
        const error = (e)=>{
            fn();
            return Promise.reject(e);
        };
        return Promise.resolve(promise).then(success, error);
    }
    static set(t, value) {
        return new $29b64d391bfe12b4$export$786b4da70f00938b().set(t, value);
    }
    static wrap(promise, t, value) {
        return new $29b64d391bfe12b4$export$786b4da70f00938b().wrap(promise, t, value);
    }
}
function $29b64d391bfe12b4$export$1391212d75b2ee65(delayInMs, abortSignal, abortErrorMsg, value) {
    return new Promise((resolve, reject)=>{
        let timer = undefined;
        let onAborted = undefined;
        const rejectOnAbort = ()=>{
            return reject(new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)(abortErrorMsg ? abortErrorMsg : (0, $807770c0815ec6f8$export$ec529641dbabb04c)));
        };
        const removeListeners = ()=>{
            if (abortSignal && onAborted) abortSignal.removeEventListener("abort", onAborted);
        };
        onAborted = ()=>{
            if ((0, $6a6c5885a1b92eeb$export$4e62c701997796c1)(timer)) clearTimeout(timer);
            removeListeners();
            return rejectOnAbort();
        };
        if (abortSignal && abortSignal.aborted) return rejectOnAbort();
        timer = setTimeout(()=>{
            removeListeners();
            resolve(value);
        }, delayInMs);
        if (abortSignal) abortSignal.addEventListener("abort", onAborted);
    });
}
function $29b64d391bfe12b4$export$961d4f1c3e44b855(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}
function $29b64d391bfe12b4$export$eb1bffa23dfc2696(promiseFactories, kickstart) {
    let result = Promise.resolve(kickstart);
    promiseFactories.forEach((promiseFactory)=>{
        result = result.then(promiseFactory);
    });
    return result;
}
function $29b64d391bfe12b4$export$2a20d4547a2d6e97(connectionString) {
    connectionString = String(connectionString);
    let result = false;
    const model = $29b64d391bfe12b4$export$6369f286b474466d(connectionString);
    if (model && model.HostName && model.SharedAccessKey && model.SharedAccessKeyName) result = true;
    return result;
}
function $29b64d391bfe12b4$export$844ec244b1367d54(s) {
    return typeof s === "string";
}
function $29b64d391bfe12b4$export$7e4aa119212bc614(n) {
    return typeof n === "number";
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper TypeGuard that checks if something is defined or not.
 * @param thing - Anything
 * @internal
 */ function $447d2c65ccf7f178$var$isDefined(thing) {
    return typeof thing !== "undefined" && thing !== null;
}
function $447d2c65ccf7f178$export$44aa3a8a1abdb9b6(thing, properties) {
    if (!$447d2c65ccf7f178$var$isDefined(thing) || typeof thing !== "object") return false;
    for (const property of properties){
        if (!$447d2c65ccf7f178$var$objectHasProperty(thing, property)) return false;
    }
    return true;
}
/**
 * Helper TypeGuard that checks if the input is an object with the specified property.
 * Note: The property may be inherited.
 * @param thing - Any object.
 * @param property - The name of the property that should appear in the object.
 * @internal
 */ function $447d2c65ccf7f178$var$objectHasProperty(thing, property) {
    return typeof thing === "object" && property in thing;
}


class $720970adf00c6270$export$f435da19f94fed78 {
    /**
     * Create an instance of an AzureNamedKeyCredential for use
     * with a service client.
     *
     * @param name - The initial value of the name to use in authentication.
     * @param key - The initial value of the key to use in authentication.
     */ constructor(name, key){
        if (!name || !key) throw new TypeError("name and key must be non-empty strings");
        this._name = name;
        this._key = key;
    }
    /**
     * The value of the key to be used in authentication.
     */ get key() {
        return this._key;
    }
    /**
     * The value of the name to be used in authentication.
     */ get name() {
        return this._name;
    }
    /**
     * Change the value of the key.
     *
     * Updates will take effect upon the next request after
     * updating the key value.
     *
     * @param newName - The new name value to be used.
     * @param newKey - The new key value to be used.
     */ update(newName, newKey) {
        if (!newName || !newKey) throw new TypeError("newName and newKey must be non-empty strings");
        this._name = newName;
        this._key = newKey;
    }
}
function $720970adf00c6270$export$9117b72f7d656ea5(credential) {
    return (0, $447d2c65ccf7f178$export$44aa3a8a1abdb9b6)(credential, [
        "name",
        "key"
    ]) && typeof credential.key === "string" && typeof credential.name === "string";
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Tests an object to determine whether it implements TokenCredential.
 *
 * @param credential - The assumed TokenCredential to be tested.
 */ function $5bfba789bf6c5d92$export$59ba6af2e517603a(credential) {
    // Check for an object with a 'getToken' function and possibly with
    // a 'signRequest' function.  We do this check to make sure that
    // a ServiceClientCredentials implementor (like TokenClientCredentials
    // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if
    // it doesn't actually implement TokenCredential also.
    const castCredential = credential;
    return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === undefined || castCredential.getToken.length > 0);
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function $b376023a8674c0ff$var$normalizeName(name) {
    return name.toLowerCase();
}
function* $b376023a8674c0ff$var$headerIterator(map) {
    for (const entry of map.values())yield [
        entry.name,
        entry.value
    ];
}
class $b376023a8674c0ff$var$HttpHeadersImpl {
    constructor(rawHeaders){
        this._headersMap = new Map();
        if (rawHeaders) for (const headerName of Object.keys(rawHeaders))this.set(headerName, rawHeaders[headerName]);
    }
    /**
     * Set a header in this collection with the provided name and value. The name is
     * case-insensitive.
     * @param name - The name of the header to set. This value is case-insensitive.
     * @param value - The value of the header to set.
     */ set(name, value) {
        this._headersMap.set($b376023a8674c0ff$var$normalizeName(name), {
            name: name,
            value: String(value)
        });
    }
    /**
     * Get the header value for the provided header name, or undefined if no header exists in this
     * collection with the provided name.
     * @param name - The name of the header. This value is case-insensitive.
     */ get(name) {
        var _a;
        return (_a = this._headersMap.get($b376023a8674c0ff$var$normalizeName(name))) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * Get whether or not this header collection contains a header entry for the provided header name.
     * @param name - The name of the header to set. This value is case-insensitive.
     */ has(name) {
        return this._headersMap.has($b376023a8674c0ff$var$normalizeName(name));
    }
    /**
     * Remove the header with the provided headerName.
     * @param name - The name of the header to remove.
     */ delete(name) {
        this._headersMap.delete($b376023a8674c0ff$var$normalizeName(name));
    }
    /**
     * Get the JSON object representation of this HTTP header collection.
     */ toJSON(options = {}) {
        const result = {};
        if (options.preserveCase) for (const entry of this._headersMap.values())result[entry.name] = entry.value;
        else for (const [normalizedName, entry] of this._headersMap)result[normalizedName] = entry.value;
        return result;
    }
    /**
     * Get the string representation of this HTTP header collection.
     */ toString() {
        return JSON.stringify(this.toJSON({
            preserveCase: true
        }));
    }
    /**
     * Iterate over tuples of header [name, value] pairs.
     */ [Symbol.iterator]() {
        return $b376023a8674c0ff$var$headerIterator(this._headersMap);
    }
}
function $b376023a8674c0ff$export$4c8e967a76f3c947(rawHeaders) {
    return new $b376023a8674c0ff$var$HttpHeadersImpl(rawHeaders);
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var $26815cb93bd8b4c3$var$getRandomValues;
var $26815cb93bd8b4c3$var$rnds8 = new Uint8Array(16);
function $26815cb93bd8b4c3$export$2e2bcd8739ae039() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!$26815cb93bd8b4c3$var$getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        $26815cb93bd8b4c3$var$getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
        if (!$26815cb93bd8b4c3$var$getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    return $26815cb93bd8b4c3$var$getRandomValues($26815cb93bd8b4c3$var$rnds8);
}


var $c676955404233ca9$export$2e2bcd8739ae039 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;


function $87af7b3e7b1f75f3$var$validate(uuid) {
    return typeof uuid === "string" && (0, $c676955404233ca9$export$2e2bcd8739ae039).test(uuid);
}
var $87af7b3e7b1f75f3$export$2e2bcd8739ae039 = $87af7b3e7b1f75f3$var$validate;


/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ var $9d4e36e8da6b5ca3$var$byteToHex = [];
for(var $9d4e36e8da6b5ca3$var$i = 0; $9d4e36e8da6b5ca3$var$i < 256; ++$9d4e36e8da6b5ca3$var$i)$9d4e36e8da6b5ca3$var$byteToHex.push(($9d4e36e8da6b5ca3$var$i + 0x100).toString(16).substr(1));
function $9d4e36e8da6b5ca3$var$stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    var uuid = ($9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 0]] + $9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 1]] + $9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 2]] + $9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 3]] + "-" + $9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 4]] + $9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 5]] + "-" + $9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 6]] + $9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 7]] + "-" + $9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 8]] + $9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 9]] + "-" + $9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 10]] + $9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 11]] + $9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 12]] + $9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 13]] + $9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 14]] + $9d4e36e8da6b5ca3$var$byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!(0, $87af7b3e7b1f75f3$export$2e2bcd8739ae039)(uuid)) throw TypeError("Stringified UUID is invalid");
    return uuid;
}
var $9d4e36e8da6b5ca3$export$2e2bcd8739ae039 = $9d4e36e8da6b5ca3$var$stringify;


function $8724fcfe428c3048$var$v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || (0, $26815cb93bd8b4c3$export$2e2bcd8739ae039))(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(var i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
        return buf;
    }
    return (0, $9d4e36e8da6b5ca3$export$2e2bcd8739ae039)(rnds);
}
var $8724fcfe428c3048$export$2e2bcd8739ae039 = $8724fcfe428c3048$var$v4;


function $fce48570aa20772f$export$1c3aefb711c3a4cc() {
    return (0, $8724fcfe428c3048$export$2e2bcd8739ae039)();
}


class $02e45365db79d766$var$PipelineRequestImpl {
    constructor(options){
        var _a, _b, _c, _d, _e, _f, _g;
        this.url = options.url;
        this.body = options.body;
        this.headers = (_a = options.headers) !== null && _a !== void 0 ? _a : (0, $b376023a8674c0ff$export$4c8e967a76f3c947)();
        this.method = (_b = options.method) !== null && _b !== void 0 ? _b : "GET";
        this.timeout = (_c = options.timeout) !== null && _c !== void 0 ? _c : 0;
        this.formData = options.formData;
        this.disableKeepAlive = (_d = options.disableKeepAlive) !== null && _d !== void 0 ? _d : false;
        this.proxySettings = options.proxySettings;
        this.streamResponseStatusCodes = options.streamResponseStatusCodes;
        this.withCredentials = (_e = options.withCredentials) !== null && _e !== void 0 ? _e : false;
        this.abortSignal = options.abortSignal;
        this.tracingOptions = options.tracingOptions;
        this.onUploadProgress = options.onUploadProgress;
        this.onDownloadProgress = options.onDownloadProgress;
        this.requestId = options.requestId || (0, $fce48570aa20772f$export$1c3aefb711c3a4cc)();
        this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== void 0 ? _f : false;
        this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== void 0 ? _g : false;
    }
}
function $02e45365db79d766$export$7a9cd74b232af14e(options) {
    return new $02e45365db79d766$var$PipelineRequestImpl(options);
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Default key used to access the XML attributes.
 */ const $ee65f5e4dea21a8c$export$3dfa762fc17d84c8 = "$";
const $ee65f5e4dea21a8c$export$3fa08d02e488b7ae = "_";


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper to determine when an input is a generic JS object.
 * @returns true when input is an object type that is not null, Array, RegExp, or Date.
 */ function $cf310ecb90b089bf$export$a6cdc56e425d0d0a(input) {
    return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
}


function $0a59209d5914926b$export$e6127cc7fe7395c3(e) {
    if ((0, $cf310ecb90b089bf$export$a6cdc56e425d0d0a)(e)) {
        const hasName = typeof e.name === "string";
        const hasMessage = typeof e.message === "string";
        return hasName && hasMessage;
    }
    return false;
}
function $0a59209d5914926b$export$82f46aa4e6535a45(e) {
    if ($0a59209d5914926b$export$e6127cc7fe7395c3(e)) return e.message;
    else {
        let stringified;
        try {
            if (typeof e === "object" && e) stringified = JSON.stringify(e);
            else stringified = String(e);
        } catch (err) {
            stringified = "[unable to stringify input]";
        }
        return `Unknown error ${stringified}`;
    }
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const $8a4a256990289573$export$4c00f665f0d4b443 = {};


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

const $1ecbf9da13fb2cf8$var$RedactedString = "REDACTED";
// Make sure this list is up-to-date with the one under core/logger/Readme#Keyconcepts
const $1ecbf9da13fb2cf8$var$defaultAllowedHeaderNames = [
    "x-ms-client-request-id",
    "x-ms-return-client-request-id",
    "x-ms-useragent",
    "x-ms-correlation-request-id",
    "x-ms-request-id",
    "client-request-id",
    "ms-cv",
    "return-client-request-id",
    "traceparent",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Origin",
    "Accept",
    "Accept-Encoding",
    "Cache-Control",
    "Connection",
    "Content-Length",
    "Content-Type",
    "Date",
    "ETag",
    "Expires",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "Last-Modified",
    "Pragma",
    "Request-Id",
    "Retry-After",
    "Server",
    "Transfer-Encoding",
    "User-Agent",
    "WWW-Authenticate"
];
const $1ecbf9da13fb2cf8$var$defaultAllowedQueryParameters = [
    "api-version"
];
class $1ecbf9da13fb2cf8$export$a6cec3dfaf45e6ac {
    constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [] , additionalAllowedQueryParameters: allowedQueryParameters = []  } = {}){
        allowedHeaderNames = $1ecbf9da13fb2cf8$var$defaultAllowedHeaderNames.concat(allowedHeaderNames);
        allowedQueryParameters = $1ecbf9da13fb2cf8$var$defaultAllowedQueryParameters.concat(allowedQueryParameters);
        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n)=>n.toLowerCase()));
        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p)=>p.toLowerCase()));
    }
    sanitize(obj) {
        const seen = new Set();
        return JSON.stringify(obj, (key, value)=>{
            // Ensure Errors include their interesting non-enumerable members
            if (value instanceof Error) return Object.assign(Object.assign({}, value), {
                name: value.name,
                message: value.message
            });
            if (key === "headers") return this.sanitizeHeaders(value);
            else if (key === "url") return this.sanitizeUrl(value);
            else if (key === "query") return this.sanitizeQuery(value);
            else if (key === "body") // Don't log the request body
            return undefined;
            else if (key === "response") // Don't log response again
            return undefined;
            else if (key === "operationSpec") // When using sendOperationRequest, the request carries a massive
            // field with the autorest spec. No need to log it.
            return undefined;
            else if (Array.isArray(value) || (0, $cf310ecb90b089bf$export$a6cdc56e425d0d0a)(value)) {
                if (seen.has(value)) return "[Circular]";
                seen.add(value);
            }
            return value;
        }, 2);
    }
    sanitizeHeaders(obj) {
        const sanitized = {};
        for (const key of Object.keys(obj))if (this.allowedHeaderNames.has(key.toLowerCase())) sanitized[key] = obj[key];
        else sanitized[key] = $1ecbf9da13fb2cf8$var$RedactedString;
        return sanitized;
    }
    sanitizeQuery(value) {
        if (typeof value !== "object" || value === null) return value;
        const sanitized = {};
        for (const k of Object.keys(value))if (this.allowedQueryParameters.has(k.toLowerCase())) sanitized[k] = value[k];
        else sanitized[k] = $1ecbf9da13fb2cf8$var$RedactedString;
        return sanitized;
    }
    sanitizeUrl(value) {
        if (typeof value !== "string" || value === null) return value;
        const url = new URL(value);
        if (!url.search) return value;
        for (const [key] of url.searchParams)if (!this.allowedQueryParameters.has(key.toLowerCase())) url.searchParams.set(key, $1ecbf9da13fb2cf8$var$RedactedString);
        return url.toString();
    }
}


const $193c259516f52386$var$errorSanitizer = new (0, $1ecbf9da13fb2cf8$export$a6cec3dfaf45e6ac)();
class $193c259516f52386$export$dc24566375af80f3 extends Error {
    constructor(message, options = {}){
        super(message);
        this.name = "RestError";
        this.code = options.code;
        this.statusCode = options.statusCode;
        this.request = options.request;
        this.response = options.response;
        Object.setPrototypeOf(this, $193c259516f52386$export$dc24566375af80f3.prototype);
    }
    /**
     * Logging method for util.inspect in Node
     */ [(0, $8a4a256990289573$export$4c00f665f0d4b443)]() {
        return `RestError: ${this.message} \n ${$193c259516f52386$var$errorSanitizer.sanitize(this)}`;
    }
}
/**
 * Something went wrong when making the request.
 * This means the actual request failed for some reason,
 * such as a DNS issue or the connection being lost.
 */ $193c259516f52386$export$dc24566375af80f3.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
/**
 * This means that parsing the response from the server failed.
 * It may have been malformed.
 */ $193c259516f52386$export$dc24566375af80f3.PARSE_ERROR = "PARSE_ERROR";
function $193c259516f52386$export$d5d5fe2886ccec3c(e) {
    if (e instanceof $193c259516f52386$export$dc24566375af80f3) return true;
    return (0, $0a59209d5914926b$export$e6127cc7fe7395c3)(e) && e.name === "RestError";
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Encodes a string in base64 format.
 * @param value - the string to encode
 */ function $3b97741f567bbf02$export$8146d2e653b87d6a(value) {
    return btoa(value);
}
function $3b97741f567bbf02$export$17377a4f963349ad(value) {
    let str = "";
    for(let i = 0; i < value.length; i++)str += String.fromCharCode(value[i]);
    return btoa(str);
}
function $3b97741f567bbf02$export$a0fb664af7d0cc44(value) {
    const byteString = atob(value);
    const arr = new Uint8Array(byteString.length);
    for(let i = 0; i < byteString.length; i++)arr[i] = byteString.charCodeAt(i);
    return arr;
}
function $3b97741f567bbf02$export$4366648502cfed0c(value) {
    return atob(value);
}



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A type guard for a primitive response body.
 * @param value - Value to test
 *
 * @internal
 */ function $c0f36cd5ab3a5dd4$export$9f2fa9f9ffee89a0(value, mapperTypeName) {
    return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === undefined || value === null);
}
const $c0f36cd5ab3a5dd4$var$validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function $c0f36cd5ab3a5dd4$export$757a451204d10ad6(value) {
    return $c0f36cd5ab3a5dd4$var$validateISODuration.test(value);
}
const $c0f36cd5ab3a5dd4$var$validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
function $c0f36cd5ab3a5dd4$export$6ad459db9a6bcc76(uuid) {
    return $c0f36cd5ab3a5dd4$var$validUuidRegex.test(uuid);
}
/**
 * Maps the response as follows:
 * - wraps the response body if needed (typically if its type is primitive).
 * - returns null if the combination of the headers and the body is empty.
 * - otherwise, returns the combination of the headers and the body.
 *
 * @param responseObject - a representation of the parsed response
 * @returns the response that will be returned to the user which can be null and/or wrapped
 *
 * @internal
 */ function $c0f36cd5ab3a5dd4$var$handleNullableResponseAndWrappableBody(responseObject) {
    const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);
    if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) return responseObject.shouldWrapBody ? {
        body: null
    } : null;
    else return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), {
        body: responseObject.body
    }) : combinedHeadersAndBody;
}
function $c0f36cd5ab3a5dd4$export$10ef1a07d9cdec62(fullResponse, responseSpec) {
    var _a, _b;
    const parsedHeaders = fullResponse.parsedHeaders;
    // head methods never have a body, but we return a boolean set to body property
    // to indicate presence/absence of the resource
    if (fullResponse.request.method === "HEAD") return Object.assign(Object.assign({}, parsedHeaders), {
        body: fullResponse.parsedBody
    });
    const bodyMapper = responseSpec && responseSpec.bodyMapper;
    const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);
    const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;
    /** If the body is asked for, we look at the expected body type to handle it */ if (expectedBodyTypeName === "Stream") return Object.assign(Object.assign({}, parsedHeaders), {
        blobBody: fullResponse.blobBody,
        readableStreamBody: fullResponse.readableStreamBody
    });
    const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
    const isPageableResponse = Object.keys(modelProperties).some((k)=>modelProperties[k].serializedName === "");
    if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
        const arrayResponse = (_a = fullResponse.parsedBody) !== null && _a !== void 0 ? _a : [];
        for (const key of Object.keys(modelProperties))if (modelProperties[key].serializedName) arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];
        if (parsedHeaders) for (const key of Object.keys(parsedHeaders))arrayResponse[key] = parsedHeaders[key];
        return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
    }
    return $c0f36cd5ab3a5dd4$var$handleNullableResponseAndWrappableBody({
        body: fullResponse.parsedBody,
        headers: parsedHeaders,
        hasNullableType: isNullable,
        shouldWrapBody: $c0f36cd5ab3a5dd4$export$9f2fa9f9ffee89a0(fullResponse.parsedBody, expectedBodyTypeName)
    });
}


class $72e78c9c5b4d8ef9$var$SerializerImpl {
    constructor(modelMappers = {}, isXML = false){
        this.modelMappers = modelMappers;
        this.isXML = isXML;
    }
    /**
     * @deprecated Removing the constraints validation on client side.
     */ validateConstraints(mapper, value, objectName) {
        const failValidation = (constraintName, constraintValue)=>{
            throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
        };
        if (mapper.constraints && value !== undefined && value !== null) {
            const { ExclusiveMaximum: ExclusiveMaximum , ExclusiveMinimum: ExclusiveMinimum , InclusiveMaximum: InclusiveMaximum , InclusiveMinimum: InclusiveMinimum , MaxItems: MaxItems , MaxLength: MaxLength , MinItems: MinItems , MinLength: MinLength , MultipleOf: MultipleOf , Pattern: Pattern , UniqueItems: UniqueItems  } = mapper.constraints;
            if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) failValidation("ExclusiveMaximum", ExclusiveMaximum);
            if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) failValidation("ExclusiveMinimum", ExclusiveMinimum);
            if (InclusiveMaximum !== undefined && value > InclusiveMaximum) failValidation("InclusiveMaximum", InclusiveMaximum);
            if (InclusiveMinimum !== undefined && value < InclusiveMinimum) failValidation("InclusiveMinimum", InclusiveMinimum);
            if (MaxItems !== undefined && value.length > MaxItems) failValidation("MaxItems", MaxItems);
            if (MaxLength !== undefined && value.length > MaxLength) failValidation("MaxLength", MaxLength);
            if (MinItems !== undefined && value.length < MinItems) failValidation("MinItems", MinItems);
            if (MinLength !== undefined && value.length < MinLength) failValidation("MinLength", MinLength);
            if (MultipleOf !== undefined && value % MultipleOf !== 0) failValidation("MultipleOf", MultipleOf);
            if (Pattern) {
                const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
                if (typeof value !== "string" || value.match(pattern) === null) failValidation("Pattern", Pattern);
            }
            if (UniqueItems && value.some((item, i, ar)=>ar.indexOf(item) !== i)) failValidation("UniqueItems", UniqueItems);
        }
    }
    /**
     * Serialize the given object based on its metadata defined in the mapper
     *
     * @param mapper - The mapper which defines the metadata of the serializable object
     *
     * @param object - A valid Javascript object to be serialized
     *
     * @param objectName - Name of the serialized object
     *
     * @param options - additional options to serialization
     *
     * @returns A valid serialized Javascript object
     */ serialize(mapper, object, objectName, options = {
        xml: {}
    }) {
        var _a, _b, _c;
        const updatedOptions = {
            xml: {
                rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : "",
                includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,
                xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : (0, $ee65f5e4dea21a8c$export$3fa08d02e488b7ae)
            }
        };
        let payload = {};
        const mapperType = mapper.type.name;
        if (!objectName) objectName = mapper.serializedName;
        if (mapperType.match(/^Sequence$/i) !== null) payload = [];
        if (mapper.isConstant) object = mapper.defaultValue;
        // This table of allowed values should help explain
        // the mapper.required and mapper.nullable properties.
        // X means "neither undefined or null are allowed".
        //           || required
        //           || true      | false
        //  nullable || ==========================
        //      true || null      | undefined/null
        //     false || X         | undefined
        // undefined || X         | undefined/null
        const { required: required , nullable: nullable  } = mapper;
        if (required && nullable && object === undefined) throw new Error(`${objectName} cannot be undefined.`);
        if (required && !nullable && (object === undefined || object === null)) throw new Error(`${objectName} cannot be null or undefined.`);
        if (!required && nullable === false && object === null) throw new Error(`${objectName} cannot be null.`);
        if (object === undefined || object === null) payload = object;
        else {
            if (mapperType.match(/^any$/i) !== null) payload = object;
            else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) payload = $72e78c9c5b4d8ef9$var$serializeBasicTypes(mapperType, objectName, object);
            else if (mapperType.match(/^Enum$/i) !== null) {
                const enumMapper = mapper;
                payload = $72e78c9c5b4d8ef9$var$serializeEnumType(objectName, enumMapper.type.allowedValues, object);
            } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) payload = $72e78c9c5b4d8ef9$var$serializeDateTypes(mapperType, object, objectName);
            else if (mapperType.match(/^ByteArray$/i) !== null) payload = $72e78c9c5b4d8ef9$var$serializeByteArrayType(objectName, object);
            else if (mapperType.match(/^Base64Url$/i) !== null) payload = $72e78c9c5b4d8ef9$var$serializeBase64UrlType(objectName, object);
            else if (mapperType.match(/^Sequence$/i) !== null) payload = $72e78c9c5b4d8ef9$var$serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
            else if (mapperType.match(/^Dictionary$/i) !== null) payload = $72e78c9c5b4d8ef9$var$serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
            else if (mapperType.match(/^Composite$/i) !== null) payload = $72e78c9c5b4d8ef9$var$serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        }
        return payload;
    }
    /**
     * Deserialize the given object based on its metadata defined in the mapper
     *
     * @param mapper - The mapper which defines the metadata of the serializable object
     *
     * @param responseBody - A valid Javascript entity to be deserialized
     *
     * @param objectName - Name of the deserialized object
     *
     * @param options - Controls behavior of XML parser and builder.
     *
     * @returns A valid deserialized Javascript object
     */ deserialize(mapper, responseBody, objectName, options = {
        xml: {}
    }) {
        var _a, _b, _c, _d;
        const updatedOptions = {
            xml: {
                rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : "",
                includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,
                xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : (0, $ee65f5e4dea21a8c$export$3fa08d02e488b7ae)
            },
            ignoreUnknownProperties: (_d = options.ignoreUnknownProperties) !== null && _d !== void 0 ? _d : false
        };
        if (responseBody === undefined || responseBody === null) {
            if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) // Edge case for empty XML non-wrapped lists. xml2js can't distinguish
            // between the list being empty versus being missing,
            // so let's do the more user-friendly thing and return an empty list.
            responseBody = [];
            // specifically check for undefined as default value can be a falsey value `0, "", false, null`
            if (mapper.defaultValue !== undefined) responseBody = mapper.defaultValue;
            return responseBody;
        }
        let payload;
        const mapperType = mapper.type.name;
        if (!objectName) objectName = mapper.serializedName;
        if (mapperType.match(/^Composite$/i) !== null) payload = $72e78c9c5b4d8ef9$var$deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
        else {
            if (this.isXML) {
                const xmlCharKey = updatedOptions.xml.xmlCharKey;
                /**
                 * If the mapper specifies this as a non-composite type value but the responseBody contains
                 * both header ("$" i.e., XML_ATTRKEY) and body ("#" i.e., XML_CHARKEY) properties,
                 * then just reduce the responseBody value to the body ("#" i.e., XML_CHARKEY) property.
                 */ if (responseBody[0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8] !== undefined && responseBody[xmlCharKey] !== undefined) responseBody = responseBody[xmlCharKey];
            }
            if (mapperType.match(/^Number$/i) !== null) {
                payload = parseFloat(responseBody);
                if (isNaN(payload)) payload = responseBody;
            } else if (mapperType.match(/^Boolean$/i) !== null) {
                if (responseBody === "true") payload = true;
                else if (responseBody === "false") payload = false;
                else payload = responseBody;
            } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) payload = responseBody;
            else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) payload = new Date(responseBody);
            else if (mapperType.match(/^UnixTime$/i) !== null) payload = $72e78c9c5b4d8ef9$var$unixTimeToDate(responseBody);
            else if (mapperType.match(/^ByteArray$/i) !== null) payload = $3b97741f567bbf02$export$a0fb664af7d0cc44(responseBody);
            else if (mapperType.match(/^Base64Url$/i) !== null) payload = $72e78c9c5b4d8ef9$var$base64UrlToByteArray(responseBody);
            else if (mapperType.match(/^Sequence$/i) !== null) payload = $72e78c9c5b4d8ef9$var$deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
            else if (mapperType.match(/^Dictionary$/i) !== null) payload = $72e78c9c5b4d8ef9$var$deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
        }
        if (mapper.isConstant) payload = mapper.defaultValue;
        return payload;
    }
}
function $72e78c9c5b4d8ef9$export$4c6f8df9af3da79c(modelMappers = {}, isXML = false) {
    return new $72e78c9c5b4d8ef9$var$SerializerImpl(modelMappers, isXML);
}
function $72e78c9c5b4d8ef9$var$trimEnd(str, ch) {
    let len = str.length;
    while(len - 1 >= 0 && str[len - 1] === ch)--len;
    return str.substr(0, len);
}
function $72e78c9c5b4d8ef9$var$bufferToBase64Url(buffer) {
    if (!buffer) return undefined;
    if (!(buffer instanceof Uint8Array)) throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
    // Uint8Array to Base64.
    const str = $3b97741f567bbf02$export$17377a4f963349ad(buffer);
    // Base64 to Base64Url.
    return $72e78c9c5b4d8ef9$var$trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
}
function $72e78c9c5b4d8ef9$var$base64UrlToByteArray(str) {
    if (!str) return undefined;
    if (str && typeof str.valueOf() !== "string") throw new Error("Please provide an input of type string for converting to Uint8Array");
    // Base64Url to Base64.
    str = str.replace(/-/g, "+").replace(/_/g, "/");
    // Base64 to Uint8Array.
    return $3b97741f567bbf02$export$a0fb664af7d0cc44(str);
}
function $72e78c9c5b4d8ef9$var$splitSerializeName(prop) {
    const classes = [];
    let partialclass = "";
    if (prop) {
        const subwords = prop.split(".");
        for (const item of subwords)if (item.charAt(item.length - 1) === "\\") partialclass += item.substr(0, item.length - 1) + ".";
        else {
            partialclass += item;
            classes.push(partialclass);
            partialclass = "";
        }
    }
    return classes;
}
function $72e78c9c5b4d8ef9$var$dateToUnixTime(d) {
    if (!d) return undefined;
    if (typeof d.valueOf() === "string") d = new Date(d);
    return Math.floor(d.getTime() / 1000);
}
function $72e78c9c5b4d8ef9$var$unixTimeToDate(n) {
    if (!n) return undefined;
    return new Date(n * 1000);
}
function $72e78c9c5b4d8ef9$var$serializeBasicTypes(typeName, objectName, value) {
    if (value !== null && value !== undefined) {
        if (typeName.match(/^Number$/i) !== null) {
            if (typeof value !== "number") throw new Error(`${objectName} with value ${value} must be of type number.`);
        } else if (typeName.match(/^String$/i) !== null) {
            if (typeof value.valueOf() !== "string") throw new Error(`${objectName} with value "${value}" must be of type string.`);
        } else if (typeName.match(/^Uuid$/i) !== null) {
            if (!(typeof value.valueOf() === "string" && (0, $c0f36cd5ab3a5dd4$export$6ad459db9a6bcc76)(value))) throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
        } else if (typeName.match(/^Boolean$/i) !== null) {
            if (typeof value !== "boolean") throw new Error(`${objectName} with value ${value} must be of type boolean.`);
        } else if (typeName.match(/^Stream$/i) !== null) {
            const objectType = typeof value;
            if (objectType !== "string" && typeof value.pipe !== "function" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && // File objects count as a type of Blob, so we want to use instanceof explicitly
            !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob) && objectType !== "function") throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, NodeJS.ReadableStream, or () => NodeJS.ReadableStream.`);
        }
    }
    return value;
}
function $72e78c9c5b4d8ef9$var$serializeEnumType(objectName, allowedValues, value) {
    if (!allowedValues) throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
    const isPresent = allowedValues.some((item)=>{
        if (typeof item.valueOf() === "string") return item.toLowerCase() === value.toLowerCase();
        return item === value;
    });
    if (!isPresent) throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
    return value;
}
function $72e78c9c5b4d8ef9$var$serializeByteArrayType(objectName, value) {
    if (value !== undefined && value !== null) {
        if (!(value instanceof Uint8Array)) throw new Error(`${objectName} must be of type Uint8Array.`);
        value = $3b97741f567bbf02$export$17377a4f963349ad(value);
    }
    return value;
}
function $72e78c9c5b4d8ef9$var$serializeBase64UrlType(objectName, value) {
    if (value !== undefined && value !== null) {
        if (!(value instanceof Uint8Array)) throw new Error(`${objectName} must be of type Uint8Array.`);
        value = $72e78c9c5b4d8ef9$var$bufferToBase64Url(value);
    }
    return value;
}
function $72e78c9c5b4d8ef9$var$serializeDateTypes(typeName, value, objectName) {
    if (value !== undefined && value !== null) {
        if (typeName.match(/^Date$/i) !== null) {
            if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
            value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
        } else if (typeName.match(/^DateTime$/i) !== null) {
            if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
            value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
        } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
            if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
            value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
        } else if (typeName.match(/^UnixTime$/i) !== null) {
            if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` + `for it to be serialized in UnixTime/Epoch format.`);
            value = $72e78c9c5b4d8ef9$var$dateToUnixTime(value);
        } else if (typeName.match(/^TimeSpan$/i) !== null) {
            if (!(0, $c0f36cd5ab3a5dd4$export$757a451204d10ad6)(value)) throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
        }
    }
    return value;
}
function $72e78c9c5b4d8ef9$var$serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
    var _a;
    if (!Array.isArray(object)) throw new Error(`${objectName} must be of type Array.`);
    let elementType = mapper.type.element;
    if (!elementType || typeof elementType !== "object") throw new Error(`element" metadata for an Array must be defined in the ` + `mapper and it must of type "object" in ${objectName}.`);
    // Quirk: Composite mappers referenced by `element` might
    // not have *all* properties declared (like uberParent),
    // so let's try to look up the full definition by name.
    if (elementType.type.name === "Composite" && elementType.type.className) elementType = (_a = serializer.modelMappers[elementType.type.className]) !== null && _a !== void 0 ? _a : elementType;
    const tempArray = [];
    for(let i = 0; i < object.length; i++){
        const serializedValue = serializer.serialize(elementType, object[i], objectName, options);
        if (isXml && elementType.xmlNamespace) {
            const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
            if (elementType.type.name === "Composite") {
                tempArray[i] = Object.assign({}, serializedValue);
                tempArray[i][0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8] = {
                    [xmlnsKey]: elementType.xmlNamespace
                };
            } else {
                tempArray[i] = {};
                tempArray[i][options.xml.xmlCharKey] = serializedValue;
                tempArray[i][0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8] = {
                    [xmlnsKey]: elementType.xmlNamespace
                };
            }
        } else tempArray[i] = serializedValue;
    }
    return tempArray;
}
function $72e78c9c5b4d8ef9$var$serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
    if (typeof object !== "object") throw new Error(`${objectName} must be of type object.`);
    const valueType = mapper.type.value;
    if (!valueType || typeof valueType !== "object") throw new Error(`"value" metadata for a Dictionary must be defined in the ` + `mapper and it must of type "object" in ${objectName}.`);
    const tempDictionary = {};
    for (const key of Object.keys(object)){
        const serializedValue = serializer.serialize(valueType, object[key], objectName, options);
        // If the element needs an XML namespace we need to add it within the $ property
        tempDictionary[key] = $72e78c9c5b4d8ef9$var$getXmlObjectValue(valueType, serializedValue, isXml, options);
    }
    // Add the namespace to the root element if needed
    if (isXml && mapper.xmlNamespace) {
        const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
        const result = tempDictionary;
        result[0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8] = {
            [xmlnsKey]: mapper.xmlNamespace
        };
        return result;
    }
    return tempDictionary;
}
/**
 * Resolves the additionalProperties property from a referenced mapper
 * @param serializer - the serializer containing the entire set of mappers
 * @param mapper - the composite mapper to resolve
 * @param objectName - name of the object being serialized
 */ function $72e78c9c5b4d8ef9$var$resolveAdditionalProperties(serializer, mapper, objectName) {
    const additionalProperties = mapper.type.additionalProperties;
    if (!additionalProperties && mapper.type.className) {
        const modelMapper = $72e78c9c5b4d8ef9$var$resolveReferencedMapper(serializer, mapper, objectName);
        return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;
    }
    return additionalProperties;
}
/**
 * Finds the mapper referenced by className
 * @param serializer - the serializer containing the entire set of mappers
 * @param mapper - the composite mapper to resolve
 * @param objectName - name of the object being serialized
 */ function $72e78c9c5b4d8ef9$var$resolveReferencedMapper(serializer, mapper, objectName) {
    const className = mapper.type.className;
    if (!className) throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, undefined, 2)}".`);
    return serializer.modelMappers[className];
}
/**
 * Resolves a composite mapper's modelProperties.
 * @param serializer - the serializer containing the entire set of mappers
 * @param mapper - the composite mapper to resolve
 */ function $72e78c9c5b4d8ef9$var$resolveModelProperties(serializer, mapper, objectName) {
    let modelProps = mapper.type.modelProperties;
    if (!modelProps) {
        const modelMapper = $72e78c9c5b4d8ef9$var$resolveReferencedMapper(serializer, mapper, objectName);
        if (!modelMapper) throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
        modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;
        if (!modelProps) throw new Error(`modelProperties cannot be null or undefined in the ` + `mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
    }
    return modelProps;
}
function $72e78c9c5b4d8ef9$var$serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
    if ($72e78c9c5b4d8ef9$var$getPolymorphicDiscriminatorRecursively(serializer, mapper)) mapper = $72e78c9c5b4d8ef9$var$getPolymorphicMapper(serializer, mapper, object, "clientName");
    if (object !== undefined && object !== null) {
        const payload = {};
        const modelProps = $72e78c9c5b4d8ef9$var$resolveModelProperties(serializer, mapper, objectName);
        for (const key of Object.keys(modelProps)){
            const propertyMapper = modelProps[key];
            if (propertyMapper.readOnly) continue;
            let propName;
            let parentObject = payload;
            if (serializer.isXML) {
                if (propertyMapper.xmlIsWrapped) propName = propertyMapper.xmlName;
                else propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
            } else {
                const paths = $72e78c9c5b4d8ef9$var$splitSerializeName(propertyMapper.serializedName);
                propName = paths.pop();
                for (const pathName of paths){
                    const childObject = parentObject[pathName];
                    if ((childObject === undefined || childObject === null) && (object[key] !== undefined && object[key] !== null || propertyMapper.defaultValue !== undefined)) parentObject[pathName] = {};
                    parentObject = parentObject[pathName];
                }
            }
            if (parentObject !== undefined && parentObject !== null) {
                if (isXml && mapper.xmlNamespace) {
                    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
                    parentObject[0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8] = Object.assign(Object.assign({}, parentObject[0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8]), {
                        [xmlnsKey]: mapper.xmlNamespace
                    });
                }
                const propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
                let toSerialize = object[key];
                const polymorphicDiscriminator = $72e78c9c5b4d8ef9$var$getPolymorphicDiscriminatorRecursively(serializer, mapper);
                if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === undefined || toSerialize === null)) toSerialize = mapper.serializedName;
                const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
                if (serializedValue !== undefined && propName !== undefined && propName !== null) {
                    const value = $72e78c9c5b4d8ef9$var$getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
                    if (isXml && propertyMapper.xmlIsAttribute) {
                        // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.
                        // This keeps things simple while preventing name collision
                        // with names in user documents.
                        parentObject[0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8] = parentObject[0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8] || {};
                        parentObject[0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8][propName] = serializedValue;
                    } else if (isXml && propertyMapper.xmlIsWrapped) parentObject[propName] = {
                        [propertyMapper.xmlElementName]: value
                    };
                    else parentObject[propName] = value;
                }
            }
        }
        const additionalPropertiesMapper = $72e78c9c5b4d8ef9$var$resolveAdditionalProperties(serializer, mapper, objectName);
        if (additionalPropertiesMapper) {
            const propNames = Object.keys(modelProps);
            for(const clientPropName in object){
                const isAdditionalProperty = propNames.every((pn)=>pn !== clientPropName);
                if (isAdditionalProperty) payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
            }
        }
        return payload;
    }
    return object;
}
function $72e78c9c5b4d8ef9$var$getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
    if (!isXml || !propertyMapper.xmlNamespace) return serializedValue;
    const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns";
    const xmlNamespace = {
        [xmlnsKey]: propertyMapper.xmlNamespace
    };
    if ([
        "Composite"
    ].includes(propertyMapper.type.name)) {
        if (serializedValue[0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8]) return serializedValue;
        else {
            const result = Object.assign({}, serializedValue);
            result[0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8] = xmlNamespace;
            return result;
        }
    }
    const result = {};
    result[options.xml.xmlCharKey] = serializedValue;
    result[0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8] = xmlNamespace;
    return result;
}
function $72e78c9c5b4d8ef9$var$isSpecialXmlProperty(propertyName, options) {
    return [
        (0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8),
        options.xml.xmlCharKey
    ].includes(propertyName);
}
function $72e78c9c5b4d8ef9$var$deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
    var _a, _b;
    const xmlCharKey = (_a = options.xml.xmlCharKey) !== null && _a !== void 0 ? _a : (0, $ee65f5e4dea21a8c$export$3fa08d02e488b7ae);
    if ($72e78c9c5b4d8ef9$var$getPolymorphicDiscriminatorRecursively(serializer, mapper)) mapper = $72e78c9c5b4d8ef9$var$getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
    const modelProps = $72e78c9c5b4d8ef9$var$resolveModelProperties(serializer, mapper, objectName);
    let instance = {};
    const handledPropertyNames = [];
    for (const key of Object.keys(modelProps)){
        const propertyMapper = modelProps[key];
        const paths = $72e78c9c5b4d8ef9$var$splitSerializeName(modelProps[key].serializedName);
        handledPropertyNames.push(paths[0]);
        const { serializedName: serializedName , xmlName: xmlName , xmlElementName: xmlElementName  } = propertyMapper;
        let propertyObjectName = objectName;
        if (serializedName !== "" && serializedName !== undefined) propertyObjectName = objectName + "." + serializedName;
        const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
        if (headerCollectionPrefix) {
            const dictionary = {};
            for (const headerKey of Object.keys(responseBody)){
                if (headerKey.startsWith(headerCollectionPrefix)) dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
                handledPropertyNames.push(headerKey);
            }
            instance[key] = dictionary;
        } else if (serializer.isXML) {
            if (propertyMapper.xmlIsAttribute && responseBody[0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8]) instance[key] = serializer.deserialize(propertyMapper, responseBody[0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8][xmlName], propertyObjectName, options);
            else if (propertyMapper.xmlIsMsText) {
                if (responseBody[xmlCharKey] !== undefined) instance[key] = responseBody[xmlCharKey];
                else if (typeof responseBody === "string") // The special case where xml parser parses "<Name>content</Name>" into JSON of
                //   `{ name: "content"}` instead of `{ name: { "_": "content" }}`
                instance[key] = responseBody;
            } else {
                const propertyName = xmlElementName || xmlName || serializedName;
                if (propertyMapper.xmlIsWrapped) {
                    /* a list of <xmlElementName> wrapped by <xmlName>
                      For the xml example below
                        <Cors>
                          <CorsRule>...</CorsRule>
                          <CorsRule>...</CorsRule>
                        </Cors>
                      the responseBody has
                        {
                          Cors: {
                            CorsRule: [{...}, {...}]
                          }
                        }
                      xmlName is "Cors" and xmlElementName is"CorsRule".
                    */ const wrapped = responseBody[xmlName];
                    const elementList = (_b = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _b !== void 0 ? _b : [];
                    instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
                    handledPropertyNames.push(xmlName);
                } else {
                    const property = responseBody[propertyName];
                    instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
                    handledPropertyNames.push(propertyName);
                }
            }
        } else {
            // deserialize the property if it is present in the provided responseBody instance
            let propertyInstance;
            let res = responseBody;
            // traversing the object step by step.
            for (const item of paths){
                if (!res) break;
                res = res[item];
            }
            propertyInstance = res;
            const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
            // checking that the model property name (key)(ex: "fishtype") and the
            // clientName of the polymorphicDiscriminator {metadata} (ex: "fishtype")
            // instead of the serializedName of the polymorphicDiscriminator (ex: "fish.type")
            // is a better approach. The generator is not consistent with escaping '\.' in the
            // serializedName of the property (ex: "fish\.type") that is marked as polymorphic discriminator
            // and the serializedName of the metadata polymorphicDiscriminator (ex: "fish.type"). However,
            // the clientName transformation of the polymorphicDiscriminator (ex: "fishtype") and
            // the transformation of model property name (ex: "fishtype") is done consistently.
            // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.
            if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === undefined || propertyInstance === null)) propertyInstance = mapper.serializedName;
            let serializedValue;
            // paging
            if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
                propertyInstance = responseBody[key];
                const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
                // Copy over any properties that have already been added into the instance, where they do
                // not exist on the newly de-serialized array
                for (const [k, v] of Object.entries(instance))if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) arrayInstance[k] = v;
                instance = arrayInstance;
            } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {
                serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
                instance[key] = serializedValue;
            }
        }
    }
    const additionalPropertiesMapper = mapper.type.additionalProperties;
    if (additionalPropertiesMapper) {
        const isAdditionalProperty = (responsePropName)=>{
            for(const clientPropName in modelProps){
                const paths = $72e78c9c5b4d8ef9$var$splitSerializeName(modelProps[clientPropName].serializedName);
                if (paths[0] === responsePropName) return false;
            }
            return true;
        };
        for(const responsePropName in responseBody)if (isAdditionalProperty(responsePropName)) instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
    } else if (responseBody && !options.ignoreUnknownProperties) {
        for (const key of Object.keys(responseBody))if (instance[key] === undefined && !handledPropertyNames.includes(key) && !$72e78c9c5b4d8ef9$var$isSpecialXmlProperty(key, options)) instance[key] = responseBody[key];
    }
    return instance;
}
function $72e78c9c5b4d8ef9$var$deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
    /* jshint validthis: true */ const value = mapper.type.value;
    if (!value || typeof value !== "object") throw new Error(`"value" metadata for a Dictionary must be defined in the ` + `mapper and it must of type "object" in ${objectName}`);
    if (responseBody) {
        const tempDictionary = {};
        for (const key of Object.keys(responseBody))tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
        return tempDictionary;
    }
    return responseBody;
}
function $72e78c9c5b4d8ef9$var$deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
    var _a;
    let element = mapper.type.element;
    if (!element || typeof element !== "object") throw new Error(`element" metadata for an Array must be defined in the ` + `mapper and it must of type "object" in ${objectName}`);
    if (responseBody) {
        if (!Array.isArray(responseBody)) // xml2js will interpret a single element array as just the element, so force it to be an array
        responseBody = [
            responseBody
        ];
        // Quirk: Composite mappers referenced by `element` might
        // not have *all* properties declared (like uberParent),
        // so let's try to look up the full definition by name.
        if (element.type.name === "Composite" && element.type.className) element = (_a = serializer.modelMappers[element.type.className]) !== null && _a !== void 0 ? _a : element;
        const tempArray = [];
        for(let i = 0; i < responseBody.length; i++)tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
        return tempArray;
    }
    return responseBody;
}
function $72e78c9c5b4d8ef9$var$getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
    const typeNamesToCheck = [
        typeName
    ];
    while(typeNamesToCheck.length){
        const currentName = typeNamesToCheck.shift();
        const indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + "." + discriminatorValue;
        if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) return discriminators[indexDiscriminator];
        else {
            for (const [name, mapper] of Object.entries(discriminators))if (name.startsWith(currentName + ".") && mapper.type.uberParent === currentName && mapper.type.className) typeNamesToCheck.push(mapper.type.className);
        }
    }
    return undefined;
}
function $72e78c9c5b4d8ef9$var$getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
    var _a;
    const polymorphicDiscriminator = $72e78c9c5b4d8ef9$var$getPolymorphicDiscriminatorRecursively(serializer, mapper);
    if (polymorphicDiscriminator) {
        let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
        if (discriminatorName) {
            // The serializedName might have \\, which we just want to ignore
            if (polymorphicPropertyName === "serializedName") discriminatorName = discriminatorName.replace(/\\/gi, "");
            const discriminatorValue = object[discriminatorName];
            const typeName = (_a = mapper.type.uberParent) !== null && _a !== void 0 ? _a : mapper.type.className;
            if (typeof discriminatorValue === "string" && typeName) {
                const polymorphicMapper = $72e78c9c5b4d8ef9$var$getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);
                if (polymorphicMapper) mapper = polymorphicMapper;
            }
        }
    }
    return mapper;
}
function $72e78c9c5b4d8ef9$var$getPolymorphicDiscriminatorRecursively(serializer, mapper) {
    return mapper.type.polymorphicDiscriminator || $72e78c9c5b4d8ef9$var$getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || $72e78c9c5b4d8ef9$var$getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);
}
function $72e78c9c5b4d8ef9$var$getPolymorphicDiscriminatorSafely(serializer, typeName) {
    return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;
}
const $72e78c9c5b4d8ef9$export$b672a79edbc76af0 = {
    Base64Url: "Base64Url",
    Boolean: "Boolean",
    ByteArray: "ByteArray",
    Composite: "Composite",
    Date: "Date",
    DateTime: "DateTime",
    DateTimeRfc1123: "DateTimeRfc1123",
    Dictionary: "Dictionary",
    Enum: "Enum",
    Number: "Number",
    Object: "Object",
    Sequence: "Sequence",
    String: "String",
    Stream: "Stream",
    TimeSpan: "TimeSpan",
    UnixTime: "UnixTime"
};


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Retrieves the value to use for a given operation argument
 * @param operationArguments - The arguments passed from the generated client
 * @param parameter - The parameter description
 * @param fallbackObject - If something isn't found in the arguments bag, look here.
 *  Generally used to look at the service client properties.
 */ function $2ef4d3ba23b5b384$export$2c986a50f6fe8e47(operationArguments, parameter, fallbackObject) {
    let parameterPath = parameter.parameterPath;
    const parameterMapper = parameter.mapper;
    let value;
    if (typeof parameterPath === "string") parameterPath = [
        parameterPath
    ];
    if (Array.isArray(parameterPath)) {
        if (parameterPath.length > 0) {
            if (parameterMapper.isConstant) value = parameterMapper.defaultValue;
            else {
                let propertySearchResult = $2ef4d3ba23b5b384$var$getPropertyFromParameterPath(operationArguments, parameterPath);
                if (!propertySearchResult.propertyFound && fallbackObject) propertySearchResult = $2ef4d3ba23b5b384$var$getPropertyFromParameterPath(fallbackObject, parameterPath);
                let useDefaultValue = false;
                if (!propertySearchResult.propertyFound) useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
                value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
            }
        }
    } else {
        if (parameterMapper.required) value = {};
        for(const propertyName in parameterPath){
            const propertyMapper = parameterMapper.type.modelProperties[propertyName];
            const propertyPath = parameterPath[propertyName];
            const propertyValue = $2ef4d3ba23b5b384$export$2c986a50f6fe8e47(operationArguments, {
                parameterPath: propertyPath,
                mapper: propertyMapper
            }, fallbackObject);
            if (propertyValue !== undefined) {
                if (!value) value = {};
                value[propertyName] = propertyValue;
            }
        }
    }
    return value;
}
function $2ef4d3ba23b5b384$var$getPropertyFromParameterPath(parent, parameterPath) {
    const result = {
        propertyFound: false
    };
    let i = 0;
    for(; i < parameterPath.length; ++i){
        const parameterPathPart = parameterPath[i];
        // Make sure to check inherited properties too, so don't use hasOwnProperty().
        if (parent && parameterPathPart in parent) parent = parent[parameterPathPart];
        else break;
    }
    if (i === parameterPath.length) {
        result.propertyValue = parent;
        result.propertyFound = true;
    }
    return result;
}
const $2ef4d3ba23b5b384$var$operationRequestMap = new WeakMap();
const $2ef4d3ba23b5b384$var$originalRequestSymbol = Symbol.for("@azure/core-client original request");
function $2ef4d3ba23b5b384$var$hasOriginalRequest(request) {
    return $2ef4d3ba23b5b384$var$originalRequestSymbol in request;
}
function $2ef4d3ba23b5b384$export$8b0bd44d99f399ab(request) {
    if ($2ef4d3ba23b5b384$var$hasOriginalRequest(request)) return $2ef4d3ba23b5b384$export$8b0bd44d99f399ab(request[$2ef4d3ba23b5b384$var$originalRequestSymbol]);
    let info = $2ef4d3ba23b5b384$var$operationRequestMap.get(request);
    if (!info) {
        info = {};
        $2ef4d3ba23b5b384$var$operationRequestMap.set(request, info);
    }
    return info;
}


const $291f602c4a77976b$var$defaultJsonContentTypes = [
    "application/json",
    "text/json"
];
const $291f602c4a77976b$var$defaultXmlContentTypes = [
    "application/xml",
    "application/atom+xml"
];
const $291f602c4a77976b$export$707bc30a23fb366b = "deserializationPolicy";
function $291f602c4a77976b$export$ac090ac7c9014334(options = {}) {
    var _a, _b, _c, _d, _e, _f, _g;
    const jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : $291f602c4a77976b$var$defaultJsonContentTypes;
    const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : $291f602c4a77976b$var$defaultXmlContentTypes;
    const parseXML = options.parseXML;
    const serializerOptions = options.serializerOptions;
    const updatedOptions = {
        xml: {
            rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : "",
            includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,
            xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : (0, $ee65f5e4dea21a8c$export$3fa08d02e488b7ae)
        }
    };
    return {
        name: $291f602c4a77976b$export$707bc30a23fb366b,
        async sendRequest (request, next) {
            const response = await next(request);
            return $291f602c4a77976b$var$deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
        }
    };
}
function $291f602c4a77976b$var$getOperationResponseMap(parsedResponse) {
    let result;
    const request = parsedResponse.request;
    const operationInfo = (0, $2ef4d3ba23b5b384$export$8b0bd44d99f399ab)(request);
    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
    if (operationSpec) {
        if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) result = operationSpec.responses[parsedResponse.status];
        else result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);
    }
    return result;
}
function $291f602c4a77976b$var$shouldDeserializeResponse(parsedResponse) {
    const request = parsedResponse.request;
    const operationInfo = (0, $2ef4d3ba23b5b384$export$8b0bd44d99f399ab)(request);
    const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;
    let result;
    if (shouldDeserialize === undefined) result = true;
    else if (typeof shouldDeserialize === "boolean") result = shouldDeserialize;
    else result = shouldDeserialize(parsedResponse);
    return result;
}
async function $291f602c4a77976b$var$deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
    const parsedResponse = await $291f602c4a77976b$var$parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
    if (!$291f602c4a77976b$var$shouldDeserializeResponse(parsedResponse)) return parsedResponse;
    const operationInfo = (0, $2ef4d3ba23b5b384$export$8b0bd44d99f399ab)(parsedResponse.request);
    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
    if (!operationSpec || !operationSpec.responses) return parsedResponse;
    const responseSpec = $291f602c4a77976b$var$getOperationResponseMap(parsedResponse);
    const { error: error , shouldReturnResponse: shouldReturnResponse  } = $291f602c4a77976b$var$handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);
    if (error) throw error;
    else if (shouldReturnResponse) return parsedResponse;
    // An operation response spec does exist for current status code, so
    // use it to deserialize the response.
    if (responseSpec) {
        if (responseSpec.bodyMapper) {
            let valueToDeserialize = parsedResponse.parsedBody;
            if (operationSpec.isXML && responseSpec.bodyMapper.type.name === (0, $72e78c9c5b4d8ef9$export$b672a79edbc76af0).Sequence) valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
            try {
                parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
            } catch (deserializeError) {
                const restError = new (0, $193c259516f52386$export$dc24566375af80f3)(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
                    statusCode: parsedResponse.status,
                    request: parsedResponse.request,
                    response: parsedResponse
                });
                throw restError;
            }
        } else if (operationSpec.httpMethod === "HEAD") // head methods never have a body, but we return a boolean to indicate presence/absence of the resource
        parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
        if (responseSpec.headersMapper) parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", {
            xml: {},
            ignoreUnknownProperties: true
        });
    }
    return parsedResponse;
}
function $291f602c4a77976b$var$isOperationSpecEmpty(operationSpec) {
    const expectedStatusCodes = Object.keys(operationSpec.responses);
    return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
}
function $291f602c4a77976b$var$handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
    var _a;
    const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
    const isExpectedStatusCode = $291f602c4a77976b$var$isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
    if (isExpectedStatusCode) {
        if (responseSpec) {
            if (!responseSpec.isError) return {
                error: null,
                shouldReturnResponse: false
            };
        } else return {
            error: null,
            shouldReturnResponse: false
        };
    }
    const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
    const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
    const error = new (0, $193c259516f52386$export$dc24566375af80f3)(initialErrorMessage, {
        statusCode: parsedResponse.status,
        request: parsedResponse.request,
        response: parsedResponse
    });
    // If the item failed but there's no error spec or default spec to deserialize the error,
    // we should fail so we just throw the parsed response
    if (!errorResponseSpec) throw error;
    const defaultBodyMapper = errorResponseSpec.bodyMapper;
    const defaultHeadersMapper = errorResponseSpec.headersMapper;
    try {
        // If error response has a body, try to deserialize it using default body mapper.
        // Then try to extract error code & message from it
        if (parsedResponse.parsedBody) {
            const parsedBody = parsedResponse.parsedBody;
            let deserializedError;
            if (defaultBodyMapper) {
                let valueToDeserialize = parsedBody;
                if (operationSpec.isXML && defaultBodyMapper.type.name === (0, $72e78c9c5b4d8ef9$export$b672a79edbc76af0).Sequence) {
                    valueToDeserialize = [];
                    const elementName = defaultBodyMapper.xmlElementName;
                    if (typeof parsedBody === "object" && elementName) valueToDeserialize = parsedBody[elementName];
                }
                deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
            }
            const internalError = parsedBody.error || deserializedError || parsedBody;
            error.code = internalError.code;
            if (internalError.message) error.message = internalError.message;
            if (defaultBodyMapper) error.response.parsedBody = deserializedError;
        }
        // If error response has headers, try to deserialize it using default header mapper
        if (parsedResponse.headers && defaultHeadersMapper) error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
    } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
    }
    return {
        error: error,
        shouldReturnResponse: false
    };
}
async function $291f602c4a77976b$var$parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
    var _a;
    if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) && operationResponse.bodyAsText) {
        const text = operationResponse.bodyAsText;
        const contentType = operationResponse.headers.get("Content-Type") || "";
        const contentComponents = !contentType ? [] : contentType.split(";").map((component)=>component.toLowerCase());
        try {
            if (contentComponents.length === 0 || contentComponents.some((component)=>jsonContentTypes.indexOf(component) !== -1)) {
                operationResponse.parsedBody = JSON.parse(text);
                return operationResponse;
            } else if (contentComponents.some((component)=>xmlContentTypes.indexOf(component) !== -1)) {
                if (!parseXML) throw new Error("Parsing XML not supported.");
                const body = await parseXML(text, opts.xml);
                operationResponse.parsedBody = body;
                return operationResponse;
            }
        } catch (err) {
            const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
            const errCode = err.code || (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR;
            const e = new (0, $193c259516f52386$export$dc24566375af80f3)(msg, {
                code: errCode,
                statusCode: operationResponse.status,
                request: operationResponse.request,
                response: operationResponse
            });
            throw e;
        }
    }
    return operationResponse;
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

const $4606fb641cf163bc$var$StandardAbortMessage = "The operation was aborted.";
function $4606fb641cf163bc$export$1391212d75b2ee65(delayInMs, value, options) {
    return new Promise((resolve, reject)=>{
        let timer = undefined;
        let onAborted = undefined;
        const rejectOnAbort = ()=>{
            return reject(new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : $4606fb641cf163bc$var$StandardAbortMessage));
        };
        const removeListeners = ()=>{
            if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) options.abortSignal.removeEventListener("abort", onAborted);
        };
        onAborted = ()=>{
            if (timer) clearTimeout(timer);
            removeListeners();
            return rejectOnAbort();
        };
        if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) return rejectOnAbort();
        timer = setTimeout(()=>{
            removeListeners();
            resolve(value);
        }, delayInMs);
        if (options === null || options === void 0 ? void 0 : options.abortSignal) options.abortSignal.addEventListener("abort", onAborted);
    });
}
function $4606fb641cf163bc$export$e72e490e94da6f8f(response, headerName) {
    const value = response.headers.get(headerName);
    if (!value) return;
    const valueAsNum = Number(value);
    if (Number.isNaN(valueAsNum)) return;
    return valueAsNum;
}


const $6b96776e17ed3962$export$52bca39539a4d010 = {
    forcedRefreshWindowInMs: 1000,
    retryIntervalInMs: 3000,
    refreshWindowInMs: 120000
};
/**
 * Converts an an unreliable access token getter (which may resolve with null)
 * into an AccessTokenGetter by retrying the unreliable getter in a regular
 * interval.
 *
 * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.
 * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.
 * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.
 * @returns - A promise that, if it resolves, will resolve with an access token.
 */ async function $6b96776e17ed3962$var$beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
    // This wrapper handles exceptions gracefully as long as we haven't exceeded
    // the timeout.
    async function tryGetAccessToken() {
        if (Date.now() < refreshTimeout) try {
            return await getAccessToken();
        } catch (_a) {
            return null;
        }
        else {
            const finalToken = await getAccessToken();
            // Timeout is up, so throw if it's still null
            if (finalToken === null) throw new Error("Failed to refresh access token.");
            return finalToken;
        }
    }
    let token = await tryGetAccessToken();
    while(token === null){
        await (0, $4606fb641cf163bc$export$1391212d75b2ee65)(retryIntervalInMs);
        token = await tryGetAccessToken();
    }
    return token;
}
function $6b96776e17ed3962$export$95b8567f1f70eca(credential, tokenCyclerOptions) {
    let refreshWorker = null;
    let token = null;
    let tenantId;
    const options = Object.assign(Object.assign({}, $6b96776e17ed3962$export$52bca39539a4d010), tokenCyclerOptions);
    /**
     * This little holder defines several predicates that we use to construct
     * the rules of refreshing the token.
     */ const cycler = {
        /**
         * Produces true if a refresh job is currently in progress.
         */ get isRefreshing () {
            return refreshWorker !== null;
        },
        /**
         * Produces true if the cycler SHOULD refresh (we are within the refresh
         * window and not already refreshing)
         */ get shouldRefresh () {
            var _a;
            return !cycler.isRefreshing && ((_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : 0) - options.refreshWindowInMs < Date.now();
        },
        /**
         * Produces true if the cycler MUST refresh (null or nearly-expired
         * token).
         */ get mustRefresh () {
            return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
        }
    };
    /**
     * Starts a refresh job or returns the existing job if one is already
     * running.
     */ function refresh(scopes, getTokenOptions) {
        var _a;
        if (!cycler.isRefreshing) {
            // We bind `scopes` here to avoid passing it around a lot
            const tryGetAccessToken = ()=>credential.getToken(scopes, getTokenOptions);
            // Take advantage of promise chaining to insert an assignment to `token`
            // before the refresh can be considered done.
            refreshWorker = $6b96776e17ed3962$var$beginRefresh(tryGetAccessToken, options.retryIntervalInMs, // If we don't have a token, then we should timeout immediately
            (_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : Date.now()).then((_token)=>{
                refreshWorker = null;
                token = _token;
                tenantId = getTokenOptions.tenantId;
                return token;
            }).catch((reason)=>{
                // We also should reset the refresher if we enter a failed state.  All
                // existing awaiters will throw, but subsequent requests will start a
                // new retry chain.
                refreshWorker = null;
                token = null;
                tenantId = undefined;
                throw reason;
            });
        }
        return refreshWorker;
    }
    return async (scopes, tokenOptions)=>{
        //
        // Simple rules:
        // - If we MUST refresh, then return the refresh task, blocking
        //   the pipeline until a token is available.
        // - If we SHOULD refresh, then run refresh but don't return it
        //   (we can still use the cached token).
        // - Return the token, since it's fine if we didn't return in
        //   step 1.
        //
        // If the tenantId passed in token options is different to the one we have
        // Or if we are in claim challenge and the token was rejected and a new access token need to be issued, we need to
        // refresh the token with the new tenantId or token.
        const mustRefresh = tenantId !== tokenOptions.tenantId || Boolean(tokenOptions.claims) || cycler.mustRefresh;
        if (mustRefresh) return refresh(scopes, tokenOptions);
        if (cycler.shouldRefresh) refresh(scopes, tokenOptions);
        return token;
    };
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

const $6a700ef01554d889$export$af88d00dbe7f521 = (0, $317b6f994b1c7cb4$export$6817aa89e2fe44fd)("core-rest-pipeline");


const $9b145b715880113b$export$2f6555b1e4373019 = "bearerTokenAuthenticationPolicy";
/**
 * Default authorize request handler
 */ async function $9b145b715880113b$var$defaultAuthorizeRequest(options) {
    const { scopes: scopes , getAccessToken: getAccessToken , request: request  } = options;
    const getTokenOptions = {
        abortSignal: request.abortSignal,
        tracingOptions: request.tracingOptions
    };
    const accessToken = await getAccessToken(scopes, getTokenOptions);
    if (accessToken) options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
}
/**
 * We will retrieve the challenge only if the response status code was 401,
 * and if the response contained the header "WWW-Authenticate" with a non-empty value.
 */ function $9b145b715880113b$var$getChallenge(response) {
    const challenge = response.headers.get("WWW-Authenticate");
    if (response.status === 401 && challenge) return challenge;
    return;
}
function $9b145b715880113b$export$e5acbbd47d7d0b35(options) {
    var _a;
    const { credential: credential , scopes: scopes , challengeCallbacks: challengeCallbacks  } = options;
    const logger = options.logger || (0, $6a700ef01554d889$export$af88d00dbe7f521);
    const callbacks = Object.assign({
        authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a !== void 0 ? _a : $9b145b715880113b$var$defaultAuthorizeRequest,
        authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge
    }, challengeCallbacks);
    // This function encapsulates the entire process of reliably retrieving the token
    // The options are left out of the public API until there's demand to configure this.
    // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`
    // in order to pass through the `options` object.
    const getAccessToken = credential ? (0, $6b96776e17ed3962$export$95b8567f1f70eca)(credential /* , options */ ) : ()=>Promise.resolve(null);
    return {
        name: $9b145b715880113b$export$2f6555b1e4373019,
        /**
         * If there's no challenge parameter:
         * - It will try to retrieve the token using the cache, or the credential's getToken.
         * - Then it will try the next policy with or without the retrieved token.
         *
         * It uses the challenge parameters to:
         * - Skip a first attempt to get the token from the credential if there's no cached token,
         *   since it expects the token to be retrievable only after the challenge.
         * - Prepare the outgoing request if the `prepareRequest` method has been provided.
         * - Send an initial request to receive the challenge if it fails.
         * - Process a challenge if the response contains it.
         * - Retrieve a token with the challenge information, then re-send the request.
         */ async sendRequest (request, next) {
            if (!request.url.toLowerCase().startsWith("https://")) throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
            await callbacks.authorizeRequest({
                scopes: Array.isArray(scopes) ? scopes : [
                    scopes
                ],
                request: request,
                getAccessToken: getAccessToken,
                logger: logger
            });
            let response;
            let error;
            try {
                response = await next(request);
            } catch (err) {
                error = err;
                response = err.response;
            }
            if (callbacks.authorizeRequestOnChallenge && (response === null || response === void 0 ? void 0 : response.status) === 401 && $9b145b715880113b$var$getChallenge(response)) {
                // processes challenge
                const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
                    scopes: Array.isArray(scopes) ? scopes : [
                        scopes
                    ],
                    request: request,
                    response: response,
                    getAccessToken: getAccessToken,
                    logger: logger
                });
                if (shouldSendRequest) return next(request);
            }
            if (error) throw error;
            else return response;
        }
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


const $af9ccd0fbeb37611$export$162cd7b3c39e4c57 = "logPolicy";
function $af9ccd0fbeb37611$export$c96ba9e66d66ee29(options = {}) {
    var _a;
    const logger = (_a = options.logger) !== null && _a !== void 0 ? _a : (0, $6a700ef01554d889$export$af88d00dbe7f521).info;
    const sanitizer = new (0, $1ecbf9da13fb2cf8$export$a6cec3dfaf45e6ac)({
        additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
        additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
    });
    return {
        name: $af9ccd0fbeb37611$export$162cd7b3c39e4c57,
        async sendRequest (request, next) {
            if (!logger.enabled) return next(request);
            logger(`Request: ${sanitizer.sanitize(request)}`);
            const response = await next(request);
            logger(`Response status code: ${response.status}`);
            logger(`Headers: ${sanitizer.sanitize(response.headers)}`);
            return response;
        }
    };
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const $2b2a01191f1d7896$var$ValidPhaseNames = new Set([
    "Deserialize",
    "Serialize",
    "Retry",
    "Sign"
]);
/**
 * A private implementation of Pipeline.
 * Do not export this class from the package.
 * @internal
 */ class $2b2a01191f1d7896$var$HttpPipeline {
    constructor(policies){
        var _a;
        this._policies = [];
        this._policies = (_a = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a !== void 0 ? _a : [];
        this._orderedPolicies = undefined;
    }
    addPolicy(policy, options = {}) {
        if (options.phase && options.afterPhase) throw new Error("Policies inside a phase cannot specify afterPhase.");
        if (options.phase && !$2b2a01191f1d7896$var$ValidPhaseNames.has(options.phase)) throw new Error(`Invalid phase name: ${options.phase}`);
        if (options.afterPhase && !$2b2a01191f1d7896$var$ValidPhaseNames.has(options.afterPhase)) throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
        this._policies.push({
            policy: policy,
            options: options
        });
        this._orderedPolicies = undefined;
    }
    removePolicy(options) {
        const removedPolicies = [];
        this._policies = this._policies.filter((policyDescriptor)=>{
            if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
                removedPolicies.push(policyDescriptor.policy);
                return false;
            } else return true;
        });
        this._orderedPolicies = undefined;
        return removedPolicies;
    }
    sendRequest(httpClient, request) {
        const policies = this.getOrderedPolicies();
        const pipeline = policies.reduceRight((next, policy)=>{
            return (req)=>{
                return policy.sendRequest(req, next);
            };
        }, (req)=>httpClient.sendRequest(req));
        return pipeline(request);
    }
    getOrderedPolicies() {
        if (!this._orderedPolicies) this._orderedPolicies = this.orderPolicies();
        return this._orderedPolicies;
    }
    clone() {
        return new $2b2a01191f1d7896$var$HttpPipeline(this._policies);
    }
    static create() {
        return new $2b2a01191f1d7896$var$HttpPipeline();
    }
    orderPolicies() {
        /**
         * The goal of this method is to reliably order pipeline policies
         * based on their declared requirements when they were added.
         *
         * Order is first determined by phase:
         *
         * 1. Serialize Phase
         * 2. Policies not in a phase
         * 3. Deserialize Phase
         * 4. Retry Phase
         * 5. Sign Phase
         *
         * Within each phase, policies are executed in the order
         * they were added unless they were specified to execute
         * before/after other policies or after a particular phase.
         *
         * To determine the final order, we will walk the policy list
         * in phase order multiple times until all dependencies are
         * satisfied.
         *
         * `afterPolicies` are the set of policies that must be
         * executed before a given policy. This requirement is
         * considered satisfied when each of the listed policies
         * have been scheduled.
         *
         * `beforePolicies` are the set of policies that must be
         * executed after a given policy. Since this dependency
         * can be expressed by converting it into a equivalent
         * `afterPolicies` declarations, they are normalized
         * into that form for simplicity.
         *
         * An `afterPhase` dependency is considered satisfied when all
         * policies in that phase have scheduled.
         *
         */ const result = [];
        // Track all policies we know about.
        const policyMap = new Map();
        function createPhase(name) {
            return {
                name: name,
                policies: new Set(),
                hasRun: false,
                hasAfterPolicies: false
            };
        }
        // Track policies for each phase.
        const serializePhase = createPhase("Serialize");
        const noPhase = createPhase("None");
        const deserializePhase = createPhase("Deserialize");
        const retryPhase = createPhase("Retry");
        const signPhase = createPhase("Sign");
        // a list of phases in order
        const orderedPhases = [
            serializePhase,
            noPhase,
            deserializePhase,
            retryPhase,
            signPhase
        ];
        // Small helper function to map phase name to each Phase
        function getPhase(phase) {
            if (phase === "Retry") return retryPhase;
            else if (phase === "Serialize") return serializePhase;
            else if (phase === "Deserialize") return deserializePhase;
            else if (phase === "Sign") return signPhase;
            else return noPhase;
        }
        // First walk each policy and create a node to track metadata.
        for (const descriptor of this._policies){
            const policy = descriptor.policy;
            const options = descriptor.options;
            const policyName = policy.name;
            if (policyMap.has(policyName)) throw new Error("Duplicate policy names not allowed in pipeline");
            const node = {
                policy: policy,
                dependsOn: new Set(),
                dependants: new Set()
            };
            if (options.afterPhase) {
                node.afterPhase = getPhase(options.afterPhase);
                node.afterPhase.hasAfterPolicies = true;
            }
            policyMap.set(policyName, node);
            const phase = getPhase(options.phase);
            phase.policies.add(node);
        }
        // Now that each policy has a node, connect dependency references.
        for (const descriptor of this._policies){
            const { policy: policy , options: options  } = descriptor;
            const policyName = policy.name;
            const node = policyMap.get(policyName);
            if (!node) throw new Error(`Missing node for policy ${policyName}`);
            if (options.afterPolicies) for (const afterPolicyName of options.afterPolicies){
                const afterNode = policyMap.get(afterPolicyName);
                if (afterNode) {
                    // Linking in both directions helps later
                    // when we want to notify dependants.
                    node.dependsOn.add(afterNode);
                    afterNode.dependants.add(node);
                }
            }
            if (options.beforePolicies) for (const beforePolicyName of options.beforePolicies){
                const beforeNode = policyMap.get(beforePolicyName);
                if (beforeNode) {
                    // To execute before another node, make it
                    // depend on the current node.
                    beforeNode.dependsOn.add(node);
                    node.dependants.add(beforeNode);
                }
            }
        }
        function walkPhase(phase) {
            phase.hasRun = true;
            // Sets iterate in insertion order
            for (const node of phase.policies){
                if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) continue;
                if (node.dependsOn.size === 0) {
                    // If there's nothing else we're waiting for, we can
                    // add this policy to the result list.
                    result.push(node.policy);
                    // Notify anything that depends on this policy that
                    // the policy has been scheduled.
                    for (const dependant of node.dependants)dependant.dependsOn.delete(node);
                    policyMap.delete(node.policy.name);
                    phase.policies.delete(node);
                }
            }
        }
        function walkPhases() {
            for (const phase of orderedPhases){
                walkPhase(phase);
                // if the phase isn't complete
                if (phase.policies.size > 0 && phase !== noPhase) {
                    if (!noPhase.hasRun) // Try running noPhase to see if that unblocks this phase next tick.
                    // This can happen if a phase that happens before noPhase
                    // is waiting on a noPhase policy to complete.
                    walkPhase(noPhase);
                    // Don't proceed to the next phase until this phase finishes.
                    return;
                }
                if (phase.hasAfterPolicies) // Run any policies unblocked by this phase
                walkPhase(noPhase);
            }
        }
        // Iterate until we've put every node in the result list.
        let iteration = 0;
        while(policyMap.size > 0){
            iteration++;
            const initialResultLength = result.length;
            // Keep walking each phase in order until we can order every node.
            walkPhases();
            // The result list *should* get at least one larger each time
            // after the first full pass.
            // Otherwise, we're going to loop forever.
            if (result.length <= initialResultLength && iteration > 1) throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
        }
        return result;
    }
}
function $2b2a01191f1d7896$export$d1727d948a2aa6e7() {
    return $2b2a01191f1d7896$var$HttpPipeline.create();
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the redirectPolicy.
 */ const $2e7a22c7c7f7dd1e$export$2bb09fba19b91286 = "redirectPolicy";
/**
 * Methods that are allowed to follow redirects 301 and 302
 */ const $2e7a22c7c7f7dd1e$var$allowedRedirect = [
    "GET",
    "HEAD"
];
function $2e7a22c7c7f7dd1e$export$aec739cfb985bd48(options = {}) {
    const { maxRetries: maxRetries = 20  } = options;
    return {
        name: $2e7a22c7c7f7dd1e$export$2bb09fba19b91286,
        async sendRequest (request, next) {
            const response = await next(request);
            return $2e7a22c7c7f7dd1e$var$handleRedirect(next, response, maxRetries);
        }
    };
}
async function $2e7a22c7c7f7dd1e$var$handleRedirect(next, response, maxRetries, currentRetries = 0) {
    const { request: request , status: status , headers: headers  } = response;
    const locationHeader = headers.get("location");
    if (locationHeader && (status === 300 || status === 301 && $2e7a22c7c7f7dd1e$var$allowedRedirect.includes(request.method) || status === 302 && $2e7a22c7c7f7dd1e$var$allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && currentRetries < maxRetries) {
        const url = new URL(locationHeader, request.url);
        request.url = url.toString();
        // POST request with Status code 303 should be converted into a
        // redirected GET request if the redirect url is present in the location header
        if (status === 303) {
            request.method = "GET";
            request.headers.delete("Content-Length");
            delete request.body;
        }
        request.headers.delete("Authorization");
        const res = await next(request);
        return $2e7a22c7c7f7dd1e$var$handleRedirect(next, res, maxRetries, currentRetries + 1);
    }
    return response;
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*
 * NOTE: When moving this file, please update "browser" section in package.json.
 */ /**
 * @internal
 */ function $1787b91d1b0a6364$export$87e37b6916dc901a() {
    return "x-ms-useragent";
}
function $1787b91d1b0a6364$export$3e6b862a73a0e567(map) {
    const navigator = self.navigator;
    map.set("OS", (navigator.oscpu || navigator.platform).replace(" ", ""));
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const $9c2923b73c95bef5$export$31499a9cd224b78c = "1.10.1";
const $9c2923b73c95bef5$export$e3758b282b1c2dcb = 3;


function $1640f05a30325a88$var$getUserAgentString(telemetryInfo) {
    const parts = [];
    for (const [key, value] of telemetryInfo){
        const token = value ? `${key}/${value}` : key;
        parts.push(token);
    }
    return parts.join(" ");
}
function $1640f05a30325a88$export$f9841484781380f9() {
    return (0, $1787b91d1b0a6364$export$87e37b6916dc901a)();
}
function $1640f05a30325a88$export$221b71a1214c5f7a(prefix) {
    const runtimeInfo = new Map();
    runtimeInfo.set("core-rest-pipeline", (0, $9c2923b73c95bef5$export$31499a9cd224b78c));
    (0, $1787b91d1b0a6364$export$3e6b862a73a0e567)(runtimeInfo);
    const defaultAgent = $1640f05a30325a88$var$getUserAgentString(runtimeInfo);
    const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
    return userAgentValue;
}


const $dc3d1b5a58e7db79$var$UserAgentHeaderName = (0, $1640f05a30325a88$export$f9841484781380f9)();
const $dc3d1b5a58e7db79$export$5bf0c6ccddee0872 = "userAgentPolicy";
function $dc3d1b5a58e7db79$export$df2ab2ef63bad35a(options = {}) {
    const userAgentValue = (0, $1640f05a30325a88$export$221b71a1214c5f7a)(options.userAgentPrefix);
    return {
        name: $dc3d1b5a58e7db79$export$5bf0c6ccddee0872,
        async sendRequest (request, next) {
            if (!request.headers.has($dc3d1b5a58e7db79$var$UserAgentHeaderName)) request.headers.set($dc3d1b5a58e7db79$var$UserAgentHeaderName, userAgentValue);
            return next(request);
        }
    };
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*
 * NOTE: When moving this file, please update "browser" section in package.json
 */ const $5220c3e9ec354312$var$NotSupported = new Error("decompressResponsePolicy is not supported in browser environment");
const $5220c3e9ec354312$export$71b15ae52e40e9b9 = "decompressResponsePolicy";
function $5220c3e9ec354312$export$a07d3565d8e03af5() {
    throw $5220c3e9ec354312$var$NotSupported;
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Returns a random integer value between a lower and upper bound,
 * inclusive of both bounds.
 * Note that this uses Math.random and isn't secure. If you need to use
 * this for any kind of security purpose, find a better source of random.
 * @param min - The smallest integer value allowed.
 * @param max - The largest integer value allowed.
 */ function $a308c8cb34bb1ce7$export$d35777cbac4821b(min, max) {
    // Make sure inputs are integers.
    min = Math.ceil(min);
    max = Math.floor(max);
    // Pick a random offset from zero to the size of the range.
    // Since Math.random() can never return 1, we have to make the range one larger
    // in order to be inclusive of the maximum value after we take the floor.
    const offset = Math.floor(Math.random() * (max - min + 1));
    return offset + min;
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * The header that comes back from Azure services representing
 * the amount of time (minimum) to wait to retry (in seconds or timestamp after which we can retry).
 */ const $6da668ba5992a75c$var$RetryAfterHeader = "Retry-After";
/**
 * The headers that come back from Azure services representing
 * the amount of time (minimum) to wait to retry.
 *
 * "retry-after-ms", "x-ms-retry-after-ms" : milliseconds
 * "Retry-After" : seconds or timestamp
 */ const $6da668ba5992a75c$var$AllRetryAfterHeaders = [
    "retry-after-ms",
    "x-ms-retry-after-ms",
    $6da668ba5992a75c$var$RetryAfterHeader
];
/**
 * A response is a throttling retry response if it has a throttling status code (429 or 503),
 * as long as one of the [ "Retry-After" or "retry-after-ms" or "x-ms-retry-after-ms" ] headers has a valid value.
 *
 * Returns the `retryAfterInMs` value if the response is a throttling retry response.
 * If not throttling retry response, returns `undefined`.
 *
 * @internal
 */ function $6da668ba5992a75c$var$getRetryAfterInMs(response) {
    if (!(response && [
        429,
        503
    ].includes(response.status))) return undefined;
    try {
        // Headers: "retry-after-ms", "x-ms-retry-after-ms", "Retry-After"
        for (const header of $6da668ba5992a75c$var$AllRetryAfterHeaders){
            const retryAfterValue = (0, $4606fb641cf163bc$export$e72e490e94da6f8f)(response, header);
            if (retryAfterValue === 0 || retryAfterValue) {
                // "Retry-After" header ==> seconds
                // "retry-after-ms", "x-ms-retry-after-ms" headers ==> milli-seconds
                const multiplyingFactor = header === $6da668ba5992a75c$var$RetryAfterHeader ? 1000 : 1;
                return retryAfterValue * multiplyingFactor; // in milli-seconds
            }
        }
        // RetryAfterHeader ("Retry-After") has a special case where it might be formatted as a date instead of a number of seconds
        const retryAfterHeader = response.headers.get($6da668ba5992a75c$var$RetryAfterHeader);
        if (!retryAfterHeader) return;
        const date = Date.parse(retryAfterHeader);
        const diff = date - Date.now();
        // negative diff would mean a date in the past, so retry asap with 0 milliseconds
        return Number.isFinite(diff) ? Math.max(0, diff) : undefined;
    } catch (e) {
        return undefined;
    }
}
function $6da668ba5992a75c$export$48a74a1c26461af(response) {
    return Number.isFinite($6da668ba5992a75c$var$getRetryAfterInMs(response));
}
function $6da668ba5992a75c$export$3d2fd7f8042e755a() {
    return {
        name: "throttlingRetryStrategy",
        retry ({ response: response  }) {
            const retryAfterInMs = $6da668ba5992a75c$var$getRetryAfterInMs(response);
            if (!Number.isFinite(retryAfterInMs)) return {
                skipStrategy: true
            };
            return {
                retryAfterInMs: retryAfterInMs
            };
        }
    };
}


// intervals are in milliseconds
const $3102c395b91bd98a$var$DEFAULT_CLIENT_RETRY_INTERVAL = 1000;
const $3102c395b91bd98a$var$DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 64000;
function $3102c395b91bd98a$export$32df8c45a4e0ceb(options = {}) {
    var _a, _b;
    const retryInterval = (_a = options.retryDelayInMs) !== null && _a !== void 0 ? _a : $3102c395b91bd98a$var$DEFAULT_CLIENT_RETRY_INTERVAL;
    const maxRetryInterval = (_b = options.maxRetryDelayInMs) !== null && _b !== void 0 ? _b : $3102c395b91bd98a$var$DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
    let retryAfterInMs = retryInterval;
    return {
        name: "exponentialRetryStrategy",
        retry ({ retryCount: retryCount , response: response , responseError: responseError  }) {
            const matchedSystemError = $3102c395b91bd98a$export$4963f644aa8940e5(responseError);
            const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
            const isExponential = $3102c395b91bd98a$export$8f4e838352aae1f9(response);
            const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
            const unknownResponse = response && ((0, $6da668ba5992a75c$export$48a74a1c26461af)(response) || !isExponential);
            if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) return {
                skipStrategy: true
            };
            if (responseError && !matchedSystemError && !isExponential) return {
                errorToThrow: responseError
            };
            // Exponentially increase the delay each time
            const exponentialDelay = retryAfterInMs * Math.pow(2, retryCount);
            // Don't let the delay exceed the maximum
            const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);
            // Allow the final value to have some "jitter" (within 50% of the delay size) so
            // that retries across multiple clients don't occur simultaneously.
            retryAfterInMs = clampedExponentialDelay / 2 + (0, $a308c8cb34bb1ce7$export$d35777cbac4821b)(0, clampedExponentialDelay / 2);
            return {
                retryAfterInMs: retryAfterInMs
            };
        }
    };
}
function $3102c395b91bd98a$export$8f4e838352aae1f9(response) {
    return Boolean(response && response.status !== undefined && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
}
function $3102c395b91bd98a$export$4963f644aa8940e5(err) {
    if (!err) return false;
    return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT";
}



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.




const $244267dd3413894f$var$retryPolicyLogger = (0, $317b6f994b1c7cb4$export$6817aa89e2fe44fd)("core-rest-pipeline retryPolicy");
/**
 * The programmatic identifier of the retryPolicy.
 */ const $244267dd3413894f$var$retryPolicyName = "retryPolicy";
function $244267dd3413894f$export$37db893101ba8efb(strategies, options = {
    maxRetries: (0, $9c2923b73c95bef5$export$e3758b282b1c2dcb)
}) {
    const logger = options.logger || $244267dd3413894f$var$retryPolicyLogger;
    return {
        name: $244267dd3413894f$var$retryPolicyName,
        async sendRequest (request, next) {
            var _a, _b;
            let response;
            let responseError;
            let retryCount = -1;
            // eslint-disable-next-line no-constant-condition
            retryRequest: while(true){
                retryCount += 1;
                response = undefined;
                responseError = undefined;
                try {
                    logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
                    response = await next(request);
                    logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
                } catch (e) {
                    logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
                    // RestErrors are valid targets for the retry strategies.
                    // If none of the retry strategies can work with them, they will be thrown later in this policy.
                    // If the received error is not a RestError, it is immediately thrown.
                    responseError = e;
                    if (!e || responseError.name !== "RestError") throw e;
                    response = responseError.response;
                }
                if ((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {
                    logger.error(`Retry ${retryCount}: Request aborted.`);
                    const abortError = new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)();
                    throw abortError;
                }
                if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : (0, $9c2923b73c95bef5$export$e3758b282b1c2dcb))) {
                    logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
                    if (responseError) throw responseError;
                    else if (response) return response;
                    else throw new Error("Maximum retries reached with no response or error to throw");
                }
                logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
                strategiesLoop: for (const strategy of strategies){
                    const strategyLogger = strategy.logger || $244267dd3413894f$var$retryPolicyLogger;
                    strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
                    const modifiers = strategy.retry({
                        retryCount: retryCount,
                        response: response,
                        responseError: responseError
                    });
                    if (modifiers.skipStrategy) {
                        strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                        continue strategiesLoop;
                    }
                    const { errorToThrow: errorToThrow , retryAfterInMs: retryAfterInMs , redirectTo: redirectTo  } = modifiers;
                    if (errorToThrow) {
                        strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                        throw errorToThrow;
                    }
                    if (retryAfterInMs || retryAfterInMs === 0) {
                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                        await (0, $4606fb641cf163bc$export$1391212d75b2ee65)(retryAfterInMs, undefined, {
                            abortSignal: request.abortSignal
                        });
                        continue retryRequest;
                    }
                    if (redirectTo) {
                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                        request.url = redirectTo;
                        continue retryRequest;
                    }
                }
                if (responseError) {
                    logger.info(`None of the retry strategies could work with the received error. Throwing it.`);
                    throw responseError;
                }
                if (response) {
                    logger.info(`None of the retry strategies could work with the received response. Returning it.`);
                    return response;
                }
            // If all the retries skip and there's no response,
            // we're still in the retry loop, so a new request will be sent
            // until `maxRetries` is reached.
            }
        }
    };
}



const $acc3a78d5f58f537$export$8e84dd420dfc05b3 = "defaultRetryPolicy";
function $acc3a78d5f58f537$export$2797ac0c742a895c(options = {}) {
    var _a;
    return {
        name: $acc3a78d5f58f537$export$8e84dd420dfc05b3,
        sendRequest: (0, $244267dd3413894f$export$37db893101ba8efb)([
            (0, $6da668ba5992a75c$export$3d2fd7f8042e755a)(),
            (0, $3102c395b91bd98a$export$32df8c45a4e0ceb)(options)
        ], {
            maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : (0, $9c2923b73c95bef5$export$e3758b282b1c2dcb)
        }).sendRequest
    };
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the formDataPolicy.
 */ const $44b19483823d3e9f$export$17a6717f6759c6c6 = "formDataPolicy";
function $44b19483823d3e9f$export$605ab7ff664094f0() {
    return {
        name: $44b19483823d3e9f$export$17a6717f6759c6c6,
        async sendRequest (request, next) {
            if (request.formData) {
                const formData = request.formData;
                const requestForm = new FormData();
                for (const formKey of Object.keys(formData)){
                    const formValue = formData[formKey];
                    if (Array.isArray(formValue)) for (const subValue of formValue)requestForm.append(formKey, subValue);
                    else requestForm.append(formKey, formValue);
                }
                request.body = requestForm;
                request.formData = undefined;
                const contentType = request.headers.get("Content-Type");
                if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) request.body = new URLSearchParams(requestForm).toString();
                else if (contentType && contentType.indexOf("multipart/form-data") !== -1) // browser will automatically apply a suitable content-type header
                request.headers.delete("Content-Type");
            }
            return next(request);
        }
    };
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A constant that indicates whether the environment the code is running is Node.JS.
 */ const $72332c5644972df7$export$8ee0fc9ee280b4ee = false;


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*
 * NOTE: When moving this file, please update "browser" section in package.json
 */ const $89ade17572dfe4b6$var$NotSupported = new Error("proxyPolicy is not supported in browser environment");
const $89ade17572dfe4b6$export$da40def3840f10fb = "proxyPolicy";
function $89ade17572dfe4b6$export$a59f045a6868232f() {
    throw $89ade17572dfe4b6$var$NotSupported;
}
function $89ade17572dfe4b6$export$c8ba111c8b5cde39() {
    throw $89ade17572dfe4b6$var$NotSupported;
}
function $89ade17572dfe4b6$export$c0bf6e840aff75d1() {
    throw $89ade17572dfe4b6$var$NotSupported;
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the setClientRequestIdPolicy.
 */ const $662831931d556f25$export$b96f0a399433e783 = "setClientRequestIdPolicy";
function $662831931d556f25$export$89a9abde4287c015(requestIdHeaderName = "x-ms-client-request-id") {
    return {
        name: $662831931d556f25$export$b96f0a399433e783,
        async sendRequest (request, next) {
            if (!request.headers.has(requestIdHeaderName)) request.headers.set(requestIdHeaderName, request.requestId);
            return next(request);
        }
    };
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Name of the TLS Policy
 */ const $e510f06eed8ca9b7$export$de2418bd56fd77e7 = "tlsPolicy";
function $e510f06eed8ca9b7$export$6f1cb49a51acb2b0(tlsSettings) {
    return {
        name: $e510f06eed8ca9b7$export$de2418bd56fd77e7,
        sendRequest: async (req, next)=>{
            // Users may define a request tlsSettings, honor those over the client level one
            if (!req.tlsSettings) req.tlsSettings = tlsSettings;
            return next(req);
        }
    };
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/** @internal */ const $8a68a38cec0db871$export$49bcd6db97664b30 = {
    span: Symbol.for("@azure/core-tracing span"),
    namespace: Symbol.for("@azure/core-tracing namespace")
};
function $8a68a38cec0db871$export$adc0ba9c4c5a984d(options = {}) {
    let context = new $8a68a38cec0db871$export$ea437edda9257640(options.parentContext);
    if (options.span) context = context.setValue($8a68a38cec0db871$export$49bcd6db97664b30.span, options.span);
    if (options.namespace) context = context.setValue($8a68a38cec0db871$export$49bcd6db97664b30.namespace, options.namespace);
    return context;
}
class $8a68a38cec0db871$export$ea437edda9257640 {
    constructor(initialContext){
        this._contextMap = initialContext instanceof $8a68a38cec0db871$export$ea437edda9257640 ? new Map(initialContext._contextMap) : new Map();
    }
    setValue(key, value) {
        const newContext = new $8a68a38cec0db871$export$ea437edda9257640(this);
        newContext._contextMap.set(key, value);
        return newContext;
    }
    getValue(key) {
        return this._contextMap.get(key);
    }
    deleteValue(key) {
        const newContext = new $8a68a38cec0db871$export$ea437edda9257640(this);
        newContext._contextMap.delete(key);
        return newContext;
    }
}


function $a1078fa26c02e5db$export$587b9db4b7c4a6ca() {
    return {
        end: ()=>{
        // noop
        },
        isRecording: ()=>false,
        recordException: ()=>{
        // noop
        },
        setAttribute: ()=>{
        // noop
        },
        setStatus: ()=>{
        // noop
        }
    };
}
function $a1078fa26c02e5db$export$d5a1a4534f47a56c() {
    return {
        createRequestHeaders: ()=>{
            return {};
        },
        parseTraceparentHeader: ()=>{
            return undefined;
        },
        startSpan: (_name, spanOptions)=>{
            return {
                span: $a1078fa26c02e5db$export$587b9db4b7c4a6ca(),
                tracingContext: (0, $8a68a38cec0db871$export$adc0ba9c4c5a984d)({
                    parentContext: spanOptions.tracingContext
                })
            };
        },
        withContext (_context, callback, ...callbackArgs) {
            return callback(...callbackArgs);
        }
    };
}
/** @internal */ let $a1078fa26c02e5db$var$instrumenterImplementation;
function $a1078fa26c02e5db$export$98309c408aedd7b9(instrumenter) {
    $a1078fa26c02e5db$var$instrumenterImplementation = instrumenter;
}
function $a1078fa26c02e5db$export$4b530bf07734fa4c() {
    if (!$a1078fa26c02e5db$var$instrumenterImplementation) $a1078fa26c02e5db$var$instrumenterImplementation = $a1078fa26c02e5db$export$d5a1a4534f47a56c();
    return $a1078fa26c02e5db$var$instrumenterImplementation;
}



function $0be52965dd582894$export$3bcb12d844328c5c(options) {
    const { namespace: namespace , packageName: packageName , packageVersion: packageVersion  } = options;
    function startSpan(name, operationOptions, spanOptions) {
        var _a;
        const startSpanResult = (0, $a1078fa26c02e5db$export$4b530bf07734fa4c)().startSpan(name, Object.assign(Object.assign({}, spanOptions), {
            packageName: packageName,
            packageVersion: packageVersion,
            tracingContext: (_a = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext
        }));
        let tracingContext = startSpanResult.tracingContext;
        const span = startSpanResult.span;
        if (!tracingContext.getValue((0, $8a68a38cec0db871$export$49bcd6db97664b30).namespace)) tracingContext = tracingContext.setValue((0, $8a68a38cec0db871$export$49bcd6db97664b30).namespace, namespace);
        span.setAttribute("az.namespace", tracingContext.getValue((0, $8a68a38cec0db871$export$49bcd6db97664b30).namespace));
        const updatedOptions = Object.assign({}, operationOptions, {
            tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), {
                tracingContext: tracingContext
            })
        });
        return {
            span: span,
            updatedOptions: updatedOptions
        };
    }
    async function withSpan(name, operationOptions, callback, spanOptions) {
        const { span: span , updatedOptions: updatedOptions  } = startSpan(name, operationOptions, spanOptions);
        try {
            const result = await withContext(updatedOptions.tracingOptions.tracingContext, ()=>Promise.resolve(callback(updatedOptions, span)));
            span.setStatus({
                status: "success"
            });
            return result;
        } catch (err) {
            span.setStatus({
                status: "error",
                error: err
            });
            throw err;
        } finally{
            span.end();
        }
    }
    function withContext(context, callback, ...callbackArgs) {
        return (0, $a1078fa26c02e5db$export$4b530bf07734fa4c)().withContext(context, callback, ...callbackArgs);
    }
    /**
     * Parses a traceparent header value into a span identifier.
     *
     * @param traceparentHeader - The traceparent header to parse.
     * @returns An implementation-specific identifier for the span.
     */ function parseTraceparentHeader(traceparentHeader) {
        return (0, $a1078fa26c02e5db$export$4b530bf07734fa4c)().parseTraceparentHeader(traceparentHeader);
    }
    /**
     * Creates a set of request headers to propagate tracing information to a backend.
     *
     * @param tracingContext - The context containing the span to serialize.
     * @returns The set of headers to add to a request.
     */ function createRequestHeaders(tracingContext) {
        return (0, $a1078fa26c02e5db$export$4b530bf07734fa4c)().createRequestHeaders(tracingContext);
    }
    return {
        startSpan: startSpan,
        withSpan: withSpan,
        withContext: withContext,
        parseTraceparentHeader: parseTraceparentHeader,
        createRequestHeaders: createRequestHeaders
    };
}







const $bce1b55e60ad2d8b$export$95e79aa245a9e403 = "tracingPolicy";
function $bce1b55e60ad2d8b$export$3ac4e45166506a4b(options = {}) {
    const userAgent = (0, $1640f05a30325a88$export$221b71a1214c5f7a)(options.userAgentPrefix);
    const tracingClient = $bce1b55e60ad2d8b$var$tryCreateTracingClient();
    return {
        name: $bce1b55e60ad2d8b$export$95e79aa245a9e403,
        async sendRequest (request, next) {
            var _a, _b;
            if (!tracingClient || !((_a = request.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext)) return next(request);
            const { span: span , tracingContext: tracingContext  } = (_b = $bce1b55e60ad2d8b$var$tryCreateSpan(tracingClient, request, userAgent)) !== null && _b !== void 0 ? _b : {};
            if (!span || !tracingContext) return next(request);
            try {
                const response = await tracingClient.withContext(tracingContext, next, request);
                $bce1b55e60ad2d8b$var$tryProcessResponse(span, response);
                return response;
            } catch (err) {
                $bce1b55e60ad2d8b$var$tryProcessError(span, err);
                throw err;
            }
        }
    };
}
function $bce1b55e60ad2d8b$var$tryCreateTracingClient() {
    try {
        return (0, $0be52965dd582894$export$3bcb12d844328c5c)({
            namespace: "",
            packageName: "@azure/core-rest-pipeline",
            packageVersion: (0, $9c2923b73c95bef5$export$31499a9cd224b78c)
        });
    } catch (e) {
        (0, $6a700ef01554d889$export$af88d00dbe7f521).warning(`Error when creating the TracingClient: ${(0, $0a59209d5914926b$export$82f46aa4e6535a45)(e)}`);
        return undefined;
    }
}
function $bce1b55e60ad2d8b$var$tryCreateSpan(tracingClient, request, userAgent) {
    try {
        // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.
        const { span: span , updatedOptions: updatedOptions  } = tracingClient.startSpan(`HTTP ${request.method}`, {
            tracingOptions: request.tracingOptions
        }, {
            spanKind: "client",
            spanAttributes: {
                "http.method": request.method,
                "http.url": request.url,
                requestId: request.requestId
            }
        });
        // If the span is not recording, don't do any more work.
        if (!span.isRecording()) {
            span.end();
            return undefined;
        }
        if (userAgent) span.setAttribute("http.user_agent", userAgent);
        // set headers
        const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
        for (const [key, value] of Object.entries(headers))request.headers.set(key, value);
        return {
            span: span,
            tracingContext: updatedOptions.tracingOptions.tracingContext
        };
    } catch (e) {
        (0, $6a700ef01554d889$export$af88d00dbe7f521).warning(`Skipping creating a tracing span due to an error: ${(0, $0a59209d5914926b$export$82f46aa4e6535a45)(e)}`);
        return undefined;
    }
}
function $bce1b55e60ad2d8b$var$tryProcessError(span, error) {
    try {
        span.setStatus({
            status: "error",
            error: (0, $0a59209d5914926b$export$e6127cc7fe7395c3)(error) ? error : undefined
        });
        if ((0, $193c259516f52386$export$d5d5fe2886ccec3c)(error) && error.statusCode) span.setAttribute("http.status_code", error.statusCode);
        span.end();
    } catch (e) {
        (0, $6a700ef01554d889$export$af88d00dbe7f521).warning(`Skipping tracing span processing due to an error: ${(0, $0a59209d5914926b$export$82f46aa4e6535a45)(e)}`);
    }
}
function $bce1b55e60ad2d8b$var$tryProcessResponse(span, response) {
    try {
        span.setAttribute("http.status_code", response.status);
        const serviceRequestId = response.headers.get("x-ms-request-id");
        if (serviceRequestId) span.setAttribute("serviceRequestId", serviceRequestId);
        span.setStatus({
            status: "success"
        });
        span.end();
    } catch (e) {
        (0, $6a700ef01554d889$export$af88d00dbe7f521).warning(`Skipping tracing span processing due to an error: ${(0, $0a59209d5914926b$export$82f46aa4e6535a45)(e)}`);
    }
}


function $930b2d4a108c5dd3$export$79e143a6bb5a0b5c(options) {
    const pipeline = (0, $2b2a01191f1d7896$export$d1727d948a2aa6e7)();
    if (0, $72332c5644972df7$export$8ee0fc9ee280b4ee) {
        if (options.tlsOptions) pipeline.addPolicy((0, $e510f06eed8ca9b7$export$6f1cb49a51acb2b0)(options.tlsOptions));
        pipeline.addPolicy((0, $89ade17572dfe4b6$export$c8ba111c8b5cde39)(options.proxyOptions));
        pipeline.addPolicy((0, $5220c3e9ec354312$export$a07d3565d8e03af5)());
    }
    pipeline.addPolicy((0, $44b19483823d3e9f$export$605ab7ff664094f0)());
    pipeline.addPolicy((0, $dc3d1b5a58e7db79$export$df2ab2ef63bad35a)(options.userAgentOptions));
    pipeline.addPolicy((0, $662831931d556f25$export$89a9abde4287c015)());
    pipeline.addPolicy((0, $acc3a78d5f58f537$export$2797ac0c742a895c)(options.retryOptions), {
        phase: "Retry"
    });
    pipeline.addPolicy((0, $bce1b55e60ad2d8b$export$3ac4e45166506a4b)(options.userAgentOptions), {
        afterPhase: "Retry"
    });
    if (0, $72332c5644972df7$export$8ee0fc9ee280b4ee) // Both XHR and Fetch expect to handle redirects automatically,
    // so only include this policy when we're in Node.
    pipeline.addPolicy((0, $2e7a22c7c7f7dd1e$export$aec739cfb985bd48)(options.redirectOptions), {
        afterPhase: "Retry"
    });
    pipeline.addPolicy((0, $af9ccd0fbeb37611$export$c96ba9e66d66ee29)(options.loggingOptions), {
        afterPhase: "Sign"
    });
    return pipeline;
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

function $973441e5503c9ea9$export$1c504bd9a245807c(operationSpec) {
    const result = new Set();
    for(const statusCode in operationSpec.responses){
        const operationResponse = operationSpec.responses[statusCode];
        if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === (0, $72e78c9c5b4d8ef9$export$b672a79edbc76af0).Stream) result.add(Number(statusCode));
    }
    return result;
}
function $973441e5503c9ea9$export$173afac482274412(parameter) {
    const { parameterPath: parameterPath , mapper: mapper  } = parameter;
    let result;
    if (typeof parameterPath === "string") result = parameterPath;
    else if (Array.isArray(parameterPath)) result = parameterPath.join(".");
    else result = mapper.serializedName;
    return result;
}


const $f9528d8a385bcd85$export$4587c427028f4d5d = "serializationPolicy";
function $f9528d8a385bcd85$export$62c17809e04ee806(options = {}) {
    const stringifyXML = options.stringifyXML;
    return {
        name: $f9528d8a385bcd85$export$4587c427028f4d5d,
        async sendRequest (request, next) {
            const operationInfo = (0, $2ef4d3ba23b5b384$export$8b0bd44d99f399ab)(request);
            const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
            const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;
            if (operationSpec && operationArguments) {
                $f9528d8a385bcd85$export$dfd5dd9013041417(request, operationArguments, operationSpec);
                $f9528d8a385bcd85$export$d41791bb388bd485(request, operationArguments, operationSpec, stringifyXML);
            }
            return next(request);
        }
    };
}
function $f9528d8a385bcd85$export$dfd5dd9013041417(request, operationArguments, operationSpec) {
    var _a, _b;
    if (operationSpec.headerParameters) for (const headerParameter of operationSpec.headerParameters){
        let headerValue = (0, $2ef4d3ba23b5b384$export$2c986a50f6fe8e47)(operationArguments, headerParameter);
        if (headerValue !== null && headerValue !== undefined || headerParameter.mapper.required) {
            headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, (0, $973441e5503c9ea9$export$173afac482274412)(headerParameter));
            const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
            if (headerCollectionPrefix) for (const key of Object.keys(headerValue))request.headers.set(headerCollectionPrefix + key, headerValue[key]);
            else request.headers.set(headerParameter.mapper.serializedName || (0, $973441e5503c9ea9$export$173afac482274412)(headerParameter), headerValue);
        }
    }
    const customHeaders = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;
    if (customHeaders) for (const customHeaderName of Object.keys(customHeaders))request.headers.set(customHeaderName, customHeaders[customHeaderName]);
}
function $f9528d8a385bcd85$export$d41791bb388bd485(request, operationArguments, operationSpec, stringifyXML = function() {
    throw new Error("XML serialization unsupported!");
}) {
    var _a, _b, _c, _d, _e;
    const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;
    const updatedOptions = {
        xml: {
            rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : "",
            includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,
            xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : (0, $ee65f5e4dea21a8c$export$3fa08d02e488b7ae)
        }
    };
    const xmlCharKey = updatedOptions.xml.xmlCharKey;
    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
        request.body = (0, $2ef4d3ba23b5b384$export$2c986a50f6fe8e47)(operationArguments, operationSpec.requestBody);
        const bodyMapper = operationSpec.requestBody.mapper;
        const { required: required , serializedName: serializedName , xmlName: xmlName , xmlElementName: xmlElementName , xmlNamespace: xmlNamespace , xmlNamespacePrefix: xmlNamespacePrefix , nullable: nullable  } = bodyMapper;
        const typeName = bodyMapper.type.name;
        try {
            if (request.body !== undefined && request.body !== null || nullable && request.body === null || required) {
                const requestBodyParameterPathString = (0, $973441e5503c9ea9$export$173afac482274412)(operationSpec.requestBody);
                request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
                const isStream = typeName === (0, $72e78c9c5b4d8ef9$export$b672a79edbc76af0).Stream;
                if (operationSpec.isXML) {
                    const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
                    const value = $f9528d8a385bcd85$var$getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
                    if (typeName === (0, $72e78c9c5b4d8ef9$export$b672a79edbc76af0).Sequence) request.body = stringifyXML($f9528d8a385bcd85$var$prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {
                        rootName: xmlName || serializedName,
                        xmlCharKey: xmlCharKey
                    });
                    else if (!isStream) request.body = stringifyXML(value, {
                        rootName: xmlName || serializedName,
                        xmlCharKey: xmlCharKey
                    });
                } else if (typeName === (0, $72e78c9c5b4d8ef9$export$b672a79edbc76af0).String && (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match("text/plain")) || operationSpec.mediaType === "text")) // the String serializer has validated that request body is a string
                // so just send the string.
                return;
                else if (!isStream) request.body = JSON.stringify(request.body);
            }
        } catch (error) {
            throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, "  ")}.`);
        }
    } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
        request.formData = {};
        for (const formDataParameter of operationSpec.formDataParameters){
            const formDataParameterValue = (0, $2ef4d3ba23b5b384$export$2c986a50f6fe8e47)(operationArguments, formDataParameter);
            if (formDataParameterValue !== undefined && formDataParameterValue !== null) {
                const formDataParameterPropertyName = formDataParameter.mapper.serializedName || (0, $973441e5503c9ea9$export$173afac482274412)(formDataParameter);
                request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, (0, $973441e5503c9ea9$export$173afac482274412)(formDataParameter), updatedOptions);
            }
        }
    }
}
/**
 * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself
 */ function $f9528d8a385bcd85$var$getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
    // Composite and Sequence schemas already got their root namespace set during serialization
    // We just need to add xmlns to the other schema types
    if (xmlNamespace && ![
        "Composite",
        "Sequence",
        "Dictionary"
    ].includes(typeName)) {
        const result = {};
        result[options.xml.xmlCharKey] = serializedValue;
        result[0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8] = {
            [xmlnsKey]: xmlNamespace
        };
        return result;
    }
    return serializedValue;
}
function $f9528d8a385bcd85$var$prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
    if (!Array.isArray(obj)) obj = [
        obj
    ];
    if (!xmlNamespaceKey || !xmlNamespace) return {
        [elementName]: obj
    };
    const result = {
        [elementName]: obj
    };
    result[0, $ee65f5e4dea21a8c$export$3dfa762fc17d84c8] = {
        [xmlNamespaceKey]: xmlNamespace
    };
    return result;
}


function $96f96959b2b91c2e$export$7d57dbe7f7617174(options = {}) {
    const pipeline = (0, $930b2d4a108c5dd3$export$79e143a6bb5a0b5c)(options !== null && options !== void 0 ? options : {});
    if (options.credentialOptions) pipeline.addPolicy((0, $9b145b715880113b$export$e5acbbd47d7d0b35)({
        credential: options.credentialOptions.credential,
        scopes: options.credentialOptions.credentialScopes
    }));
    pipeline.addPolicy((0, $f9528d8a385bcd85$export$62c17809e04ee806)(options.serializationOptions), {
        phase: "Serialize"
    });
    pipeline.addPolicy((0, $291f602c4a77976b$export$ac090ac7c9014334)(options.deserializationOptions), {
        phase: "Deserialize"
    });
    return pipeline;
}



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.



/**
 * Checks if the body is a NodeReadable stream which is not supported in Browsers
 */ function $56cecc7c844355a8$var$isNodeReadableStream(body) {
    return body && typeof body.pipe === "function";
}
/**
 * Checks if the body is a ReadableStream supported by browsers
 */ function $56cecc7c844355a8$var$isReadableStream(body) {
    return Boolean(body && typeof body.getReader === "function" && typeof body.tee === "function");
}
/**
 * Checks if the body is a Blob or Blob-like
 */ function $56cecc7c844355a8$var$isBlob(body) {
    // File objects count as a type of Blob, so we want to use instanceof explicitly
    return (typeof Blob === "function" || typeof Blob === "object") && body instanceof Blob;
}
/**
 * A HttpClient implementation that uses window.fetch to send HTTP requests.
 * @internal
 */ class $56cecc7c844355a8$var$FetchHttpClient {
    /**
     * Makes a request over an underlying transport layer and returns the response.
     * @param request - The request to be made.
     */ async sendRequest(request) {
        const url = new URL(request.url);
        const isInsecure = url.protocol !== "https:";
        if (isInsecure && !request.allowInsecureConnection) throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
        if (request.proxySettings) throw new Error("HTTP proxy is not supported in browser environment");
        try {
            return await $56cecc7c844355a8$var$makeRequest(request);
        } catch (e) {
            throw $56cecc7c844355a8$var$getError(e, request);
        }
    }
}
/**
 * Sends a request
 */ async function $56cecc7c844355a8$var$makeRequest(request) {
    const { abortController: abortController , abortControllerCleanup: abortControllerCleanup  } = $56cecc7c844355a8$var$setupAbortSignal(request);
    try {
        const headers = $56cecc7c844355a8$var$buildFetchHeaders(request.headers);
        const requestBody = $56cecc7c844355a8$var$buildRequestBody(request);
        /**
         * Developers of the future:
         * Do not set redirect: "manual" as part
         * of request options.
         * It will not work as you expect.
         */ const response = await fetch(request.url, {
            body: requestBody,
            method: request.method,
            headers: headers,
            signal: abortController.signal,
            credentials: request.withCredentials ? "include" : "same-origin",
            cache: "no-store"
        });
        // If we're uploading a blob, we need to fire the progress event manually
        if ($56cecc7c844355a8$var$isBlob(request.body) && request.onUploadProgress) request.onUploadProgress({
            loadedBytes: request.body.size
        });
        return $56cecc7c844355a8$var$buildPipelineResponse(response, request);
    } finally{
        if (abortControllerCleanup) abortControllerCleanup();
    }
}
/**
 * Creates a pipeline response from a Fetch response;
 */ async function $56cecc7c844355a8$var$buildPipelineResponse(httpResponse, request) {
    var _a, _b;
    const headers = $56cecc7c844355a8$var$buildPipelineHeaders(httpResponse);
    const response = {
        request: request,
        headers: headers,
        status: httpResponse.status
    };
    const bodyStream = $56cecc7c844355a8$var$isReadableStream(httpResponse.body) ? $56cecc7c844355a8$var$buildBodyStream(httpResponse.body, request.onDownloadProgress) : httpResponse.body;
    if (// Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
    ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) || ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status))) {
        if (request.enableBrowserStreams) response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : undefined;
        else {
            const responseStream = new Response(bodyStream);
            response.blobBody = responseStream.blob();
        }
    } else {
        const responseStream = new Response(bodyStream);
        response.bodyAsText = await responseStream.text();
    }
    return response;
}
function $56cecc7c844355a8$var$setupAbortSignal(request) {
    const abortController = new AbortController();
    // Cleanup function
    let abortControllerCleanup;
    /**
     * Attach an abort listener to the request
     */ let abortListener;
    if (request.abortSignal) {
        if (request.abortSignal.aborted) throw new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)("The operation was aborted.");
        abortListener = (event)=>{
            if (event.type === "abort") abortController.abort();
        };
        request.abortSignal.addEventListener("abort", abortListener);
        abortControllerCleanup = ()=>{
            var _a;
            if (abortListener) (_a = request.abortSignal) === null || _a === void 0 || _a.removeEventListener("abort", abortListener);
        };
    }
    // If a timeout was passed, call the abort signal once the time elapses
    if (request.timeout > 0) setTimeout(()=>{
        abortController.abort();
    }, request.timeout);
    return {
        abortController: abortController,
        abortControllerCleanup: abortControllerCleanup
    };
}
/**
 * Gets the specific error
 */ function $56cecc7c844355a8$var$getError(e, request) {
    var _a;
    if (e && (e === null || e === void 0 ? void 0 : e.name) === "AbortError") return e;
    else return new (0, $193c259516f52386$export$dc24566375af80f3)(`Error sending request: ${e.message}`, {
        code: (_a = e === null || e === void 0 ? void 0 : e.code) !== null && _a !== void 0 ? _a : (0, $193c259516f52386$export$dc24566375af80f3).REQUEST_SEND_ERROR,
        request: request
    });
}
/**
 * Converts PipelineRequest headers to Fetch headers
 */ function $56cecc7c844355a8$var$buildFetchHeaders(pipelineHeaders) {
    const headers = new Headers();
    for (const [name, value] of pipelineHeaders)headers.append(name, value);
    return headers;
}
function $56cecc7c844355a8$var$buildPipelineHeaders(httpResponse) {
    const responseHeaders = (0, $b376023a8674c0ff$export$4c8e967a76f3c947)();
    for (const [name, value] of httpResponse.headers)responseHeaders.set(name, value);
    return responseHeaders;
}
function $56cecc7c844355a8$var$buildRequestBody(request) {
    const body = typeof request.body === "function" ? request.body() : request.body;
    if ($56cecc7c844355a8$var$isNodeReadableStream(body)) throw new Error("Node streams are not supported in browser environment.");
    return $56cecc7c844355a8$var$isReadableStream(body) ? $56cecc7c844355a8$var$buildBodyStream(body, request.onUploadProgress) : body;
}
/**
 * Reads the request/response original stream and stream it through a new
 * ReadableStream, this is done to be able to report progress in a way that
 * all modern browsers support. TransformStreams would be an alternative,
 * however they are not yet supported by all browsers i.e Firefox
 */ function $56cecc7c844355a8$var$buildBodyStream(readableStream, onProgress) {
    let loadedBytes = 0;
    // If the current browser supports pipeThrough we use a TransformStream
    // to report progress
    if ($56cecc7c844355a8$var$isTransformStreamSupported(readableStream)) return readableStream.pipeThrough(new TransformStream({
        transform (chunk, controller) {
            if (chunk === null) {
                controller.terminate();
                return;
            }
            controller.enqueue(chunk);
            loadedBytes += chunk.length;
            if (onProgress) onProgress({
                loadedBytes: loadedBytes
            });
        }
    }));
    else {
        // If we can't use transform streams, wrap the original stream in a new readable stream
        // and use pull to enqueue each chunk and report progress.
        const reader = readableStream.getReader();
        return new ReadableStream({
            async pull (controller) {
                var _a;
                const { done: done , value: value  } = await reader.read();
                // When no more data needs to be consumed, break the reading
                if (done || !value) {
                    // Close the stream
                    controller.close();
                    reader.releaseLock();
                    return;
                }
                loadedBytes += (_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0;
                // Enqueue the next data chunk into our target stream
                controller.enqueue(value);
                if (onProgress) onProgress({
                    loadedBytes: loadedBytes
                });
            }
        });
    }
}
function $56cecc7c844355a8$export$a30ee91d3082b1b0() {
    return new $56cecc7c844355a8$var$FetchHttpClient();
}
function $56cecc7c844355a8$var$isTransformStreamSupported(readableStream) {
    return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;
}


function $377f735a36c7d8ee$export$e2b0f951cdeb69f4() {
    return (0, $56cecc7c844355a8$export$a30ee91d3082b1b0)();
}


let $56edff50561cbfc9$var$cachedHttpClient;
function $56edff50561cbfc9$export$d93b5f299dd18102() {
    if (!$56edff50561cbfc9$var$cachedHttpClient) $56edff50561cbfc9$var$cachedHttpClient = (0, $377f735a36c7d8ee$export$e2b0f951cdeb69f4)();
    return $56edff50561cbfc9$var$cachedHttpClient;
}



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


const $c18195882ce309ca$var$CollectionFormatToDelimiterMap = {
    CSV: ",",
    SSV: " ",
    Multi: "Multi",
    TSV: "	",
    Pipes: "|"
};
function $c18195882ce309ca$export$14619c0eed01a470(baseUri, operationSpec, operationArguments, fallbackObject) {
    const urlReplacements = $c18195882ce309ca$var$calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
    let isAbsolutePath = false;
    let requestUrl = $c18195882ce309ca$var$replaceAll(baseUri, urlReplacements);
    if (operationSpec.path) {
        let path = $c18195882ce309ca$var$replaceAll(operationSpec.path, urlReplacements);
        // QUIRK: sometimes we get a path component like /{nextLink}
        // which may be a fully formed URL with a leading /. In that case, we should
        // remove the leading /
        if (operationSpec.path === "/{nextLink}" && path.startsWith("/")) path = path.substring(1);
        // QUIRK: sometimes we get a path component like {nextLink}
        // which may be a fully formed URL. In that case, we should
        // ignore the baseUri.
        if ($c18195882ce309ca$var$isAbsoluteUrl(path)) {
            requestUrl = path;
            isAbsolutePath = true;
        } else requestUrl = $c18195882ce309ca$var$appendPath(requestUrl, path);
    }
    const { queryParams: queryParams , sequenceParams: sequenceParams  } = $c18195882ce309ca$var$calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
    /**
     * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`
     * is an absolute path. This ensures that existing query parameter values in `requestUrl`
     * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it
     * is still being built so there is nothing to overwrite.
     */ requestUrl = $c18195882ce309ca$export$a0b32aef6b0d7373(requestUrl, queryParams, sequenceParams, isAbsolutePath);
    return requestUrl;
}
function $c18195882ce309ca$var$replaceAll(input, replacements) {
    let result = input;
    for (const [searchValue, replaceValue] of replacements)result = result.split(searchValue).join(replaceValue);
    return result;
}
function $c18195882ce309ca$var$calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
    var _a;
    const result = new Map();
    if ((_a = operationSpec.urlParameters) === null || _a === void 0 ? void 0 : _a.length) for (const urlParameter of operationSpec.urlParameters){
        let urlParameterValue = (0, $2ef4d3ba23b5b384$export$2c986a50f6fe8e47)(operationArguments, urlParameter, fallbackObject);
        const parameterPathString = (0, $973441e5503c9ea9$export$173afac482274412)(urlParameter);
        urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
        if (!urlParameter.skipEncoding) urlParameterValue = encodeURIComponent(urlParameterValue);
        result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
    }
    return result;
}
function $c18195882ce309ca$var$isAbsoluteUrl(url) {
    return url.includes("://");
}
function $c18195882ce309ca$var$appendPath(url, pathToAppend) {
    if (!pathToAppend) return url;
    const parsedUrl = new URL(url);
    let newPath = parsedUrl.pathname;
    if (!newPath.endsWith("/")) newPath = `${newPath}/`;
    if (pathToAppend.startsWith("/")) pathToAppend = pathToAppend.substring(1);
    const searchStart = pathToAppend.indexOf("?");
    if (searchStart !== -1) {
        const path = pathToAppend.substring(0, searchStart);
        const search = pathToAppend.substring(searchStart + 1);
        newPath = newPath + path;
        if (search) parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
    } else newPath = newPath + pathToAppend;
    parsedUrl.pathname = newPath;
    return parsedUrl.toString();
}
function $c18195882ce309ca$var$calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
    var _a;
    const result = new Map();
    const sequenceParams = new Set();
    if ((_a = operationSpec.queryParameters) === null || _a === void 0 ? void 0 : _a.length) for (const queryParameter of operationSpec.queryParameters){
        if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) sequenceParams.add(queryParameter.mapper.serializedName);
        let queryParameterValue = (0, $2ef4d3ba23b5b384$export$2c986a50f6fe8e47)(operationArguments, queryParameter, fallbackObject);
        if (queryParameterValue !== undefined && queryParameterValue !== null || queryParameter.mapper.required) {
            queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, (0, $973441e5503c9ea9$export$173afac482274412)(queryParameter));
            const delimiter = queryParameter.collectionFormat ? $c18195882ce309ca$var$CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
            if (Array.isArray(queryParameterValue)) // replace null and undefined
            queryParameterValue = queryParameterValue.map((item)=>{
                if (item === null || item === undefined) return "";
                return item;
            });
            if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) continue;
            else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) queryParameterValue = queryParameterValue.join(delimiter);
            if (!queryParameter.skipEncoding) {
                if (Array.isArray(queryParameterValue)) queryParameterValue = queryParameterValue.map((item)=>{
                    return encodeURIComponent(item);
                });
                else queryParameterValue = encodeURIComponent(queryParameterValue);
            }
            // Join pipes and CSV *after* encoding, or the server will be upset.
            if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) queryParameterValue = queryParameterValue.join(delimiter);
            result.set(queryParameter.mapper.serializedName || (0, $973441e5503c9ea9$export$173afac482274412)(queryParameter), queryParameterValue);
        }
    }
    return {
        queryParams: result,
        sequenceParams: sequenceParams
    };
}
function $c18195882ce309ca$var$simpleParseQueryParams(queryString) {
    const result = new Map();
    if (!queryString || queryString[0] !== "?") return result;
    // remove the leading ?
    queryString = queryString.slice(1);
    const pairs = queryString.split("&");
    for (const pair of pairs){
        const [name, value] = pair.split("=", 2);
        const existingValue = result.get(name);
        if (existingValue) {
            if (Array.isArray(existingValue)) existingValue.push(value);
            else result.set(name, [
                existingValue,
                value
            ]);
        } else result.set(name, value);
    }
    return result;
}
function $c18195882ce309ca$export$a0b32aef6b0d7373(url, queryParams, sequenceParams, noOverwrite = false) {
    if (queryParams.size === 0) return url;
    const parsedUrl = new URL(url);
    // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which
    // can change their meaning to the server, such as in the case of a SAS signature.
    // To avoid accidentally un-encoding a query param, we parse the key/values ourselves
    const combinedParams = $c18195882ce309ca$var$simpleParseQueryParams(parsedUrl.search);
    for (const [name, value] of queryParams){
        const existingValue = combinedParams.get(name);
        if (Array.isArray(existingValue)) {
            if (Array.isArray(value)) {
                existingValue.push(...value);
                const valueSet = new Set(existingValue);
                combinedParams.set(name, Array.from(valueSet));
            } else existingValue.push(value);
        } else if (existingValue) {
            if (Array.isArray(value)) value.unshift(existingValue);
            else if (sequenceParams.has(name)) combinedParams.set(name, [
                existingValue,
                value
            ]);
            if (!noOverwrite) combinedParams.set(name, value);
        } else combinedParams.set(name, value);
    }
    const searchPieces = [];
    for (const [name, value] of combinedParams){
        if (typeof value === "string") searchPieces.push(`${name}=${value}`);
        else if (Array.isArray(value)) // QUIRK: If we get an array of values, include multiple key/value pairs
        for (const subValue of value)searchPieces.push(`${name}=${subValue}`);
        else searchPieces.push(`${name}=${value}`);
    }
    // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.
    parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return parsedUrl.toString();
}



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

const $f4a4b26931a9ca3e$export$af88d00dbe7f521 = (0, $317b6f994b1c7cb4$export$6817aa89e2fe44fd)("core-client");


class $2ade6bc07be65fbf$export$eca146def0f3ecb3 {
    /**
     * The ServiceClient constructor
     * @param credential - The credentials used for authentication with the service.
     * @param options - The service client options that govern the behavior of the client.
     */ constructor(options = {}){
        var _a, _b;
        this._requestContentType = options.requestContentType;
        this._endpoint = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri;
        if (options.baseUri) (0, $f4a4b26931a9ca3e$export$af88d00dbe7f521).warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
        this._allowInsecureConnection = options.allowInsecureConnection;
        this._httpClient = options.httpClient || (0, $56edff50561cbfc9$export$d93b5f299dd18102)();
        this.pipeline = options.pipeline || $2ade6bc07be65fbf$var$createDefaultPipeline(options);
        if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) for (const { policy: policy , position: position  } of options.additionalPolicies){
            // Sign happens after Retry and is commonly needed to occur
            // before policies that intercept post-retry.
            const afterPhase = position === "perRetry" ? "Sign" : undefined;
            this.pipeline.addPolicy(policy, {
                afterPhase: afterPhase
            });
        }
    }
    /**
     * Send the provided httpRequest.
     */ async sendRequest(request) {
        return this.pipeline.sendRequest(this._httpClient, request);
    }
    /**
     * Send an HTTP request that is populated using the provided OperationSpec.
     * @typeParam T - The typed result of the request, based on the OperationSpec.
     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
     * @param operationSpec - The OperationSpec to use to populate the httpRequest.
     */ async sendOperationRequest(operationArguments, operationSpec) {
        const endpoint = operationSpec.baseUrl || this._endpoint;
        if (!endpoint) throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
        // Templatized URLs sometimes reference properties on the ServiceClient child class,
        // so we have to pass `this` below in order to search these properties if they're
        // not part of OperationArguments
        const url = (0, $c18195882ce309ca$export$14619c0eed01a470)(endpoint, operationSpec, operationArguments, this);
        const request = (0, $02e45365db79d766$export$7a9cd74b232af14e)({
            url: url
        });
        request.method = operationSpec.httpMethod;
        const operationInfo = (0, $2ef4d3ba23b5b384$export$8b0bd44d99f399ab)(request);
        operationInfo.operationSpec = operationSpec;
        operationInfo.operationArguments = operationArguments;
        const contentType = operationSpec.contentType || this._requestContentType;
        if (contentType && operationSpec.requestBody) request.headers.set("Content-Type", contentType);
        const options = operationArguments.options;
        if (options) {
            const requestOptions = options.requestOptions;
            if (requestOptions) {
                if (requestOptions.timeout) request.timeout = requestOptions.timeout;
                if (requestOptions.onUploadProgress) request.onUploadProgress = requestOptions.onUploadProgress;
                if (requestOptions.onDownloadProgress) request.onDownloadProgress = requestOptions.onDownloadProgress;
                if (requestOptions.shouldDeserialize !== undefined) operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
                if (requestOptions.allowInsecureConnection) request.allowInsecureConnection = true;
            }
            if (options.abortSignal) request.abortSignal = options.abortSignal;
            if (options.tracingOptions) request.tracingOptions = options.tracingOptions;
        }
        if (this._allowInsecureConnection) request.allowInsecureConnection = true;
        if (request.streamResponseStatusCodes === undefined) request.streamResponseStatusCodes = (0, $973441e5503c9ea9$export$1c504bd9a245807c)(operationSpec);
        try {
            const rawResponse = await this.sendRequest(request);
            const flatResponse = (0, $c0f36cd5ab3a5dd4$export$10ef1a07d9cdec62)(rawResponse, operationSpec.responses[rawResponse.status]);
            if (options === null || options === void 0 ? void 0 : options.onResponse) options.onResponse(rawResponse, flatResponse);
            return flatResponse;
        } catch (error) {
            if (typeof error === "object" && (error === null || error === void 0 ? void 0 : error.response)) {
                const rawResponse = error.response;
                const flatResponse = (0, $c0f36cd5ab3a5dd4$export$10ef1a07d9cdec62)(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
                error.details = flatResponse;
                if (options === null || options === void 0 ? void 0 : options.onResponse) options.onResponse(rawResponse, flatResponse, error);
            }
            throw error;
        }
    }
}
function $2ade6bc07be65fbf$var$createDefaultPipeline(options) {
    const credentialScopes = $2ade6bc07be65fbf$var$getCredentialScopes(options);
    const credentialOptions = options.credential && credentialScopes ? {
        credentialScopes: credentialScopes,
        credential: options.credential
    } : undefined;
    return (0, $96f96959b2b91c2e$export$7d57dbe7f7617174)(Object.assign(Object.assign({}, options), {
        credentialOptions: credentialOptions
    }));
}
function $2ade6bc07be65fbf$var$getCredentialScopes(options) {
    if (options.credentialScopes) {
        const scopes = options.credentialScopes;
        return Array.isArray(scopes) ? scopes.map((scope)=>new URL(scope).toString()) : new URL(scopes).toString();
    }
    if (options.endpoint) return `${options.endpoint}/.default`;
    if (options.baseUri) return `${options.baseUri}/.default`;
    if (options.credential && !options.credentialScopes) throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
    return undefined;
}



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper TypeGuard that checks if something is defined or not.
 * @param thing - Anything
 */ function $a7961d970a7496cb$export$4e62c701997796c1(thing) {
    return typeof thing !== "undefined" && thing !== null;
}
function $a7961d970a7496cb$export$44aa3a8a1abdb9b6(thing, properties) {
    if (!$a7961d970a7496cb$export$4e62c701997796c1(thing) || typeof thing !== "object") return false;
    for (const property of properties){
        if (!$a7961d970a7496cb$export$48d753fb7585d4bb(thing, property)) return false;
    }
    return true;
}
function $a7961d970a7496cb$export$48d753fb7585d4bb(thing, property) {
    return $a7961d970a7496cb$export$4e62c701997796c1(thing) && typeof thing === "object" && property in thing;
}


const $f014dc9d393cdf62$export$af88d00dbe7f521 = $f014dc9d393cdf62$export$20189e4eec33a8a4("service-bus");
const $f014dc9d393cdf62$export$e0718a134caff0cf = $f014dc9d393cdf62$export$20189e4eec33a8a4("service-bus:receiver");
const $f014dc9d393cdf62$export$eed4bd3850cd4ef3 = $f014dc9d393cdf62$export$20189e4eec33a8a4("service-bus:sender");
const $f014dc9d393cdf62$export$f4fc36e28d2894a8 = $f014dc9d393cdf62$export$20189e4eec33a8a4("service-bus:rulemanager");
const $f014dc9d393cdf62$export$5801c71a5905b414 = $f014dc9d393cdf62$export$20189e4eec33a8a4("service-bus:connection");
const $f014dc9d393cdf62$export$ad4beb6ef0944731 = $f014dc9d393cdf62$export$20189e4eec33a8a4("service-bus:administration");
const $f014dc9d393cdf62$export$bb8c8b6a9c29dff9 = $f014dc9d393cdf62$export$20189e4eec33a8a4("service-bus:messages");
const $f014dc9d393cdf62$export$af6f5d5234509fc9 = $f014dc9d393cdf62$export$20189e4eec33a8a4("service-bus:management");
function $f014dc9d393cdf62$export$6fe26fa55e239433(_logger, error) {
    if ((0, $a7961d970a7496cb$export$44aa3a8a1abdb9b6)(error, [
        "stack"
    ]) && error.stack) _logger.verbose(error.stack);
}
function $f014dc9d393cdf62$export$20189e4eec33a8a4(namespace) {
    const _logger = (0, $317b6f994b1c7cb4$export$6817aa89e2fe44fd)(namespace);
    _logger["logError"] = (err, ...args)=>{
        let l;
        // abort errors are user initiated so we don't have to treat them as warnings, like we
        // would with other errors.
        if ($f014dc9d393cdf62$var$isError(err) && err.name === "AbortError") l = _logger.info;
        else l = _logger.warning;
        // tack on the error object so it also gets logged.
        args.push(":", err);
        // let the normal formatting work and include the error at the end.
        l(...args);
        // optionally log the stack trace if it's available but this always goes to verbose
        if (err && err.stack) _logger.verbose(err.stack);
    };
    return _logger;
}
/**
 * @internal
 */ function $f014dc9d393cdf62$var$isError(err) {
    return err != null && err.name != null;
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/// <reference lib="dom"/>
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Default key used to access the XML attributes.
 */ const $3eac3ad234c705a4$export$3dfa762fc17d84c8 = "$";
const $3eac3ad234c705a4$export$3fa08d02e488b7ae = "_";


if (!document || !DOMParser || !Node || !XMLSerializer) throw new Error(`This library depends on the following DOM objects: ["document", "DOMParser", "Node", "XMLSerializer"] to parse XML, but some of these are undefined. You may provide a polyfill to make these globally available in order to support your environment. For more information, please refer to https://aka.ms/azsdk/js/web-workers. `);
// Policy to make our code Trusted Types compliant at running time.
//   https://github.com/w3c/webappsec-trusted-types
// We are calling DOMParser.parseFromString() to parse XML payload from Azure services.
// The parsed DOM object is not exposed to outside. Scripts are disabled when parsing
// according to the spec.  There are no HTML/XSS security concerns on the usage of
// parseFromString() here.
let $912ad09622b3b2a0$var$ttPolicy;
if (typeof self.trustedTypes !== "undefined") $912ad09622b3b2a0$var$ttPolicy = self.trustedTypes.createPolicy("@azure/core-xml#xml.browser", {
    createHTML: (s)=>s
});
const $912ad09622b3b2a0$var$doc = document.implementation.createDocument(null, null, null);
const $912ad09622b3b2a0$var$parser = new DOMParser();
function $912ad09622b3b2a0$export$eacefc55fad2867e(str, opts = {}) {
    var _a, _b, _c, _d, _e, _f;
    try {
        const updatedOptions = {
            rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : "",
            includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,
            xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : (0, $3eac3ad234c705a4$export$3fa08d02e488b7ae),
            cdataPropName: (_d = opts.cdataPropName) !== null && _d !== void 0 ? _d : "__cdata",
            stopNodes: (_e = opts.stopNodes) !== null && _e !== void 0 ? _e : []
        };
        const dom = $912ad09622b3b2a0$var$parser.parseFromString((_f = $912ad09622b3b2a0$var$ttPolicy === null || $912ad09622b3b2a0$var$ttPolicy === void 0 ? void 0 : $912ad09622b3b2a0$var$ttPolicy.createHTML(str)) !== null && _f !== void 0 ? _f : str, "application/xml");
        $912ad09622b3b2a0$var$throwIfError(dom);
        let obj;
        if (updatedOptions.includeRoot) obj = $912ad09622b3b2a0$var$domToObject(dom, updatedOptions);
        else obj = $912ad09622b3b2a0$var$domToObject(dom.childNodes[0], updatedOptions);
        return Promise.resolve(obj);
    } catch (err) {
        return Promise.reject(err);
    }
}
let $912ad09622b3b2a0$var$errorNS;
function $912ad09622b3b2a0$var$getErrorNamespace() {
    var _a, _b;
    if ($912ad09622b3b2a0$var$errorNS === undefined) try {
        const invalidXML = (_a = $912ad09622b3b2a0$var$ttPolicy === null || $912ad09622b3b2a0$var$ttPolicy === void 0 ? void 0 : $912ad09622b3b2a0$var$ttPolicy.createHTML("INVALID")) !== null && _a !== void 0 ? _a : "INVALID";
        $912ad09622b3b2a0$var$errorNS = (_b = $912ad09622b3b2a0$var$parser.parseFromString(invalidXML, "text/xml").getElementsByTagName("parsererror")[0].namespaceURI) !== null && _b !== void 0 ? _b : "";
    } catch (ignored) {
        // Most browsers will return a document containing <parsererror>, but IE will throw.
        $912ad09622b3b2a0$var$errorNS = "";
    }
    return $912ad09622b3b2a0$var$errorNS;
}
function $912ad09622b3b2a0$var$throwIfError(dom) {
    const parserErrors = dom.getElementsByTagName("parsererror");
    if (parserErrors.length > 0 && $912ad09622b3b2a0$var$getErrorNamespace()) for(let i = 0; i < parserErrors.length; i++){
        if (parserErrors[i].namespaceURI === $912ad09622b3b2a0$var$errorNS) throw new Error(parserErrors[i].innerHTML);
    }
}
function $912ad09622b3b2a0$var$isElement(node) {
    return !!node.attributes;
}
/**
 * Get the Element-typed version of the provided Node if the provided node is an element with
 * attributes. If it isn't, then undefined is returned.
 */ function $912ad09622b3b2a0$var$asElementWithAttributes(node) {
    return $912ad09622b3b2a0$var$isElement(node) && node.hasAttributes() ? node : undefined;
}
function $912ad09622b3b2a0$var$domToObject(node, options) {
    var _a;
    let result = {};
    const childNodeCount = node.childNodes.length;
    const firstChildNode = node.childNodes[0];
    const onlyChildTextValue = firstChildNode && childNodeCount === 1 && firstChildNode.nodeType === Node.TEXT_NODE && firstChildNode.nodeValue || undefined;
    const elementWithAttributes = $912ad09622b3b2a0$var$asElementWithAttributes(node);
    if (elementWithAttributes) {
        result[0, $3eac3ad234c705a4$export$3dfa762fc17d84c8] = {};
        for(let i = 0; i < elementWithAttributes.attributes.length; i++){
            const attr = elementWithAttributes.attributes[i];
            result[0, $3eac3ad234c705a4$export$3dfa762fc17d84c8][attr.nodeName] = attr.nodeValue;
        }
        if (onlyChildTextValue) result[options.xmlCharKey] = onlyChildTextValue;
    } else if (childNodeCount === 0) result = "";
    else if (onlyChildTextValue) result = onlyChildTextValue;
    if (!onlyChildTextValue) for(let i = 0; i < childNodeCount; i++){
        const child = node.childNodes[i];
        // Check if CData
        if ((child === null || child === void 0 ? void 0 : child.nodeType) === Node.CDATA_SECTION_NODE) // Already in the CDATA
        result = child.textContent;
        else if (((_a = child === null || child === void 0 ? void 0 : child.firstChild) === null || _a === void 0 ? void 0 : _a.nodeType) === Node.CDATA_SECTION_NODE) // Look if child is CDATA
        result[child.nodeName] = child.textContent;
        else if (child.nodeType !== Node.TEXT_NODE) {
            // Ignore leading/trailing whitespace nodes
            const childObject = $912ad09622b3b2a0$var$domToObject(child, options);
            if (!result[child.nodeName]) result[child.nodeName] = childObject;
            else if (Array.isArray(result[child.nodeName])) result[child.nodeName].push(childObject);
            else result[child.nodeName] = [
                result[child.nodeName],
                childObject
            ];
        }
    }
    return result;
}
const $912ad09622b3b2a0$var$serializer = new XMLSerializer();
function $912ad09622b3b2a0$export$746eb2ada42c6647(content, opts = {}) {
    var _a, _b, _c, _d, _e;
    const updatedOptions = {
        rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : "root",
        includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,
        xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : (0, $3eac3ad234c705a4$export$3fa08d02e488b7ae),
        cdataPropName: (_d = opts.cdataPropName) !== null && _d !== void 0 ? _d : "__cdata",
        stopNodes: (_e = opts.stopNodes) !== null && _e !== void 0 ? _e : []
    };
    const dom = $912ad09622b3b2a0$var$buildNode(content, updatedOptions.rootName, updatedOptions)[0];
    return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + $912ad09622b3b2a0$var$serializer.serializeToString(dom);
}
function $912ad09622b3b2a0$var$buildAttributes(attrs) {
    const result = [];
    for (const key of Object.keys(attrs)){
        const attr = $912ad09622b3b2a0$var$doc.createAttribute(key);
        attr.value = attrs[key].toString();
        result.push(attr);
    }
    return result;
}
function $912ad09622b3b2a0$var$buildNode(obj, elementName, options) {
    if (obj === undefined || obj === null || typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean") {
        const elem = $912ad09622b3b2a0$var$doc.createElement(elementName);
        elem.textContent = obj === undefined || obj === null ? "" : obj.toString();
        return [
            elem
        ];
    } else if (Array.isArray(obj)) {
        const result = [];
        for (const arrayElem of obj)for (const child of $912ad09622b3b2a0$var$buildNode(arrayElem, elementName, options))result.push(child);
        return result;
    } else if (typeof obj === "object") {
        const elem = $912ad09622b3b2a0$var$doc.createElement(elementName);
        for (const key of Object.keys(obj)){
            if (key === (0, $3eac3ad234c705a4$export$3dfa762fc17d84c8)) for (const attr of $912ad09622b3b2a0$var$buildAttributes(obj[key]))elem.attributes.setNamedItem(attr);
            else if (key === options.xmlCharKey) elem.textContent = obj[key].toString();
            else if (key === options.cdataPropName) {
                const cdataElement = $912ad09622b3b2a0$var$doc.createCDATASection(obj[key].toString());
                elem.appendChild(cdataElement);
            } else for (const child of $912ad09622b3b2a0$var$buildNode(obj[key], key, options))elem.appendChild(child);
        }
        return [
            elem
        ];
    } else throw new Error(`Illegal value passed to buildObject: ${obj}`);
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */ const $8cc22362d89dbe31$export$8c36c31580f051c6 = {
    name: "@azure/service-bus",
    version: "7.8.0"
};
const $8cc22362d89dbe31$export$38a381526c40932a = 20000;
const $8cc22362d89dbe31$export$84cf8d4e39776cfd = Math.pow(2, 31) - 1;
const $8cc22362d89dbe31$export$c03ce443fb86f91a = "QueueName";
const $8cc22362d89dbe31$export$9add4b3ca55e5b86 = "TopicName";
const $8cc22362d89dbe31$export$c259a26626651715 = "SubscriptionName";
const $8cc22362d89dbe31$export$16059a9982ca14f7 = "RuleName";
const $8cc22362d89dbe31$export$d5edc10079103dd5 = "AccessedAt";
const $8cc22362d89dbe31$export$fc3ba281eb90e180 = "UpdatedAt";
const $8cc22362d89dbe31$export$c7c655b4d4e19cd6 = "CreatedAt";
const $8cc22362d89dbe31$export$3ce81da285e28f5c = "AuthorizationRules";
const $8cc22362d89dbe31$export$135cd3c73c8ad4d0 = "IsAnonymousAccessible";
const $8cc22362d89dbe31$export$f25eef92e6eaff77 = "EntityAvailabilityStatus";
const $8cc22362d89dbe31$export$ddcc78c26fc673f = "EnableExpress";
const $8cc22362d89dbe31$export$b635c79196c06b14 = "IsExpress";
const $8cc22362d89dbe31$export$1bb6b821f4e12649 = "EnableSubscriptionPartitioning";
const $8cc22362d89dbe31$export$3b2abf070f31879 = "FilteringMessagesBeforePublishing";
const $8cc22362d89dbe31$export$d8760f7a08f70566 = "SizeInBytes";
const $8cc22362d89dbe31$export$6a8945be60a08d93 = "MessageCount";
const $8cc22362d89dbe31$export$24af18af21e666cd = "SubscriptionCount";
const $8cc22362d89dbe31$export$b68fd778a3104382 = "CountDetails";
const $8cc22362d89dbe31$export$65bf1d79c3958c92 = "$Default";
const $8cc22362d89dbe31$export$2cf637dd9778c784 = "AutoDeleteOnIdle";
const $8cc22362d89dbe31$export$e50006273435e7d4 = "Status";
const $8cc22362d89dbe31$export$431d1593f04de92b = "ForwardTo";
const $8cc22362d89dbe31$export$20d6ffce908b5455 = "UserMetadata";
const $8cc22362d89dbe31$export$4c3594da079cdd46 = "MaxSizeInMegabytes";
const $8cc22362d89dbe31$export$c27bcac6d30d8132 = "MaxMessageSizeInKilobytes";
const $8cc22362d89dbe31$export$ebb1501f6b9cd29b = "DefaultMessageTimeToLive";
const $8cc22362d89dbe31$export$4a087504ce383457 = "LockDuration";
const $8cc22362d89dbe31$export$4e9b94238de609ed = "RequiresSession";
const $8cc22362d89dbe31$export$93f5cc3bef763609 = "RequiresDuplicateDetection";
const $8cc22362d89dbe31$export$48fc3466cadf8005 = "DeadLetteringOnMessageExpiration";
const $8cc22362d89dbe31$export$8d90c906c47a103d = "DeadLetteringOnFilterEvaluationExceptions";
const $8cc22362d89dbe31$export$2b0dc8e0f24ad57e = "DuplicateDetectionHistoryTimeWindow";
const $8cc22362d89dbe31$export$3bce654153779089 = "MaxDeliveryCount";
const $8cc22362d89dbe31$export$6d9281d5501e5f7e = "EnableBatchedOperations";
const $8cc22362d89dbe31$export$da85a201c1d11265 = "SupportOrdering";
const $8cc22362d89dbe31$export$e7aafcd704df2679 = "EnablePartitioning";
const $8cc22362d89dbe31$export$aed634d2038095a3 = "ForwardDeadLetteredMessagesTo";
const $8cc22362d89dbe31$export$dc61c0db22c9ffdc = "api-version";
const $8cc22362d89dbe31$export$5488f3aad090aec4 = "2021-05";
const $8cc22362d89dbe31$export$d9cad541346954ef = "message";
const $8cc22362d89dbe31$export$805e4823aa8efdab = "value";
const $8cc22362d89dbe31$export$8b009e1e43cec8e0 = "$";
const $8cc22362d89dbe31$export$d3da985b4e812681 = "_";
const $8cc22362d89dbe31$export$42fd5579ee70843 = "_";
const $8cc22362d89dbe31$export$2f5329dd812e9589 = {
    100: "Continue",
    101: "SwitchingProtocols",
    200: "Ok",
    201: "Created",
    202: "Accepted",
    203: "NonAuthoritativeInformation",
    204: "NoContent",
    205: "ResetContent",
    206: "PartialContent",
    300: "MultipleChoices",
    301: "Moved",
    302: "Redirect",
    303: "RedirectMethod",
    304: "NotModified",
    305: "UseProxy",
    306: "Unused",
    400: "BadRequest",
    401: "Unauthorized",
    402: "PaymentRequired",
    403: "Forbidden",
    404: "NotFound",
    405: "MethodNotAllowed",
    406: "NotAcceptable",
    407: "ProxyAuthenticationRequired",
    409: "Conflict",
    410: "Gone",
    411: "LengthRequired",
    412: "PreconditionFailed",
    413: "RequestEntityTooLarge",
    414: "RequestUriTooLong",
    415: "UnsupportedMediaType",
    416: "RequestRangeNotSatisfiable",
    417: "ExpectationFailed",
    426: "UpgradeRequired",
    500: "InternalServerError",
    501: "NotImplemented",
    502: "BadGateway",
    503: "ServiceUnavailable",
    504: "GatewayTimeout",
    505: "HttpVersionNotSupported"
};




var $6FDNW = parcelRequire("6FDNW");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 */ const $589aa7cc5ed318ce$export$4b3d9a5bae55976 = (rawUrl)=>{
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore: "self" will exist in the browser.
    return new self.URL(rawUrl);
};


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var $c2bd6b1b7ffc7b0d$exports = {};
// GENERATED FILE. DO NOT EDIT.
var $c2bd6b1b7ffc7b0d$var$Long = function(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = void 0;
    /**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */ // WebAssembly optimizations to do native i64 multiplication and divide
    var wasm = null;
    try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1,
            13,
            2,
            96,
            0,
            1,
            127,
            96,
            4,
            127,
            127,
            127,
            127,
            1,
            127,
            3,
            7,
            6,
            0,
            1,
            1,
            1,
            1,
            1,
            6,
            6,
            1,
            127,
            1,
            65,
            0,
            11,
            7,
            50,
            6,
            3,
            109,
            117,
            108,
            0,
            1,
            5,
            100,
            105,
            118,
            95,
            115,
            0,
            2,
            5,
            100,
            105,
            118,
            95,
            117,
            0,
            3,
            5,
            114,
            101,
            109,
            95,
            115,
            0,
            4,
            5,
            114,
            101,
            109,
            95,
            117,
            0,
            5,
            8,
            103,
            101,
            116,
            95,
            104,
            105,
            103,
            104,
            0,
            0,
            10,
            191,
            1,
            6,
            4,
            0,
            35,
            0,
            11,
            36,
            1,
            1,
            126,
            32,
            0,
            173,
            32,
            1,
            173,
            66,
            32,
            134,
            132,
            32,
            2,
            173,
            32,
            3,
            173,
            66,
            32,
            134,
            132,
            126,
            34,
            4,
            66,
            32,
            135,
            167,
            36,
            0,
            32,
            4,
            167,
            11,
            36,
            1,
            1,
            126,
            32,
            0,
            173,
            32,
            1,
            173,
            66,
            32,
            134,
            132,
            32,
            2,
            173,
            32,
            3,
            173,
            66,
            32,
            134,
            132,
            127,
            34,
            4,
            66,
            32,
            135,
            167,
            36,
            0,
            32,
            4,
            167,
            11,
            36,
            1,
            1,
            126,
            32,
            0,
            173,
            32,
            1,
            173,
            66,
            32,
            134,
            132,
            32,
            2,
            173,
            32,
            3,
            173,
            66,
            32,
            134,
            132,
            128,
            34,
            4,
            66,
            32,
            135,
            167,
            36,
            0,
            32,
            4,
            167,
            11,
            36,
            1,
            1,
            126,
            32,
            0,
            173,
            32,
            1,
            173,
            66,
            32,
            134,
            132,
            32,
            2,
            173,
            32,
            3,
            173,
            66,
            32,
            134,
            132,
            129,
            34,
            4,
            66,
            32,
            135,
            167,
            36,
            0,
            32,
            4,
            167,
            11,
            36,
            1,
            1,
            126,
            32,
            0,
            173,
            32,
            1,
            173,
            66,
            32,
            134,
            132,
            32,
            2,
            173,
            32,
            3,
            173,
            66,
            32,
            134,
            132,
            130,
            34,
            4,
            66,
            32,
            135,
            167,
            36,
            0,
            32,
            4,
            167,
            11
        ])), {}).exports;
    } catch (e) {}
    /**
   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
   *  See the from* functions below for more convenient ways of constructing Longs.
   * @exports Long
   * @class A Long class for representing a 64 bit two's-complement integer value.
   * @param {number} low The low (signed) 32 bits of the long
   * @param {number} high The high (signed) 32 bits of the long
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @constructor
   */ function Long(low, high, unsigned) {
        /**
     * The low 32 bits as a signed value.
     * @type {number}
     */ this.low = low | 0;
        /**
     * The high 32 bits as a signed value.
     * @type {number}
     */ this.high = high | 0;
        /**
     * Whether unsigned or not.
     * @type {boolean}
     */ this.unsigned = !!unsigned;
    } // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.
    /**
   * An indicator used to reliably determine if an object is a Long or not.
   * @type {boolean}
   * @const
   * @private
   */ Long.prototype.__isLong__;
    Object.defineProperty(Long.prototype, "__isLong__", {
        value: true
    });
    /**
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   * @inner
   */ function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
    }
    /**
   * @function
   * @param {*} value number
   * @returns {number}
   * @inner
   */ function ctz32(value) {
        var c = Math.clz32(value & -value);
        return value ? 31 - c : c;
    }
    /**
   * Tests if the specified object is a Long.
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   */ Long.isLong = isLong;
    /**
   * A cache of the Long representations of small integer values.
   * @type {!Object}
   * @inner
   */ var INT_CACHE = {};
    /**
   * A cache of the Long representations of small unsigned integer values.
   * @type {!Object}
   * @inner
   */ var UINT_CACHE = {};
    /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */ function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
            value >>>= 0;
            if (cache = 0 <= value && value < 256) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj) return cachedObj;
            }
            obj = fromBits(value, 0, true);
            if (cache) UINT_CACHE[value] = obj;
            return obj;
        } else {
            value |= 0;
            if (cache = -128 <= value && value < 128) {
                cachedObj = INT_CACHE[value];
                if (cachedObj) return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache) INT_CACHE[value] = obj;
            return obj;
        }
    }
    /**
   * Returns a Long representing the given 32 bit integer value.
   * @function
   * @param {number} value The 32 bit integer in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */ Long.fromInt = fromInt;
    /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */ function fromNumber(value, unsigned) {
        if (isNaN(value)) return unsigned ? UZERO : ZERO;
        if (unsigned) {
            if (value < 0) return UZERO;
            if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
        } else {
            if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
        }
        if (value < 0) return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    /**
   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
   * @function
   * @param {number} value The number in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */ Long.fromNumber = fromNumber;
    /**
   * @param {number} lowBits
   * @param {number} highBits
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */ function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    }
    /**
   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
   *  assumed to use 32 bits.
   * @function
   * @param {number} lowBits The low 32 bits
   * @param {number} highBits The high 32 bits
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */ Long.fromBits = fromBits;
    /**
   * @function
   * @param {number} base
   * @param {number} exponent
   * @returns {number}
   * @inner
   */ var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)
    /**
   * @param {string} str
   * @param {(boolean|number)=} unsigned
   * @param {number=} radix
   * @returns {!Long}
   * @inner
   */ function fromString(str, unsigned, radix) {
        if (str.length === 0) throw Error("empty string");
        if (typeof unsigned === "number") {
            // For goog.math.long compatibility
            radix = unsigned;
            unsigned = false;
        } else unsigned = !!unsigned;
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError("radix");
        var p;
        if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
        else if (p === 0) return fromString(str.substring(1), unsigned, radix).neg();
         // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO;
        for(var i = 0; i < str.length; i += 8){
            var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = fromNumber(pow_dbl(radix, size));
                result = result.mul(power).add(fromNumber(value));
            } else {
                result = result.mul(radixToPower);
                result = result.add(fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    }
    /**
   * Returns a Long representation of the given string, written using the specified radix.
   * @function
   * @param {string} str The textual representation of the Long
   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
   * @returns {!Long} The corresponding Long value
   */ Long.fromString = fromString;
    /**
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */ function fromValue(val, unsigned) {
        if (typeof val === "number") return fromNumber(val, unsigned);
        if (typeof val === "string") return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:
        return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    /**
   * Converts the specified value to a Long using the appropriate from* function for its type.
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long}
   */ Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.
    /**
   * @type {number}
   * @const
   * @inner
   */ var TWO_PWR_16_DBL = 65536;
    /**
   * @type {number}
   * @const
   * @inner
   */ var TWO_PWR_24_DBL = 16777216;
    /**
   * @type {number}
   * @const
   * @inner
   */ var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    /**
   * @type {number}
   * @const
   * @inner
   */ var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    /**
   * @type {number}
   * @const
   * @inner
   */ var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    /**
   * @type {!Long}
   * @const
   * @inner
   */ var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    /**
   * @type {!Long}
   * @inner
   */ var ZERO = fromInt(0);
    /**
   * Signed zero.
   * @type {!Long}
   */ Long.ZERO = ZERO;
    /**
   * @type {!Long}
   * @inner
   */ var UZERO = fromInt(0, true);
    /**
   * Unsigned zero.
   * @type {!Long}
   */ Long.UZERO = UZERO;
    /**
   * @type {!Long}
   * @inner
   */ var ONE = fromInt(1);
    /**
   * Signed one.
   * @type {!Long}
   */ Long.ONE = ONE;
    /**
   * @type {!Long}
   * @inner
   */ var UONE = fromInt(1, true);
    /**
   * Unsigned one.
   * @type {!Long}
   */ Long.UONE = UONE;
    /**
   * @type {!Long}
   * @inner
   */ var NEG_ONE = fromInt(-1);
    /**
   * Signed negative one.
   * @type {!Long}
   */ Long.NEG_ONE = NEG_ONE;
    /**
   * @type {!Long}
   * @inner
   */ var MAX_VALUE = fromBits(-1, 2147483647, false);
    /**
   * Maximum signed value.
   * @type {!Long}
   */ Long.MAX_VALUE = MAX_VALUE;
    /**
   * @type {!Long}
   * @inner
   */ var MAX_UNSIGNED_VALUE = fromBits(-1, -1, true);
    /**
   * Maximum unsigned value.
   * @type {!Long}
   */ Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    /**
   * @type {!Long}
   * @inner
   */ var MIN_VALUE = fromBits(0, -2147483648, false);
    /**
   * Minimum signed value.
   * @type {!Long}
   */ Long.MIN_VALUE = MIN_VALUE;
    /**
   * @alias Long.prototype
   * @inner
   */ var LongPrototype = Long.prototype;
    /**
   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
   * @this {!Long}
   * @returns {number}
   */ LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };
    /**
   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
   * @this {!Long}
   * @returns {number}
   */ LongPrototype.toNumber = function toNumber() {
        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    /**
   * Converts the Long to a string written in the specified radix.
   * @this {!Long}
   * @param {number=} radix Radix (2-36), defaults to 10
   * @returns {string}
   * @override
   * @throws {RangeError} If `radix` is out of range
   */ LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError("radix");
        if (this.isZero()) return "0";
        if (this.isNegative()) {
            // Unsigned Longs are never negative
            if (this.eq(MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            } else return "-" + this.neg().toString(radix);
        } // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while(true){
            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero()) return digits + result;
            else {
                while(digits.length < 6)digits = "0" + digits;
                result = "" + digits + result;
            }
        }
    };
    /**
   * Gets the high 32 bits as a signed integer.
   * @this {!Long}
   * @returns {number} Signed high bits
   */ LongPrototype.getHighBits = function getHighBits() {
        return this.high;
    };
    /**
   * Gets the high 32 bits as an unsigned integer.
   * @this {!Long}
   * @returns {number} Unsigned high bits
   */ LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
    };
    /**
   * Gets the low 32 bits as a signed integer.
   * @this {!Long}
   * @returns {number} Signed low bits
   */ LongPrototype.getLowBits = function getLowBits() {
        return this.low;
    };
    /**
   * Gets the low 32 bits as an unsigned integer.
   * @this {!Long}
   * @returns {number} Unsigned low bits
   */ LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
    };
    /**
   * Gets the number of bits needed to represent the absolute value of this Long.
   * @this {!Long}
   * @returns {number}
   */ LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for(var bit = 31; bit > 0; bit--)if ((val & 1 << bit) != 0) break;
        return this.high != 0 ? bit + 33 : bit + 1;
    };
    /**
   * Tests if this Long's value equals zero.
   * @this {!Long}
   * @returns {boolean}
   */ LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
    };
    /**
   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
   * @returns {boolean}
   */ LongPrototype.eqz = LongPrototype.isZero;
    /**
   * Tests if this Long's value is negative.
   * @this {!Long}
   * @returns {boolean}
   */ LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
    };
    /**
   * Tests if this Long's value is positive or zero.
   * @this {!Long}
   * @returns {boolean}
   */ LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
    };
    /**
   * Tests if this Long's value is odd.
   * @this {!Long}
   * @returns {boolean}
   */ LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
    };
    /**
   * Tests if this Long's value is even.
   * @this {!Long}
   * @returns {boolean}
   */ LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
    };
    /**
   * Tests if this Long's value equals the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */ LongPrototype.equals = function equals(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
        return this.high === other.high && this.low === other.low;
    };
    /**
   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */ LongPrototype.eq = LongPrototype.equals;
    /**
   * Tests if this Long's value differs from the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */ LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(/* validates */ other);
    };
    /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */ LongPrototype.neq = LongPrototype.notEquals;
    /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */ LongPrototype.ne = LongPrototype.notEquals;
    /**
   * Tests if this Long's value is less than the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */ LongPrototype.lessThan = function lessThan(other) {
        return this.comp(/* validates */ other) < 0;
    };
    /**
   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */ LongPrototype.lt = LongPrototype.lessThan;
    /**
   * Tests if this Long's value is less than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */ LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(/* validates */ other) <= 0;
    };
    /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */ LongPrototype.lte = LongPrototype.lessThanOrEqual;
    /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */ LongPrototype.le = LongPrototype.lessThanOrEqual;
    /**
   * Tests if this Long's value is greater than the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */ LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(/* validates */ other) > 0;
    };
    /**
   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */ LongPrototype.gt = LongPrototype.greaterThan;
    /**
   * Tests if this Long's value is greater than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */ LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(/* validates */ other) >= 0;
    };
    /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */ LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */ LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    /**
   * Compares this Long's value with the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */ LongPrototype.compare = function compare(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.eq(other)) return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) return -1;
        if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same
        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    /**
   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */ LongPrototype.comp = LongPrototype.compare;
    /**
   * Negates this Long's value.
   * @this {!Long}
   * @returns {!Long} Negated Long
   */ LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
        return this.not().add(ONE);
    };
    /**
   * Negates this Long's value. This is an alias of {@link Long#negate}.
   * @function
   * @returns {!Long} Negated Long
   */ LongPrototype.neg = LongPrototype.negate;
    /**
   * Returns the sum of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} addend Addend
   * @returns {!Long} Sum
   */ LongPrototype.add = function add(addend) {
        if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    /**
   * Returns the difference of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */ LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };
    /**
   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
   * @function
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */ LongPrototype.sub = LongPrototype.subtract;
    /**
   * Returns the product of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */ LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero()) return this;
        if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present
        if (wasm) {
            var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
            return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
            else return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.
        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    /**
   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
   * @function
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */ LongPrototype.mul = LongPrototype.multiply;
    /**
   * Returns this Long divided by the specified. The result is signed if this Long is signed or
   *  unsigned if this Long is unsigned.
   * @this {!Long}
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */ LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        if (divisor.isZero()) throw Error("division by zero"); // use wasm support if present
        if (wasm) {
            // guard against signed division overflow: the largest
            // negative number / -1 would be 1 larger than the largest
            // positive number, due to two's complement.
            if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) // be consistent with non-wasm code path
            return this;
            var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
            return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (this.isZero()) return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
            // This section is only relevant for signed longs and is derived from the
            // closure library as a whole.
            if (this.eq(MIN_VALUE)) {
                if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
                else if (divisor.eq(MIN_VALUE)) return ONE;
                else {
                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                    var halfThis = this.shr(1);
                    approx = halfThis.div(divisor).shl(1);
                    if (approx.eq(ZERO)) return divisor.isNegative() ? ONE : NEG_ONE;
                    else {
                        rem = this.sub(divisor.mul(approx));
                        res = approx.add(rem.div(divisor));
                        return res;
                    }
                }
            } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative()) return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
            res = ZERO;
        } else {
            // The algorithm below has not been made for unsigned longs. It's therefore
            // required to take special care of the MSB prior to running it.
            if (!divisor.unsigned) divisor = divisor.toUnsigned();
            if (divisor.gt(this)) return UZERO;
            if (divisor.gt(this.shru(1))) return UONE;
            res = UZERO;
        } // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        rem = this;
        while(rem.gte(divisor)){
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
            while(approxRem.isNegative() || approxRem.gt(rem)){
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            } // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero()) approxRes = ONE;
            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };
    /**
   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */ LongPrototype.div = LongPrototype.divide;
    /**
   * Returns this Long modulo the specified.
   * @this {!Long}
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */ LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present
        if (wasm) {
            var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
            return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
    };
    /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */ LongPrototype.mod = LongPrototype.modulo;
    /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */ LongPrototype.rem = LongPrototype.modulo;
    /**
   * Returns the bitwise NOT of this Long.
   * @this {!Long}
   * @returns {!Long}
   */ LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };
    /**
   * Returns count leading zeros of this Long.
   * @this {!Long}
   * @returns {!number}
   */ LongPrototype.countLeadingZeros = function countLeadingZeros() {
        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
    };
    /**
   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
   * @function
   * @param {!Long}
   * @returns {!number}
   */ LongPrototype.clz = LongPrototype.countLeadingZeros;
    /**
   * Returns count trailing zeros of this Long.
   * @this {!Long}
   * @returns {!number}
   */ LongPrototype.countTrailingZeros = function countTrailingZeros() {
        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
    };
    /**
   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
   * @function
   * @param {!Long}
   * @returns {!number}
   */ LongPrototype.ctz = LongPrototype.countTrailingZeros;
    /**
   * Returns the bitwise AND of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */ LongPrototype.and = function and(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    /**
   * Returns the bitwise OR of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */ LongPrototype.or = function or(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    /**
   * Returns the bitwise XOR of this Long and the given one.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */ LongPrototype.xor = function xor(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    /**
   * Returns this Long with bits shifted to the left by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */ LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    /**
   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */ LongPrototype.shl = LongPrototype.shiftLeft;
    /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */ LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */ LongPrototype.shr = LongPrototype.shiftRight;
    /**
   * Returns this Long with bits logically shifted to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */ LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
        if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
    };
    /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */ LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */ LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    /**
   * Returns this Long with bits rotated to the left by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */ LongPrototype.rotateLeft = function rotateLeft(numBits) {
        var b;
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
            b = 32 - numBits;
            return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
    };
    /**
   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */ LongPrototype.rotl = LongPrototype.rotateLeft;
    /**
   * Returns this Long with bits rotated to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */ LongPrototype.rotateRight = function rotateRight(numBits) {
        var b;
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
            b = 32 - numBits;
            return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
    };
    /**
   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */ LongPrototype.rotr = LongPrototype.rotateRight;
    /**
   * Converts this Long to signed.
   * @this {!Long}
   * @returns {!Long} Signed long
   */ LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned) return this;
        return fromBits(this.low, this.high, false);
    };
    /**
   * Converts this Long to unsigned.
   * @this {!Long}
   * @returns {!Long} Unsigned long
   */ LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned) return this;
        return fromBits(this.low, this.high, true);
    };
    /**
   * Converts this Long to its byte representation.
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @this {!Long}
   * @returns {!Array.<number>} Byte representation
   */ LongPrototype.toBytes = function toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
    };
    /**
   * Converts this Long to its little endian byte representation.
   * @this {!Long}
   * @returns {!Array.<number>} Little endian byte representation
   */ LongPrototype.toBytesLE = function toBytesLE() {
        var hi = this.high, lo = this.low;
        return [
            lo & 0xff,
            lo >>> 8 & 0xff,
            lo >>> 16 & 0xff,
            lo >>> 24,
            hi & 0xff,
            hi >>> 8 & 0xff,
            hi >>> 16 & 0xff,
            hi >>> 24
        ];
    };
    /**
   * Converts this Long to its big endian byte representation.
   * @this {!Long}
   * @returns {!Array.<number>} Big endian byte representation
   */ LongPrototype.toBytesBE = function toBytesBE() {
        var hi = this.high, lo = this.low;
        return [
            hi >>> 24,
            hi >>> 16 & 0xff,
            hi >>> 8 & 0xff,
            hi & 0xff,
            lo >>> 24,
            lo >>> 16 & 0xff,
            lo >>> 8 & 0xff,
            lo & 0xff
        ];
    };
    /**
   * Creates a Long from its byte representation.
   * @param {!Array.<number>} bytes Byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @returns {Long} The corresponding Long value
   */ Long.fromBytes = function fromBytes(bytes, unsigned, le) {
        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    };
    /**
   * Creates a Long from its little endian byte representation.
   * @param {!Array.<number>} bytes Little endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */ Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
    };
    /**
   * Creates a Long from its big endian byte representation.
   * @param {!Array.<number>} bytes Big endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */ Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
        return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
    };
    var _default = Long;
    exports.default = _default;
    return "default" in exports ? exports.default : exports;
}({});
if (typeof define === "function" && define.amd) define([], function() {
    return $c2bd6b1b7ffc7b0d$var$Long;
});
else $c2bd6b1b7ffc7b0d$exports = $c2bd6b1b7ffc7b0d$var$Long;




var $ecfddc481ab00b65$exports = {};
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ $ecfddc481ab00b65$exports = function isBuffer(obj) {
    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
};



var $6FDNW = parcelRequire("6FDNW");



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A collection of HttpHeaders that can be sent with a HTTP request.
 */ function $e0651cb341ba0add$var$getHeaderKey(headerName) {
    return headerName.toLowerCase();
}
function $e0651cb341ba0add$export$f67692cb92e78cb1(object) {
    if (object && typeof object === "object") {
        const castObject = object;
        if (typeof castObject.rawHeaders === "function" && typeof castObject.clone === "function" && typeof castObject.get === "function" && typeof castObject.set === "function" && typeof castObject.contains === "function" && typeof castObject.remove === "function" && typeof castObject.headersArray === "function" && typeof castObject.headerValues === "function" && typeof castObject.headerNames === "function" && typeof castObject.toJson === "function") return true;
    }
    return false;
}
class $e0651cb341ba0add$export$2b4577ff97ee74d5 {
    constructor(rawHeaders){
        this._headersMap = {};
        if (rawHeaders) for(const headerName in rawHeaders)this.set(headerName, rawHeaders[headerName]);
    }
    /**
     * Set a header in this collection with the provided name and value. The name is
     * case-insensitive.
     * @param headerName - The name of the header to set. This value is case-insensitive.
     * @param headerValue - The value of the header to set.
     */ set(headerName, headerValue) {
        this._headersMap[$e0651cb341ba0add$var$getHeaderKey(headerName)] = {
            name: headerName,
            value: headerValue.toString()
        };
    }
    /**
     * Get the header value for the provided header name, or undefined if no header exists in this
     * collection with the provided name.
     * @param headerName - The name of the header.
     */ get(headerName) {
        const header = this._headersMap[$e0651cb341ba0add$var$getHeaderKey(headerName)];
        return !header ? undefined : header.value;
    }
    /**
     * Get whether or not this header collection contains a header entry for the provided header name.
     */ contains(headerName) {
        return !!this._headersMap[$e0651cb341ba0add$var$getHeaderKey(headerName)];
    }
    /**
     * Remove the header with the provided headerName. Return whether or not the header existed and
     * was removed.
     * @param headerName - The name of the header to remove.
     */ remove(headerName) {
        const result = this.contains(headerName);
        delete this._headersMap[$e0651cb341ba0add$var$getHeaderKey(headerName)];
        return result;
    }
    /**
     * Get the headers that are contained this collection as an object.
     */ rawHeaders() {
        return this.toJson({
            preserveCase: true
        });
    }
    /**
     * Get the headers that are contained in this collection as an array.
     */ headersArray() {
        const headers = [];
        for(const headerKey in this._headersMap)headers.push(this._headersMap[headerKey]);
        return headers;
    }
    /**
     * Get the header names that are contained in this collection.
     */ headerNames() {
        const headerNames = [];
        const headers = this.headersArray();
        for(let i = 0; i < headers.length; ++i)headerNames.push(headers[i].name);
        return headerNames;
    }
    /**
     * Get the header values that are contained in this collection.
     */ headerValues() {
        const headerValues = [];
        const headers = this.headersArray();
        for(let i = 0; i < headers.length; ++i)headerValues.push(headers[i].value);
        return headerValues;
    }
    /**
     * Get the JSON object representation of this HTTP header collection.
     */ toJson(options = {}) {
        const result = {};
        if (options.preserveCase) for(const headerKey in this._headersMap){
            const header = this._headersMap[headerKey];
            result[header.name] = header.value;
        }
        else for(const headerKey in this._headersMap){
            const header = this._headersMap[headerKey];
            result[$e0651cb341ba0add$var$getHeaderKey(header.name)] = header.value;
        }
        return result;
    }
    /**
     * Get the string representation of this HTTP header collection.
     */ toString() {
        return JSON.stringify(this.toJson({
            preserveCase: true
        }));
    }
    /**
     * Create a deep clone/copy of this HttpHeaders collection.
     */ clone() {
        const resultPreservingCasing = {};
        for(const headerKey in this._headersMap){
            const header = this._headersMap[headerKey];
            resultPreservingCasing[header.name] = header.value;
        }
        return new $e0651cb341ba0add$export$2b4577ff97ee74d5(resultPreservingCasing);
    }
}


function $9c3099bbe0441464$var$toHttpHeaderLike(headers) {
    return new (0, $e0651cb341ba0add$export$2b4577ff97ee74d5)(headers.toJSON({
        preserveCase: true
    }));
}
function $9c3099bbe0441464$var$toWebResourceLike(request) {
    return {
        url: request.url,
        method: request.method,
        headers: $9c3099bbe0441464$var$toHttpHeaderLike(request.headers),
        withCredentials: request.withCredentials,
        timeout: request.timeout,
        requestId: request.headers.get("x-ms-client-request-id") || ""
    };
}
function $9c3099bbe0441464$export$6e93530fbf8e23ac(response) {
    return {
        request: $9c3099bbe0441464$var$toWebResourceLike(response.request),
        status: response.status,
        headers: $9c3099bbe0441464$var$toHttpHeaderLike(response.headers)
    };
}



function $3402f46f0a1b2976$export$798a797a6d4e253e(name) {
    return `${name}-${(0, $4973e2e602c1cc10$exports.generate_uuid)()}`;
}
function $3402f46f0a1b2976$export$dad746c31d112b77(prefix, identifier) {
    return identifier ? identifier : $3402f46f0a1b2976$export$798a797a6d4e253e(prefix);
}
function $3402f46f0a1b2976$export$79654292bb147350(lockTokenBytes) {
    if (!lockTokenBytes || !(0, $6FDNW.Buffer).isBuffer(lockTokenBytes)) return lockTokenBytes;
    return (0, $6FDNW.Buffer).from([
        lockTokenBytes[3],
        lockTokenBytes[2],
        lockTokenBytes[1],
        lockTokenBytes[0],
        lockTokenBytes[5],
        lockTokenBytes[4],
        lockTokenBytes[7],
        lockTokenBytes[6],
        lockTokenBytes[8],
        lockTokenBytes[9],
        lockTokenBytes[10],
        lockTokenBytes[11],
        lockTokenBytes[12],
        lockTokenBytes[13],
        lockTokenBytes[14],
        lockTokenBytes[15]
    ]);
}
function $3402f46f0a1b2976$export$b445d5bd96910ece(lockedUntilUtc) {
    const now = Date.now();
    const lockedUntil = lockedUntilUtc.getTime();
    const remainingTime = lockedUntil - now;
    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("Locked until utc  : %d", lockedUntil);
    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("Current time is   : %d", now);
    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("Remaining time is : %d", remainingTime);
    if (remainingTime < 1000) return 0;
    const buffer = Math.min(remainingTime / 2, 10000); // 10 seconds
    const renewAfter = remainingTime - buffer;
    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("Renew after       : %d", renewAfter);
    return renewAfter;
}
function $3402f46f0a1b2976$export$7474b3e128eefec5(buf) {
    const epochMicroDiff = 621355968000000000;
    const longValue = (0, (/*@__PURE__*/$parcel$interopDefault($c2bd6b1b7ffc7b0d$exports))).fromBytesBE(buf);
    const timeInMS = longValue.sub(epochMicroDiff).div(10000).toNumber();
    const result = new Date(timeInMS);
    (0, $f014dc9d393cdf62$export$af88d00dbe7f521).verbose("The converted date is: %s", result.toString());
    return result;
}
function $3402f46f0a1b2976$export$fc336dbfaf62f18f(input) {
    let result;
    (0, $f014dc9d393cdf62$export$bb8c8b6a9c29dff9).verbose("[utils.toBuffer] The given message body that needs to be converted to buffer is: ", input);
    if ((0, (/*@__PURE__*/$parcel$interopDefault($ecfddc481ab00b65$exports)))(input)) result = input;
    else {
        // string, undefined, null, boolean, array, object, number should end up here
        // coercing undefined to null as that will ensure that null value will be given to the
        // customer on receive.
        if (input === undefined) input = null;
        try {
            const inputStr = JSON.stringify(input);
            result = (0, $6FDNW.Buffer).from(inputStr, "utf8");
        } catch (err) {
            const msg = `An error occurred while executing JSON.stringify() on the given input ` + input + `${err instanceof Error ? err.stack : JSON.stringify(err)}`;
            (0, $f014dc9d393cdf62$export$bb8c8b6a9c29dff9).warning("[utils.toBuffer] " + msg);
            throw err instanceof Error ? err : new Error(msg);
        }
    }
    (0, $f014dc9d393cdf62$export$bb8c8b6a9c29dff9).verbose("[utils.toBuffer] The converted buffer is: %O.", result);
    return result;
}
function $3402f46f0a1b2976$export$f8963f3214707ee4(value, nameOfProperty) {
    const result = $3402f46f0a1b2976$export$df9e08d3f49523a1(value);
    if (result === undefined) throw new Error(`"${nameOfProperty}" received from service expected to be a string value and not undefined.`);
    return result;
}
function $3402f46f0a1b2976$export$df9e08d3f49523a1(value) {
    if (!(0, $a7961d970a7496cb$export$4e62c701997796c1)(value)) return undefined;
    return value.toString();
}
function $3402f46f0a1b2976$export$e259718caa99b88b(value, nameOfProperty) {
    const result = $3402f46f0a1b2976$export$2689dbaa7374737(value);
    if (result === undefined) throw new Error(`"${nameOfProperty}" received from service expected to be a number value and not undefined.`);
    return result;
}
function $3402f46f0a1b2976$export$2689dbaa7374737(value) {
    if (!(0, $a7961d970a7496cb$export$4e62c701997796c1)(value)) return undefined;
    const result = parseInt(value.toString());
    return isNaN(result) ? undefined : result;
}
function $3402f46f0a1b2976$export$aa350b96d91cd94(value, nameOfProperty) {
    return new Date($3402f46f0a1b2976$export$f8963f3214707ee4(value, nameOfProperty));
}
function $3402f46f0a1b2976$export$11811c4d2c6a473d(value, nameOfProperty) {
    const result = $3402f46f0a1b2976$export$94ac6be98ec5d053(value);
    if (result === undefined) throw new Error(`"${nameOfProperty}" received from service expected to be a boolean value and not undefined.`);
    return result;
}
function $3402f46f0a1b2976$export$94ac6be98ec5d053(value) {
    if (!(0, $a7961d970a7496cb$export$4e62c701997796c1)(value)) return undefined;
    return value.toString().trim().toLowerCase() === "true";
}
/**
 * @internal
 * Helps in differentiating JSON like objects from other kinds of objects.
 */ const $3402f46f0a1b2976$var$EMPTY_JSON_OBJECT_CONSTRUCTOR = {}.constructor;
function $3402f46f0a1b2976$export$27c50b3aa4baf433(value) {
    // `value.constructor === {}.constructor` differentiates among the "object"s,
    //    would filter the JSON objects and won't match any array or other kinds of objects
    // -------------------------------------------------------------------------------
    // Few examples       | typeof obj ==="object" |  obj.constructor==={}.constructor
    // -------------------------------------------------------------------------------
    // {abc:1}            | true                   | true
    // ["a","b"]          | true                   | false
    // [{"a":1},{"b":2}]  | true                   | false
    // new Date()         | true                   | false
    // 123                | false                  | false
    // -------------------------------------------------------------------------------
    return typeof value === "object" && value.constructor === $3402f46f0a1b2976$var$EMPTY_JSON_OBJECT_CONSTRUCTOR;
}
function $3402f46f0a1b2976$export$ed4b9672d18fcf0c(value) {
    const xmlnsPrefix = $3402f46f0a1b2976$export$6ccc4823b1a190db(value);
    if (!(0, $a7961d970a7496cb$export$4e62c701997796c1)(value)) value = {};
    return {
        activeMessageCount: parseInt(value[`${xmlnsPrefix}:ActiveMessageCount`]) || 0,
        deadLetterMessageCount: parseInt(value[`${xmlnsPrefix}:DeadLetterMessageCount`]) || 0,
        scheduledMessageCount: parseInt(value[`${xmlnsPrefix}:ScheduledMessageCount`]) || 0,
        transferMessageCount: parseInt(value[`${xmlnsPrefix}:TransferMessageCount`]) || 0,
        transferDeadLetterMessageCount: parseInt(value[`${xmlnsPrefix}:TransferDeadLetterMessageCount`]) || 0
    };
}
function $3402f46f0a1b2976$export$6ccc4823b1a190db(value) {
    if (!value[$8cc22362d89dbe31$export$8b009e1e43cec8e0]) throw new Error(`Error occurred while parsing the response body - cannot find the XML_METADATA_MARKER "$" on the object ${JSON.stringify(value)}`);
    const keys = Object.keys(value[$8cc22362d89dbe31$export$8b009e1e43cec8e0]);
    if (keys.length !== 1) throw new Error(`Error occurred while parsing the response body - unexpected number of "xmlns:\${prefix}" keys at ${JSON.stringify(value[$8cc22362d89dbe31$export$8b009e1e43cec8e0])}`);
    if (!keys[0].startsWith("xmlns:")) throw new Error(`Error occurred while parsing the response body - unexpected key at ${JSON.stringify(value[$8cc22362d89dbe31$export$8b009e1e43cec8e0])}`);
    // Pick the substring that's after "xmlns:"
    const xmlnsPrefix = keys[0].substring(6);
    if (!xmlnsPrefix) throw new Error(`Error occurred while parsing the response body - unexpected xmlns prefix at ${JSON.stringify(value[$8cc22362d89dbe31$export$8b009e1e43cec8e0])}`);
    return xmlnsPrefix;
}
function $3402f46f0a1b2976$export$6b2b27c74d663f64(value) {
    const authorizationRules = [];
    // Ignore special case as Service Bus treats "" as a valid value for authorization rules
    if (typeof value === "string" && value.trim() === "") return undefined;
    if (!(0, $a7961d970a7496cb$export$4e62c701997796c1)(value)) return undefined;
    const rawAuthorizationRules = value.AuthorizationRule;
    if (Array.isArray(rawAuthorizationRules)) for(let i = 0; i < rawAuthorizationRules.length; i++)authorizationRules.push($3402f46f0a1b2976$var$buildAuthorizationRule(rawAuthorizationRules[i]));
    else authorizationRules.push($3402f46f0a1b2976$var$buildAuthorizationRule(rawAuthorizationRules));
    return authorizationRules;
}
/**
 * @internal
 * Helper utility to build an instance of parsed authorization rule as `AuthorizationRule` from given input.
 */ function $3402f46f0a1b2976$var$buildAuthorizationRule(value) {
    let accessRights;
    if ((0, $a7961d970a7496cb$export$4e62c701997796c1)(value["Rights"])) accessRights = value["Rights"]["AccessRights"];
    const authorizationRule = {
        claimType: value["ClaimType"],
        accessRights: accessRights,
        keyName: value["KeyName"],
        primaryKey: value["PrimaryKey"],
        secondaryKey: value["SecondaryKey"]
    };
    if (authorizationRule.accessRights && !Array.isArray(authorizationRule.accessRights)) authorizationRule.accessRights = [
        authorizationRule.accessRights
    ];
    return authorizationRule;
}
function $3402f46f0a1b2976$export$2bfb34db9d6c56ee(authorizationRules) {
    if (!(0, $a7961d970a7496cb$export$4e62c701997796c1)(authorizationRules)) return undefined;
    if (!Array.isArray(authorizationRules)) throw new TypeError(`authorizationRules must be an array of AuthorizationRule objects or undefined, but received ${JSON.stringify(authorizationRules, undefined, 2)}`);
    const rawAuthorizationRules = [];
    for(let i = 0; i < authorizationRules.length; i++)rawAuthorizationRules.push($3402f46f0a1b2976$var$buildRawAuthorizationRule(authorizationRules[i]));
    return {
        AuthorizationRule: rawAuthorizationRules
    };
}
/**
 * @internal
 * Helper utility to build an instance of raw authorization rule as RawAuthorizationRule from given `AuthorizationRule` input.
 * @param authorizationRule - parsed Authorization Rule instance
 */ function $3402f46f0a1b2976$var$buildRawAuthorizationRule(authorizationRule) {
    if (!$3402f46f0a1b2976$export$27c50b3aa4baf433(authorizationRule) || authorizationRule === null) throw new TypeError(`Expected authorizationRule input to be a JS object value, but received ${JSON.stringify(authorizationRule, undefined, 2)}`);
    const rawAuthorizationRule = {
        ClaimType: authorizationRule.claimType,
        // ClaimValue is not settable by the users, but service expects the value for PUT requests
        ClaimValue: "None",
        Rights: {
            AccessRights: authorizationRule.accessRights
        },
        KeyName: authorizationRule.keyName,
        PrimaryKey: authorizationRule.primaryKey,
        SecondaryKey: authorizationRule.secondaryKey
    };
    rawAuthorizationRule[$8cc22362d89dbe31$export$8b009e1e43cec8e0] = {
        "p5:type": "SharedAccessAuthorizationRule",
        "xmlns:p5": "http://www.w3.org/2001/XMLSchema-instance"
    };
    return rawAuthorizationRule;
}
function $3402f46f0a1b2976$export$a1cbf2de32a9fd1(url) {
    const _url = url.toLowerCase();
    return _url.startsWith("sb://") || _url.startsWith("http://") || _url.startsWith("https://");
}
async function $3402f46f0a1b2976$export$302134c8253a54bb(args) {
    if (args.abortSignal && args.abortSignal.aborted) throw new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)((0, $807770c0815ec6f8$export$ec529641dbabb04c));
    let timer = undefined;
    let clearAbortSignal = undefined;
    const clearAbortSignalAndTimer = ()=>{
        var _a, _b;
        ((_b = (_a = args.timeoutFunctions) === null || _a === void 0 ? void 0 : _a.clearTimeoutFn) !== null && _b !== void 0 ? _b : clearTimeout)(timer);
        if (clearAbortSignal) clearAbortSignal();
    };
    // eslint-disable-next-line promise/param-names
    const abortOrTimeoutPromise = new Promise((_resolve, reject)=>{
        var _a, _b;
        clearAbortSignal = $3402f46f0a1b2976$export$97f8ca01894ba2ff(reject, args.abortSignal);
        timer = ((_b = (_a = args.timeoutFunctions) === null || _a === void 0 ? void 0 : _a.setTimeoutFn) !== null && _b !== void 0 ? _b : setTimeout)(()=>{
            reject(new (0, $4973e2e602c1cc10$exports.OperationTimeoutError)(args.timeoutMessage));
        }, args.timeoutMs);
    });
    try {
        return await Promise.race([
            abortOrTimeoutPromise,
            args.actionFn()
        ]);
    } finally{
        clearAbortSignalAndTimer();
    }
}
function $3402f46f0a1b2976$export$97f8ca01894ba2ff(onAbortFn, abortSignal) {
    if (abortSignal == null) return ()=>{
    /** Nothing to do here, no abort signal */ };
    if (abortSignal.aborted) throw new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)((0, $807770c0815ec6f8$export$ec529641dbabb04c));
    const onAbort = ()=>{
        abortSignal.removeEventListener("abort", onAbort);
        onAbortFn(new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)((0, $807770c0815ec6f8$export$ec529641dbabb04c)));
    };
    abortSignal.addEventListener("abort", onAbort);
    return ()=>abortSignal.removeEventListener("abort", onAbort);
}
const $3402f46f0a1b2976$export$2dfe8fa169e2faa9 = `azsdk-js-azureservicebus/${$8cc22362d89dbe31$export$8c36c31580f051c6.version}`;
function $3402f46f0a1b2976$export$868f6999e4c7a5e7(prefix) {
    let userAgentPrefix = `${(prefix || "").replace(" ", "")}`;
    userAgentPrefix = userAgentPrefix.length > 0 ? userAgentPrefix + " " : "";
    return `${userAgentPrefix}${$3402f46f0a1b2976$export$2dfe8fa169e2faa9}`;
}
const $3402f46f0a1b2976$export$79c999c4b055cb73 = (pipelineResponse)=>(0, $9c3099bbe0441464$export$6e93530fbf8e23ac)(pipelineResponse);



/**
   applies options to the pipeline request.
  */ function $bf0a38f921c857f0$var$applyRequestOptions(request, options) {
    if (options.headers) {
        const headers = options.headers;
        for (const headerName of Object.keys(headers))request.headers.set(headerName, headers[headerName]);
    }
    request.onDownloadProgress = options.onDownloadProgress;
    request.onUploadProgress = options.onUploadProgress;
    request.abortSignal = options.abortSignal;
    request.timeout = options.timeout;
    if (options.tracingOptions) request.tracingOptions = options.tracingOptions;
}
async function $bf0a38f921c857f0$export$66322938018968c(serviceBusAtomManagementClient, request, serializer, operationOptions, requestObject) {
    var _a, _b, _c, _d;
    if (requestObject) {
        request.body = (0, $912ad09622b3b2a0$export$746eb2ada42c6647)(serializer.serialize(requestObject), {
            rootName: "entry"
        });
        if (request.method === "PUT") request.headers.set("content-length", (0, $6FDNW.Buffer).byteLength(request.body));
    }
    (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Executing ATOM based HTTP request: ${request.body}`);
    const reqPrepareOptions = {
        headers: (_a = operationOptions.requestOptions) === null || _a === void 0 ? void 0 : _a.customHeaders,
        onUploadProgress: (_b = operationOptions.requestOptions) === null || _b === void 0 ? void 0 : _b.onUploadProgress,
        onDownloadProgress: (_c = operationOptions.requestOptions) === null || _c === void 0 ? void 0 : _c.onDownloadProgress,
        abortSignal: operationOptions.abortSignal,
        tracingOptions: operationOptions.tracingOptions,
        disableJsonStringifyOnBody: true,
        timeout: ((_d = operationOptions.requestOptions) === null || _d === void 0 ? void 0 : _d.timeout) || 0
    };
    $bf0a38f921c857f0$var$applyRequestOptions(request, reqPrepareOptions);
    const response = await serviceBusAtomManagementClient.sendRequest(request);
    (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Received ATOM based HTTP response: ${response.bodyAsText}`);
    try {
        if (response.bodyAsText) response.parsedBody = await (0, $912ad09622b3b2a0$export$eacefc55fad2867e)(response.bodyAsText, {
            includeRoot: true
        });
    } catch (err) {
        const error = new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - expected the service to return valid xml content.`, {
            code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
            statusCode: response.status,
            request: response.request,
            response: response
        });
        (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Error parsing response body from Service");
        throw error;
    }
    return serializer.deserialize(response);
}
function $bf0a38f921c857f0$export$ac058409cd8a3a5(resource) {
    Object.keys(resource).forEach(function(property) {
        if (!(0, $a7961d970a7496cb$export$4e62c701997796c1)(resource[property])) delete resource[property];
        else if ((0, $3402f46f0a1b2976$export$27c50b3aa4baf433)(resource[property])) $bf0a38f921c857f0$export$ac058409cd8a3a5(resource[property]);
    });
}
function $bf0a38f921c857f0$export$be46b417f5b95e9b(resourceName, resource) {
    const content = {};
    content[resourceName] = Object.assign({}, resource);
    $bf0a38f921c857f0$export$ac058409cd8a3a5(content[resourceName]);
    content[resourceName][$8cc22362d89dbe31$export$8b009e1e43cec8e0] = {
        xmlns: "http://schemas.microsoft.com/netservices/2010/10/servicebus/connect",
        "xmlns:i": "http://www.w3.org/2001/XMLSchema-instance"
    };
    content[$8cc22362d89dbe31$export$8b009e1e43cec8e0] = {
        type: "application/xml"
    };
    const requestDetails = {
        updated: new Date().toISOString(),
        content: content
    };
    requestDetails[$8cc22362d89dbe31$export$8b009e1e43cec8e0] = {
        xmlns: "http://www.w3.org/2005/Atom"
    };
    return requestDetails;
}
async function $bf0a38f921c857f0$export$bd0d1e994bebafd8(nameProperties, response) {
    // If received data is a non-valid HTTP response, the body is expected to contain error information
    if (response.status < 200 || response.status >= 300) throw $bf0a38f921c857f0$export$28dd9fcb1e8e5bab(response);
    $bf0a38f921c857f0$var$parseAtomResult(response, nameProperties);
    return response;
}
/**
 * @internal
 * Utility to deserialize the given JSON content in response body based on
 * if it's a single `entry` or `feed` and updates the `response.parsedBody` to hold the evaluated output.
 * @param response - Response containing the JSON value in `response.parsedBody`
 * @param nameProperties - The set of 'name' properties to be constructed on the
 * resultant object e.g., QueueName, TopicName, etc.
 * */ function $bf0a38f921c857f0$var$parseAtomResult(response, nameProperties) {
    const atomResponseInJson = response.parsedBody;
    let result;
    if (!atomResponseInJson) {
        response.parsedBody = undefined;
        return;
    }
    if (atomResponseInJson.feed) result = $bf0a38f921c857f0$var$parseFeedResult(atomResponseInJson.feed);
    else if (atomResponseInJson.entry) result = $bf0a38f921c857f0$var$parseEntryResult(atomResponseInJson.entry);
    if (result) {
        if (Array.isArray(result)) result.forEach((entry)=>{
            $bf0a38f921c857f0$var$setName(entry, nameProperties);
        });
        else $bf0a38f921c857f0$var$setName(result, nameProperties);
        response.parsedBody = result;
        return;
    }
    (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).warning("Failure in parsing response body from service. Expected response to be in Atom XML format and have either feed or entry components, but received - %0", atomResponseInJson);
    throw new (0, $193c259516f52386$export$dc24566375af80f3)("Error occurred while parsing the response body - expected the service to return atom xml content with either feed or entry elements.", {
        code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
        statusCode: response.status,
        request: response.request,
        response: response
    });
}
/**
 * @internal
 * Utility to help parse given `entry` result
 */ function $bf0a38f921c857f0$var$parseEntryResult(entry) {
    let result;
    if (typeof entry !== "object" || entry == null || typeof entry.content !== "object" || entry.content == null) return undefined;
    const contentElementNames = Object.keys(entry.content).filter(function(key) {
        return key !== $8cc22362d89dbe31$export$8b009e1e43cec8e0;
    });
    if (contentElementNames && contentElementNames[0]) {
        const contentRootElementName = contentElementNames[0];
        delete entry.content[contentRootElementName][$8cc22362d89dbe31$export$8b009e1e43cec8e0];
        result = entry.content[contentRootElementName];
        if (result) {
            if (entry[$8cc22362d89dbe31$export$8b009e1e43cec8e0]) result[$8cc22362d89dbe31$export$42fd5579ee70843] = entry[$8cc22362d89dbe31$export$8b009e1e43cec8e0];
            else result[$8cc22362d89dbe31$export$42fd5579ee70843] = {};
            result[$8cc22362d89dbe31$export$42fd5579ee70843]["ContentRootElement"] = contentRootElementName;
            Object.keys(entry).forEach((property)=>{
                if (property !== "content" && property !== $8cc22362d89dbe31$export$8b009e1e43cec8e0) result[$8cc22362d89dbe31$export$42fd5579ee70843][property] = entry[property];
            });
            return result;
        }
    }
    return undefined;
}
/**
 * @internal
 * Utility to help parse link info from the given `feed` result
 */ function $bf0a38f921c857f0$var$parseLinkInfo(feedLink, relationship) {
    if (!feedLink || !Array.isArray(feedLink)) return undefined;
    for (const linkInfo of feedLink){
        if (linkInfo[$8cc22362d89dbe31$export$8b009e1e43cec8e0].rel === relationship) return linkInfo[$8cc22362d89dbe31$export$8b009e1e43cec8e0].href;
    }
    return undefined;
}
/**
 * @internal
 * Utility to help parse given `feed` result
 */ function $bf0a38f921c857f0$var$parseFeedResult(feed) {
    const result = [];
    if (typeof feed === "object" && feed != null && feed.entry) {
        if (Array.isArray(feed.entry)) feed.entry.forEach((entry)=>{
            const parsedEntryResult = $bf0a38f921c857f0$var$parseEntryResult(entry);
            if (parsedEntryResult) result.push(parsedEntryResult);
        });
        else {
            const parsedEntryResult = $bf0a38f921c857f0$var$parseEntryResult(feed.entry);
            if (parsedEntryResult) result.push(parsedEntryResult);
        }
        result.nextLink = $bf0a38f921c857f0$var$parseLinkInfo(feed.link, "next");
    }
    return result;
}
/**
 * @internal
 */ function $bf0a38f921c857f0$var$isKnownResponseCode(statusCode) {
    return !!$8cc22362d89dbe31$export$2f5329dd812e9589[statusCode];
}
/**
 * @internal
 * Extracts the applicable entity name(s) from the URL based on the known structure
 * and instantiates the corresponding name properties to the deserialized response
 *
 * The pattern matching checks to extract entity names are based on following
 * constraints dictated by the service
 * - '/' is allowed in Queue and Topic names
 * - '/' is not allowed in Namespace, Subscription and Rule names
 * - Valid pathname URL structures used in the ATOM based management API are
 *     - `<namespace-component>/<topic-name>/Subscriptions/<subscription-name>/Rules/<rule-name>`
 *     - `<namespace-component>/<topic-name>/Subscriptions/<subscription-name>`
 *     - `<namespace-component>/<any-entity-name>`
 *
 */ function $bf0a38f921c857f0$var$setName(entry, nameProperties) {
    if (entry[$8cc22362d89dbe31$export$42fd5579ee70843]) {
        let rawUrl = entry[$8cc22362d89dbe31$export$42fd5579ee70843].id;
        // The parsedUrl gets constructed differently for browser vs Node.
        // It is specifically behaves different for some of the Atom based management API where
        // the received URL in "id" element is of type "sb:// ... " and not a standard HTTP one
        // Hence, normalizing the URL for parsing to work as expected in browser
        if (rawUrl.startsWith("sb://")) rawUrl = "https://" + rawUrl.substring(5);
        const parsedUrl = (0, $589aa7cc5ed318ce$export$4b3d9a5bae55976)(rawUrl);
        const pathname = parsedUrl.pathname;
        const firstIndexOfDelimiter = pathname.indexOf("/");
        if (pathname.match("(.*)/(.*)/Subscriptions/(.*)/Rules/(.*)")) {
            const lastIndexOfSubscriptionsDelimiter = pathname.lastIndexOf("/Subscriptions/");
            const firstIndexOfRulesDelimiter = pathname.indexOf("/Rules/");
            entry[nameProperties[0]] = pathname.substring(firstIndexOfDelimiter + 1, lastIndexOfSubscriptionsDelimiter);
            entry[nameProperties[1]] = pathname.substring(lastIndexOfSubscriptionsDelimiter + 15, firstIndexOfRulesDelimiter);
            entry[nameProperties[2]] = pathname.substring(firstIndexOfRulesDelimiter + 7);
        } else if (pathname.match("(.*)/(.*)/Subscriptions/(.*)")) {
            const lastIndexOfSubscriptionsDelimiter = pathname.lastIndexOf("/Subscriptions/");
            entry[nameProperties[0]] = pathname.substring(firstIndexOfDelimiter + 1, lastIndexOfSubscriptionsDelimiter);
            entry[nameProperties[1]] = pathname.substring(lastIndexOfSubscriptionsDelimiter + 15);
        } else if (pathname.match("(.*)/(.*)")) entry[nameProperties[0]] = pathname.substring(firstIndexOfDelimiter + 1);
    }
}
function $bf0a38f921c857f0$export$28dd9fcb1e8e5bab(response) {
    if (!$bf0a38f921c857f0$var$isKnownResponseCode(response.status)) throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Service returned an error response with an unrecognized HTTP status code - ${response.status}`, {
        code: "ServiceError",
        statusCode: response.status,
        request: response.request,
        response: response
    });
    const errorBody = response.parsedBody;
    let errorMessage;
    if (typeof errorBody === "string") errorMessage = errorBody;
    else if (!(0, $a7961d970a7496cb$export$4e62c701997796c1)(errorBody) || !(0, $a7961d970a7496cb$export$4e62c701997796c1)(errorBody.Error) || !(0, $a7961d970a7496cb$export$4e62c701997796c1)(errorBody.Error.Detail)) errorMessage = "Detailed error message information not available. Look at the 'code' property on error for more information.";
    else errorMessage = errorBody.Error.Detail;
    const errorCode = $bf0a38f921c857f0$var$getErrorCode(response, errorMessage);
    const error = new (0, $193c259516f52386$export$dc24566375af80f3)(errorMessage, {
        code: errorCode,
        statusCode: response.status,
        request: response.request,
        response: response
    });
    return error;
}
/**
 * @internal
 * Helper utility to construct user friendly error codes based on based on given error
 * information and other data present in the received `response` object.
 */ function $bf0a38f921c857f0$var$getErrorCode(response, errorMessage) {
    if (response.status === 401) return "UnauthorizedRequestError";
    if (response.status === 404) return "MessageEntityNotFoundError";
    if (response.status === 409) {
        if (response.request.method === "DELETE") return "ServiceError";
        if (response.request.method === "PUT" && response.request.headers.get("If-Match") === "*") return "ServiceError";
        if (errorMessage && errorMessage.toLowerCase().includes("subcode=40901")) return "ServiceError";
        return "MessageEntityAlreadyExistsError";
    }
    if (response.status === 403) {
        if (errorMessage && errorMessage.toLowerCase().includes("subcode=40301")) return "InvalidOperationError";
        return "QuotaExceededError";
    }
    if (response.status === 400) return "ServiceError";
    if (response.status === 503) return "ServerBusyError";
    return $8cc22362d89dbe31$export$2f5329dd812e9589[response.status];
}



function $3f68d19b3fecc479$export$cd489e29c3f9bf7(rawNamespace) {
    const messagingSku = (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawNamespace["MessagingSKU"], "messagingSku");
    return {
        createdAt: (0, $3402f46f0a1b2976$export$aa350b96d91cd94)(rawNamespace["CreatedTime"], "createdAt"),
        messagingSku: messagingSku,
        modifiedAt: (0, $3402f46f0a1b2976$export$aa350b96d91cd94)(rawNamespace["ModifiedTime"], "modifiedAt"),
        name: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawNamespace["Name"], "name"),
        messagingUnits: messagingSku === "Premium" ? (0, $3402f46f0a1b2976$export$e259718caa99b88b)(rawNamespace["MessagingUnits"], "messagingUnits") : undefined
    };
}
class $3f68d19b3fecc479$export$5715838625fbe05c {
    serialize() {
        return (0, $bf0a38f921c857f0$export$be46b417f5b95e9b)("NamespaceProperties", {});
    }
    async deserialize(response) {
        return (0, $bf0a38f921c857f0$export$bd0d1e994bebafd8)([
            "name"
        ], response);
    }
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.



function $545a8f0de2fd8008$export$fb7a684c74e58647(queue) {
    return {
        // NOTE: this ordering is extremely important. As an example, misordering of the ForwardTo property
        // resulted in a customer bug where the Forwarding attributes appeared to be set but the portal was
        // not picking up on it.
        //
        // The authority on this ordering is here:
        // https://github.com/Azure/azure-sdk-for-net/blob/8af2dfc32c96ef3e340f9d20013bf588d97ea756/sdk/servicebus/Azure.Messaging.ServiceBus/src/Administration/QueuePropertiesExtensions.cs#L20
        LockDuration: queue.lockDuration,
        MaxSizeInMegabytes: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(queue.maxSizeInMegabytes),
        RequiresDuplicateDetection: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(queue.requiresDuplicateDetection),
        RequiresSession: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(queue.requiresSession),
        DefaultMessageTimeToLive: queue.defaultMessageTimeToLive,
        DeadLetteringOnMessageExpiration: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(queue.deadLetteringOnMessageExpiration),
        DuplicateDetectionHistoryTimeWindow: queue.duplicateDetectionHistoryTimeWindow,
        MaxDeliveryCount: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(queue.maxDeliveryCount),
        EnableBatchedOperations: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(queue.enableBatchedOperations),
        AuthorizationRules: (0, $3402f46f0a1b2976$export$2bfb34db9d6c56ee)(queue.authorizationRules),
        Status: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(queue.status),
        ForwardTo: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(queue.forwardTo),
        UserMetadata: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(queue.userMetadata),
        AutoDeleteOnIdle: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(queue.autoDeleteOnIdle),
        EnablePartitioning: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(queue.enablePartitioning),
        ForwardDeadLetteredMessagesTo: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(queue.forwardDeadLetteredMessagesTo),
        EntityAvailabilityStatus: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(queue.availabilityStatus),
        EnableExpress: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(queue.enableExpress),
        MaxMessageSizeInKilobytes: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(queue.maxMessageSizeInKilobytes)
    };
}
function $545a8f0de2fd8008$export$129ff0b29bedf14f(rawQueue) {
    return {
        name: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawQueue[$8cc22362d89dbe31$export$c03ce443fb86f91a], "queueName"),
        forwardTo: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(rawQueue[$8cc22362d89dbe31$export$431d1593f04de92b]),
        userMetadata: rawQueue[$8cc22362d89dbe31$export$20d6ffce908b5455],
        lockDuration: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawQueue[$8cc22362d89dbe31$export$4a087504ce383457], "lockDuration"),
        maxSizeInMegabytes: (0, $3402f46f0a1b2976$export$e259718caa99b88b)(rawQueue[$8cc22362d89dbe31$export$4c3594da079cdd46], "maxSizeInMegabytes"),
        maxDeliveryCount: (0, $3402f46f0a1b2976$export$e259718caa99b88b)(rawQueue[$8cc22362d89dbe31$export$3bce654153779089], "maxDeliveryCount"),
        enablePartitioning: (0, $3402f46f0a1b2976$export$11811c4d2c6a473d)(rawQueue[$8cc22362d89dbe31$export$e7aafcd704df2679], "enablePartitioning"),
        requiresSession: (0, $3402f46f0a1b2976$export$11811c4d2c6a473d)(rawQueue[$8cc22362d89dbe31$export$4e9b94238de609ed], "requiresSession"),
        enableBatchedOperations: (0, $3402f46f0a1b2976$export$11811c4d2c6a473d)(rawQueue[$8cc22362d89dbe31$export$6d9281d5501e5f7e], "enableBatchedOperations"),
        defaultMessageTimeToLive: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawQueue[$8cc22362d89dbe31$export$ebb1501f6b9cd29b], "defaultMessageTimeToLive"),
        autoDeleteOnIdle: rawQueue[$8cc22362d89dbe31$export$2cf637dd9778c784],
        requiresDuplicateDetection: (0, $3402f46f0a1b2976$export$11811c4d2c6a473d)(rawQueue[$8cc22362d89dbe31$export$93f5cc3bef763609], "requiresDuplicateDetection"),
        duplicateDetectionHistoryTimeWindow: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawQueue[$8cc22362d89dbe31$export$2b0dc8e0f24ad57e], "duplicateDetectionHistoryTimeWindow"),
        deadLetteringOnMessageExpiration: (0, $3402f46f0a1b2976$export$11811c4d2c6a473d)(rawQueue[$8cc22362d89dbe31$export$48fc3466cadf8005], "deadLetteringOnMessageExpiration"),
        forwardDeadLetteredMessagesTo: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(rawQueue[$8cc22362d89dbe31$export$aed634d2038095a3]),
        authorizationRules: (0, $3402f46f0a1b2976$export$6b2b27c74d663f64)(rawQueue[$8cc22362d89dbe31$export$3ce81da285e28f5c]),
        status: rawQueue[$8cc22362d89dbe31$export$e50006273435e7d4],
        enableExpress: (0, $3402f46f0a1b2976$export$11811c4d2c6a473d)(rawQueue[$8cc22362d89dbe31$export$ddcc78c26fc673f], "enableExpress"),
        availabilityStatus: rawQueue[$8cc22362d89dbe31$export$f25eef92e6eaff77],
        maxMessageSizeInKilobytes: (0, $3402f46f0a1b2976$export$2689dbaa7374737)(rawQueue[$8cc22362d89dbe31$export$c27bcac6d30d8132])
    };
}
function $545a8f0de2fd8008$export$caec8e35e4815432(rawQueue) {
    const messageCountDetails = (0, $3402f46f0a1b2976$export$ed4b9672d18fcf0c)(rawQueue[$8cc22362d89dbe31$export$b68fd778a3104382]);
    return Object.assign(Object.assign({
        name: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawQueue[$8cc22362d89dbe31$export$c03ce443fb86f91a], "queueName"),
        sizeInBytes: (0, $3402f46f0a1b2976$export$2689dbaa7374737)(rawQueue[$8cc22362d89dbe31$export$d8760f7a08f70566]),
        totalMessageCount: (0, $3402f46f0a1b2976$export$2689dbaa7374737)(rawQueue[$8cc22362d89dbe31$export$6a8945be60a08d93])
    }, messageCountDetails), {
        createdAt: (0, $3402f46f0a1b2976$export$aa350b96d91cd94)(rawQueue[$8cc22362d89dbe31$export$c7c655b4d4e19cd6], "createdAt"),
        modifiedAt: (0, $3402f46f0a1b2976$export$aa350b96d91cd94)(rawQueue[$8cc22362d89dbe31$export$fc3ba281eb90e180], "modifiedAt"),
        accessedAt: (0, $3402f46f0a1b2976$export$aa350b96d91cd94)(rawQueue[$8cc22362d89dbe31$export$d5edc10079103dd5], "accessedAt")
    });
}
class $545a8f0de2fd8008$export$dd5666c52a519943 {
    serialize(resource) {
        return (0, $bf0a38f921c857f0$export$be46b417f5b95e9b)("QueueDescription", resource);
    }
    async deserialize(response) {
        return (0, $bf0a38f921c857f0$export$bd0d1e994bebafd8)([
            "QueueName"
        ], response);
    }
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.




function $02cef6d7b305ba6a$export$8938027f2b62a6b4(rawRule) {
    return {
        name: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawRule["RuleName"], "ruleName"),
        filter: $02cef6d7b305ba6a$var$getTopicFilter(rawRule["Filter"]),
        action: $02cef6d7b305ba6a$var$getRuleAction(rawRule["Action"])
    };
}
/**
 * @internal
 * Helper utility to retrieve `filter` value from given input,
 * or undefined if not passed in.
 */ function $02cef6d7b305ba6a$var$getTopicFilter(value) {
    let result;
    if ((0, $a7961d970a7496cb$export$4e62c701997796c1)(value["SqlExpression"])) result = {
        sqlExpression: value["SqlExpression"],
        sqlParameters: $02cef6d7b305ba6a$var$getKeyValuePairsOrUndefined(value["Parameters"], "SQLParameters")
    };
    else result = {
        correlationId: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(value["CorrelationId"]),
        subject: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(value["Label"]),
        to: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(value["To"]),
        replyTo: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(value["ReplyTo"]),
        replyToSessionId: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(value["ReplyToSessionId"]),
        sessionId: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(value["SessionId"]),
        messageId: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(value["MessageId"]),
        contentType: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(value["ContentType"]),
        applicationProperties: $02cef6d7b305ba6a$var$getKeyValuePairsOrUndefined(value["Properties"], "ApplicationProperties")
    };
    return result;
}
/**
 * @internal
 * Helper utility to retrieve rule `action` value from given input.
 */ function $02cef6d7b305ba6a$var$getRuleAction(value) {
    return {
        sqlExpression: value["SqlExpression"],
        sqlParameters: $02cef6d7b305ba6a$var$getKeyValuePairsOrUndefined(value["Parameters"], "SQLParameters")
    };
}
function $02cef6d7b305ba6a$export$511099875fa4870c(rule) {
    const resource = {
        Filter: {},
        Action: {},
        Name: rule.name
    };
    if (!(0, $a7961d970a7496cb$export$4e62c701997796c1)(rule.filter)) {
        // Defaults to creating a true filter if none specified
        resource.Filter = {
            SqlExpression: "1=1"
        };
        resource.Filter[$8cc22362d89dbe31$export$8b009e1e43cec8e0] = {
            "p4:type": "SqlFilter",
            "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance"
        };
    } else if ((0, $a7961d970a7496cb$export$44aa3a8a1abdb9b6)(rule.filter, [
        "sqlExpression"
    ])) {
        const sqlFilter = rule.filter;
        resource.Filter = {
            SqlExpression: sqlFilter.sqlExpression,
            Parameters: $02cef6d7b305ba6a$export$c59c1366c0521de3(sqlFilter.sqlParameters, "sqlParameters")
        };
        resource.Filter[$8cc22362d89dbe31$export$8b009e1e43cec8e0] = {
            "p4:type": "SqlFilter",
            "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance"
        };
    } else {
        const correlationFilter = rule.filter;
        resource.Filter = {
            CorrelationId: correlationFilter.correlationId,
            Label: correlationFilter.subject,
            To: correlationFilter.to,
            ReplyTo: correlationFilter.replyTo,
            ReplyToSessionId: correlationFilter.replyToSessionId,
            ContentType: correlationFilter.contentType,
            SessionId: correlationFilter.sessionId,
            MessageId: correlationFilter.messageId,
            Properties: $02cef6d7b305ba6a$export$c59c1366c0521de3(correlationFilter.applicationProperties, "applicationProperties")
        };
        resource.Filter[$8cc22362d89dbe31$export$8b009e1e43cec8e0] = {
            "p4:type": "CorrelationFilter",
            "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance"
        };
    }
    if (!(0, $a7961d970a7496cb$export$4e62c701997796c1)(rule.action) || !(0, $a7961d970a7496cb$export$4e62c701997796c1)(rule.action.sqlExpression)) {
        // Defaults to creating an empty rule action instance if none specified
        resource.Action = {};
        resource.Action[$8cc22362d89dbe31$export$8b009e1e43cec8e0] = {
            "p4:type": "EmptyRuleAction",
            "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance"
        };
    } else {
        resource.Action = {
            SqlExpression: rule.action.sqlExpression,
            Parameters: $02cef6d7b305ba6a$export$c59c1366c0521de3(rule.action.sqlParameters, "sqlParameters")
        };
        resource.Action[$8cc22362d89dbe31$export$8b009e1e43cec8e0] = {
            "p4:type": "SqlRuleAction",
            "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance"
        };
    }
    return resource;
}
class $02cef6d7b305ba6a$export$6f9b70b9b6ed9892 {
    serialize(rule) {
        return (0, $bf0a38f921c857f0$export$be46b417f5b95e9b)("RuleDescription", $02cef6d7b305ba6a$export$511099875fa4870c(rule));
    }
    async deserialize(response) {
        return (0, $bf0a38f921c857f0$export$bd0d1e994bebafd8)([
            "TopicName",
            "SubscriptionName",
            "RuleName"
        ], response);
    }
}
function $02cef6d7b305ba6a$export$fe1f0ef55e4df00d(action) {
    return (0, $a7961d970a7496cb$export$44aa3a8a1abdb9b6)(action, [
        "sqlExpression"
    ]);
}
/**
 * Service expects the XML request with the special type names serialized in the request,
 * the request would fail otherwise.
 *
 * @internal
 */ var $02cef6d7b305ba6a$var$TypeMapForRequestSerialization;
(function(TypeMapForRequestSerialization) {
    TypeMapForRequestSerialization["double"] = "l28:double";
    TypeMapForRequestSerialization["string"] = "l28:string";
    TypeMapForRequestSerialization["long"] = "l28:long";
    TypeMapForRequestSerialization["date"] = "l28:dateTime";
    TypeMapForRequestSerialization["boolean"] = "l28:boolean";
})($02cef6d7b305ba6a$var$TypeMapForRequestSerialization || ($02cef6d7b305ba6a$var$TypeMapForRequestSerialization = {}));
/**
 * @internal
 */ var $02cef6d7b305ba6a$var$TypeMapForResponseDeserialization;
(function(TypeMapForResponseDeserialization) {
    TypeMapForResponseDeserialization["int"] = "int";
    TypeMapForResponseDeserialization["double"] = "double";
    TypeMapForResponseDeserialization["string"] = "string";
    TypeMapForResponseDeserialization["boolean"] = "boolean";
    TypeMapForResponseDeserialization["date"] = "dateTime";
})($02cef6d7b305ba6a$var$TypeMapForResponseDeserialization || ($02cef6d7b305ba6a$var$TypeMapForResponseDeserialization = {}));
/**
 * Key-value pairs are supposed to be wrapped with this tag in the XML request, they are ignored otherwise.
 *
 * @internal
 */ const $02cef6d7b305ba6a$var$keyValuePairXMLTag = "KeyValueOfstringanyType";
/**
 * @internal
 * Helper utility to retrieve the key-value pairs from the RawKeyValue object from given input,
 * or undefined if not passed in.
 */ function $02cef6d7b305ba6a$var$getKeyValuePairsOrUndefined(value, attribute) {
    var _a;
    if (!value) return undefined;
    const properties = {};
    let rawProperties;
    if (!Array.isArray(value[$02cef6d7b305ba6a$var$keyValuePairXMLTag]) && ((_a = value[$02cef6d7b305ba6a$var$keyValuePairXMLTag]) === null || _a === void 0 ? void 0 : _a.Key)) // When a single property is present,
    //    value["KeyValueOfstringanyType"] is { Key: <key>, Value: [Object] }
    // When multiple properties are present,
    //    value["KeyValueOfstringanyType"] is [ { Key: <key-1>, Value: [Object] }, { Key: <key-2>, Value: [Object] } ]
    // For consistency, wrapping `value["KeyValueOfstringanyType"]` as an array for the "single property" case.
    rawProperties = [
        value[$02cef6d7b305ba6a$var$keyValuePairXMLTag]
    ];
    else rawProperties = value[$02cef6d7b305ba6a$var$keyValuePairXMLTag];
    if (Array.isArray(rawProperties)) for (const rawProperty of rawProperties){
        const key = rawProperty.Key;
        const _value = rawProperty.Value["_"];
        const encodedValueType = rawProperty.Value["$"]["i:type"].toString().substring(5);
        if (encodedValueType === $02cef6d7b305ba6a$var$TypeMapForResponseDeserialization.int || encodedValueType === $02cef6d7b305ba6a$var$TypeMapForResponseDeserialization.double) properties[key] = Number(_value);
        else if (encodedValueType === $02cef6d7b305ba6a$var$TypeMapForResponseDeserialization.string) properties[key] = _value;
        else if (encodedValueType === $02cef6d7b305ba6a$var$TypeMapForResponseDeserialization.boolean) properties[key] = _value === "true" ? true : false;
        else if (encodedValueType === $02cef6d7b305ba6a$var$TypeMapForResponseDeserialization.date) properties[key] = new Date(_value);
        else throw new TypeError(`Unable to parse the key-value pairs in the response - ${JSON.stringify(rawProperty)}`);
    }
    else throw new TypeError(`${attribute} in the response is not an array, unable to parse the response - ${JSON.stringify(value)}`);
    return properties;
}
function $02cef6d7b305ba6a$export$c59c1366c0521de3(parameters, attribute) {
    if (!(0, $a7961d970a7496cb$export$4e62c701997796c1)(parameters)) return undefined;
    if (Array.isArray(parameters) || typeof parameters === "string" || typeof parameters !== "object" || Object.entries(parameters).length < 1) throw new TypeError(`Unsupported value for the ${attribute} ${JSON.stringify(parameters)}, expected a JSON object with key-value pairs.`);
    const rawParameters = [];
    for (const key of Object.keys(parameters)){
        let type;
        let value = parameters[key];
        if (typeof value === "number") type = $02cef6d7b305ba6a$var$TypeMapForRequestSerialization.double;
        else if (typeof value === "string") type = $02cef6d7b305ba6a$var$TypeMapForRequestSerialization.string;
        else if (typeof value === "boolean") type = $02cef6d7b305ba6a$var$TypeMapForRequestSerialization.boolean;
        else if (value instanceof Date && !isNaN(value.valueOf())) {
            type = $02cef6d7b305ba6a$var$TypeMapForRequestSerialization.date;
            value = value.toJSON();
        } else throw new TypeError(`Unsupported type for the value in the ${attribute} for the key '${key}'`);
        const rawParameter = {
            Key: key,
            Value: {
                [$8cc22362d89dbe31$export$8b009e1e43cec8e0]: {
                    "p4:type": type,
                    "xmlns:l28": "http://www.w3.org/2001/XMLSchema"
                },
                [$8cc22362d89dbe31$export$d3da985b4e812681]: value
            }
        };
        rawParameters.push(rawParameter);
    }
    return {
        [$02cef6d7b305ba6a$var$keyValuePairXMLTag]: rawParameters
    };
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.




function $489c9f3421be3b35$export$43af13797271483(subscription) {
    return {
        // NOTE: this ordering is extremely important. As an example, misordering of the ForwardTo property
        // resulted in a customer bug where the Forwarding attributes appeared to be set but the portal was
        // not picking up on it.
        //
        // The authority on this ordering is here:
        // https://github.com/Azure/azure-sdk-for-net/blob/8af2dfc32c96ef3e340f9d20013bf588d97ea756/sdk/servicebus/Azure.Messaging.ServiceBus/src/Administration/SubscriptionPropertiesExtensions.cs#L191
        LockDuration: subscription.lockDuration,
        RequiresSession: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(subscription.requiresSession),
        DefaultMessageTimeToLive: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(subscription.defaultMessageTimeToLive),
        DeadLetteringOnMessageExpiration: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(subscription.deadLetteringOnMessageExpiration),
        DeadLetteringOnFilterEvaluationExceptions: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(subscription.deadLetteringOnFilterEvaluationExceptions),
        DefaultRuleDescription: subscription.defaultRuleOptions ? (0, $02cef6d7b305ba6a$export$511099875fa4870c)(subscription.defaultRuleOptions) : undefined,
        MaxDeliveryCount: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(subscription.maxDeliveryCount),
        EnableBatchedOperations: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(subscription.enableBatchedOperations),
        Status: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(subscription.status),
        ForwardTo: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(subscription.forwardTo),
        UserMetadata: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(subscription.userMetadata),
        ForwardDeadLetteredMessagesTo: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(subscription.forwardDeadLetteredMessagesTo),
        AutoDeleteOnIdle: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(subscription.autoDeleteOnIdle),
        EntityAvailabilityStatus: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(subscription.availabilityStatus)
    };
}
function $489c9f3421be3b35$export$84aa05677b8355d(rawSubscription) {
    return {
        subscriptionName: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawSubscription[$8cc22362d89dbe31$export$c259a26626651715], "subscriptionName"),
        topicName: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawSubscription[$8cc22362d89dbe31$export$9add4b3ca55e5b86], "topicName"),
        lockDuration: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawSubscription[$8cc22362d89dbe31$export$4a087504ce383457], "lockDuration"),
        maxDeliveryCount: (0, $3402f46f0a1b2976$export$e259718caa99b88b)(rawSubscription[$8cc22362d89dbe31$export$3bce654153779089], "maxDeliveryCount"),
        requiresSession: (0, $3402f46f0a1b2976$export$11811c4d2c6a473d)(rawSubscription[$8cc22362d89dbe31$export$4e9b94238de609ed], "requiresSession"),
        enableBatchedOperations: (0, $3402f46f0a1b2976$export$11811c4d2c6a473d)(rawSubscription[$8cc22362d89dbe31$export$6d9281d5501e5f7e], "enableBatchedOperations"),
        defaultMessageTimeToLive: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawSubscription[$8cc22362d89dbe31$export$ebb1501f6b9cd29b], "defaultMessageTimeToLive"),
        autoDeleteOnIdle: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawSubscription[$8cc22362d89dbe31$export$2cf637dd9778c784], "autoDeleteOnIdle"),
        deadLetteringOnMessageExpiration: (0, $3402f46f0a1b2976$export$11811c4d2c6a473d)(rawSubscription[$8cc22362d89dbe31$export$48fc3466cadf8005], "deadLetteringOnMessageExpiration"),
        deadLetteringOnFilterEvaluationExceptions: (0, $3402f46f0a1b2976$export$11811c4d2c6a473d)(rawSubscription[$8cc22362d89dbe31$export$8d90c906c47a103d], "deadLetteringOnFilterEvaluationExceptions"),
        forwardDeadLetteredMessagesTo: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(rawSubscription[$8cc22362d89dbe31$export$aed634d2038095a3]),
        forwardTo: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(rawSubscription[$8cc22362d89dbe31$export$431d1593f04de92b]),
        userMetadata: rawSubscription[$8cc22362d89dbe31$export$20d6ffce908b5455],
        status: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawSubscription[$8cc22362d89dbe31$export$e50006273435e7d4], "status"),
        availabilityStatus: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawSubscription[$8cc22362d89dbe31$export$f25eef92e6eaff77], "availabilityStatus")
    };
}
function $489c9f3421be3b35$export$37852aadde5460a2(rawSubscription) {
    const messageCountDetails = (0, $3402f46f0a1b2976$export$ed4b9672d18fcf0c)(rawSubscription[$8cc22362d89dbe31$export$b68fd778a3104382]);
    return {
        subscriptionName: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawSubscription[$8cc22362d89dbe31$export$c259a26626651715], "subscriptionName"),
        topicName: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawSubscription[$8cc22362d89dbe31$export$9add4b3ca55e5b86], "topicName"),
        totalMessageCount: (0, $3402f46f0a1b2976$export$e259718caa99b88b)(rawSubscription[$8cc22362d89dbe31$export$6a8945be60a08d93], "messageCount"),
        activeMessageCount: messageCountDetails.activeMessageCount,
        deadLetterMessageCount: messageCountDetails.deadLetterMessageCount,
        transferDeadLetterMessageCount: messageCountDetails.transferDeadLetterMessageCount,
        transferMessageCount: messageCountDetails.transferMessageCount,
        createdAt: (0, $3402f46f0a1b2976$export$aa350b96d91cd94)(rawSubscription[$8cc22362d89dbe31$export$c7c655b4d4e19cd6], "createdAt"),
        modifiedAt: (0, $3402f46f0a1b2976$export$aa350b96d91cd94)(rawSubscription[$8cc22362d89dbe31$export$fc3ba281eb90e180], "modifiedAt"),
        accessedAt: (0, $3402f46f0a1b2976$export$aa350b96d91cd94)(rawSubscription[$8cc22362d89dbe31$export$d5edc10079103dd5], "accessedAt")
    };
}
class $489c9f3421be3b35$export$3eebf93f8407a63d {
    serialize(resource) {
        return (0, $bf0a38f921c857f0$export$be46b417f5b95e9b)("SubscriptionDescription", resource);
    }
    async deserialize(response) {
        return (0, $bf0a38f921c857f0$export$bd0d1e994bebafd8)([
            "TopicName",
            "SubscriptionName"
        ], response);
    }
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.



function $031470a0c4fa9f0d$export$5f7750e59fafe835(topic) {
    return {
        // NOTE: this ordering is extremely important. As an example, misordering of the ForwardTo property
        // resulted in a customer bug where the Forwarding attributes appeared to be set but the portal was
        // not picking up on it.
        //
        // The authority on this ordering is here:
        // https://github.com/Azure/azure-sdk-for-net/blob/8af2dfc32c96ef3e340f9d20013bf588d97ea756/sdk/servicebus/Azure.Messaging.ServiceBus/src/Administration/TopicPropertiesExtensions.cs#L175
        DefaultMessageTimeToLive: topic.defaultMessageTimeToLive,
        MaxSizeInMegabytes: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(topic.maxSizeInMegabytes),
        RequiresDuplicateDetection: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(topic.requiresDuplicateDetection),
        DuplicateDetectionHistoryTimeWindow: topic.duplicateDetectionHistoryTimeWindow,
        EnableBatchedOperations: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(topic.enableBatchedOperations),
        AuthorizationRules: (0, $3402f46f0a1b2976$export$2bfb34db9d6c56ee)(topic.authorizationRules),
        Status: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(topic.status),
        UserMetadata: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(topic.userMetadata),
        SupportOrdering: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(topic.supportOrdering),
        AutoDeleteOnIdle: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(topic.autoDeleteOnIdle),
        EnablePartitioning: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(topic.enablePartitioning),
        EntityAvailabilityStatus: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(topic.availabilityStatus),
        EnableExpress: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(topic.enableExpress),
        MaxMessageSizeInKilobytes: (0, $3402f46f0a1b2976$export$df9e08d3f49523a1)(topic.maxMessageSizeInKilobytes)
    };
}
function $031470a0c4fa9f0d$export$438f66a38b1d6272(rawTopic) {
    return {
        name: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawTopic[$8cc22362d89dbe31$export$9add4b3ca55e5b86], "topicName"),
        maxSizeInMegabytes: (0, $3402f46f0a1b2976$export$e259718caa99b88b)(rawTopic[$8cc22362d89dbe31$export$4c3594da079cdd46], "maxSizeInMegabytes"),
        enablePartitioning: (0, $3402f46f0a1b2976$export$11811c4d2c6a473d)(rawTopic[$8cc22362d89dbe31$export$e7aafcd704df2679], "enablePartitioning"),
        supportOrdering: (0, $3402f46f0a1b2976$export$11811c4d2c6a473d)(rawTopic[$8cc22362d89dbe31$export$da85a201c1d11265], "supportOrdering"),
        enableBatchedOperations: (0, $3402f46f0a1b2976$export$11811c4d2c6a473d)(rawTopic[$8cc22362d89dbe31$export$6d9281d5501e5f7e], "enableBatchedOperations"),
        defaultMessageTimeToLive: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawTopic[$8cc22362d89dbe31$export$ebb1501f6b9cd29b], "defaultMessageTimeToLive"),
        autoDeleteOnIdle: rawTopic[$8cc22362d89dbe31$export$2cf637dd9778c784],
        requiresDuplicateDetection: (0, $3402f46f0a1b2976$export$11811c4d2c6a473d)(rawTopic[$8cc22362d89dbe31$export$93f5cc3bef763609], "requiresDuplicateDetection"),
        duplicateDetectionHistoryTimeWindow: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawTopic[$8cc22362d89dbe31$export$2b0dc8e0f24ad57e], "duplicateDetectionHistoryTimeWindow"),
        authorizationRules: (0, $3402f46f0a1b2976$export$6b2b27c74d663f64)(rawTopic[$8cc22362d89dbe31$export$3ce81da285e28f5c]),
        userMetadata: rawTopic[$8cc22362d89dbe31$export$20d6ffce908b5455],
        status: rawTopic[$8cc22362d89dbe31$export$e50006273435e7d4],
        enableExpress: (0, $3402f46f0a1b2976$export$11811c4d2c6a473d)(rawTopic[$8cc22362d89dbe31$export$ddcc78c26fc673f], "enableExpress"),
        availabilityStatus: rawTopic[$8cc22362d89dbe31$export$f25eef92e6eaff77],
        maxMessageSizeInKilobytes: (0, $3402f46f0a1b2976$export$2689dbaa7374737)(rawTopic[$8cc22362d89dbe31$export$c27bcac6d30d8132])
    };
}
function $031470a0c4fa9f0d$export$883fa8c9f5d006f7(rawTopic) {
    return {
        name: (0, $3402f46f0a1b2976$export$f8963f3214707ee4)(rawTopic[$8cc22362d89dbe31$export$9add4b3ca55e5b86], "topicName"),
        sizeInBytes: (0, $3402f46f0a1b2976$export$2689dbaa7374737)(rawTopic[$8cc22362d89dbe31$export$d8760f7a08f70566]),
        subscriptionCount: (0, $3402f46f0a1b2976$export$2689dbaa7374737)(rawTopic[$8cc22362d89dbe31$export$24af18af21e666cd]),
        createdAt: (0, $3402f46f0a1b2976$export$aa350b96d91cd94)(rawTopic[$8cc22362d89dbe31$export$c7c655b4d4e19cd6], "createdAt"),
        scheduledMessageCount: (0, $3402f46f0a1b2976$export$ed4b9672d18fcf0c)(rawTopic[$8cc22362d89dbe31$export$b68fd778a3104382]).scheduledMessageCount,
        modifiedAt: (0, $3402f46f0a1b2976$export$aa350b96d91cd94)(rawTopic[$8cc22362d89dbe31$export$fc3ba281eb90e180], "modifiedAt"),
        accessedAt: (0, $3402f46f0a1b2976$export$aa350b96d91cd94)(rawTopic[$8cc22362d89dbe31$export$d5edc10079103dd5], "accessedAt")
    };
}
class $031470a0c4fa9f0d$export$ac8a617754153f13 {
    serialize(resource) {
        return (0, $bf0a38f921c857f0$export$be46b417f5b95e9b)("TopicDescription", resource);
    }
    async deserialize(response) {
        return (0, $bf0a38f921c857f0$export$bd0d1e994bebafd8)([
            "TopicName"
        ], response);
    }
}





// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 */ async function $eb6b4b7222473d43$export$3a7728e868aa3ebd(secret, stringToSign) {
    const key = await self.crypto.subtle.importKey("raw", $eb6b4b7222473d43$var$convertToUint8Array(secret), {
        name: "HMAC",
        hash: {
            name: "SHA-256"
        }
    }, false, [
        "sign"
    ]);
    const signature = await self.crypto.subtle.sign("HMAC", key, $eb6b4b7222473d43$var$convertToUint8Array(stringToSign));
    const base64encodedString = $eb6b4b7222473d43$var$encodeByteArray(new Uint8Array(signature));
    const result = encodeURIComponent(base64encodedString);
    return result;
}
/**
 * @internal
 */ function $eb6b4b7222473d43$var$convertToUint8Array(value) {
    const arr = new Uint8Array(value.length);
    for(let i = 0; i < value.length; i++)arr[i] = value.charCodeAt(i);
    return arr;
}
/**
 * Encodes a byte array in base64 format.
 * @param value - the Uint8Aray to encode
 * @internal
 *
 */ function $eb6b4b7222473d43$var$encodeByteArray(value) {
    let str = "";
    for(let i = 0; i < value.length; i++)str += String.fromCharCode(value[i]);
    return btoa(str);
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

class $c156b569e523edc4$export$144d569f55afc767 {
    /**
     * Create an instance of an AzureSASCredential for use
     * with a service client.
     *
     * @param signature - The initial value of the shared access signature to use in authentication
     */ constructor(signature){
        if (!signature) throw new Error("shared access signature must be a non-empty string");
        this._signature = signature;
    }
    /**
     * The value of the shared access signature to be used in authentication
     */ get signature() {
        return this._signature;
    }
    /**
     * Change the value of the signature.
     *
     * Updates will take effect upon the next request after
     * updating the signature value.
     *
     * @param newSignature - The new shared access signature value to be used
     */ update(newSignature) {
        if (!newSignature) throw new Error("shared access signature must be a non-empty string");
        this._signature = newSignature;
    }
}
function $c156b569e523edc4$export$3b616d4df4414a6e(credential) {
    return (0, $447d2c65ccf7f178$export$44aa3a8a1abdb9b6)(credential, [
        "signature"
    ]) && typeof credential.signature === "string";
}



/**
 * A JavaScript implementation of the SHA family of hashes - defined in FIPS PUB 180-4, FIPS PUB 202,
 * and SP 800-185 - as well as the corresponding HMAC implementation as defined in FIPS PUB 198-1.
 *
 * Copyright 2008-2020 Brian Turek, 1998-2009 Paul Johnston & Contributors
 * Distributed under the BSD License
 * See http://caligatio.github.com/jsSHA/ for more information
 */ const $c738c9cb3c1fa17f$var$t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function $c738c9cb3c1fa17f$var$n(t, n, e, r) {
    let i, s, o;
    const h = n || [
        0
    ], u = (e = e || 0) >>> 3, w = -1 === r ? 3 : 0;
    for(i = 0; i < t.length; i += 1)o = i + u, s = o >>> 2, h.length <= s && h.push(0), h[s] |= t[i] << 8 * (w + r * (o % 4));
    return {
        value: h,
        binLen: 8 * t.length + e
    };
}
function $c738c9cb3c1fa17f$var$e(e, r, i) {
    switch(r){
        case "UTF8":
        case "UTF16BE":
        case "UTF16LE":
            break;
        default:
            throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
    }
    switch(e){
        case "HEX":
            return function(t, n, e) {
                return function(t, n, e, r) {
                    let i, s, o, h;
                    if (0 != t.length % 2) throw new Error("String of HEX type must be in byte increments");
                    const u = n || [
                        0
                    ], w = (e = e || 0) >>> 3, c = -1 === r ? 3 : 0;
                    for(i = 0; i < t.length; i += 2){
                        if (s = parseInt(t.substr(i, 2), 16), isNaN(s)) throw new Error("String of HEX type contains invalid characters");
                        for(h = (i >>> 1) + w, o = h >>> 2; u.length <= o;)u.push(0);
                        u[o] |= s << 8 * (c + r * (h % 4));
                    }
                    return {
                        value: u,
                        binLen: 4 * t.length + e
                    };
                }(t, n, e, i);
            };
        case "TEXT":
            return function(t, n, e) {
                return function(t, n, e, r, i) {
                    let s, o, h, u, w, c, f, a, l = 0;
                    const A = e || [
                        0
                    ], E = (r = r || 0) >>> 3;
                    if ("UTF8" === n) for(f = -1 === i ? 3 : 0, h = 0; h < t.length; h += 1)for(s = t.charCodeAt(h), o = [], 128 > s ? o.push(s) : 2048 > s ? (o.push(192 | s >>> 6), o.push(128 | 63 & s)) : 55296 > s || 57344 <= s ? o.push(224 | s >>> 12, 128 | s >>> 6 & 63, 128 | 63 & s) : (h += 1, s = 65536 + ((1023 & s) << 10 | 1023 & t.charCodeAt(h)), o.push(240 | s >>> 18, 128 | s >>> 12 & 63, 128 | s >>> 6 & 63, 128 | 63 & s)), u = 0; u < o.length; u += 1){
                        for(c = l + E, w = c >>> 2; A.length <= w;)A.push(0);
                        A[w] |= o[u] << 8 * (f + i * (c % 4)), l += 1;
                    }
                    else for(f = -1 === i ? 2 : 0, a = "UTF16LE" === n && 1 !== i || "UTF16LE" !== n && 1 === i, h = 0; h < t.length; h += 1){
                        for(s = t.charCodeAt(h), !0 === a && (u = 255 & s, s = u << 8 | s >>> 8), c = l + E, w = c >>> 2; A.length <= w;)A.push(0);
                        A[w] |= s << 8 * (f + i * (c % 4)), l += 2;
                    }
                    return {
                        value: A,
                        binLen: 8 * l + r
                    };
                }(t, r, n, e, i);
            };
        case "B64":
            return function(n, e, r) {
                return function(n, e, r, i) {
                    let s, o, h, u, w, c, f, a = 0;
                    const l = e || [
                        0
                    ], A = (r = r || 0) >>> 3, E = -1 === i ? 3 : 0, H = n.indexOf("=");
                    if (-1 === n.search(/^[a-zA-Z0-9=+/]+$/)) throw new Error("Invalid character in base-64 string");
                    if (n = n.replace(/=/g, ""), -1 !== H && H < n.length) throw new Error("Invalid '=' found in base-64 string");
                    for(o = 0; o < n.length; o += 4){
                        for(w = n.substr(o, 4), u = 0, h = 0; h < w.length; h += 1)s = $c738c9cb3c1fa17f$var$t.indexOf(w.charAt(h)), u |= s << 18 - 6 * h;
                        for(h = 0; h < w.length - 1; h += 1){
                            for(f = a + A, c = f >>> 2; l.length <= c;)l.push(0);
                            l[c] |= (u >>> 16 - 8 * h & 255) << 8 * (E + i * (f % 4)), a += 1;
                        }
                    }
                    return {
                        value: l,
                        binLen: 8 * a + r
                    };
                }(n, e, r, i);
            };
        case "BYTES":
            return function(t, n, e) {
                return function(t, n, e, r) {
                    let i, s, o, h;
                    const u = n || [
                        0
                    ], w = (e = e || 0) >>> 3, c = -1 === r ? 3 : 0;
                    for(s = 0; s < t.length; s += 1)i = t.charCodeAt(s), h = s + w, o = h >>> 2, u.length <= o && u.push(0), u[o] |= i << 8 * (c + r * (h % 4));
                    return {
                        value: u,
                        binLen: 8 * t.length + e
                    };
                }(t, n, e, i);
            };
        case "ARRAYBUFFER":
            try {
                new ArrayBuffer(0);
            } catch (t) {
                throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(t, e, r) {
                return function(t, e, r, i) {
                    return $c738c9cb3c1fa17f$var$n(new Uint8Array(t), e, r, i);
                }(t, e, r, i);
            };
        case "UINT8ARRAY":
            try {
                new Uint8Array(0);
            } catch (t) {
                throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(t, e, r) {
                return $c738c9cb3c1fa17f$var$n(t, e, r, i);
            };
        default:
            throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
    }
}
function $c738c9cb3c1fa17f$var$r(n, e, r, i) {
    switch(n){
        case "HEX":
            return function(t) {
                return function(t, n, e, r) {
                    let i, s, o = "";
                    const h = n / 8, u = -1 === e ? 3 : 0;
                    for(i = 0; i < h; i += 1)s = t[i >>> 2] >>> 8 * (u + e * (i % 4)), o += "0123456789abcdef".charAt(s >>> 4 & 15) + "0123456789abcdef".charAt(15 & s);
                    return r.outputUpper ? o.toUpperCase() : o;
                }(t, e, r, i);
            };
        case "B64":
            return function(n) {
                return function(n, e, r, i) {
                    let s, o, h, u, w, c = "";
                    const f = e / 8, a = -1 === r ? 3 : 0;
                    for(s = 0; s < f; s += 3)for(u = s + 1 < f ? n[s + 1 >>> 2] : 0, w = s + 2 < f ? n[s + 2 >>> 2] : 0, h = (n[s >>> 2] >>> 8 * (a + r * (s % 4)) & 255) << 16 | (u >>> 8 * (a + r * ((s + 1) % 4)) & 255) << 8 | w >>> 8 * (a + r * ((s + 2) % 4)) & 255, o = 0; o < 4; o += 1)c += 8 * s + 6 * o <= e ? $c738c9cb3c1fa17f$var$t.charAt(h >>> 6 * (3 - o) & 63) : i.b64Pad;
                    return c;
                }(n, e, r, i);
            };
        case "BYTES":
            return function(t) {
                return function(t, n, e) {
                    let r, i, s = "";
                    const o = n / 8, h = -1 === e ? 3 : 0;
                    for(r = 0; r < o; r += 1)i = t[r >>> 2] >>> 8 * (h + e * (r % 4)) & 255, s += String.fromCharCode(i);
                    return s;
                }(t, e, r);
            };
        case "ARRAYBUFFER":
            try {
                new ArrayBuffer(0);
            } catch (t) {
                throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(t) {
                return function(t, n, e) {
                    let r;
                    const i = n / 8, s = new ArrayBuffer(i), o = new Uint8Array(s), h = -1 === e ? 3 : 0;
                    for(r = 0; r < i; r += 1)o[r] = t[r >>> 2] >>> 8 * (h + e * (r % 4)) & 255;
                    return s;
                }(t, e, r);
            };
        case "UINT8ARRAY":
            try {
                new Uint8Array(0);
            } catch (t) {
                throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(t) {
                return function(t, n, e) {
                    let r;
                    const i = n / 8, s = -1 === e ? 3 : 0, o = new Uint8Array(i);
                    for(r = 0; r < i; r += 1)o[r] = t[r >>> 2] >>> 8 * (s + e * (r % 4)) & 255;
                    return o;
                }(t, e, r);
            };
        default:
            throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
    }
}
const $c738c9cb3c1fa17f$var$i = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
], $c738c9cb3c1fa17f$var$s = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
], $c738c9cb3c1fa17f$var$o = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
], $c738c9cb3c1fa17f$var$h = "Chosen SHA variant is not supported";
function $c738c9cb3c1fa17f$var$u(t, n) {
    let e, r;
    const i = t.binLen >>> 3, s = n.binLen >>> 3, o = i << 3, h = 4 - i << 3;
    if (i % 4 != 0) {
        for(e = 0; e < s; e += 4)r = i + e >>> 2, t.value[r] |= n.value[e >>> 2] << o, t.value.push(0), t.value[r + 1] |= n.value[e >>> 2] >>> h;
        return (t.value.length << 2) - 4 >= s + i && t.value.pop(), {
            value: t.value,
            binLen: t.binLen + n.binLen
        };
    }
    return {
        value: t.value.concat(n.value),
        binLen: t.binLen + n.binLen
    };
}
function $c738c9cb3c1fa17f$var$w(t) {
    const n = {
        outputUpper: !1,
        b64Pad: "=",
        outputLen: -1
    }, e = t || {}, r = "Output length must be a multiple of 8";
    if (n.outputUpper = e.outputUpper || !1, e.b64Pad && (n.b64Pad = e.b64Pad), e.outputLen) {
        if (e.outputLen % 8 != 0) throw new Error(r);
        n.outputLen = e.outputLen;
    } else if (e.shakeLen) {
        if (e.shakeLen % 8 != 0) throw new Error(r);
        n.outputLen = e.shakeLen;
    }
    if ("boolean" != typeof n.outputUpper) throw new Error("Invalid outputUpper formatting option");
    if ("string" != typeof n.b64Pad) throw new Error("Invalid b64Pad formatting option");
    return n;
}
function $c738c9cb3c1fa17f$var$c(t, n, r, i) {
    const s = t + " must include a value and format";
    if (!n) {
        if (!i) throw new Error(s);
        return i;
    }
    if (void 0 === n.value || !n.format) throw new Error(s);
    return $c738c9cb3c1fa17f$var$e(n.format, n.encoding || "UTF8", r)(n.value);
}
class $c738c9cb3c1fa17f$var$f {
    constructor(t, n, e){
        const r = e || {};
        if (this.t = n, this.i = r.encoding || "UTF8", this.numRounds = r.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds) throw new Error("numRounds must a integer >= 1");
        this.s = t, this.o = [], this.h = 0, this.u = !1, this.l = 0, this.A = !1, this.H = [], this.S = [];
    }
    update(t) {
        let n, e = 0;
        const r = this.p >>> 5, i = this.m(t, this.o, this.h), s = i.binLen, o = i.value, h = s >>> 5;
        for(n = 0; n < h; n += r)e + this.p <= s && (this.C = this.R(o.slice(n, n + r), this.C), e += this.p);
        this.l += e, this.o = o.slice(e >>> 5), this.h = s % this.p, this.u = !0;
    }
    getHash(t, n) {
        let e, i, s = this.U;
        const o = $c738c9cb3c1fa17f$var$w(n);
        if (this.v) {
            if (-1 === o.outputLen) throw new Error("Output length must be specified in options");
            s = o.outputLen;
        }
        const h = $c738c9cb3c1fa17f$var$r(t, s, this.K, o);
        if (this.A && this.T) return h(this.T(o));
        for(i = this.F(this.o.slice(), this.h, this.l, this.g(this.C), s), e = 1; e < this.numRounds; e += 1)this.v && s % 32 != 0 && (i[i.length - 1] &= 16777215 >>> 24 - s % 32), i = this.F(i, s, 0, this.B(this.s), s);
        return h(i);
    }
    setHMACKey(t, n, r) {
        if (!this.L) throw new Error("Variant does not support HMAC");
        if (this.u) throw new Error("Cannot set MAC key after calling update");
        const i = $c738c9cb3c1fa17f$var$e(n, (r || {}).encoding || "UTF8", this.K);
        this.M(i(t));
    }
    M(t) {
        const n = this.p >>> 3, e = n / 4 - 1;
        let r;
        if (1 !== this.numRounds) throw new Error("Cannot set numRounds with MAC");
        if (this.A) throw new Error("MAC key already set");
        for(n < t.binLen / 8 && (t.value = this.F(t.value, t.binLen, 0, this.B(this.s), this.U)); t.value.length <= e;)t.value.push(0);
        for(r = 0; r <= e; r += 1)this.H[r] = 909522486 ^ t.value[r], this.S[r] = 1549556828 ^ t.value[r];
        this.C = this.R(this.H, this.C), this.l = this.p, this.A = !0;
    }
    getHMAC(t, n) {
        const e = $c738c9cb3c1fa17f$var$w(n);
        return $c738c9cb3c1fa17f$var$r(t, this.U, this.K, e)(this.k());
    }
    k() {
        let t;
        if (!this.A) throw new Error("Cannot call getHMAC without first setting MAC key");
        const n = this.F(this.o.slice(), this.h, this.l, this.g(this.C), this.U);
        return t = this.R(this.S, this.B(this.s)), t = this.F(n, this.U, this.p, t, this.U), t;
    }
}
function $c738c9cb3c1fa17f$var$a(t, n) {
    return t << n | t >>> 32 - n;
}
function $c738c9cb3c1fa17f$var$l(t, n) {
    return t >>> n | t << 32 - n;
}
function $c738c9cb3c1fa17f$var$A(t, n) {
    return t >>> n;
}
function $c738c9cb3c1fa17f$var$E(t, n, e) {
    return t ^ n ^ e;
}
function $c738c9cb3c1fa17f$var$H(t, n, e) {
    return t & n ^ ~t & e;
}
function $c738c9cb3c1fa17f$var$S(t, n, e) {
    return t & n ^ t & e ^ n & e;
}
function $c738c9cb3c1fa17f$var$b(t) {
    return $c738c9cb3c1fa17f$var$l(t, 2) ^ $c738c9cb3c1fa17f$var$l(t, 13) ^ $c738c9cb3c1fa17f$var$l(t, 22);
}
function $c738c9cb3c1fa17f$var$p(t, n) {
    const e = (65535 & t) + (65535 & n);
    return (65535 & (t >>> 16) + (n >>> 16) + (e >>> 16)) << 16 | 65535 & e;
}
function $c738c9cb3c1fa17f$var$d(t, n, e, r) {
    const i = (65535 & t) + (65535 & n) + (65535 & e) + (65535 & r);
    return (65535 & (t >>> 16) + (n >>> 16) + (e >>> 16) + (r >>> 16) + (i >>> 16)) << 16 | 65535 & i;
}
function $c738c9cb3c1fa17f$var$m(t, n, e, r, i) {
    const s = (65535 & t) + (65535 & n) + (65535 & e) + (65535 & r) + (65535 & i);
    return (65535 & (t >>> 16) + (n >>> 16) + (e >>> 16) + (r >>> 16) + (i >>> 16) + (s >>> 16)) << 16 | 65535 & s;
}
function $c738c9cb3c1fa17f$var$C(t) {
    return $c738c9cb3c1fa17f$var$l(t, 7) ^ $c738c9cb3c1fa17f$var$l(t, 18) ^ $c738c9cb3c1fa17f$var$A(t, 3);
}
function $c738c9cb3c1fa17f$var$y(t) {
    return $c738c9cb3c1fa17f$var$l(t, 6) ^ $c738c9cb3c1fa17f$var$l(t, 11) ^ $c738c9cb3c1fa17f$var$l(t, 25);
}
function $c738c9cb3c1fa17f$var$R(t) {
    return [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
    ];
}
function $c738c9cb3c1fa17f$var$U(t, n) {
    let e, r, i, s, o, h, u;
    const w = [];
    for(e = n[0], r = n[1], i = n[2], s = n[3], o = n[4], u = 0; u < 80; u += 1)w[u] = u < 16 ? t[u] : $c738c9cb3c1fa17f$var$a(w[u - 3] ^ w[u - 8] ^ w[u - 14] ^ w[u - 16], 1), h = u < 20 ? $c738c9cb3c1fa17f$var$m($c738c9cb3c1fa17f$var$a(e, 5), $c738c9cb3c1fa17f$var$H(r, i, s), o, 1518500249, w[u]) : u < 40 ? $c738c9cb3c1fa17f$var$m($c738c9cb3c1fa17f$var$a(e, 5), $c738c9cb3c1fa17f$var$E(r, i, s), o, 1859775393, w[u]) : u < 60 ? $c738c9cb3c1fa17f$var$m($c738c9cb3c1fa17f$var$a(e, 5), $c738c9cb3c1fa17f$var$S(r, i, s), o, 2400959708, w[u]) : $c738c9cb3c1fa17f$var$m($c738c9cb3c1fa17f$var$a(e, 5), $c738c9cb3c1fa17f$var$E(r, i, s), o, 3395469782, w[u]), o = s, s = i, i = $c738c9cb3c1fa17f$var$a(r, 30), r = e, e = h;
    return n[0] = $c738c9cb3c1fa17f$var$p(e, n[0]), n[1] = $c738c9cb3c1fa17f$var$p(r, n[1]), n[2] = $c738c9cb3c1fa17f$var$p(i, n[2]), n[3] = $c738c9cb3c1fa17f$var$p(s, n[3]), n[4] = $c738c9cb3c1fa17f$var$p(o, n[4]), n;
}
function $c738c9cb3c1fa17f$var$v(t, n, e, r) {
    let i;
    const s = 15 + (n + 65 >>> 9 << 4), o = n + e;
    for(; t.length <= s;)t.push(0);
    for(t[n >>> 5] |= 128 << 24 - n % 32, t[s] = 4294967295 & o, t[s - 1] = o / 4294967296 | 0, i = 0; i < t.length; i += 16)r = $c738c9cb3c1fa17f$var$U(t.slice(i, i + 16), r);
    return r;
}
class $c738c9cb3c1fa17f$var$K extends $c738c9cb3c1fa17f$var$f {
    constructor(t, n, r){
        if ("SHA-1" !== t) throw new Error($c738c9cb3c1fa17f$var$h);
        super(t, n, r);
        const i = r || {};
        this.L = !0, this.T = this.k, this.K = -1, this.m = $c738c9cb3c1fa17f$var$e(this.t, this.i, this.K), this.R = $c738c9cb3c1fa17f$var$U, this.g = function(t) {
            return t.slice();
        }, this.B = $c738c9cb3c1fa17f$var$R, this.F = $c738c9cb3c1fa17f$var$v, this.C = [
            1732584193,
            4023233417,
            2562383102,
            271733878,
            3285377520
        ], this.p = 512, this.U = 160, this.v = !1, i.hmacKey && this.M($c738c9cb3c1fa17f$var$c("hmacKey", i.hmacKey, this.K));
    }
}
function $c738c9cb3c1fa17f$var$T(t) {
    let n;
    return n = "SHA-224" == t ? $c738c9cb3c1fa17f$var$s.slice() : $c738c9cb3c1fa17f$var$o.slice(), n;
}
function $c738c9cb3c1fa17f$var$F(t, n) {
    let e, r, s, o, h, u, w, c, f, a, E;
    const R = [];
    for(e = n[0], r = n[1], s = n[2], o = n[3], h = n[4], u = n[5], w = n[6], c = n[7], E = 0; E < 64; E += 1)R[E] = E < 16 ? t[E] : $c738c9cb3c1fa17f$var$d($c738c9cb3c1fa17f$var$l(U = R[E - 2], 17) ^ $c738c9cb3c1fa17f$var$l(U, 19) ^ $c738c9cb3c1fa17f$var$A(U, 10), R[E - 7], $c738c9cb3c1fa17f$var$C(R[E - 15]), R[E - 16]), f = $c738c9cb3c1fa17f$var$m(c, $c738c9cb3c1fa17f$var$y(h), $c738c9cb3c1fa17f$var$H(h, u, w), $c738c9cb3c1fa17f$var$i[E], R[E]), a = $c738c9cb3c1fa17f$var$p($c738c9cb3c1fa17f$var$b(e), $c738c9cb3c1fa17f$var$S(e, r, s)), c = w, w = u, u = h, h = $c738c9cb3c1fa17f$var$p(o, f), o = s, s = r, r = e, e = $c738c9cb3c1fa17f$var$p(f, a);
    var U;
    return n[0] = $c738c9cb3c1fa17f$var$p(e, n[0]), n[1] = $c738c9cb3c1fa17f$var$p(r, n[1]), n[2] = $c738c9cb3c1fa17f$var$p(s, n[2]), n[3] = $c738c9cb3c1fa17f$var$p(o, n[3]), n[4] = $c738c9cb3c1fa17f$var$p(h, n[4]), n[5] = $c738c9cb3c1fa17f$var$p(u, n[5]), n[6] = $c738c9cb3c1fa17f$var$p(w, n[6]), n[7] = $c738c9cb3c1fa17f$var$p(c, n[7]), n;
}
class $c738c9cb3c1fa17f$var$g extends $c738c9cb3c1fa17f$var$f {
    constructor(t, n, r){
        if ("SHA-224" !== t && "SHA-256" !== t) throw new Error($c738c9cb3c1fa17f$var$h);
        super(t, n, r);
        const i = r || {};
        this.T = this.k, this.L = !0, this.K = -1, this.m = $c738c9cb3c1fa17f$var$e(this.t, this.i, this.K), this.R = $c738c9cb3c1fa17f$var$F, this.g = function(t) {
            return t.slice();
        }, this.B = $c738c9cb3c1fa17f$var$T, this.F = function(n, e, r, i) {
            return function(t, n, e, r, i) {
                let s, o;
                const h = 15 + (n + 65 >>> 9 << 4), u = n + e;
                for(; t.length <= h;)t.push(0);
                for(t[n >>> 5] |= 128 << 24 - n % 32, t[h] = 4294967295 & u, t[h - 1] = u / 4294967296 | 0, s = 0; s < t.length; s += 16)r = $c738c9cb3c1fa17f$var$F(t.slice(s, s + 16), r);
                return o = "SHA-224" === i ? [
                    r[0],
                    r[1],
                    r[2],
                    r[3],
                    r[4],
                    r[5],
                    r[6]
                ] : r, o;
            }(n, e, r, i, t);
        }, this.C = $c738c9cb3c1fa17f$var$T(t), this.p = 512, this.U = "SHA-224" === t ? 224 : 256, this.v = !1, i.hmacKey && this.M($c738c9cb3c1fa17f$var$c("hmacKey", i.hmacKey, this.K));
    }
}
class $c738c9cb3c1fa17f$var$B {
    constructor(t, n){
        this.Y = t, this.N = n;
    }
}
function $c738c9cb3c1fa17f$var$L(t, n) {
    let e;
    return n > 32 ? (e = 64 - n, new $c738c9cb3c1fa17f$var$B(t.N << n | t.Y >>> e, t.Y << n | t.N >>> e)) : 0 !== n ? (e = 32 - n, new $c738c9cb3c1fa17f$var$B(t.Y << n | t.N >>> e, t.N << n | t.Y >>> e)) : t;
}
function $c738c9cb3c1fa17f$var$M(t, n) {
    let e;
    return n < 32 ? (e = 32 - n, new $c738c9cb3c1fa17f$var$B(t.Y >>> n | t.N << e, t.N >>> n | t.Y << e)) : (e = 64 - n, new $c738c9cb3c1fa17f$var$B(t.N >>> n | t.Y << e, t.Y >>> n | t.N << e));
}
function $c738c9cb3c1fa17f$var$k(t, n) {
    return new $c738c9cb3c1fa17f$var$B(t.Y >>> n, t.N >>> n | t.Y << 32 - n);
}
function $c738c9cb3c1fa17f$var$Y(t, n, e) {
    return new $c738c9cb3c1fa17f$var$B(t.Y & n.Y ^ t.Y & e.Y ^ n.Y & e.Y, t.N & n.N ^ t.N & e.N ^ n.N & e.N);
}
function $c738c9cb3c1fa17f$var$N(t) {
    const n = $c738c9cb3c1fa17f$var$M(t, 28), e = $c738c9cb3c1fa17f$var$M(t, 34), r = $c738c9cb3c1fa17f$var$M(t, 39);
    return new $c738c9cb3c1fa17f$var$B(n.Y ^ e.Y ^ r.Y, n.N ^ e.N ^ r.N);
}
function $c738c9cb3c1fa17f$var$I(t, n) {
    let e, r;
    e = (65535 & t.N) + (65535 & n.N), r = (t.N >>> 16) + (n.N >>> 16) + (e >>> 16);
    const i = (65535 & r) << 16 | 65535 & e;
    e = (65535 & t.Y) + (65535 & n.Y) + (r >>> 16), r = (t.Y >>> 16) + (n.Y >>> 16) + (e >>> 16);
    return new $c738c9cb3c1fa17f$var$B((65535 & r) << 16 | 65535 & e, i);
}
function $c738c9cb3c1fa17f$var$X(t, n, e, r) {
    let i, s;
    i = (65535 & t.N) + (65535 & n.N) + (65535 & e.N) + (65535 & r.N), s = (t.N >>> 16) + (n.N >>> 16) + (e.N >>> 16) + (r.N >>> 16) + (i >>> 16);
    const o = (65535 & s) << 16 | 65535 & i;
    i = (65535 & t.Y) + (65535 & n.Y) + (65535 & e.Y) + (65535 & r.Y) + (s >>> 16), s = (t.Y >>> 16) + (n.Y >>> 16) + (e.Y >>> 16) + (r.Y >>> 16) + (i >>> 16);
    return new $c738c9cb3c1fa17f$var$B((65535 & s) << 16 | 65535 & i, o);
}
function $c738c9cb3c1fa17f$var$z(t, n, e, r, i) {
    let s, o;
    s = (65535 & t.N) + (65535 & n.N) + (65535 & e.N) + (65535 & r.N) + (65535 & i.N), o = (t.N >>> 16) + (n.N >>> 16) + (e.N >>> 16) + (r.N >>> 16) + (i.N >>> 16) + (s >>> 16);
    const h = (65535 & o) << 16 | 65535 & s;
    s = (65535 & t.Y) + (65535 & n.Y) + (65535 & e.Y) + (65535 & r.Y) + (65535 & i.Y) + (o >>> 16), o = (t.Y >>> 16) + (n.Y >>> 16) + (e.Y >>> 16) + (r.Y >>> 16) + (i.Y >>> 16) + (s >>> 16);
    return new $c738c9cb3c1fa17f$var$B((65535 & o) << 16 | 65535 & s, h);
}
function $c738c9cb3c1fa17f$var$x(t, n) {
    return new $c738c9cb3c1fa17f$var$B(t.Y ^ n.Y, t.N ^ n.N);
}
function $c738c9cb3c1fa17f$var$_(t) {
    const n = $c738c9cb3c1fa17f$var$M(t, 19), e = $c738c9cb3c1fa17f$var$M(t, 61), r = $c738c9cb3c1fa17f$var$k(t, 6);
    return new $c738c9cb3c1fa17f$var$B(n.Y ^ e.Y ^ r.Y, n.N ^ e.N ^ r.N);
}
function $c738c9cb3c1fa17f$var$O(t) {
    const n = $c738c9cb3c1fa17f$var$M(t, 1), e = $c738c9cb3c1fa17f$var$M(t, 8), r = $c738c9cb3c1fa17f$var$k(t, 7);
    return new $c738c9cb3c1fa17f$var$B(n.Y ^ e.Y ^ r.Y, n.N ^ e.N ^ r.N);
}
function $c738c9cb3c1fa17f$var$P(t) {
    const n = $c738c9cb3c1fa17f$var$M(t, 14), e = $c738c9cb3c1fa17f$var$M(t, 18), r = $c738c9cb3c1fa17f$var$M(t, 41);
    return new $c738c9cb3c1fa17f$var$B(n.Y ^ e.Y ^ r.Y, n.N ^ e.N ^ r.N);
}
const $c738c9cb3c1fa17f$var$V = [
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[0], 3609767458),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[1], 602891725),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[2], 3964484399),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[3], 2173295548),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[4], 4081628472),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[5], 3053834265),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[6], 2937671579),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[7], 3664609560),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[8], 2734883394),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[9], 1164996542),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[10], 1323610764),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[11], 3590304994),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[12], 4068182383),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[13], 991336113),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[14], 633803317),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[15], 3479774868),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[16], 2666613458),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[17], 944711139),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[18], 2341262773),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[19], 2007800933),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[20], 1495990901),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[21], 1856431235),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[22], 3175218132),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[23], 2198950837),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[24], 3999719339),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[25], 766784016),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[26], 2566594879),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[27], 3203337956),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[28], 1034457026),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[29], 2466948901),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[30], 3758326383),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[31], 168717936),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[32], 1188179964),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[33], 1546045734),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[34], 1522805485),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[35], 2643833823),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[36], 2343527390),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[37], 1014477480),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[38], 1206759142),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[39], 344077627),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[40], 1290863460),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[41], 3158454273),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[42], 3505952657),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[43], 106217008),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[44], 3606008344),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[45], 1432725776),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[46], 1467031594),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[47], 851169720),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[48], 3100823752),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[49], 1363258195),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[50], 3750685593),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[51], 3785050280),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[52], 3318307427),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[53], 3812723403),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[54], 2003034995),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[55], 3602036899),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[56], 1575990012),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[57], 1125592928),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[58], 2716904306),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[59], 442776044),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[60], 593698344),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[61], 3733110249),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[62], 2999351573),
    new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$i[63], 3815920427),
    new $c738c9cb3c1fa17f$var$B(3391569614, 3928383900),
    new $c738c9cb3c1fa17f$var$B(3515267271, 566280711),
    new $c738c9cb3c1fa17f$var$B(3940187606, 3454069534),
    new $c738c9cb3c1fa17f$var$B(4118630271, 4000239992),
    new $c738c9cb3c1fa17f$var$B(116418474, 1914138554),
    new $c738c9cb3c1fa17f$var$B(174292421, 2731055270),
    new $c738c9cb3c1fa17f$var$B(289380356, 3203993006),
    new $c738c9cb3c1fa17f$var$B(460393269, 320620315),
    new $c738c9cb3c1fa17f$var$B(685471733, 587496836),
    new $c738c9cb3c1fa17f$var$B(852142971, 1086792851),
    new $c738c9cb3c1fa17f$var$B(1017036298, 365543100),
    new $c738c9cb3c1fa17f$var$B(1126000580, 2618297676),
    new $c738c9cb3c1fa17f$var$B(1288033470, 3409855158),
    new $c738c9cb3c1fa17f$var$B(1501505948, 4234509866),
    new $c738c9cb3c1fa17f$var$B(1607167915, 987167468),
    new $c738c9cb3c1fa17f$var$B(1816402316, 1246189591)
];
function $c738c9cb3c1fa17f$var$Z(t) {
    return "SHA-384" === t ? [
        new $c738c9cb3c1fa17f$var$B(3418070365, $c738c9cb3c1fa17f$var$s[0]),
        new $c738c9cb3c1fa17f$var$B(1654270250, $c738c9cb3c1fa17f$var$s[1]),
        new $c738c9cb3c1fa17f$var$B(2438529370, $c738c9cb3c1fa17f$var$s[2]),
        new $c738c9cb3c1fa17f$var$B(355462360, $c738c9cb3c1fa17f$var$s[3]),
        new $c738c9cb3c1fa17f$var$B(1731405415, $c738c9cb3c1fa17f$var$s[4]),
        new $c738c9cb3c1fa17f$var$B(41048885895, $c738c9cb3c1fa17f$var$s[5]),
        new $c738c9cb3c1fa17f$var$B(3675008525, $c738c9cb3c1fa17f$var$s[6]),
        new $c738c9cb3c1fa17f$var$B(1203062813, $c738c9cb3c1fa17f$var$s[7])
    ] : [
        new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$o[0], 4089235720),
        new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$o[1], 2227873595),
        new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$o[2], 4271175723),
        new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$o[3], 1595750129),
        new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$o[4], 2917565137),
        new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$o[5], 725511199),
        new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$o[6], 4215389547),
        new $c738c9cb3c1fa17f$var$B($c738c9cb3c1fa17f$var$o[7], 327033209)
    ];
}
function $c738c9cb3c1fa17f$var$j(t, n) {
    let e, r, i, s, o, h, u, w, c, f, a, l;
    const A = [];
    for(e = n[0], r = n[1], i = n[2], s = n[3], o = n[4], h = n[5], u = n[6], w = n[7], a = 0; a < 80; a += 1)a < 16 ? (l = 2 * a, A[a] = new $c738c9cb3c1fa17f$var$B(t[l], t[l + 1])) : A[a] = $c738c9cb3c1fa17f$var$X($c738c9cb3c1fa17f$var$_(A[a - 2]), A[a - 7], $c738c9cb3c1fa17f$var$O(A[a - 15]), A[a - 16]), c = $c738c9cb3c1fa17f$var$z(w, $c738c9cb3c1fa17f$var$P(o), (H = h, S = u, new $c738c9cb3c1fa17f$var$B((E = o).Y & H.Y ^ ~E.Y & S.Y, E.N & H.N ^ ~E.N & S.N)), $c738c9cb3c1fa17f$var$V[a], A[a]), f = $c738c9cb3c1fa17f$var$I($c738c9cb3c1fa17f$var$N(e), $c738c9cb3c1fa17f$var$Y(e, r, i)), w = u, u = h, h = o, o = $c738c9cb3c1fa17f$var$I(s, c), s = i, i = r, r = e, e = $c738c9cb3c1fa17f$var$I(c, f);
    var E, H, S;
    return n[0] = $c738c9cb3c1fa17f$var$I(e, n[0]), n[1] = $c738c9cb3c1fa17f$var$I(r, n[1]), n[2] = $c738c9cb3c1fa17f$var$I(i, n[2]), n[3] = $c738c9cb3c1fa17f$var$I(s, n[3]), n[4] = $c738c9cb3c1fa17f$var$I(o, n[4]), n[5] = $c738c9cb3c1fa17f$var$I(h, n[5]), n[6] = $c738c9cb3c1fa17f$var$I(u, n[6]), n[7] = $c738c9cb3c1fa17f$var$I(w, n[7]), n;
}
class $c738c9cb3c1fa17f$var$q extends $c738c9cb3c1fa17f$var$f {
    constructor(t, n, r){
        if ("SHA-384" !== t && "SHA-512" !== t) throw new Error($c738c9cb3c1fa17f$var$h);
        super(t, n, r);
        const i = r || {};
        this.T = this.k, this.L = !0, this.K = -1, this.m = $c738c9cb3c1fa17f$var$e(this.t, this.i, this.K), this.R = $c738c9cb3c1fa17f$var$j, this.g = function(t) {
            return t.slice();
        }, this.B = $c738c9cb3c1fa17f$var$Z, this.F = function(n, e, r, i) {
            return function(t, n, e, r, i) {
                let s, o;
                const h = 31 + (n + 129 >>> 10 << 5), u = n + e;
                for(; t.length <= h;)t.push(0);
                for(t[n >>> 5] |= 128 << 24 - n % 32, t[h] = 4294967295 & u, t[h - 1] = u / 4294967296 | 0, s = 0; s < t.length; s += 32)r = $c738c9cb3c1fa17f$var$j(t.slice(s, s + 32), r);
                return o = "SHA-384" === i ? [
                    r[0].Y,
                    r[0].N,
                    r[1].Y,
                    r[1].N,
                    r[2].Y,
                    r[2].N,
                    r[3].Y,
                    r[3].N,
                    r[4].Y,
                    r[4].N,
                    r[5].Y,
                    r[5].N
                ] : [
                    r[0].Y,
                    r[0].N,
                    r[1].Y,
                    r[1].N,
                    r[2].Y,
                    r[2].N,
                    r[3].Y,
                    r[3].N,
                    r[4].Y,
                    r[4].N,
                    r[5].Y,
                    r[5].N,
                    r[6].Y,
                    r[6].N,
                    r[7].Y,
                    r[7].N
                ], o;
            }(n, e, r, i, t);
        }, this.C = $c738c9cb3c1fa17f$var$Z(t), this.p = 1024, this.U = "SHA-384" === t ? 384 : 512, this.v = !1, i.hmacKey && this.M($c738c9cb3c1fa17f$var$c("hmacKey", i.hmacKey, this.K));
    }
}
const $c738c9cb3c1fa17f$var$D = [
    new $c738c9cb3c1fa17f$var$B(0, 1),
    new $c738c9cb3c1fa17f$var$B(0, 32898),
    new $c738c9cb3c1fa17f$var$B(2147483648, 32906),
    new $c738c9cb3c1fa17f$var$B(2147483648, 2147516416),
    new $c738c9cb3c1fa17f$var$B(0, 32907),
    new $c738c9cb3c1fa17f$var$B(0, 2147483649),
    new $c738c9cb3c1fa17f$var$B(2147483648, 2147516545),
    new $c738c9cb3c1fa17f$var$B(2147483648, 32777),
    new $c738c9cb3c1fa17f$var$B(0, 138),
    new $c738c9cb3c1fa17f$var$B(0, 136),
    new $c738c9cb3c1fa17f$var$B(0, 2147516425),
    new $c738c9cb3c1fa17f$var$B(0, 2147483658),
    new $c738c9cb3c1fa17f$var$B(0, 2147516555),
    new $c738c9cb3c1fa17f$var$B(2147483648, 139),
    new $c738c9cb3c1fa17f$var$B(2147483648, 32905),
    new $c738c9cb3c1fa17f$var$B(2147483648, 32771),
    new $c738c9cb3c1fa17f$var$B(2147483648, 32770),
    new $c738c9cb3c1fa17f$var$B(2147483648, 128),
    new $c738c9cb3c1fa17f$var$B(0, 32778),
    new $c738c9cb3c1fa17f$var$B(2147483648, 2147483658),
    new $c738c9cb3c1fa17f$var$B(2147483648, 2147516545),
    new $c738c9cb3c1fa17f$var$B(2147483648, 32896),
    new $c738c9cb3c1fa17f$var$B(0, 2147483649),
    new $c738c9cb3c1fa17f$var$B(2147483648, 2147516424)
], $c738c9cb3c1fa17f$var$G = [
    [
        0,
        36,
        3,
        41,
        18
    ],
    [
        1,
        44,
        10,
        45,
        2
    ],
    [
        62,
        6,
        43,
        15,
        61
    ],
    [
        28,
        55,
        25,
        21,
        56
    ],
    [
        27,
        20,
        39,
        8,
        14
    ]
];
function $c738c9cb3c1fa17f$var$J(t) {
    let n;
    const e = [];
    for(n = 0; n < 5; n += 1)e[n] = [
        new $c738c9cb3c1fa17f$var$B(0, 0),
        new $c738c9cb3c1fa17f$var$B(0, 0),
        new $c738c9cb3c1fa17f$var$B(0, 0),
        new $c738c9cb3c1fa17f$var$B(0, 0),
        new $c738c9cb3c1fa17f$var$B(0, 0)
    ];
    return e;
}
function $c738c9cb3c1fa17f$var$Q(t) {
    let n;
    const e = [];
    for(n = 0; n < 5; n += 1)e[n] = t[n].slice();
    return e;
}
function $c738c9cb3c1fa17f$var$W(t, n) {
    let e, r, i, s;
    const o = [], h = [];
    if (null !== t) for(r = 0; r < t.length; r += 2)n[(r >>> 1) % 5][(r >>> 1) / 5 | 0] = $c738c9cb3c1fa17f$var$x(n[(r >>> 1) % 5][(r >>> 1) / 5 | 0], new $c738c9cb3c1fa17f$var$B(t[r + 1], t[r]));
    for(e = 0; e < 24; e += 1){
        for(s = $c738c9cb3c1fa17f$var$J(), r = 0; r < 5; r += 1)o[r] = (u = n[r][0], w = n[r][1], c = n[r][2], f = n[r][3], a = n[r][4], new $c738c9cb3c1fa17f$var$B(u.Y ^ w.Y ^ c.Y ^ f.Y ^ a.Y, u.N ^ w.N ^ c.N ^ f.N ^ a.N));
        for(r = 0; r < 5; r += 1)h[r] = $c738c9cb3c1fa17f$var$x(o[(r + 4) % 5], $c738c9cb3c1fa17f$var$L(o[(r + 1) % 5], 1));
        for(r = 0; r < 5; r += 1)for(i = 0; i < 5; i += 1)n[r][i] = $c738c9cb3c1fa17f$var$x(n[r][i], h[r]);
        for(r = 0; r < 5; r += 1)for(i = 0; i < 5; i += 1)s[i][(2 * r + 3 * i) % 5] = $c738c9cb3c1fa17f$var$L(n[r][i], $c738c9cb3c1fa17f$var$G[r][i]);
        for(r = 0; r < 5; r += 1)for(i = 0; i < 5; i += 1)n[r][i] = $c738c9cb3c1fa17f$var$x(s[r][i], new $c738c9cb3c1fa17f$var$B(~s[(r + 1) % 5][i].Y & s[(r + 2) % 5][i].Y, ~s[(r + 1) % 5][i].N & s[(r + 2) % 5][i].N));
        n[0][0] = $c738c9cb3c1fa17f$var$x(n[0][0], $c738c9cb3c1fa17f$var$D[e]);
    }
    var u, w, c, f, a;
    return n;
}
function $c738c9cb3c1fa17f$var$$(t) {
    let n, e, r = 0;
    const i = [
        0,
        0
    ], s = [
        4294967295 & t,
        t / 4294967296 & 2097151
    ];
    for(n = 6; n >= 0; n--)e = s[n >> 2] >>> 8 * n & 255, 0 === e && 0 === r || (i[r + 1 >> 2] |= e << 8 * (r + 1), r += 1);
    return r = 0 !== r ? r : 1, i[0] |= r, {
        value: r + 1 > 4 ? i : [
            i[0]
        ],
        binLen: 8 + 8 * r
    };
}
function $c738c9cb3c1fa17f$var$tt(t) {
    return $c738c9cb3c1fa17f$var$u($c738c9cb3c1fa17f$var$$(t.binLen), t);
}
function $c738c9cb3c1fa17f$var$nt(t, n) {
    let e, r = $c738c9cb3c1fa17f$var$$(n);
    r = $c738c9cb3c1fa17f$var$u(r, t);
    const i = n >>> 2, s = (i - r.value.length % i) % i;
    for(e = 0; e < s; e++)r.value.push(0);
    return r.value;
}
class $c738c9cb3c1fa17f$var$et extends $c738c9cb3c1fa17f$var$f {
    constructor(t, n, r){
        let i = 6, s = 0;
        super(t, n, r);
        const o = r || {};
        if (1 !== this.numRounds) {
            if (o.kmacKey || o.hmacKey) throw new Error("Cannot set numRounds with MAC");
            if ("CSHAKE128" === this.s || "CSHAKE256" === this.s) throw new Error("Cannot set numRounds for CSHAKE variants");
        }
        switch(this.K = 1, this.m = $c738c9cb3c1fa17f$var$e(this.t, this.i, this.K), this.R = $c738c9cb3c1fa17f$var$W, this.g = $c738c9cb3c1fa17f$var$Q, this.B = $c738c9cb3c1fa17f$var$J, this.C = $c738c9cb3c1fa17f$var$J(), this.v = !1, t){
            case "SHA3-224":
                this.p = s = 1152, this.U = 224, this.L = !0, this.T = this.k;
                break;
            case "SHA3-256":
                this.p = s = 1088, this.U = 256, this.L = !0, this.T = this.k;
                break;
            case "SHA3-384":
                this.p = s = 832, this.U = 384, this.L = !0, this.T = this.k;
                break;
            case "SHA3-512":
                this.p = s = 576, this.U = 512, this.L = !0, this.T = this.k;
                break;
            case "SHAKE128":
                i = 31, this.p = s = 1344, this.U = -1, this.v = !0, this.L = !1, this.T = null;
                break;
            case "SHAKE256":
                i = 31, this.p = s = 1088, this.U = -1, this.v = !0, this.L = !1, this.T = null;
                break;
            case "KMAC128":
                i = 4, this.p = s = 1344, this.I(r), this.U = -1, this.v = !0, this.L = !1, this.T = this.X;
                break;
            case "KMAC256":
                i = 4, this.p = s = 1088, this.I(r), this.U = -1, this.v = !0, this.L = !1, this.T = this.X;
                break;
            case "CSHAKE128":
                this.p = s = 1344, i = this._(r), this.U = -1, this.v = !0, this.L = !1, this.T = null;
                break;
            case "CSHAKE256":
                this.p = s = 1088, i = this._(r), this.U = -1, this.v = !0, this.L = !1, this.T = null;
                break;
            default:
                throw new Error($c738c9cb3c1fa17f$var$h);
        }
        this.F = function(t, n, e, r, o) {
            return function(t, n, e, r, i, s, o) {
                let h, u, w = 0;
                const c = [], f = i >>> 5, a = n >>> 5;
                for(h = 0; h < a && n >= i; h += f)r = $c738c9cb3c1fa17f$var$W(t.slice(h, h + f), r), n -= i;
                for(t = t.slice(h), n %= i; t.length < f;)t.push(0);
                for(h = n >>> 3, t[h >> 2] ^= s << h % 4 * 8, t[f - 1] ^= 2147483648, r = $c738c9cb3c1fa17f$var$W(t, r); 32 * c.length < o && (u = r[w % 5][w / 5 | 0], c.push(u.N), !(32 * c.length >= o));)c.push(u.Y), w += 1, 0 == 64 * w % i && ($c738c9cb3c1fa17f$var$W(null, r), w = 0);
                return c;
            }(t, n, 0, r, s, i, o);
        }, o.hmacKey && this.M($c738c9cb3c1fa17f$var$c("hmacKey", o.hmacKey, this.K));
    }
    _(t, n) {
        const e = function(t) {
            const n = t || {};
            return {
                funcName: $c738c9cb3c1fa17f$var$c("funcName", n.funcName, 1, {
                    value: [],
                    binLen: 0
                }),
                customization: $c738c9cb3c1fa17f$var$c("Customization", n.customization, 1, {
                    value: [],
                    binLen: 0
                })
            };
        }(t || {});
        n && (e.funcName = n);
        const r = $c738c9cb3c1fa17f$var$u($c738c9cb3c1fa17f$var$tt(e.funcName), $c738c9cb3c1fa17f$var$tt(e.customization));
        if (0 !== e.customization.binLen || 0 !== e.funcName.binLen) {
            const t = $c738c9cb3c1fa17f$var$nt(r, this.p >>> 3);
            for(let n = 0; n < t.length; n += this.p >>> 5)this.C = this.R(t.slice(n, n + (this.p >>> 5)), this.C), this.l += this.p;
            return 4;
        }
        return 31;
    }
    I(t) {
        const n = function(t) {
            const n = t || {};
            return {
                kmacKey: $c738c9cb3c1fa17f$var$c("kmacKey", n.kmacKey, 1),
                funcName: {
                    value: [
                        1128353099
                    ],
                    binLen: 32
                },
                customization: $c738c9cb3c1fa17f$var$c("Customization", n.customization, 1, {
                    value: [],
                    binLen: 0
                })
            };
        }(t || {});
        this._(t, n.funcName);
        const e = $c738c9cb3c1fa17f$var$nt($c738c9cb3c1fa17f$var$tt(n.kmacKey), this.p >>> 3);
        for(let t = 0; t < e.length; t += this.p >>> 5)this.C = this.R(e.slice(t, t + (this.p >>> 5)), this.C), this.l += this.p;
        this.A = !0;
    }
    X(t) {
        const n = $c738c9cb3c1fa17f$var$u({
            value: this.o.slice(),
            binLen: this.h
        }, function(t) {
            let n, e, r = 0;
            const i = [
                0,
                0
            ], s = [
                4294967295 & t,
                t / 4294967296 & 2097151
            ];
            for(n = 6; n >= 0; n--)e = s[n >> 2] >>> 8 * n & 255, 0 === e && 0 === r || (i[r >> 2] |= e << 8 * r, r += 1);
            return r = 0 !== r ? r : 1, i[r >> 2] |= r << 8 * r, {
                value: r + 1 > 4 ? i : [
                    i[0]
                ],
                binLen: 8 + 8 * r
            };
        }(t.outputLen));
        return this.F(n.value, n.binLen, this.l, this.g(this.C), t.outputLen);
    }
}
class $c738c9cb3c1fa17f$export$2e2bcd8739ae039 {
    constructor(t, n, e){
        if ("SHA-1" == t) this.O = new $c738c9cb3c1fa17f$var$K(t, n, e);
        else if ("SHA-224" == t || "SHA-256" == t) this.O = new $c738c9cb3c1fa17f$var$g(t, n, e);
        else if ("SHA-384" == t || "SHA-512" == t) this.O = new $c738c9cb3c1fa17f$var$q(t, n, e);
        else {
            if ("SHA3-224" != t && "SHA3-256" != t && "SHA3-384" != t && "SHA3-512" != t && "SHAKE128" != t && "SHAKE256" != t && "CSHAKE128" != t && "CSHAKE256" != t && "KMAC128" != t && "KMAC256" != t) throw new Error($c738c9cb3c1fa17f$var$h);
            this.O = new $c738c9cb3c1fa17f$var$et(t, n, e);
        }
    }
    update(t) {
        this.O.update(t);
    }
    getHash(t, n) {
        return this.O.getHash(t, n);
    }
    setHMACKey(t, n, e) {
        this.O.setHMACKey(t, n, e);
    }
    getHMAC(t, n) {
        return this.O.getHMAC(t, n);
    }
}


function $2b2ee06118a0ba22$export$cd7ed918a1ce0ac(data) {
    if ((0, $720970adf00c6270$export$9117b72f7d656ea5)(data) || (0, $c156b569e523edc4$export$3b616d4df4414a6e)(data)) return new $2b2ee06118a0ba22$export$98f2a3543e1013d1(data);
    else if ((0, $6a6c5885a1b92eeb$export$44aa3a8a1abdb9b6)(data, [
        "sharedAccessKeyName",
        "sharedAccessKey"
    ])) return new $2b2ee06118a0ba22$export$98f2a3543e1013d1({
        name: data.sharedAccessKeyName,
        key: data.sharedAccessKey
    });
    else return new $2b2ee06118a0ba22$export$98f2a3543e1013d1({
        signature: data.sharedAccessSignature
    });
}
class $2b2ee06118a0ba22$export$98f2a3543e1013d1 {
    /**
     * Initializes a new instance of SasTokenProvider
     * @param credential - The source `NamedKeyCredential` or `SASCredential`.
     */ constructor(credential){
        this._credential = credential;
    }
    /**
     * Property used to distinguish TokenProvider from TokenCredential.
     */ get isSasTokenProvider() {
        return true;
    }
    /**
     * Gets the sas token for the specified audience
     * @param audience - The audience for which the token is desired.
     */ getToken(audience) {
        if ((0, $720970adf00c6270$export$9117b72f7d656ea5)(this._credential)) return $2b2ee06118a0ba22$var$createToken(this._credential.name, this._credential.key, Math.floor(Date.now() / 1000) + 3600, audience);
        else return {
            token: this._credential.signature,
            expiresOnTimestamp: 0
        };
    }
}
/**
 * Creates the sas token based on the provided information.
 * @param keyName - The shared access key name.
 * @param key - The shared access key.
 * @param expiry - The time period in unix time after which the token will expire.
 * @param audience - The audience for which the token is desired.
 * @internal
 */ function $2b2ee06118a0ba22$var$createToken(keyName, key, expiry, audience) {
    audience = encodeURIComponent(audience);
    keyName = encodeURIComponent(keyName);
    const stringToSign = audience + "\n" + expiry;
    const shaObj = new (0, $c738c9cb3c1fa17f$export$2e2bcd8739ae039)("SHA-256", "TEXT");
    shaObj.setHMACKey(key, "TEXT");
    shaObj.update(stringToSign);
    const sig = encodeURIComponent(shaObj.getHMAC("B64"));
    return {
        token: `SharedAccessSignature sr=${audience}&sig=${sig}&se=${expiry}&skn=${keyName}`,
        expiresOnTimestamp: expiry
    };
}


class $4b11e13556237de5$export$46493a8d2de880f8 {
    /**
     * Creates a new sasServiceClientCredentials object.
     *
     * @param credential - The NamedKeyCredential containing the key name and secret key value.
     */ constructor(credential){
        this._credential = credential;
        this._tokenProvider = (0, $2b2ee06118a0ba22$export$cd7ed918a1ce0ac)(credential);
    }
    async _generateSignature(targetUri, expirationDate) {
        const stringToSign = `${targetUri}\n${expirationDate}`;
        const result = await (0, $eb6b4b7222473d43$export$3a7728e868aa3ebd)(this._credential.key, stringToSign);
        return result;
    }
    /**
     * Signs a request with the Authentication header.
     *
     * @param request - The {@link PipelineRequest} to be signed.
     * @returns The signed request object.
     */ async signRequest(request) {
        if (!request.headers) request.headers = (0, $b376023a8674c0ff$export$4c8e967a76f3c947)();
        const targetUri = encodeURIComponent(request.url.toLowerCase()).toLowerCase();
        const date = new Date();
        date.setMinutes(date.getMinutes() + 5);
        const expirationDate = Math.round(date.getTime() / 1000);
        const signature = await this._generateSignature(targetUri, expirationDate);
        request.headers.set("authorization", `SharedAccessSignature sig=${signature}&se=${expirationDate}&skn=${this._credential.name}&sr=${targetUri}`);
        request.withCredentials = true;
        return request;
    }
    getToken(audience) {
        return this._tokenProvider.getToken(audience);
    }
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


const $10b26da869f0d653$export$fd8e54df9573b5e4 = (0, $0be52965dd582894$export$3bcb12d844328c5c)({
    namespace: "Microsoft.ServiceBus",
    packageName: (0, $8cc22362d89dbe31$export$8c36c31580f051c6).name,
    packageVersion: (0, $8cc22362d89dbe31$export$8c36c31580f051c6).version
});
function $10b26da869f0d653$export$d2129a31a8b4253f(serviceBusConfig, spanKind) {
    const spanOptions = {
        spanAttributes: {
            "message_bus.destination": serviceBusConfig.entityPath,
            "peer.address": serviceBusConfig.host
        }
    };
    if (spanKind) spanOptions.spanKind = spanKind;
    return spanOptions;
}




function $0f4ecb9a156d839d$var$signingPolicy(credentials) {
    return {
        name: "signingPolicy",
        async sendRequest (request, next) {
            const signed = await credentials.signRequest(request);
            return next(signed);
        }
    };
}
class $0f4ecb9a156d839d$export$a0e4807668b2dd72 extends (0, $2ade6bc07be65fbf$export$eca146def0f3ecb3) {
    constructor(fullyQualifiedNamespaceOrConnectionString1, credentialOrOptions2, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options3){
        var _a, _b;
        let options;
        let fullyQualifiedNamespace;
        let credentials;
        let authPolicy;
        if ((0, $5bfba789bf6c5d92$export$59ba6af2e517603a)(credentialOrOptions2)) {
            fullyQualifiedNamespace = fullyQualifiedNamespaceOrConnectionString1;
            options = options3 || {};
            credentials = credentialOrOptions2;
            authPolicy = (0, $9b145b715880113b$export$e5acbbd47d7d0b35)({
                credential: credentials,
                scopes: (0, $807770c0815ec6f8$export$a002182e51710d39).aadServiceBusScope
            });
        } else if ((0, $720970adf00c6270$export$9117b72f7d656ea5)(credentialOrOptions2)) {
            fullyQualifiedNamespace = fullyQualifiedNamespaceOrConnectionString1;
            credentials = new (0, $4b11e13556237de5$export$46493a8d2de880f8)(credentialOrOptions2);
            options = options3 || {};
            authPolicy = $0f4ecb9a156d839d$var$signingPolicy(credentials);
        } else {
            const connectionString = fullyQualifiedNamespaceOrConnectionString1;
            options = credentialOrOptions2 || {};
            const connectionStringObj = (0, $29b64d391bfe12b4$export$6369f286b474466d)(connectionString);
            if (connectionStringObj.Endpoint === undefined) throw new Error("Missing Endpoint in connection string.");
            try {
                fullyQualifiedNamespace = connectionStringObj.Endpoint.match(".*://([^/]*)")[1];
            } catch (error) {
                throw new Error("Endpoint in the connection string is not valid.");
            }
            credentials = new (0, $4b11e13556237de5$export$46493a8d2de880f8)({
                key: connectionStringObj.SharedAccessKey,
                name: connectionStringObj.SharedAccessKeyName
            });
            authPolicy = $0f4ecb9a156d839d$var$signingPolicy(credentials);
        }
        const userAgentPrefix = (0, $3402f46f0a1b2976$export$868f6999e4c7a5e7)((_a = options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix);
        const serviceClientOptions = (0, $930b2d4a108c5dd3$export$79e143a6bb5a0b5c)(Object.assign(Object.assign({}, options), {
            userAgentOptions: {
                userAgentPrefix: userAgentPrefix
            }
        }));
        serviceClientOptions.addPolicy(authPolicy);
        super({
            pipeline: serviceClientOptions
        });
        this.endpoint = fullyQualifiedNamespace;
        this.endpointWithProtocol = fullyQualifiedNamespace.endsWith("/") ? "sb://" + fullyQualifiedNamespace : "sb://" + fullyQualifiedNamespace + "/";
        this.serviceVersion = (_b = options.serviceVersion) !== null && _b !== void 0 ? _b : $8cc22362d89dbe31$export$5488f3aad090aec4;
        this.credentials = credentials;
        this.namespaceResourceSerializer = new (0, $3f68d19b3fecc479$export$5715838625fbe05c)();
        this.queueResourceSerializer = new (0, $545a8f0de2fd8008$export$dd5666c52a519943)();
        this.topicResourceSerializer = new (0, $031470a0c4fa9f0d$export$ac8a617754153f13)();
        this.subscriptionResourceSerializer = new (0, $489c9f3421be3b35$export$3eebf93f8407a63d)();
        this.ruleResourceSerializer = new (0, $02cef6d7b305ba6a$export$6f9b70b9b6ed9892)();
    }
    /**
     * Returns an object representing the metadata related to a service bus namespace.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     */ async getNamespaceProperties(// eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - getNamespaceProperties()`);
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getNamespaceProperties", operationOptions, async (updatedOptions)=>{
            const response = await this.getResource("$namespaceinfo", this.namespaceResourceSerializer, updatedOptions);
            return this.buildNamespacePropertiesResponse(response);
        });
    }
    /**
     * Creates a queue with given name, configured using the given options
     * @param options - Options to configure the Queue being created(For example, you can configure a queue to support partitions or sessions)
     *  and the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async createQueue(queueName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.createQueue", options, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - createQueue() for "${queueName}" with options: %j`, options);
            const response = await this.putResource(queueName, (0, $545a8f0de2fd8008$export$fb7a684c74e58647)(options || {}), this.queueResourceSerializer, false, updatedOptions);
            return this.buildQueueResponse(response);
        });
    }
    /**
     * Returns an object representing the Queue and its properties.
     * If you want to get the Queue runtime info like message count details, use `getQueueRuntimeProperties` API.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async getQueue(queueName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getQueue", operationOptions, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - getQueue() for "${queueName}"`);
            const response = await this.getResource(queueName, this.queueResourceSerializer, updatedOptions);
            return this.buildQueueResponse(response);
        });
    }
    /**
     * Returns an object representing the Queue runtime info like message count details.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async getQueueRuntimeProperties(queueName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getQueueRuntimeProperties", operationOptions, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - getQueueRuntimeProperties() for "${queueName}"`);
            const response = await this.getResource(queueName, this.queueResourceSerializer, updatedOptions);
            return this.buildQueueRuntimePropertiesResponse(response);
        });
    }
    /**
     * Returns a list of objects, each representing a Queue along with its properties.
     * If you want to get the runtime info of the queues like message count, use `getQueuesRuntimeProperties` API instead.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async getQueues(options = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getQueues", options, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - getQueues() with options: %j`, options);
            const response = await this.listResources("$Resources/Queues", updatedOptions, this.queueResourceSerializer);
            return this.buildListQueuesResponse(response);
        });
    }
    listQueuesPage(marker, options = {}) {
        return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* listQueuesPage_1() {
            let listResponse;
            do {
                listResponse = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(this.getQueues(Object.assign({
                    skip: Number(marker),
                    maxCount: options.maxPageSize
                }, options)));
                marker = listResponse.continuationToken;
                yield yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(listResponse);
            }while (marker);
        });
    }
    listQueuesAll(options = {}) {
        return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* listQueuesAll_1() {
            var e_1, _a;
            let marker;
            try {
                for(var _b = (0, $9187fda58d09cc70$export$e3b29a3d6162315f)(this.listQueuesPage(marker, options)), _c; _c = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_b.next()), !_c.done;){
                    const segment = _c.value;
                    yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)((yield* (0, $9187fda58d09cc70$export$bbd80228419bb833)((0, $9187fda58d09cc70$export$e3b29a3d6162315f)(segment))));
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_a.call(_b));
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list all the queues.
     *
     * .byPage() returns an async iterable iterator to list the queues in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */ listQueues(// eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - listQueues() with options: %j`, options);
        const iter = this.listQueuesAll(options);
        return {
            /**
             */ next () {
                return iter.next();
            },
            /**
             */ [Symbol.asyncIterator] () {
                return this;
            },
            /**
             */ byPage: (settings = {})=>{
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listQueuesPage(settings.continuationToken, Object.assign({
                    maxPageSize: settings.maxPageSize
                }, options));
            }
        };
    }
    /**
     * Returns a list of objects, each representing a Queue's runtime info like message count details.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async getQueuesRuntimeProperties(options = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getQueuesRuntimeProperties", options, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - getQueuesRuntimeProperties() with options: %j`, options);
            const response = await this.listResources("$Resources/Queues", updatedOptions, this.queueResourceSerializer);
            return this.buildListQueuesRuntimePropertiesResponse(response);
        });
    }
    listQueuesRuntimePropertiesPage(marker, options = {}) {
        return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* listQueuesRuntimePropertiesPage_1() {
            let listResponse;
            do {
                listResponse = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(this.getQueuesRuntimeProperties(Object.assign({
                    skip: Number(marker),
                    maxCount: options.maxPageSize
                }, options)));
                marker = listResponse.continuationToken;
                yield yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(listResponse);
            }while (marker);
        });
    }
    listQueuesRuntimePropertiesAll(options = {}) {
        return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* listQueuesRuntimePropertiesAll_1() {
            var e_2, _a;
            let marker;
            try {
                for(var _b = (0, $9187fda58d09cc70$export$e3b29a3d6162315f)(this.listQueuesRuntimePropertiesPage(marker, options)), _c; _c = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_b.next()), !_c.done;){
                    const segment = _c.value;
                    yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)((yield* (0, $9187fda58d09cc70$export$bbd80228419bb833)((0, $9187fda58d09cc70$export$e3b29a3d6162315f)(segment))));
                }
            } catch (e_2_1) {
                e_2 = {
                    error: e_2_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_a.call(_b));
                } finally{
                    if (e_2) throw e_2.error;
                }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list runtime info of the queues.
     *
     * .byPage() returns an async iterable iterator to list runtime info of the queues in pages.
     *
     *
     * @returns An asyncIterableIterator that supports paging.
     */ listQueuesRuntimeProperties(// eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - listQueuesRuntimeProperties() with options: %j`, options);
        const iter = this.listQueuesRuntimePropertiesAll(options);
        return {
            /**
             */ next () {
                return iter.next();
            },
            /**
             */ [Symbol.asyncIterator] () {
                return this;
            },
            /**
             */ byPage: (settings = {})=>{
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listQueuesRuntimePropertiesPage(settings.continuationToken, Object.assign({
                    maxPageSize: settings.maxPageSize
                }, options));
            }
        };
    }
    /**
     * Updates the queue based on the queue properties provided.
     * All queue properties must be set even though only a subset of them are actually updatable.
     * Therefore, the suggested flow is to use the output from `getQueue()`, update the desired properties in it, and then pass the modified object to `updateQueue()`.
     *
     * The properties that cannot be updated are marked as readonly in the `QueueProperties` interface.
     *
     * @param queue - Object representing the properties of the queue and the raw response.
     * `requiresSession`, `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the queue.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async updateQueue(queue, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.updateQueue", operationOptions, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - updateQueue() for "${queue.name}" with options: %j`, queue);
            if (!(0, $3402f46f0a1b2976$export$27c50b3aa4baf433)(queue) || queue == null) throw new TypeError(`Parameter "queue" must be an object of type "QueueDescription" and cannot be undefined or null.`);
            if (!queue.name) throw new TypeError(`"name" attribute of the parameter "queue" cannot be undefined.`);
            const response = await this.putResource(queue.name, (0, $545a8f0de2fd8008$export$fb7a684c74e58647)(queue), this.queueResourceSerializer, true, updatedOptions);
            return this.buildQueueResponse(response);
        });
    }
    /**
     * Deletes a queue.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async deleteQueue(queueName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.deleteQueue", operationOptions, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - deleteQueue() for "${queueName}"`);
            const response = await this.deleteResource(queueName, this.queueResourceSerializer, updatedOptions);
            return {
                _response: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            };
        });
    }
    /**
     * Checks whether a given queue exists or not.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     */ // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    async queueExists(queueName, operationOptions = {}) {
        (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - queueExists() for "${queueName}"`);
        const { span: span , updatedOptions: updatedOptions  } = (0, $10b26da869f0d653$export$fd8e54df9573b5e4).startSpan("ServiceBusAdministrationClient.queueExists", operationOptions);
        try {
            await this.getQueue(queueName, updatedOptions);
            span.setStatus({
                status: "success"
            });
            return true;
        } catch (e) {
            span.setStatus({
                status: "error",
                error: e
            });
            return false;
        } finally{
            span.end();
        }
    }
    /**
     * Creates a topic with given name, configured using the given options
     * @param options - Options to configure the Topic being created(For example, you can configure a topic to support partitions)
     * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async createTopic(topicName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.createTopic", options, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - createTopic() for "${topicName}" with options: %j`, options);
            const response = await this.putResource(topicName, (0, $031470a0c4fa9f0d$export$5f7750e59fafe835)(options || {}), this.topicResourceSerializer, false, updatedOptions);
            return this.buildTopicResponse(response);
        });
    }
    /**
     * Returns an object representing the Topic and its properties.
     * If you want to get the Topic runtime info like subscription count details, use `getTopicRuntimeProperties` API.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async getTopic(topicName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getTopic", operationOptions, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - getTopic() for "${topicName}"`);
            const response = await this.getResource(topicName, this.topicResourceSerializer, updatedOptions);
            return this.buildTopicResponse(response);
        });
    }
    /**
     * Returns an object representing the Topic runtime info like subscription count.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async getTopicRuntimeProperties(topicName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getTopicRuntimeProperties", operationOptions, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - getTopicRuntimeProperties() for "${topicName}"`);
            const response = await this.getResource(topicName, this.topicResourceSerializer, updatedOptions);
            return this.buildTopicRuntimePropertiesResponse(response);
        });
    }
    /**
     * Returns a list of objects, each representing a Topic along with its properties.
     * If you want to get the runtime info of the topics like subscription count, use `getTopicsRuntimeProperties` API instead.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async getTopics(options = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getTopics", options, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - getTopics() with options: %j`, options);
            const response = await this.listResources("$Resources/Topics", updatedOptions, this.topicResourceSerializer);
            return this.buildListTopicsResponse(response);
        });
    }
    listTopicsPage(marker, options = {}) {
        return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* listTopicsPage_1() {
            let listResponse;
            do {
                listResponse = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(this.getTopics(Object.assign({
                    skip: Number(marker),
                    maxCount: options.maxPageSize
                }, options)));
                marker = listResponse.continuationToken;
                yield yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(listResponse);
            }while (marker);
        });
    }
    listTopicsAll(options = {}) {
        return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* listTopicsAll_1() {
            var e_3, _a;
            let marker;
            try {
                for(var _b = (0, $9187fda58d09cc70$export$e3b29a3d6162315f)(this.listTopicsPage(marker, options)), _c; _c = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_b.next()), !_c.done;){
                    const segment = _c.value;
                    yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)((yield* (0, $9187fda58d09cc70$export$bbd80228419bb833)((0, $9187fda58d09cc70$export$e3b29a3d6162315f)(segment))));
                }
            } catch (e_3_1) {
                e_3 = {
                    error: e_3_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_a.call(_b));
                } finally{
                    if (e_3) throw e_3.error;
                }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list all the topics.
     *
     * .byPage() returns an async iterable iterator to list the topics in pages.
     *
     *
     * @returns An asyncIterableIterator that supports paging.
     */ listTopics(// eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - listTopics() with options: %j`, options);
        const iter = this.listTopicsAll(options);
        return {
            /**
             */ next () {
                return iter.next();
            },
            /**
             */ [Symbol.asyncIterator] () {
                return this;
            },
            /**
             */ byPage: (settings = {})=>{
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listTopicsPage(settings.continuationToken, Object.assign({
                    maxPageSize: settings.maxPageSize
                }, options));
            }
        };
    }
    /**
     * Returns a list of objects, each representing a Topic's runtime info like subscription count.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async getTopicsRuntimeProperties(options = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getTopicsRuntimeProperties", options, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - getTopicsRuntimeProperties() with options: %j`, options);
            const response = await this.listResources("$Resources/Topics", updatedOptions, this.topicResourceSerializer);
            return this.buildListTopicsRuntimePropertiesResponse(response);
        });
    }
    listTopicsRuntimePropertiesPage(marker, options = {}) {
        return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* listTopicsRuntimePropertiesPage_1() {
            let listResponse;
            do {
                listResponse = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(this.getTopicsRuntimeProperties(Object.assign({
                    skip: Number(marker),
                    maxCount: options.maxPageSize
                }, options)));
                marker = listResponse.continuationToken;
                yield yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(listResponse);
            }while (marker);
        });
    }
    listTopicsRuntimePropertiesAll(options = {}) {
        return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* listTopicsRuntimePropertiesAll_1() {
            var e_4, _a;
            let marker;
            try {
                for(var _b = (0, $9187fda58d09cc70$export$e3b29a3d6162315f)(this.listTopicsRuntimePropertiesPage(marker, options)), _c; _c = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_b.next()), !_c.done;){
                    const segment = _c.value;
                    yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)((yield* (0, $9187fda58d09cc70$export$bbd80228419bb833)((0, $9187fda58d09cc70$export$e3b29a3d6162315f)(segment))));
                }
            } catch (e_4_1) {
                e_4 = {
                    error: e_4_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_a.call(_b));
                } finally{
                    if (e_4) throw e_4.error;
                }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list runtime info of the topics.
     *
     * .byPage() returns an async iterable iterator to list runtime info of the topics in pages.
     *
     *
     * @returns An asyncIterableIterator that supports paging.
     */ listTopicsRuntimeProperties(// eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - listTopicsRuntimeProperties() with options: %j`, options);
        const iter = this.listTopicsRuntimePropertiesAll(options);
        return {
            /**
             * The next method, part of the iteration protocol
             */ next () {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */ [Symbol.asyncIterator] () {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */ byPage: (settings = {})=>{
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listTopicsRuntimePropertiesPage(settings.continuationToken, Object.assign({
                    maxPageSize: settings.maxPageSize
                }, options));
            }
        };
    }
    /**
     * Updates the topic based on the topic properties provided.
     * All topic properties must be set even though only a subset of them are actually updatable.
     * Therefore, the suggested flow is to use the output from `getTopic()`, update the desired properties in it, and then pass the modified object to `updateTopic()`.
     *
     * The properties that cannot be updated are marked as readonly in the `TopicProperties` interface.
     *
     * @param topic - Object representing the properties of the topic and the raw response.
     * `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the topic.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async updateTopic(topic, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.updateTopic", operationOptions, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - updateTopic() for "${topic.name}" with options: %j`, topic);
            if (!(0, $3402f46f0a1b2976$export$27c50b3aa4baf433)(topic) || topic == null) throw new TypeError(`Parameter "topic" must be an object of type "TopicDescription" and cannot be undefined or null.`);
            if (!topic.name) throw new TypeError(`"name" attribute of the parameter "topic" cannot be undefined.`);
            const response = await this.putResource(topic.name, (0, $031470a0c4fa9f0d$export$5f7750e59fafe835)(topic), this.topicResourceSerializer, true, updatedOptions);
            return this.buildTopicResponse(response);
        });
    }
    /**
     * Deletes a topic.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async deleteTopic(topicName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.deleteTopic", operationOptions, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - deleteTopic() for "${topicName}"`);
            const response = await this.deleteResource(topicName, this.topicResourceSerializer, updatedOptions);
            return {
                _response: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            };
        });
    }
    /**
     * Checks whether a given topic exists or not.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     */ // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    async topicExists(topicName, operationOptions) {
        (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - topicExists() for "${topicName}"`);
        const { span: span , updatedOptions: updatedOptions  } = (0, $10b26da869f0d653$export$fd8e54df9573b5e4).startSpan("ServiceBusAdministrationClient.topicExists", operationOptions);
        try {
            span.setStatus({
                status: "success"
            });
            await this.getTopic(topicName, updatedOptions);
            return true;
        } catch (e) {
            span.setStatus({
                status: "error",
                error: e
            });
            return false;
        } finally{
            span.end();
        }
    }
    /**
     * Creates a subscription with given name, configured using the given options
     * @param options - Options to configure the Subscription being created(For example, you can configure a Subscription to support partitions or sessions)
     * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async createSubscription(topicName, subscriptionName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.createSubscription", options, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - createSubscription() for "${subscriptionName}" with options: %j`, options);
            const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
            const response = await this.putResource(fullPath, (0, $489c9f3421be3b35$export$43af13797271483)(options || {}), this.subscriptionResourceSerializer, false, updatedOptions);
            return this.buildSubscriptionResponse(response);
        });
    }
    /**
     * Returns an object representing the Subscription and its properties.
     * If you want to get the Subscription runtime info like message count details, use `getSubscriptionRuntimeProperties` API.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async getSubscription(topicName, subscriptionName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getSubscription", operationOptions, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - getSubscription() for "${subscriptionName}"`);
            const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
            const response = await this.getResource(fullPath, this.subscriptionResourceSerializer, updatedOptions);
            return this.buildSubscriptionResponse(response);
        });
    }
    /**
     * Returns an object representing the Subscription runtime info like message count details.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async getSubscriptionRuntimeProperties(topicName, subscriptionName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getSubscriptionRuntimeProperties", operationOptions, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - getSubscriptionRuntimeProperties() for "${subscriptionName}"`);
            const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
            const response = await this.getResource(fullPath, this.subscriptionResourceSerializer, updatedOptions);
            return this.buildSubscriptionRuntimePropertiesResponse(response);
        });
    }
    /**
     * Returns a list of objects, each representing a Subscription along with its properties.
     * If you want to get the runtime info of the subscriptions like message count, use `getSubscriptionsRuntimeProperties` API instead.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async getSubscriptions(topicName, options = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getSubscriptions", options, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - getSubscriptions() with options: %j`, options);
            const response = await this.listResources(topicName + "/Subscriptions/", updatedOptions, this.subscriptionResourceSerializer);
            return this.buildListSubscriptionsResponse(response);
        });
    }
    listSubscriptionsPage(topicName, marker, options = {}) {
        return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* listSubscriptionsPage_1() {
            let listResponse;
            do {
                listResponse = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(this.getSubscriptions(topicName, Object.assign({
                    skip: Number(marker),
                    maxCount: options.maxPageSize
                }, options)));
                marker = listResponse.continuationToken;
                yield yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(listResponse);
            }while (marker);
        });
    }
    listSubscriptionsAll(topicName, options = {}) {
        return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* listSubscriptionsAll_1() {
            var e_5, _a;
            let marker;
            try {
                for(var _b = (0, $9187fda58d09cc70$export$e3b29a3d6162315f)(this.listSubscriptionsPage(topicName, marker, options)), _c; _c = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_b.next()), !_c.done;){
                    const segment = _c.value;
                    yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)((yield* (0, $9187fda58d09cc70$export$bbd80228419bb833)((0, $9187fda58d09cc70$export$e3b29a3d6162315f)(segment))));
                }
            } catch (e_5_1) {
                e_5 = {
                    error: e_5_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_a.call(_b));
                } finally{
                    if (e_5) throw e_5.error;
                }
            }
        });
    }
    /**
     *
     * Returns an async iterable iterator to list all the subscriptions
     * under the specified topic.
     *
     * .byPage() returns an async iterable iterator to list the subscriptions in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */ listSubscriptions(topicName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - listSubscriptions() with options: %j`, options);
        const iter = this.listSubscriptionsAll(topicName, options);
        return {
            /**
             */ next () {
                return iter.next();
            },
            /**
             */ [Symbol.asyncIterator] () {
                return this;
            },
            /**
             */ byPage: (settings = {})=>{
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listSubscriptionsPage(topicName, settings.continuationToken, Object.assign({
                    maxPageSize: settings.maxPageSize
                }, options));
            }
        };
    }
    /**
     * Returns a list of objects, each representing a Subscription's runtime info like message count details.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async getSubscriptionsRuntimeProperties(topicName, options = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getSubscriptionsRuntimeProperties", options, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - getSubscriptionsRuntimeProperties() with options: %j`, options);
            const response = await this.listResources(topicName + "/Subscriptions/", updatedOptions, this.subscriptionResourceSerializer);
            return this.buildListSubscriptionsRuntimePropertiesResponse(response);
        });
    }
    listSubscriptionsRuntimePropertiesPage(topicName, marker, options = {}) {
        return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* listSubscriptionsRuntimePropertiesPage_1() {
            let listResponse;
            do {
                listResponse = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(this.getSubscriptionsRuntimeProperties(topicName, Object.assign({
                    skip: Number(marker),
                    maxCount: options.maxPageSize
                }, options)));
                marker = listResponse.continuationToken;
                yield yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(listResponse);
            }while (marker);
        });
    }
    listSubscriptionsRuntimePropertiesAll(topicName, options = {}) {
        return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* listSubscriptionsRuntimePropertiesAll_1() {
            var e_6, _a;
            let marker;
            try {
                for(var _b = (0, $9187fda58d09cc70$export$e3b29a3d6162315f)(this.listSubscriptionsRuntimePropertiesPage(topicName, marker, options)), _c; _c = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_b.next()), !_c.done;){
                    const segment = _c.value;
                    yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)((yield* (0, $9187fda58d09cc70$export$bbd80228419bb833)((0, $9187fda58d09cc70$export$e3b29a3d6162315f)(segment))));
                }
            } catch (e_6_1) {
                e_6 = {
                    error: e_6_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_a.call(_b));
                } finally{
                    if (e_6) throw e_6.error;
                }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list runtime info of the subscriptions
     * under the specified topic.
     *
     * .byPage() returns an async iterable iterator to list runtime info of subscriptions in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */ listSubscriptionsRuntimeProperties(topicName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - listSubscriptionsRuntimeProperties() with options: %j`, options);
        const iter = this.listSubscriptionsRuntimePropertiesAll(topicName, options);
        return {
            /**
             */ next () {
                return iter.next();
            },
            /**
             */ [Symbol.asyncIterator] () {
                return this;
            },
            /**
             */ byPage: (settings = {})=>{
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listSubscriptionsRuntimePropertiesPage(topicName, settings.continuationToken, Object.assign({
                    maxPageSize: settings.maxPageSize
                }, options));
            }
        };
    }
    /**
     * Updates the subscription based on the subscription properties provided.
     * All subscription properties must be set even though only a subset of them are actually updatable.
     * Therefore, the suggested flow is to use the output from `getSubscription()`, update the desired properties in it, and then pass the modified object to `updateSubscription()`.
     *
     * The properties that cannot be updated are marked as readonly in the `SubscriptionProperties` interface.
     * @param subscription - Object representing the properties of the subscription and the raw response.
     * `subscriptionName`, `topicName`, and `requiresSession` can't be updated after creating the subscription.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async updateSubscription(subscription, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.updateSubscription", operationOptions, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - updateSubscription() for "${subscription.subscriptionName}" with options: %j`, subscription);
            if (!(0, $3402f46f0a1b2976$export$27c50b3aa4baf433)(subscription) || subscription == null) throw new TypeError(`Parameter "subscription" must be an object of type "SubscriptionDescription" and cannot be undefined or null.`);
            if (!subscription.topicName || !subscription.subscriptionName) throw new TypeError(`The attributes "topicName" and "subscriptionName" of the parameter "subscription" cannot be undefined.`);
            const fullPath = this.getSubscriptionPath(subscription.topicName, subscription.subscriptionName);
            const response = await this.putResource(fullPath, (0, $489c9f3421be3b35$export$43af13797271483)(subscription), this.subscriptionResourceSerializer, true, updatedOptions);
            return this.buildSubscriptionResponse(response);
        });
    }
    /**
     * Deletes a subscription.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async deleteSubscription(topicName, subscriptionName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.deleteSubscription", operationOptions, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - deleteSubscription() for "${subscriptionName}"`);
            const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
            const response = await this.deleteResource(fullPath, this.subscriptionResourceSerializer, updatedOptions);
            return {
                _response: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            };
        });
    }
    /**
     * Checks whether a given subscription exists in the topic or not.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     */ async subscriptionExists(topicName, subscriptionName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - subscriptionExists() for "${topicName}" and "${subscriptionName}"`);
        const { span: span , updatedOptions: updatedOptions  } = (0, $10b26da869f0d653$export$fd8e54df9573b5e4).startSpan("ServiceBusAdministrationClient.subscriptionExists", operationOptions);
        try {
            span.setStatus({
                status: "success"
            });
            await this.getSubscription(topicName, subscriptionName, updatedOptions);
            return true;
        } catch (e) {
            span.setStatus({
                status: "error",
                error: e
            });
            return false;
        } finally{
            span.end();
        }
    }
    async createRule(topicName, subscriptionName, ruleName, ruleFilter, ruleActionOrOperationOptions, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions) {
        let ruleAction = undefined;
        let operOptions;
        if (ruleActionOrOperationOptions) {
            if ((0, $02cef6d7b305ba6a$export$fe1f0ef55e4df00d)(ruleActionOrOperationOptions)) {
                // Overload#2 - where the sqlExpression in the ruleAction is defined
                ruleAction = ruleActionOrOperationOptions;
                operOptions = operationOptions;
            } else // Overload#1
            // Overload#2 - where the sqlExpression in the ruleAction is undefined
            operOptions = Object.assign(Object.assign({}, ruleActionOrOperationOptions), operationOptions);
        }
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.createRule", operOptions !== null && operOptions !== void 0 ? operOptions : {}, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - createRule() for "${ruleName}" with filter: "%j"`, ruleFilter);
            const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);
            const response = await this.putResource(fullPath, {
                name: ruleName,
                filter: ruleFilter,
                action: ruleAction
            }, this.ruleResourceSerializer, false, updatedOptions);
            return this.buildRuleResponse(response);
        });
    }
    /**
     * Returns an object representing the Rule with the given name along with all its properties.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async getRule(topicName, subscriptionName, ruleName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getRule", operationOptions, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - getRule() for "${ruleName}"`);
            const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);
            const response = await this.getResource(fullPath, this.ruleResourceSerializer, updatedOptions);
            return this.buildRuleResponse(response);
        });
    }
    /**
     * Lists existing rules.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async getRules(topicName, subscriptionName, options = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getRules", options, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - getRules() with options: %j`, options);
            const fullPath = this.getSubscriptionPath(topicName, subscriptionName) + "/Rules/";
            const response = await this.listResources(fullPath, updatedOptions, this.ruleResourceSerializer);
            return this.buildListRulesResponse(response);
        });
    }
    listRulesPage(topicName, subscriptionName, marker, options = {}) {
        return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* listRulesPage_1() {
            let listResponse;
            do {
                listResponse = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(this.getRules(topicName, subscriptionName, Object.assign({
                    skip: Number(marker),
                    maxCount: options.maxPageSize
                }, options)));
                marker = listResponse.continuationToken;
                yield yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(listResponse);
            }while (marker);
        });
    }
    listRulesAll(topicName, subscriptionName, options = {}) {
        return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* listRulesAll_1() {
            var e_7, _a;
            let marker;
            try {
                for(var _b = (0, $9187fda58d09cc70$export$e3b29a3d6162315f)(this.listRulesPage(topicName, subscriptionName, marker, options)), _c; _c = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_b.next()), !_c.done;){
                    const segment = _c.value;
                    yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)((yield* (0, $9187fda58d09cc70$export$bbd80228419bb833)((0, $9187fda58d09cc70$export$e3b29a3d6162315f)(segment))));
                }
            } catch (e_7_1) {
                e_7 = {
                    error: e_7_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_a.call(_b));
                } finally{
                    if (e_7) throw e_7.error;
                }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list all the rules
     * under the specified subscription.
     *
     * .byPage() returns an async iterable iterator to list the rules in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */ listRules(topicName, subscriptionName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - listRules() with options: %j`, options);
        const iter = this.listRulesAll(topicName, subscriptionName, options);
        return {
            /**
             */ next () {
                return iter.next();
            },
            /**
             */ [Symbol.asyncIterator] () {
                return this;
            },
            /**
             */ byPage: (settings = {})=>{
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listRulesPage(topicName, subscriptionName, settings.continuationToken, Object.assign({
                    maxPageSize: settings.maxPageSize
                }, options));
            }
        };
    }
    /**
     * Updates properties on the Rule by the given name based on the given options.
     * All rule properties must be set even if one of them is being updated.
     * Therefore, the suggested flow is to use the output from `getRule()`, update the desired properties in it, and then pass the modified object to `updateRule()`.
     *
     * @param rule - Options to configure the Rule being updated and the raw response.
     * For example, you can configure the filter to apply on associated Topic/Subscription.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async updateRule(topicName, subscriptionName, rule, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.updateRule", operationOptions !== null && operationOptions !== void 0 ? operationOptions : {}, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - updateRule() for "${rule.name}" with options: %j`, rule);
            if (!(0, $3402f46f0a1b2976$export$27c50b3aa4baf433)(rule) || rule === null) throw new TypeError(`Parameter "rule" must be an object of type "RuleDescription" and cannot be undefined or null.`);
            if (!rule.name) throw new TypeError(`"name" attribute of the parameter "rule" cannot be undefined.`);
            const fullPath = this.getRulePath(topicName, subscriptionName, rule.name);
            const response = await this.putResource(fullPath, rule, this.ruleResourceSerializer, true, updatedOptions);
            return this.buildRuleResponse(response);
        });
    }
    /**
     * Deletes a rule.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */ async deleteRule(topicName, subscriptionName, ruleName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.deleteRule", operationOptions !== null && operationOptions !== void 0 ? operationOptions : {}, async (updatedOptions)=>{
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - deleteRule() for "${ruleName}"`);
            const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);
            const response = await this.deleteResource(fullPath, this.ruleResourceSerializer, updatedOptions);
            return {
                _response: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            };
        });
    }
    /**
     * Checks whether a given rule exists or not.
     *
     */ async ruleExists(topicName, subscriptionName, ruleName, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).verbose(`Performing management operation - ruleExists() for "${ruleName}"`);
        const { span: span , updatedOptions: updatedOptions  } = (0, $10b26da869f0d653$export$fd8e54df9573b5e4).startSpan("ServiceBusAdministrationClient.ruleExists", operationOptions);
        try {
            span.setStatus({
                status: "success"
            });
            await this.getRule(topicName, subscriptionName, ruleName, updatedOptions);
            return true;
        } catch (e) {
            span.setStatus({
                status: "error",
                error: e
            });
            return false;
        } finally{
            span.end();
        }
    }
    /**
     * Creates or updates a resource based on `isUpdate` parameter.
     */ async putResource(name, entityFields, serializer, isUpdate = false, operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.putResource", operationOptions, async (updatedOptions)=>{
            const request = (0, $02e45365db79d766$export$7a9cd74b232af14e)({
                url: this.getUrl(name),
                method: "PUT"
            });
            if (isUpdate) request.headers.set("If-Match", "*");
            const queueOrSubscriptionFields = entityFields;
            if (queueOrSubscriptionFields.ForwardTo || queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo) {
                const token = this.credentials instanceof (0, $4b11e13556237de5$export$46493a8d2de880f8) ? this.credentials.getToken(this.endpoint).token : (await this.credentials.getToken([
                    (0, $807770c0815ec6f8$export$a002182e51710d39).aadServiceBusScope
                ])).token;
                if (queueOrSubscriptionFields.ForwardTo) {
                    request.headers.set("ServiceBusSupplementaryAuthorization", token);
                    if (!(0, $3402f46f0a1b2976$export$a1cbf2de32a9fd1)(queueOrSubscriptionFields.ForwardTo)) queueOrSubscriptionFields.ForwardTo = this.endpointWithProtocol.concat(queueOrSubscriptionFields.ForwardTo);
                }
                if (queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo) {
                    request.headers.set("ServiceBusDlqSupplementaryAuthorization", token);
                    if (!(0, $3402f46f0a1b2976$export$a1cbf2de32a9fd1)(queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo)) queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo = this.endpointWithProtocol.concat(queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo);
                }
            }
            request.headers.set("content-type", "application/atom+xml;type=entry;charset=utf-8");
            return (0, $bf0a38f921c857f0$export$66322938018968c)(this, request, serializer, updatedOptions, entityFields);
        });
    }
    /**
     * Gets a resource.
     */ async getResource(name, serializer, operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.getResource", operationOptions, async (updatedOptions)=>{
            const request = (0, $02e45365db79d766$export$7a9cd74b232af14e)({
                url: this.getUrl(name),
                method: "GET"
            });
            const response = await (0, $bf0a38f921c857f0$export$66322938018968c)(this, request, serializer, updatedOptions);
            if (!(0, $a7961d970a7496cb$export$4e62c701997796c1)(response.parsedBody) || Array.isArray(response.parsedBody) && response.parsedBody.length === 0) {
                const err = new (0, $193c259516f52386$export$dc24566375af80f3)(`The messaging entity "${name}" being requested cannot be found.`, {
                    code: "MessageEntityNotFoundError",
                    statusCode: response.status,
                    request: request,
                    response: response
                });
                throw err;
            }
            return response;
        });
    }
    /**
     * Lists existing resources
     */ async listResources(name, options = {}, serializer) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.listResources", options, async (updatedOptions)=>{
            const queryParams = {};
            if (options) {
                if (options.skip) queryParams["$skip"] = options.skip.toString();
                if (options.maxCount) queryParams["$top"] = options.maxCount.toString();
            }
            const request = (0, $02e45365db79d766$export$7a9cd74b232af14e)({
                url: this.getUrl(name, queryParams),
                method: "GET"
            });
            return (0, $bf0a38f921c857f0$export$66322938018968c)(this, request, serializer, updatedOptions);
        });
    }
    /**
     * Deletes a resource.
     */ async deleteResource(name, serializer, operationOptions = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusAdministrationClient.deleteResource", operationOptions, async (updatedOptions)=>{
            const request = (0, $02e45365db79d766$export$7a9cd74b232af14e)({
                url: this.getUrl(name),
                method: "DELETE"
            });
            return (0, $bf0a38f921c857f0$export$66322938018968c)(this, request, serializer, updatedOptions);
        });
    }
    getUrl(path, queryParams) {
        const baseUri = `https://${this.endpoint}/${path}`;
        const requestUrl = new URL(baseUri);
        requestUrl.searchParams.set($8cc22362d89dbe31$export$dc61c0db22c9ffdc, this.serviceVersion);
        if (queryParams) for (const key of Object.keys(queryParams))requestUrl.searchParams.set(key, queryParams[key]);
        return requestUrl.toString();
    }
    getSubscriptionPath(topicName, subscriptionName) {
        return topicName + "/Subscriptions/" + subscriptionName;
    }
    getRulePath(topicName, subscriptionName, ruleName) {
        return topicName + "/Subscriptions/" + subscriptionName + "/Rules/" + ruleName;
    }
    getMarkerFromNextLinkUrl(url) {
        if (!url) return undefined;
        try {
            const value = (0, $589aa7cc5ed318ce$export$4b3d9a5bae55976)(url).searchParams.get($8cc22362d89dbe31$export$8b009e1e43cec8e0 + "skip");
            return value !== null ? value : undefined;
        } catch (error) {
            throw new Error(`Unable to parse the '${$8cc22362d89dbe31$export$8b009e1e43cec8e0}skip' from the next-link in the response ` + error);
        }
    }
    buildNamespacePropertiesResponse(response) {
        try {
            const namespace = (0, $3f68d19b3fecc479$export$cd489e29c3f9bf7)(response.parsedBody);
            const namespaceResponse = Object.defineProperty(namespace || {}, "_response", {
                value: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            });
            return namespaceResponse;
        } catch (err) {
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Failure parsing response from service");
            throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - cannot form a namespace object using the response from the service.`, {
                code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response: response
            });
        }
    }
    buildListQueuesResponse(response) {
        try {
            const queues = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            const rawQueueArray = response.parsedBody;
            for(let i = 0; i < rawQueueArray.length; i++){
                const queue = (0, $545a8f0de2fd8008$export$129ff0b29bedf14f)(rawQueueArray[i]);
                if (queue) queues.push(queue);
            }
            const listQueuesResponse = Object.defineProperty(queues, "_response", {
                value: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            });
            listQueuesResponse.continuationToken = nextMarker;
            return listQueuesResponse;
        } catch (err) {
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Failure parsing response from service");
            throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - cannot form a list of queues using the response from the service.`, {
                code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response: response
            });
        }
    }
    buildListQueuesRuntimePropertiesResponse(response) {
        try {
            const queues = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            const rawQueueArray = response.parsedBody;
            for(let i = 0; i < rawQueueArray.length; i++){
                const queue = (0, $545a8f0de2fd8008$export$caec8e35e4815432)(rawQueueArray[i]);
                if (queue) queues.push(queue);
            }
            const listQueuesResponse = Object.defineProperty(queues, "_response", {
                value: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            });
            listQueuesResponse.continuationToken = nextMarker;
            return listQueuesResponse;
        } catch (err) {
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Failure parsing response from service");
            throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - cannot form a list of queues using the response from the service.`, {
                code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response: response
            });
        }
    }
    buildQueueResponse(response) {
        try {
            const queue = (0, $545a8f0de2fd8008$export$129ff0b29bedf14f)(response.parsedBody);
            const queueResponse = Object.defineProperty(queue || {}, "_response", {
                value: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            });
            return queueResponse;
        } catch (err) {
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Failure parsing response from service");
            throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - cannot form a queue object using the response from the service.`, {
                code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response: response
            });
        }
    }
    buildQueueRuntimePropertiesResponse(response) {
        try {
            const queue = (0, $545a8f0de2fd8008$export$caec8e35e4815432)(response.parsedBody);
            const queueResponse = Object.defineProperty(queue || {}, "_response", {
                value: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            });
            return queueResponse;
        } catch (err) {
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Failure parsing response from service");
            throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - cannot form a queue object using the response from the service.`, {
                code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response: response
            });
        }
    }
    buildListTopicsResponse(response) {
        try {
            const topics = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            const rawTopicArray = response.parsedBody;
            for(let i = 0; i < rawTopicArray.length; i++){
                const topic = (0, $031470a0c4fa9f0d$export$438f66a38b1d6272)(rawTopicArray[i]);
                if (topic) topics.push(topic);
            }
            const listTopicsResponse = Object.defineProperty(topics, "_response", {
                value: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            });
            listTopicsResponse.continuationToken = nextMarker;
            return listTopicsResponse;
        } catch (err) {
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Failure parsing response from service");
            throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - cannot form a list of topics using the response from the service.`, {
                code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response: response
            });
        }
    }
    buildListTopicsRuntimePropertiesResponse(response) {
        try {
            const topics = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            const rawTopicArray = response.parsedBody;
            for(let i = 0; i < rawTopicArray.length; i++){
                const topic = (0, $031470a0c4fa9f0d$export$883fa8c9f5d006f7)(rawTopicArray[i]);
                if (topic) topics.push(topic);
            }
            const listTopicsResponse = Object.defineProperty(topics, "_response", {
                value: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            });
            listTopicsResponse.continuationToken = nextMarker;
            return listTopicsResponse;
        } catch (err) {
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Failure parsing response from service");
            throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - cannot form a list of topics using the response from the service.`, {
                code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response: response
            });
        }
    }
    buildTopicResponse(response) {
        try {
            const topic = (0, $031470a0c4fa9f0d$export$438f66a38b1d6272)(response.parsedBody);
            const topicResponse = Object.defineProperty(topic || {}, "_response", {
                value: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            });
            return topicResponse;
        } catch (err) {
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Failure parsing response from service");
            throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - cannot form a topic object using the response from the service.`, {
                code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response: response
            });
        }
    }
    buildTopicRuntimePropertiesResponse(response) {
        try {
            const topic = (0, $031470a0c4fa9f0d$export$883fa8c9f5d006f7)(response.parsedBody);
            const topicResponse = Object.defineProperty(topic || {}, "_response", {
                value: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            });
            return topicResponse;
        } catch (err) {
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Failure parsing response from service");
            throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - cannot form a topic object using the response from the service.`, {
                code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response: response
            });
        }
    }
    buildListSubscriptionsResponse(response) {
        try {
            const subscriptions = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            const rawSubscriptionArray = response.parsedBody;
            for(let i = 0; i < rawSubscriptionArray.length; i++){
                const subscription = (0, $489c9f3421be3b35$export$84aa05677b8355d)(rawSubscriptionArray[i]);
                if (subscription) subscriptions.push(subscription);
            }
            const listSubscriptionsResponse = Object.defineProperty(subscriptions, "_response", {
                value: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            });
            listSubscriptionsResponse.continuationToken = nextMarker;
            return listSubscriptionsResponse;
        } catch (err) {
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Failure parsing response from service");
            throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - cannot form a list of subscriptions using the response from the service.`, {
                code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response: response
            });
        }
    }
    buildListSubscriptionsRuntimePropertiesResponse(response) {
        try {
            const subscriptions = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            const rawSubscriptionArray = response.parsedBody;
            for(let i = 0; i < rawSubscriptionArray.length; i++){
                const subscription = (0, $489c9f3421be3b35$export$37852aadde5460a2)(rawSubscriptionArray[i]);
                if (subscription) subscriptions.push(subscription);
            }
            const listSubscriptionsResponse = Object.defineProperty(subscriptions, "_response", {
                value: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            });
            listSubscriptionsResponse.continuationToken = nextMarker;
            return listSubscriptionsResponse;
        } catch (err) {
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Failure parsing response from service");
            throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - cannot form a list of subscriptions using the response from the service.`, {
                code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response: response
            });
        }
    }
    buildSubscriptionResponse(response) {
        try {
            const subscription = (0, $489c9f3421be3b35$export$84aa05677b8355d)(response.parsedBody);
            const subscriptionResponse = Object.defineProperty(subscription || {}, "_response", {
                value: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            });
            return subscriptionResponse;
        } catch (err) {
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Failure parsing response from service");
            throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - cannot form a subscription object using the response from the service.`, {
                code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response: response
            });
        }
    }
    buildSubscriptionRuntimePropertiesResponse(response) {
        try {
            const subscription = (0, $489c9f3421be3b35$export$37852aadde5460a2)(response.parsedBody);
            const subscriptionResponse = Object.defineProperty(subscription || {}, "_response", {
                value: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            });
            return subscriptionResponse;
        } catch (err) {
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Failure parsing response from service");
            throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - cannot form a subscription object using the response from the service.`, {
                code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response: response
            });
        }
    }
    buildListRulesResponse(response) {
        try {
            const rules = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            const rawRuleArray = response.parsedBody;
            for(let i = 0; i < rawRuleArray.length; i++){
                const rule = (0, $02cef6d7b305ba6a$export$8938027f2b62a6b4)(rawRuleArray[i]);
                if (rule) rules.push(rule);
            }
            const listRulesResponse = Object.defineProperty(rules, "_response", {
                value: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            });
            listRulesResponse.continuationToken = nextMarker;
            return listRulesResponse;
        } catch (err) {
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Failure parsing response from service");
            throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - cannot form a list of rules using the response from the service.`, {
                code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response: response
            });
        }
    }
    buildRuleResponse(response) {
        try {
            const rule = (0, $02cef6d7b305ba6a$export$8938027f2b62a6b4)(response.parsedBody);
            const ruleResponse = Object.defineProperty(rule || {}, "_response", {
                value: (0, $3402f46f0a1b2976$export$79c999c4b055cb73)(response)
            });
            return ruleResponse;
        } catch (err) {
            (0, $f014dc9d393cdf62$export$ad4beb6ef0944731).logError(err, "Failure parsing response from service");
            throw new (0, $193c259516f52386$export$dc24566375af80f3)(`Error occurred while parsing the response body - cannot form a rule object using the response from the service.`, {
                code: (0, $193c259516f52386$export$dc24566375af80f3).PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response: response
            });
        }
    }
    throwIfInvalidContinuationToken(token) {
        if (!(token === undefined || typeof token === "string" && Number(token) >= 0)) throw new Error(`Invalid continuationToken ${token} provided`);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


const $12a9a1e1ce930860$export$33fc4efe54a49ad2 = {
    /**
     * Creates the connection config.
     * @param connectionString - The connection string for a given service like
     * EventHub/ServiceBus.
     * @param path - The name/path of the entity (hub name) to which the
     * connection needs to happen. This will override the EntityPath in the connectionString
     * if present.
     * @returns ConnectionConfig
     */ create (connectionString, path) {
        connectionString = String(connectionString);
        const parsedCS = (0, $29b64d391bfe12b4$export$6369f286b474466d)(connectionString);
        if (!parsedCS.Endpoint) throw new TypeError("Missing Endpoint in Connection String.");
        if (!parsedCS.Endpoint.endsWith("/")) parsedCS.Endpoint += "/";
        const result = {
            connectionString: connectionString,
            endpoint: parsedCS.Endpoint,
            host: parsedCS && parsedCS.Endpoint ? (parsedCS.Endpoint.match(".*://([^/]*)") || [])[1] : "",
            sharedAccessKeyName: parsedCS.SharedAccessKeyName,
            sharedAccessKey: parsedCS.SharedAccessKey
        };
        if (path || parsedCS.EntityPath) result.entityPath = path || parsedCS.EntityPath;
        return result;
    },
    /**
     * Validates the properties of connection config.
     * @param config - The connection config to be validated.
     * @returns void
     */ validate (config, options) {
        if (!options) options = {};
        if (!config) throw new TypeError("Missing configuration");
        if (!config.endpoint) throw new TypeError("Missing 'endpoint' in configuration");
        config.endpoint = String(config.endpoint);
        if (!config.host) throw new TypeError("Missing 'host' in configuration");
        config.host = String(config.host);
        if (options.isEntityPathRequired && !config.entityPath) throw new TypeError("Missing 'entityPath' in configuration");
        if ((0, $6a6c5885a1b92eeb$export$4e62c701997796c1)(config.entityPath)) config.entityPath = String(config.entityPath);
        if (!$12a9a1e1ce930860$export$645fcdce3768c2b0(config.connectionString)) {
            if (!config.sharedAccessKeyName) throw new TypeError("Missing 'sharedAccessKeyName' in configuration");
            config.sharedAccessKeyName = String(config.sharedAccessKeyName);
            if (!config.sharedAccessKey) throw new TypeError("Missing 'sharedAccessKey' in configuration");
            config.sharedAccessKey = String(config.sharedAccessKey);
        }
    }
};
function $12a9a1e1ce930860$export$645fcdce3768c2b0(connectionString) {
    return connectionString.match(/;{0,1}SharedAccessSignature=SharedAccessSignature /) != null;
}



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Returns information about the platform this function is being run on.
 * @internal
 */ function $941eab4392ee683a$export$118dbd5caa5fd507() {
    return `(javascript-Browser-${$941eab4392ee683a$var$getReleaseInfo()})`;
}
function $941eab4392ee683a$export$e7f4e58606fa2954() {
    return `Browser/${$941eab4392ee683a$var$getReleaseInfo()}`;
}
/**
 * @internal
 *
 * @returns
 */ function $941eab4392ee683a$var$getReleaseInfo() {
    if (typeof self === "undefined") return "";
    const navigator = self.navigator;
    return navigator.appVersion;
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.




// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint-disable eqeqeq */ 


var $3d84b7093289460f$export$f5b3ec7c2de0d019;
(function(ConditionStatusMapper) {
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:timeout"] = 408] = "com.microsoft:timeout";
    ConditionStatusMapper[ConditionStatusMapper["amqp:not-found"] = 404] = "amqp:not-found";
    ConditionStatusMapper[ConditionStatusMapper["amqp:not-implemented"] = 501] = "amqp:not-implemented";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:entity-already-exists"] = 409] = "com.microsoft:entity-already-exists";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:message-lock-lost"] = 410] = "com.microsoft:message-lock-lost";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:session-lock-lost"] = 410] = "com.microsoft:session-lock-lost";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:no-matching-subscription"] = 500] = "com.microsoft:no-matching-subscription";
    ConditionStatusMapper[ConditionStatusMapper["amqp:link:message-size-exceeded"] = 403] = "amqp:link:message-size-exceeded";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:server-busy"] = 503] = "com.microsoft:server-busy";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:argument-error"] = 400] = "com.microsoft:argument-error";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:argument-out-of-range"] = 400] = "com.microsoft:argument-out-of-range";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:store-lock-lost"] = 410] = "com.microsoft:store-lock-lost";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:session-cannot-be-locked"] = 410] = "com.microsoft:session-cannot-be-locked";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:partition-not-owned"] = 410] = "com.microsoft:partition-not-owned";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:entity-disabled"] = 400] = "com.microsoft:entity-disabled";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:publisher-revoked"] = 401] = "com.microsoft:publisher-revoked";
    ConditionStatusMapper[ConditionStatusMapper["amqp:link:stolen"] = 410] = "amqp:link:stolen";
    ConditionStatusMapper[ConditionStatusMapper["amqp:not-allowed"] = 400] = "amqp:not-allowed";
    ConditionStatusMapper[ConditionStatusMapper["amqp:unauthorized-access"] = 401] = "amqp:unauthorized-access";
    ConditionStatusMapper[ConditionStatusMapper["amqp:resource-limit-exceeded"] = 403] = "amqp:resource-limit-exceeded";
})($3d84b7093289460f$export$f5b3ec7c2de0d019 || ($3d84b7093289460f$export$f5b3ec7c2de0d019 = {}));
var $3d84b7093289460f$export$b65b7fa0413f4b3d;
(function(ConditionErrorNameMapper) {
    /**
     * Error is thrown when the address is already in use.
     */ ConditionErrorNameMapper["com.microsoft:address-already-in-use"] = "AddressAlreadyInUseError";
    /**
     * Error is thrown when the store lock is lost.
     */ ConditionErrorNameMapper["com.microsoft:store-lock-lost"] = "StoreLockLostError";
    /**
     * Error is thrown when a matching subscription is not found.
     */ ConditionErrorNameMapper["com.microsoft:no-matching-subscription"] = "NoMatchingSubscriptionError";
    /**
     * Error is thrown when an attempt is made to access a partition that is not owned by the
     * requesting entity.
     */ ConditionErrorNameMapper["com.microsoft:partition-not-owned"] = "PartitionNotOwnedError";
    /**
     * Error is thrown when access to publisher has been revoked.
     */ ConditionErrorNameMapper["com.microsoft:publisher-revoked"] = "PublisherRevokedError";
    /**
     * Error is thrown when an attempt is made to create an entity that already exists.
     */ ConditionErrorNameMapper["com.microsoft:entity-already-exists"] = "MessagingEntityAlreadyExistsError";
    /**
     * Error is thrown when trying to access/connect to a disabled messaging entity.
     */ ConditionErrorNameMapper["com.microsoft:entity-disabled"] = "MessagingEntityDisabledError";
    /**
     * Error is thrown when the lock on the message is lost.
     */ ConditionErrorNameMapper["com.microsoft:message-lock-lost"] = "MessageLockLostError";
    /**
     * Error is thrown when the lock on the Azure ServiceBus session is lost.
     */ ConditionErrorNameMapper["com.microsoft:session-lock-lost"] = "SessionLockLostError";
    /**
     * Error is thrown when the Azure ServiceBus session cannot be locked.
     */ ConditionErrorNameMapper["com.microsoft:session-cannot-be-locked"] = "SessionCannotBeLockedError";
    /**
     * Error is thrown when an internal server error occurred. You may have found a bug?
     */ ConditionErrorNameMapper["amqp:internal-error"] = "InternalServerError";
    /**
     * Error for signaling general communication errors related to messaging operations.
     */ ConditionErrorNameMapper["amqp:not-found"] = "ServiceCommunicationError";
    /**
     * Error is thrown when the message is not found.
     */ ConditionErrorNameMapper["com.microsoft:message-not-found"] = "MessageNotFoundError";
    /**
     * Error is thrown when relay is not found.
     */ ConditionErrorNameMapper["com.microsoft:relay-not-found"] = "RelayNotFoundError";
    /**
     * Error is thrown when a feature is not implemented yet but the placeholder is present.
     */ ConditionErrorNameMapper["amqp:not-implemented"] = "NotImplementedError";
    /**
     * Error is thrown when an operation is attempted but is not allowed.
     */ ConditionErrorNameMapper["amqp:not-allowed"] = "InvalidOperationError";
    /**
     * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
     * Quotas are reset periodically, this operation will have to wait until then.
     * The messaging entity has reached its maximum allowable size.
     * This can happen if the maximum number of receivers (which is 5) has already
     * been opened on a per-consumer group level.
     */ ConditionErrorNameMapper["amqp:resource-limit-exceeded"] = "QuotaExceededError";
    /**
     * Error is thrown when the connection parameters are wrong and the server refused the connection.
     */ ConditionErrorNameMapper["amqp:unauthorized-access"] = "UnauthorizedError";
    /**
     * Error is thrown when the connection parameters are wrong and the server refused the connection.
     */ ConditionErrorNameMapper["com.microsoft:auth-failed"] = "UnauthorizedError";
    /**
     * Error is thrown when the service is unavailable. The operation should be retried.
     */ ConditionErrorNameMapper["com.microsoft:timeout"] = "ServiceUnavailableError";
    /**
     * Error is thrown when no new messages are received for the specified time.
     */ ConditionErrorNameMapper["com.microsoft:message-wait-timeout"] = "MessageWaitTimeout";
    /**
     * Error is thrown when an argument has a value that is out of the admissible range.
     */ ConditionErrorNameMapper["com.microsoft:argument-out-of-range"] = "ArgumentOutOfRangeError";
    /**
     * Error is thrown when a condition that should have been met in order to execute an operation was not.
     */ ConditionErrorNameMapper["amqp:precondition-failed"] = "PreconditionFailedError";
    /**
     * Error is thrown when a condition that should have been met in order to execute an operation was not.
     */ ConditionErrorNameMapper["com.microsoft:precondition-failed"] = "PreconditionFailedError";
    /**
     * Error is thrown when data could not be decoded.
     */ ConditionErrorNameMapper["amqp:decode-error"] = "DecodeError";
    /**
     * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
     */ ConditionErrorNameMapper["amqp:invalid-field"] = "InvalidFieldError";
    /**
     * Error is thrown when the client attempted to work with a server entity to which it
     * has no access because another client is working with it.
     */ ConditionErrorNameMapper["amqp:resource-locked"] = "ResourceLockedError";
    /**
     * Error is thrown when a server entity the client is working with has been deleted.
     */ ConditionErrorNameMapper["amqp:resource-deleted"] = "ResourceDeletedError";
    /**
     * Error is thrown when the peer sent a frame that is not permitted in the current state.
     */ ConditionErrorNameMapper["amqp:illegal-state"] = "IllegalStateError";
    /**
     * Error is thrown when the peer cannot send a frame because the smallest encoding of
     * the performative with the currently valid values would be too large to fit within
     * a frame of the agreed maximum frame size.
     */ ConditionErrorNameMapper["amqp:frame-size-too-small"] = "FrameSizeTooSmallError";
    /**
     * Error is thrown when an operator intervened to detach for some reason.
     */ ConditionErrorNameMapper["amqp:link:detach-forced"] = "DetachForcedError";
    /**
     * Error is thrown when the peer sent more message transfers than currently allowed on the link.
     */ ConditionErrorNameMapper["amqp:link:transfer-limit-exceeded"] = "TransferLimitExceededError";
    /**
     * Error is thrown when the message sent is too large: the maximum size is 256Kb.
     */ ConditionErrorNameMapper["amqp:link:message-size-exceeded"] = "MessageTooLargeError";
    /**
     * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
     */ ConditionErrorNameMapper["amqp:link:redirect"] = "LinkRedirectError";
    /**
     * Error is thrown when two or more instances connect to the same partition
     * with different epoch values.
     */ ConditionErrorNameMapper["amqp:link:stolen"] = "ReceiverDisconnectedError";
    /**
     * Error is thrown when the peer violated incoming window for the session.
     */ ConditionErrorNameMapper["amqp:session:window-violation"] = "SessionWindowViolationError";
    /**
     * Error is thrown when input was received for a link that was detached with an error.
     */ ConditionErrorNameMapper["amqp:session:errant-link"] = "ErrantLinkError";
    /**
     * Error is thrown when an attach was received using a handle that is already in use for an attached link.
     */ ConditionErrorNameMapper["amqp:session:handle-in-use"] = "HandleInUseError";
    /**
     * Error is thrown when a frame (other than attach) was received referencing a handle which is not
     * currently in use of an attached link.
     */ ConditionErrorNameMapper["amqp:session:unattached-handle"] = "UnattachedHandleError";
    /**
     * Error is thrown when an operator intervened to close the connection for some reason.
     */ ConditionErrorNameMapper["amqp:connection:forced"] = "ConnectionForcedError";
    /**
     * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
     */ ConditionErrorNameMapper["amqp:connection:framing-error"] = "FramingError";
    /**
     * Error is thrown when the container is no longer available on the current connection.
     */ ConditionErrorNameMapper["amqp:connection:redirect"] = "ConnectionRedirectError";
    /**
     * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
     */ ConditionErrorNameMapper["com.microsoft:server-busy"] = "ServerBusyError";
    /**
     * Error is thrown when an incorrect argument was received.
     */ ConditionErrorNameMapper["com.microsoft:argument-error"] = "ArgumentError";
    /**
     * Error is thrown when server cancels the operation due to an internal issue.
     */ ConditionErrorNameMapper["com.microsoft:operation-cancelled"] = "OperationCancelledError";
    /**
     * Error is thrown when the client sender does not have enough link credits to send the message.
     */ ConditionErrorNameMapper["client.sender:not-enough-link-credit"] = "SenderBusyError";
    /**
     * Error is thrown when a low level system error is thrown by node.js.
     * {@link https://nodejs.org/dist/latest-v8.x/docs/api/all.html#errors_class_system_error}
     */ ConditionErrorNameMapper["system:error"] = "SystemError";
})($3d84b7093289460f$export$b65b7fa0413f4b3d || ($3d84b7093289460f$export$b65b7fa0413f4b3d = {}));
var $3d84b7093289460f$export$65de4560c7cb6642;
(function(ErrorNameConditionMapper) {
    /**
     * Error is thrown when the address is already in use.
     */ ErrorNameConditionMapper["AddressAlreadyInUseError"] = "com.microsoft:address-already-in-use";
    /**
     * Error is thrown when the store lock is lost.
     */ ErrorNameConditionMapper["StoreLockLostError"] = "com.microsoft:store-lock-lost";
    /**
     * Error is thrown when a matching subscription is not found.
     */ ErrorNameConditionMapper["NoMatchingSubscriptionError"] = "com.microsoft:no-matching-subscription";
    /**
     * Error is thrown when an attempt is made to access a partition that is not owned by the
     * requesting entity.
     */ ErrorNameConditionMapper["PartitionNotOwnedError"] = "com.microsoft:partition-not-owned";
    /**
     * Error is thrown when access to publisher has been revoked.
     */ ErrorNameConditionMapper["PublisherRevokedError"] = "com.microsoft:publisher-revoked";
    /**
     * Error is thrown when an attempt is made to create an entity that already exists.
     */ ErrorNameConditionMapper["MessagingEntityAlreadyExistsError"] = "com.microsoft:entity-already-exists";
    /**
     * Error is thrown when trying to access/connect to a disabled messaging entity.
     */ ErrorNameConditionMapper["MessagingEntityDisabledError"] = "com.microsoft:entity-disabled";
    /**
     * Error is thrown when the lock on the message is lost.
     */ ErrorNameConditionMapper["MessageLockLostError"] = "com.microsoft:message-lock-lost";
    /**
     * Error is thrown when the lock on the Azure ServiceBus session is lost.
     */ ErrorNameConditionMapper["SessionLockLostError"] = "com.microsoft:session-lock-lost";
    /**
     * Error is thrown when the Azure ServiceBus session cannot be locked.
     */ ErrorNameConditionMapper["SessionCannotBeLockedError"] = "com.microsoft:session-cannot-be-locked";
    /**
     * Error is thrown when an internal server error occurred. You may have found a bug?
     */ ErrorNameConditionMapper["InternalServerError"] = "amqp:internal-error";
    /**
     * Error for signaling general communication errors related to messaging operations.
     */ ErrorNameConditionMapper["ServiceCommunicationError"] = "amqp:not-found";
    /**
     * Error is thrown when message is not found.
     */ ErrorNameConditionMapper["MessageNotFoundError"] = "com.microsoft:message-not-found";
    /**
     * Error is thrown when relay is not found.
     */ ErrorNameConditionMapper["RelayNotFoundError"] = "com.microsoft:relay-not-found";
    /**
     * Error is thrown when a feature is not implemented yet but the placeholder is present.
     */ ErrorNameConditionMapper["NotImplementedError"] = "amqp:not-implemented";
    /**
     * Error is thrown when an operation is attempted but is not allowed.
     */ ErrorNameConditionMapper["InvalidOperationError"] = "amqp:not-allowed";
    /**
     * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
     * Quotas are reset periodically, this operation will have to wait until then.
     * The messaging entity has reached its maximum allowable size.
     * This can happen if the maximum number of receivers (which is 5) has already
     * been opened on a per-consumer group level.
     */ ErrorNameConditionMapper["QuotaExceededError"] = "amqp:resource-limit-exceeded";
    /**
     * Error is thrown when the connection parameters are wrong and the server refused the connection.
     */ ErrorNameConditionMapper["UnauthorizedError"] = "amqp:unauthorized-access";
    /**
     * Error is thrown when the service is unavailable. The operation should be retried.
     */ ErrorNameConditionMapper["ServiceUnavailableError"] = "com.microsoft:timeout";
    /**
     * Error is thrown when no new messages are received for the specified time.
     */ ErrorNameConditionMapper["MessageWaitTimeout"] = "com.microsoft:message-wait-timeout";
    /**
     * Error is thrown when an argument has a value that is out of the admissible range.
     */ ErrorNameConditionMapper["ArgumentOutOfRangeError"] = "com.microsoft:argument-out-of-range";
    /**
     * Error is thrown when a condition that should have been met in order to execute an operation was not.
     */ ErrorNameConditionMapper["PreconditionFailedError"] = "amqp:precondition-failed";
    /**
     * Error is thrown when data could not be decoded.
     */ ErrorNameConditionMapper["DecodeError"] = "amqp:decode-error";
    /**
     * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
     */ ErrorNameConditionMapper["InvalidFieldError"] = "amqp:invalid-field";
    /**
     * Error is thrown when the client attempted to work with a server entity to which it
     * has no access because another client is working with it.
     */ ErrorNameConditionMapper["ResourceLockedError"] = "amqp:resource-locked";
    /**
     * Error is thrown when a server entity the client is working with has been deleted.
     */ ErrorNameConditionMapper["ResourceDeletedError"] = "amqp:resource-deleted";
    /**
     * Error is thrown when the peer sent a frame that is not permitted in the current state.
     */ ErrorNameConditionMapper["IllegalStateError"] = "amqp:illegal-state";
    /**
     * Error is thrown when the peer cannot send a frame because the smallest encoding of
     * the performative with the currently valid values would be too large to fit within
     * a frame of the agreed maximum frame size.
     */ ErrorNameConditionMapper["FrameSizeTooSmallError"] = "amqp:frame-size-too-small";
    /**
     * Error is thrown when an operator intervened to detach for some reason.
     */ ErrorNameConditionMapper["DetachForcedError"] = "amqp:link:detach-forced";
    /**
     * Error is thrown when the peer sent more message transfers than currently allowed on the link.
     */ ErrorNameConditionMapper["TransferLimitExceededError"] = "amqp:link:transfer-limit-exceeded";
    /**
     * Error is thrown when the message sent is too large: the maximum size is 256Kb.
     */ ErrorNameConditionMapper["MessageTooLargeError"] = "amqp:link:message-size-exceeded";
    /**
     * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
     */ ErrorNameConditionMapper["LinkRedirectError"] = "amqp:link:redirect";
    /**
     * Error is thrown when two or more instances connect to the same partition
     * with different epoch values.
     */ ErrorNameConditionMapper["ReceiverDisconnectedError"] = "amqp:link:stolen";
    /**
     * Error is thrown when the peer violated incoming window for the session.
     */ ErrorNameConditionMapper["SessionWindowViolationError"] = "amqp:session:window-violation";
    /**
     * Error is thrown when input was received for a link that was detached with an error.
     */ ErrorNameConditionMapper["ErrantLinkError"] = "amqp:session:errant-link";
    /**
     * Error is thrown when an attach was received using a handle that is already in use for an attached link.
     */ ErrorNameConditionMapper["HandleInUseError"] = "amqp:session:handle-in-use";
    /**
     * Error is thrown when a frame (other than attach) was received referencing a handle which is not
     * currently in use of an attached link.
     */ ErrorNameConditionMapper["UnattachedHandleError"] = "amqp:session:unattached-handle";
    /**
     * Error is thrown when an operator intervened to close the connection for some reason.
     */ ErrorNameConditionMapper["ConnectionForcedError"] = "amqp:connection:forced";
    /**
     * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
     */ ErrorNameConditionMapper["FramingError"] = "amqp:connection:framing-error";
    /**
     * Error is thrown when the container is no longer available on the current connection.
     */ ErrorNameConditionMapper["ConnectionRedirectError"] = "amqp:connection:redirect";
    /**
     * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
     */ ErrorNameConditionMapper["ServerBusyError"] = "com.microsoft:server-busy";
    /**
     * Error is thrown when an incorrect argument was received.
     */ ErrorNameConditionMapper["ArgumentError"] = "com.microsoft:argument-error";
    /**
     * Error is thrown when server cancels the operation due to an internal issue.
     */ ErrorNameConditionMapper["OperationCancelledError"] = "com.microsoft:operation-cancelled";
    /**
     * Error is thrown when the client sender does not have enough link credits to send the message.
     */ ErrorNameConditionMapper["SenderBusyError"] = "client.sender:not-enough-link-credit";
    /**
     * Error is thrown when a low level system error is thrown by node.js.
     * {@link https://nodejs.org/api/errors.html#errors_class_systemerror}
     */ ErrorNameConditionMapper["SystemError"] = "system:error";
})($3d84b7093289460f$export$65de4560c7cb6642 || ($3d84b7093289460f$export$65de4560c7cb6642 = {}));
/**
 * @internal
 */ const $3d84b7093289460f$var$systemErrorFieldsToCopy = [
    "address",
    "code",
    "errno",
    "info",
    "port",
    "stack",
    "syscall"
];
function $3d84b7093289460f$export$db537eabf43c4bfd(error) {
    return error.name === "MessagingError";
}
class $3d84b7093289460f$export$3b8d39dfe8534909 extends Error {
    /**
     * @param message - The error message that provides more information about the error.
     * @param originalError - An error whose properties will be copied to the MessagingError if the
     * property matches one found on the Node.js `SystemError`.
     */ constructor(message, originalError){
        super(message);
        /**
         * The error name. Default value: "MessagingError".
         */ this.name = "MessagingError";
        /**
         *
         * Describes whether the error is retryable. Default: true.
         */ this.retryable = true;
        if (!originalError) return;
        // copy properties from system error
        for (const propName of $3d84b7093289460f$var$systemErrorFieldsToCopy)if (originalError[propName] != undefined) this[propName] = originalError[propName];
    }
}
const $3d84b7093289460f$export$3e3fff3cf7358299 = [
    "InternalServerError",
    "ServerBusyError",
    "ServiceUnavailableError",
    "OperationCancelledError",
    // The service may throw UnauthorizedError if credentials have been rotated.
    // Attempt to retry in case the user has also rotated their credentials.
    "UnauthorizedError",
    // OperationTimeoutError occurs when the service fails to respond within a given timeframe.
    // Since reasons for such failures can be transient, this is treated as a retryable error.
    "OperationTimeoutError",
    "SenderBusyError",
    "MessagingError",
    "DetachForcedError",
    "ConnectionForcedError",
    "TransferLimitExceededError",
    // InsufficientCreditError occurs when the number of credits available on Rhea link is insufficient.
    // Since reasons for such shortage can be transient such as for pending delivery of messages, this is treated as a retryable error.
    "InsufficientCreditError"
];
var $3d84b7093289460f$export$7155669e070ffdd0;
(function(SystemErrorConditionMapper) {
    SystemErrorConditionMapper["ENOTFOUND"] = "amqp:not-found";
    SystemErrorConditionMapper["EBUSY"] = "com.microsoft:server-busy";
    SystemErrorConditionMapper["ECONNREFUSED"] = "amqp:connection:forced";
    SystemErrorConditionMapper["ETIMEDOUT"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["ECONNRESET"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["ENETDOWN"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["EHOSTDOWN"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["ENETRESET"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["ENETUNREACH"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["ENONET"] = "com.microsoft:timeout";
})($3d84b7093289460f$export$7155669e070ffdd0 || ($3d84b7093289460f$export$7155669e070ffdd0 = {}));
function $3d84b7093289460f$export$4963f644aa8940e5(err) {
    if (!(0, $6a6c5885a1b92eeb$export$44aa3a8a1abdb9b6)(err, [
        "code",
        "syscall",
        "errno"
    ])) return false;
    if (!(0, $29b64d391bfe12b4$export$844ec244b1367d54)(err.code) || !(0, $29b64d391bfe12b4$export$844ec244b1367d54)(err.syscall)) return false;
    if (!(0, $29b64d391bfe12b4$export$844ec244b1367d54)(err.errno) && !(0, $29b64d391bfe12b4$export$7e4aa119212bc614)(err.errno)) return false;
    return true;
}
/**
 * @internal
 * Since browser doesn't differentiate between the various kinds of service communication errors,
 * this utility is used to look at the error target to identify such category of errors.
 * For more information refer to - https://html.spec.whatwg.org/multipage/comms.html#feedback-from-the-protocol
 * @param err - object that may contain error information
 */ function $3d84b7093289460f$var$isBrowserWebsocketError(err) {
    let result = false;
    if (!(0, $29b64d391bfe12b4$export$8ee0fc9ee280b4ee) && self && err.type === "error" && err.target instanceof self.WebSocket) result = true;
    return result;
}
/**
 * @internal
 */ const $3d84b7093289460f$var$rheaPromiseErrors = [
    // OperationTimeoutError occurs when the service fails to respond within a given timeframe.
    "OperationTimeoutError",
    // InsufficientCreditError occurs when the number of credits available on Rhea link is insufficient.
    "InsufficientCreditError",
    // Defines the error that occurs when the Sender fails to send a message.
    "SendOperationFailedError"
];
function $3d84b7093289460f$export$d73ee8ef04f5226a(err) {
    if (!(0, $6a6c5885a1b92eeb$export$4e62c701997796c1)(err)) return new Error(`Unknown error encountered.`);
    else if (typeof err !== "object") // The error is a scalar type, make it the message of an actual error.
    return new Error(err);
    // Built-in errors like TypeError and RangeError should not be retryable as these indicate issues
    // with user input and not an issue with the Messaging process.
    if (err instanceof TypeError || err instanceof RangeError) return err;
    if ($3d84b7093289460f$var$isAmqpError(err)) {
        // translate
        const condition = err.condition;
        const description = err.description;
        const error = new $3d84b7093289460f$export$3b8d39dfe8534909(description);
        if (err.stack) error.stack = err.stack;
        error.info = err.info;
        if (condition) error.code = $3d84b7093289460f$export$b65b7fa0413f4b3d[condition];
        if (description && (description.includes("status-code: 404") || description.match(/The messaging entity .* could not be found.*/i) !== null)) error.code = "MessagingEntityNotFoundError";
        if (error.code && $3d84b7093289460f$export$3e3fff3cf7358299.indexOf(error.code) === -1) // not found
        error.retryable = false;
        return error;
    }
    if (err.name === "MessagingError") // already translated
    return err;
    if ($3d84b7093289460f$export$4963f644aa8940e5(err)) {
        // translate
        const condition = err.code;
        const description = err.message;
        const error = new $3d84b7093289460f$export$3b8d39dfe8534909(description, err);
        let errorType = "SystemError";
        if (condition) {
            const amqpErrorCondition = $3d84b7093289460f$export$7155669e070ffdd0[condition];
            errorType = $3d84b7093289460f$export$b65b7fa0413f4b3d[amqpErrorCondition];
        }
        if ($3d84b7093289460f$export$3e3fff3cf7358299.indexOf(errorType) === -1) // not found
        error.retryable = false;
        return error;
    }
    if ($3d84b7093289460f$var$isBrowserWebsocketError(err)) {
        // Translate browser communication errors during opening handshake to generic ServiceCommunicationError
        const error = new $3d84b7093289460f$export$3b8d39dfe8534909("Websocket connection failed.");
        error.code = $3d84b7093289460f$export$b65b7fa0413f4b3d[$3d84b7093289460f$export$65de4560c7cb6642.ServiceCommunicationError];
        error.retryable = false;
        return error;
    }
    // Some errors come from rhea-promise and need to be converted to MessagingError.
    // A subset of these are also retryable.
    if ($3d84b7093289460f$var$rheaPromiseErrors.indexOf(err.name) !== -1) {
        const error = new $3d84b7093289460f$export$3b8d39dfe8534909(err.message, err);
        error.code = err.name;
        if (error.code && $3d84b7093289460f$export$3e3fff3cf7358299.indexOf(error.code) === -1) // not found
        error.retryable = false;
        return error;
    }
    return err;
}
/**
 * @internal
 */ function $3d84b7093289460f$var$isAmqpError(error) {
    return (0, $4973e2e602c1cc10$exports.isAmqpError)(error);
}






class $187bcb0b4cae0f22$export$ed126bc9a2a90e3e {
    /**
     * @param session - The amqp session.
     * @param sender - The amqp sender link.
     * @param receiver - The amqp receiver link.
     */ constructor(session, sender, receiver){
        this.session = session;
        this.sender = sender;
        this.receiver = receiver;
        /**
         * Maintains a map of responses that
         * are being actively returned. It acts as a store for correlating the responses received for
         * the send requests.
         */ this._responsesMap = new Map();
        this.session = session;
        this.sender = sender;
        this.receiver = receiver;
        this.receiver.on((0, $4973e2e602c1cc10$exports.ReceiverEvents).message, (context)=>{
            $187bcb0b4cae0f22$export$3972b78d7a96321e(context, this.connection.id, this._responsesMap);
        });
    }
    /**
     * Provides the underlying amqp connection object.
     * @returns Connection.
     */ get connection() {
        return this.session.connection;
    }
    /**
     * Indicates whether the session and the sender and receiver links are all open or closed.
     * @returns boolean - `true` - `open`, `false` - `closed`.
     */ isOpen() {
        return this.session.isOpen() && this.sender.isOpen() && this.receiver.isOpen();
    }
    /**
     * Sends the given request message and returns the received response. If the operation is not
     * completed in the provided timeout in milliseconds `default: 60000`, then `OperationTimeoutError` is thrown.
     *
     * @param request - The AMQP (request) message.
     * @param options - Options that can be provided while sending a request.
     * @returns Promise<Message> The AMQP (response) message.
     */ sendRequest(request, options = {}) {
        const timeoutInMs = options.timeoutInMs || (0, $807770c0815ec6f8$export$a002182e51710d39).defaultOperationTimeoutInMs;
        const aborter = options.abortSignal;
        // If message_id is not already set on the request, set it to a unique value
        // This helps in determining the right response for current request among multiple incoming messages
        if (!request.message_id) request.message_id = (0, $4973e2e602c1cc10$exports.generate_uuid)();
        return new Promise((resolve, reject)=>{
            let timer = undefined;
            const rejectOnAbort = ()=>{
                this._responsesMap.delete(request.message_id);
                const address = this.receiver.address || "address";
                const requestName = options.requestName;
                const desc = `[${this.connection.id}] The request "${requestName}" ` + `to "${address}" has been cancelled by the user.`;
                // Cancellation is a user-intended action, so log to info instead of warning.
                (0, $36f34de7efabe9df$export$af88d00dbe7f521).info(desc);
                const error = new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)((0, $807770c0815ec6f8$export$ec529641dbabb04c));
                reject(error);
            };
            const onAbort = ()=>{
                // safe to clear the timeout if it hasn't already occurred.
                if ((0, $6a6c5885a1b92eeb$export$4e62c701997796c1)(timer)) clearTimeout(timer);
                aborter.removeEventListener("abort", onAbort);
                rejectOnAbort();
            };
            if (aborter) {
                // the aborter may have been triggered between request attempts
                // so check if it was triggered and reject if needed.
                if (aborter.aborted) return rejectOnAbort();
                aborter.addEventListener("abort", onAbort);
            }
            timer = setTimeout(()=>{
                this._responsesMap.delete(request.message_id);
                if (aborter) aborter.removeEventListener("abort", onAbort);
                const address = this.receiver.address || "address";
                const desc = `The request with message_id "${request.message_id}" to "${address}" ` + `endpoint timed out. Please try again later.`;
                const e = {
                    name: "OperationTimeoutError",
                    message: desc
                };
                return reject((0, $3d84b7093289460f$export$d73ee8ef04f5226a)(e));
            }, timeoutInMs);
            this._responsesMap.set(request.message_id, {
                resolve: resolve,
                reject: reject,
                cleanupBeforeResolveOrReject: ()=>{
                    if (aborter) aborter.removeEventListener("abort", onAbort);
                    if ((0, $6a6c5885a1b92eeb$export$4e62c701997796c1)(timer)) clearTimeout(timer);
                }
            });
            (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] %s request sent: %O", this.connection.id, request.to || "$management", request);
            this.sender.send(request);
        });
    }
    /**
     * Closes the sender, receiver link and the underlying session.
     * @returns Promise<void>
     */ async close() {
        await this.sender.close({
            closeSession: false
        });
        await this.receiver.close({
            closeSession: false
        });
        await this.session.close();
    }
    /**
     * Removes the sender, receiver link and it's underlying session.
     * @returns void
     */ remove() {
        this.sender.remove();
        this.receiver.remove();
        this.session.remove();
    }
    /**
     * Creates an amqp request/response link.
     *
     * @param connection - The amqp connection.
     * @param senderOptions - Options that must be provided to create the sender link.
     * @param receiverOptions - Options that must be provided to create the receiver link.
     * @param createOptions - Optional parameters that can be used to affect this method's behavior.
     *    For example, `abortSignal` can be passed to allow cancelling an in-progress `create` invocation.
     * @returns Promise<RequestResponseLink>
     */ static async create(connection, senderOptions, receiverOptions, createOptions = {}) {
        const { abortSignal: abortSignal  } = createOptions;
        const session = await connection.createSession({
            abortSignal: abortSignal
        });
        const sender = await session.createSender(Object.assign(Object.assign({}, senderOptions), {
            abortSignal: abortSignal
        }));
        const receiver = await session.createReceiver(Object.assign(Object.assign({}, receiverOptions), {
            abortSignal: abortSignal
        }));
        (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] Successfully created the sender and receiver links on the same session.", connection.id);
        return new $187bcb0b4cae0f22$export$ed126bc9a2a90e3e(session, sender, receiver);
    }
}
const $187bcb0b4cae0f22$export$9e331736307e44f4 = (props = {})=>{
    return {
        statusCode: props[(0, $807770c0815ec6f8$export$a002182e51710d39).statusCode] || props.statusCode,
        statusDescription: props[(0, $807770c0815ec6f8$export$a002182e51710d39).statusDescription] || props.statusDescription,
        errorCondition: props[(0, $807770c0815ec6f8$export$a002182e51710d39).errorCondition] || props.errorCondition
    };
};
function $187bcb0b4cae0f22$export$3972b78d7a96321e(context, connectionId, responsesMap) {
    const message = context.message;
    if (!message) {
        (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose(`[${connectionId}] "message" property on the EventContext is "undefined" which is unexpected, ` + `returning from the "onMessageReceived" handler without resolving or rejecting the promise ` + `upon encountering the message event.`);
        return;
    }
    const responseCorrelationId = message.correlation_id;
    if (!responsesMap.has(responseCorrelationId)) {
        (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose(`[${connectionId}] correlationId "${responseCorrelationId}" property on the response does not match with ` + `any of the "request-id"s in the map, returning from the "onMessageReceived" handler without resolving ` + `or rejecting the promise upon encountering the message event.`);
        return;
    }
    const promise = responsesMap.get(responseCorrelationId);
    promise.cleanupBeforeResolveOrReject();
    const deleteResult = responsesMap.delete(responseCorrelationId);
    (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose(`[${connectionId}] Successfully deleted the response with id ${responseCorrelationId} from the map. ` + `Delete result - ${deleteResult}`);
    const info = $187bcb0b4cae0f22$export$9e331736307e44f4(message.application_properties);
    let error;
    if (!info.statusCode) error = new Error(`[${connectionId}] No statusCode in the "application_properties" in the returned response with correlation-id: ${responseCorrelationId}`);
    if (info.statusCode > 199 && info.statusCode < 300) {
        (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose(`[${connectionId}] Resolving the response with correlation-id: ${responseCorrelationId}`);
        return promise.resolve(message);
    }
    if (!error) {
        const condition = info.errorCondition || (0, $3d84b7093289460f$export$f5b3ec7c2de0d019)[info.statusCode] || "amqp:internal-error";
        error = (0, $3d84b7093289460f$export$d73ee8ef04f5226a)({
            condition: condition,
            description: info.statusDescription
        });
        (0, $36f34de7efabe9df$export$af88d00dbe7f521).warning(`${error === null || error === void 0 ? void 0 : error.name}: ${error === null || error === void 0 ? void 0 : error.message}`);
    }
    (0, $36f34de7efabe9df$export$6fe26fa55e239433)(error);
    return promise.reject(error);
}





class $ecb9dbbd04f56e1a$export$7308785cbd084610 {
    /**
     * @param connection - The AMQP connection.
     * @param connectionLock - A unique string (usually a guid) per connection.
     */ constructor(connection, connectionLock){
        /**
         * CBS endpoint - "$cbs"
         */ this.endpoint = (0, $807770c0815ec6f8$export$a002182e51710d39).cbsEndpoint;
        /**
         * CBS replyTo - The receiver link name that the service should reply to.
         */ this.replyTo = `${(0, $807770c0815ec6f8$export$a002182e51710d39).cbsReplyTo}-${(0, $4973e2e602c1cc10$exports.generate_uuid)()}`;
        /**
         * The unique lock name per $cbs session per connection that is used to
         * acquire the lock for establishing a cbs session if one does not exist for an amqp connection.
         */ this.cbsLock = `${(0, $807770c0815ec6f8$export$a002182e51710d39).negotiateCbsKey}-${(0, $4973e2e602c1cc10$exports.generate_uuid)()}`;
        this.connection = connection;
        this.connectionLock = connectionLock;
    }
    /**
     * Creates a singleton instance of the CBS session if it hasn't been initialized previously on
     * the given connection.
     * @param options - Optional parameters that can be used to affect this method's behavior.
     *    For example, `abortSignal` can be passed to allow cancelling an in-progress `init` invocation.
     * @returns Promise<void>.
     */ async init(options = {}) {
        const { abortSignal: abortSignal , timeoutInMs: timeoutInMs  } = options;
        try {
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) throw new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)((0, $807770c0815ec6f8$export$ec529641dbabb04c));
            // Acquire the lock and establish an amqp connection if it does not exist.
            if (!this.connection.isOpen()) {
                (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("The CBS client is trying to establish an AMQP connection.");
                await (0, $29b64d391bfe12b4$export$47162a90c11c56c9).acquire(this.connectionLock, ()=>{
                    return this.connection.open({
                        abortSignal: abortSignal
                    });
                }, {
                    abortSignal: abortSignal,
                    timeoutInMs: timeoutInMs
                });
            }
            if (!this.isOpen()) {
                const rxOpt = {
                    source: {
                        address: this.endpoint
                    },
                    name: this.replyTo,
                    onSessionError: (context)=>{
                        const id = context.connection.options.id;
                        const ehError = (0, $3d84b7093289460f$export$d73ee8ef04f5226a)(context.session.error);
                        (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] An error occurred on the session for request/response links for $cbs: %O", id, ehError);
                    }
                };
                const srOpt = {
                    target: {
                        address: this.endpoint
                    }
                };
                (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] Creating sender/receiver links on a session for $cbs endpoint.", this.connection.id);
                this._cbsSenderReceiverLink = await (0, $187bcb0b4cae0f22$export$ed126bc9a2a90e3e).create(this.connection, srOpt, rxOpt, {
                    abortSignal: abortSignal
                });
                this._cbsSenderReceiverLink.sender.on((0, $4973e2e602c1cc10$exports.SenderEvents).senderError, (context)=>{
                    const id = context.connection.options.id;
                    const ehError = (0, $3d84b7093289460f$export$d73ee8ef04f5226a)(context.sender.error);
                    (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] An error occurred on the cbs sender link.. %O", id, ehError);
                });
                this._cbsSenderReceiverLink.receiver.on((0, $4973e2e602c1cc10$exports.ReceiverEvents).receiverError, (context)=>{
                    const id = context.connection.options.id;
                    const ehError = (0, $3d84b7093289460f$export$d73ee8ef04f5226a)(context.receiver.error);
                    (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] An error occurred on the cbs receiver link.. %O", id, ehError);
                });
                (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] Successfully created the cbs sender '%s' and receiver '%s' links over cbs session.", this.connection.id, this._cbsSenderReceiverLink.sender.name, this._cbsSenderReceiverLink.receiver.name);
            } else (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] CBS session is already present. Reusing the cbs sender '%s' and receiver '%s' links over cbs session.", this.connection.id, this._cbsSenderReceiverLink.sender.name, this._cbsSenderReceiverLink.receiver.name);
        } catch (err) {
            const translatedError = (0, $3d84b7093289460f$export$d73ee8ef04f5226a)(err);
            (0, $36f34de7efabe9df$export$af88d00dbe7f521).warning("[%s] An error occurred while establishing the cbs links: %s", this.connection.id, `${translatedError === null || translatedError === void 0 ? void 0 : translatedError.name}: ${translatedError === null || translatedError === void 0 ? void 0 : translatedError.message}`);
            (0, $36f34de7efabe9df$export$6fe26fa55e239433)(translatedError);
            throw translatedError;
        }
    }
    /**
     * Negotiates the CBS claim with the EventHub/ServiceBus Service.
     * @param audience - The entity token audience for which the token is requested in one
     * of the following forms:
     *
     * - **ServiceBus**
     *    - **Sender**
     *        - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
     *        - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
     *
     *    - **Receiver**
     *         - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
     *         - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
     *
     *    - **ManagementClient**
     *         - `"sb://<your-namespace>.servicebus.windows.net/<queue-name>/$management"`.
     *         - `"sb://<your-namespace>.servicebus.windows.net/<topic-name>/$management"`.
     *
     * - **EventHubs**
     *     - **Sender**
     *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>"`
     *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>"`.
     *
     *     - **Receiver**
     *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>"`.
     *
     *     - **ManagementClient**
     *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/$management"`.
     * @param token - The token that needs to be sent in the put-token request.
     * @param tokenType - The type of token being used. For example, 'jwt' or 'servicebus.windows.net:sastoken'.
     * @param options - Optional parameters that can be used to affect this method's behavior.
     *    For example, `abortSignal` can be passed to allow cancelling an in-progress `negotiateClaim` invocation.
     * @returns A Promise that resolves when $cbs authentication is successful
     * and rejects when an error occurs during $cbs authentication.
     */ async negotiateClaim(audience, token, tokenType, options = {}) {
        const { abortSignal: abortSignal , timeoutInMs: timeoutInMs  } = options;
        try {
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) throw new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)((0, $807770c0815ec6f8$export$ec529641dbabb04c));
            if (!this._cbsSenderReceiverLink) throw new Error("Attempted to negotiate a claim but the CBS link does not exist.");
            const request = {
                body: token,
                message_id: (0, $4973e2e602c1cc10$exports.generate_uuid)(),
                reply_to: this.replyTo,
                to: this.endpoint,
                application_properties: {
                    operation: (0, $807770c0815ec6f8$export$a002182e51710d39).operationPutToken,
                    name: audience,
                    type: tokenType
                }
            };
            const responseMessage = await this._cbsSenderReceiverLink.sendRequest(request, {
                abortSignal: abortSignal,
                timeoutInMs: timeoutInMs,
                requestName: "negotiateClaim"
            });
            (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] The CBS response is: %O", this.connection.id, responseMessage);
            return this._fromRheaMessageResponse(responseMessage);
        } catch (err) {
            (0, $36f34de7efabe9df$export$af88d00dbe7f521).warning("[%s] An error occurred while negotiating the cbs claim: %s", this.connection.id, `${err === null || err === void 0 ? void 0 : err.name}: ${err === null || err === void 0 ? void 0 : err.message}`);
            (0, $36f34de7efabe9df$export$6fe26fa55e239433)(err);
            throw err;
        }
    }
    /**
     * Closes the AMQP cbs session to the EventHub/ServiceBus for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @returns
     */ async close() {
        try {
            if (this.isOpen()) {
                const cbsLink = this._cbsSenderReceiverLink;
                this._cbsSenderReceiverLink = undefined;
                await cbsLink.close();
                (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] Successfully closed the cbs session.", this.connection.id);
            }
        } catch (err) {
            const msg = `An error occurred while closing the cbs link: ${err.stack || JSON.stringify(err)}.`;
            (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] %s", this.connection.id, msg);
            throw new Error(msg);
        }
    }
    /**
     * Removes the AMQP cbs session to the EventHub/ServiceBus for this client,
     * @returns void
     */ remove() {
        try {
            if (this._cbsSenderReceiverLink) {
                const cbsLink = this._cbsSenderReceiverLink;
                this._cbsSenderReceiverLink = undefined;
                cbsLink.remove();
                (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] Successfully removed the cbs session.", this.connection.id);
            }
        } catch (err) {
            const msg = `An error occurred while removing the cbs link: ${err.stack || JSON.stringify(err)}.`;
            (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] %s", this.connection.id, msg);
            throw new Error(msg);
        }
    }
    /**
     * Indicates whether the cbs sender receiver link is open or closed.
     * @returns `true` open, `false` closed.
     */ isOpen() {
        var _a;
        return Boolean((_a = this._cbsSenderReceiverLink) === null || _a === void 0 ? void 0 : _a.isOpen());
    }
    _fromRheaMessageResponse(msg) {
        const cbsResponse = {
            correlationId: msg.correlation_id,
            statusCode: msg.application_properties ? msg.application_properties["status-code"] : "",
            statusDescription: msg.application_properties ? msg.application_properties["status-description"] : ""
        };
        (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] The deserialized CBS response is: %o", this.connection.id, cbsResponse);
        return cbsResponse;
    }
}





const $ef5478def9dddfa3$var$maxListenerLimit = 1000;
class $ef5478def9dddfa3$var$CoreAmqpConnection extends (0, $4973e2e602c1cc10$exports.Connection) {
    /**
     * Creates an amqp sender link. Max listener limit on the sender is set to 1000 because the
     * default value of 10 in NodeJS is too low.
     * @param options - Optional parameters to create a sender link.
     * @returns Promise<Sender>.
     */ async createSender(options) {
        const sender = await super.createSender(options);
        sender.setMaxListeners($ef5478def9dddfa3$var$maxListenerLimit);
        return sender;
    }
    /**
     * Creates an awaitable amqp sender. Max listener limit on the sender is set to 1000 because the
     * default value of 10 in NodeJS is too low.
     * @param options - Optional parameters to create an awaitable sender link.
     * - If `onError` and `onSessionError` handlers are not provided then the `AwaitableSender` will
     * clear the timer and reject the Promise for all the entries of inflight send operation in its
     * `deliveryDispositionMap`.
     * - If the user is handling the reconnection of sender link or the underlying connection in it's
     * app, then the `onError` and `onSessionError` handlers must be provided by the user and (s)he
     * shall be responsible of clearing the `deliveryDispositionMap` of inflight `send()` operation.
     *
     * @returns Promise<AwaitableSender>.
     */ async createAwaitableSender(options) {
        const sender = await super.createAwaitableSender(options);
        sender.setMaxListeners($ef5478def9dddfa3$var$maxListenerLimit);
        return sender;
    }
    /**
     * Creates an amqp receiver link. Max listener limit on the sender is set to 1000 because the
     * default value of 10 in NodeJS is too low.
     * @param options - Optional parameters to create a receiver link.
     * @returns Promise<Receiver>.
     */ async createReceiver(options) {
        const receiver = await super.createReceiver(options);
        receiver.setMaxListeners($ef5478def9dddfa3$var$maxListenerLimit);
        return receiver;
    }
}
const $ef5478def9dddfa3$export$17f3d3e3f5d0e9cb = {
    /**
     * Creates the base connection context.
     * @param parameters - Parameters to be provided to create
     * the base connection context.
     */ create (parameters) {
        var _a, _b, _c;
        (0, $12a9a1e1ce930860$export$33fc4efe54a49ad2).validate(parameters.config, {
            isEntityPathRequired: parameters.isEntityPathRequired || false
        });
        const userAgent = parameters.connectionProperties.userAgent;
        if (userAgent.length > (0, $807770c0815ec6f8$export$a002182e51710d39).maxUserAgentLength) throw new Error(`The user-agent string cannot be more than ${(0, $807770c0815ec6f8$export$a002182e51710d39).maxUserAgentLength} characters in length.` + `The given user-agent string is: ${userAgent} with length: ${userAgent.length}`);
        const connectionOptions = {
            transport: (0, $807770c0815ec6f8$export$a002182e51710d39).TLS,
            host: parameters.config.host,
            hostname: (_a = parameters.config.amqpHostname) !== null && _a !== void 0 ? _a : parameters.config.host,
            username: parameters.config.sharedAccessKeyName,
            port: (_b = parameters.config.port) !== null && _b !== void 0 ? _b : 5671,
            reconnect: false,
            properties: {
                product: parameters.connectionProperties.product,
                version: parameters.connectionProperties.version,
                "user-agent": userAgent,
                platform: (0, $941eab4392ee683a$export$118dbd5caa5fd507)(),
                framework: (0, $941eab4392ee683a$export$e7f4e58606fa2954)()
            },
            idle_time_out: (0, $807770c0815ec6f8$export$a002182e51710d39).defaultConnectionIdleTimeoutInMs,
            operationTimeoutInSeconds: parameters.operationTimeoutInMs ? parameters.operationTimeoutInMs / 1000 : undefined
        };
        if (parameters.config.webSocket || !(0, $29b64d391bfe12b4$export$8ee0fc9ee280b4ee) && typeof self !== "undefined" && self.WebSocket) {
            const socket = parameters.config.webSocket || self.WebSocket;
            const host = parameters.config.host;
            const endpoint = parameters.config.webSocketEndpointPath || "";
            const socketOptions = parameters.config.webSocketConstructorOptions || {};
            const port = (_c = parameters.config.port) !== null && _c !== void 0 ? _c : 443;
            connectionOptions.webSocketOptions = {
                webSocket: socket,
                url: `wss://${host}:${port}/${endpoint}`,
                protocol: [
                    "AMQPWSB10"
                ],
                options: socketOptions
            };
        }
        const connection = new $ef5478def9dddfa3$var$CoreAmqpConnection(connectionOptions);
        const connectionLock = `${(0, $807770c0815ec6f8$export$a002182e51710d39).establishConnection}-${(0, $4973e2e602c1cc10$exports.generate_uuid)()}`;
        const connectionContextBase = {
            wasConnectionCloseCalled: false,
            connectionLock: connectionLock,
            negotiateClaimLock: `${(0, $807770c0815ec6f8$export$a002182e51710d39).negotiateClaim}-${(0, $4973e2e602c1cc10$exports.generate_uuid)()}`,
            connection: connection,
            connectionId: connection.id,
            cbsSession: new (0, $ecb9dbbd04f56e1a$export$7308785cbd084610)(connection, connectionLock),
            config: parameters.config,
            refreshConnection () {
                const newConnection = new $ef5478def9dddfa3$var$CoreAmqpConnection(connectionOptions);
                const newConnectionLock = `${(0, $807770c0815ec6f8$export$a002182e51710d39).establishConnection}-${(0, $4973e2e602c1cc10$exports.generate_uuid)()}`;
                this.wasConnectionCloseCalled = false;
                this.connectionLock = newConnectionLock;
                this.negotiateClaimLock = `${(0, $807770c0815ec6f8$export$a002182e51710d39).negotiateClaim} - ${(0, $4973e2e602c1cc10$exports.generate_uuid)()}`;
                this.connection = newConnection;
                this.connectionId = newConnection.id;
                this.cbsSession = new (0, $ecb9dbbd04f56e1a$export$7308785cbd084610)(newConnection, newConnectionLock);
            }
        };
        return connectionContextBase;
    }
};



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint-disable eqeqeq */ // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint-disable eqeqeq */ 
const $ddd8f50bf426372f$export$1aa9504b199c946b = {
    /**
     * Converts MessageHeader to RheaMessageHeader.
     *
     * @param props - Message header.
     * @returns RheaMessageHeader
     */ toRheaMessageHeader (props) {
        const amqpHeader = {};
        if (props.deliveryCount != undefined) amqpHeader.delivery_count = props.deliveryCount;
        if (props.durable != undefined) amqpHeader.durable = props.durable;
        if (props.firstAcquirer != undefined) amqpHeader.first_acquirer = props.firstAcquirer;
        if (props.priority != undefined) amqpHeader.priority = props.priority;
        if (props.timeToLive != undefined) amqpHeader.ttl = props.timeToLive;
        (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("To RheaMessageHeader: %O", amqpHeader);
        return amqpHeader;
    },
    /**
     * Converts RheaMessageHeader to MessageHeader.
     *
     * @param props - Amqp Message Header
     * @returns MessageHeader.
     */ fromRheaMessageHeader (props) {
        const msgHeader = {};
        if (props.delivery_count != undefined) msgHeader.deliveryCount = props.delivery_count;
        if (props.durable != undefined) msgHeader.durable = props.durable;
        if (props.first_acquirer != undefined) msgHeader.firstAcquirer = props.first_acquirer;
        if (props.priority != undefined) msgHeader.priority = props.priority;
        if (props.ttl != undefined) msgHeader.timeToLive = props.ttl;
        (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("From RheaMessageHeader: %O", msgHeader);
        return msgHeader;
    }
};


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint-disable eqeqeq */ 
const $22ed4d0d7bc7307a$export$f3cc594ff03fc593 = {
    /**
     * Converts MessageProperties to RheaMessageProperties.
     * @param props - Message properties.
     * @returns RheaMessageProperties.
     */ toRheaMessageProperties (props) {
        const amqpProperties = {};
        if (props.absoluteExpiryTime != undefined) amqpProperties.absolute_expiry_time = new Date(props.absoluteExpiryTime);
        if (props.contentEncoding != undefined) amqpProperties.content_encoding = props.contentEncoding;
        if (props.contentType != undefined) amqpProperties.content_type = props.contentType;
        if (props.correlationId != undefined) amqpProperties.correlation_id = props.correlationId;
        if (props.creationTime != undefined) amqpProperties.creation_time = new Date(props.creationTime);
        if (props.groupId != undefined) amqpProperties.group_id = props.groupId;
        if (props.groupSequence != undefined) amqpProperties.group_sequence = props.groupSequence;
        if (props.messageId != undefined) amqpProperties.message_id = props.messageId;
        if (props.replyTo != undefined) amqpProperties.reply_to = props.replyTo;
        if (props.replyToGroupId != undefined) amqpProperties.reply_to_group_id = props.replyToGroupId;
        if (props.subject != undefined) amqpProperties.subject = props.subject;
        if (props.to != undefined) amqpProperties.to = props.to;
        // if (props.userId != undefined) {
        //   amqpProperties.user_id = props.userId;
        // }
        (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("To RheaMessageProperties: %O", amqpProperties);
        return amqpProperties;
    },
    /**
     * Converts RheaMessageProperties to MessageProperties.
     * @param props - Amqp message properties.
     * @returns MessageProperties.
     */ fromRheaMessageProperties (props) {
        const msgProperties = {};
        if (props.absolute_expiry_time != undefined) msgProperties.absoluteExpiryTime = props.absolute_expiry_time.getTime();
        if (props.content_encoding != undefined) msgProperties.contentEncoding = props.content_encoding;
        if (props.content_type != undefined) msgProperties.contentType = props.content_type;
        if (props.correlation_id != undefined) msgProperties.correlationId = props.correlation_id;
        if (props.creation_time != undefined) msgProperties.creationTime = props.creation_time.getTime();
        if (props.group_id != undefined) msgProperties.groupId = props.group_id;
        if (props.group_sequence != undefined) msgProperties.groupSequence = props.group_sequence;
        if (props.message_id != undefined) msgProperties.messageId = props.message_id;
        if (props.reply_to != undefined) msgProperties.replyTo = props.reply_to;
        if (props.reply_to_group_id != undefined) msgProperties.replyToGroupId = props.reply_to_group_id;
        if (props.subject != undefined) msgProperties.subject = props.subject;
        if (props.to != undefined) msgProperties.to = props.to;
        // if (props.user_id != undefined) {
        //   msgProperties.userId = props.user_id;
        // }
        (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("From RheaMessageProperties: %O", msgProperties);
        return msgProperties;
    }
};


const $aa042c06b256ae25$export$d37f949cd101d3b1 = {
    /**
     * Takes RheaMessage(`Message` type from "rhea") and returns it in the AmqpAnnotatedMessage format.
     */ fromRheaMessage (msg) {
        return {
            header: (0, $ddd8f50bf426372f$export$1aa9504b199c946b).fromRheaMessageHeader(msg),
            footer: msg.footer,
            messageAnnotations: msg.message_annotations,
            deliveryAnnotations: msg.delivery_annotations,
            applicationProperties: msg.application_properties,
            properties: (0, $22ed4d0d7bc7307a$export$f3cc594ff03fc593).fromRheaMessageProperties(msg),
            body: msg.body
        };
    },
    /**
     * Takes AmqpAnnotatedMessage and returns it in the RheaMessage(`Message` type from "rhea") format.
     */ toRheaMessage (msg) {
        const message = Object.assign(Object.assign(Object.assign({}, (0, $22ed4d0d7bc7307a$export$f3cc594ff03fc593).toRheaMessageProperties(msg.properties || {})), (0, $ddd8f50bf426372f$export$1aa9504b199c946b).toRheaMessageHeader(msg.header || {})), {
            body: msg.body,
            message_annotations: msg.messageAnnotations,
            delivery_annotations: msg.deliveryAnnotations,
            application_properties: msg.applicationProperties,
            footer: msg.footer
        });
        return message;
    }
};



var $6FDNW = parcelRequire("6FDNW");


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.



var $6FDNW = parcelRequire("6FDNW");

const $6043267107e2d71b$export$1e1cb8ba5c9d4079 = 0x75;
const $6043267107e2d71b$export$b9a197febc714f62 = 0x76;
const $6043267107e2d71b$export$8b8493acb38f8c5b = 0x77;
const $6043267107e2d71b$export$317b368fb2b0354d = {
    /**
     * A function that takes the body property from an EventData object
     * and returns an encoded body (some form of AMQP type).
     *
     * @param body - The AMQP message body
     * @returns The encoded AMQP message body as an AMQP Data type
     * (data section in rhea terms). Section object with following properties:
     * - typecode: 117 (0x75)
     * - content: The given AMQP message body as a Buffer.
     * - multiple: true | undefined.
     */ encode (body, bodyType) {
        let result;
        if (bodyType === "value") {
            // TODO: Expose value_section from `rhea` similar to the data_section and sequence_section. Right now there isn't a way to create a value section officially.
            result = (0, $4973e2e602c1cc10$exports.message).data_section(body);
            result.typecode = $6043267107e2d71b$export$8b8493acb38f8c5b;
        } else if (bodyType === "sequence") result = (0, $4973e2e602c1cc10$exports.message).sequence_section(body);
        else if ((0, (/*@__PURE__*/$parcel$interopDefault($ecfddc481ab00b65$exports)))(body)) result = (0, $4973e2e602c1cc10$exports.message).data_section(body);
        else {
            // string, undefined, null, boolean, array, object, number should end up here
            // coercing undefined to null as that will ensure that null value will be given to the
            // customer on receive.
            if (body === undefined) body = null; // tslint:disable-line
            try {
                const bodyStr = JSON.stringify(body);
                result = (0, $4973e2e602c1cc10$exports.message).data_section((0, $6FDNW.Buffer).from(bodyStr, "utf8"));
            } catch (err) {
                const msg = `An error occurred while executing JSON.stringify() on the given body ` + body + `${err ? err.stack : JSON.stringify(err)}`;
                (0, $f014dc9d393cdf62$export$af88d00dbe7f521).warning("[encode] " + msg);
                (0, $f014dc9d393cdf62$export$6fe26fa55e239433)((0, $f014dc9d393cdf62$export$af88d00dbe7f521), err);
                throw new Error(msg);
            }
        }
        return result;
    },
    /**
     * A function that takes the body property from an AMQP message
     * (an AMQP Data type (data section in rhea terms)) and returns the decoded message body.
     * If it cannot decode the body then it returns the body
     * as-is.
     *
     * NOTE: Use this to decode a message body when you know that the entire contents are _only_ contained
     * in the 'data' section of the message (for instance, messages from the $mgmt link). Otherwise
     * use 'defaultDataTransformer.decodeWithType', which can handle data coming from separate sections
     * of the AMQP mesage.
     *
     * @param body - The AMQP message body
     * @param skipParsingBodyAsJson - Boolean to skip running JSON.parse() on message body content.
     * @returns decoded body or the given body as-is.
     */ decode (body, skipParsingBodyAsJson) {
        let actualContent = body;
        if ($6043267107e2d71b$export$d8479b89ae246380(body)) actualContent = body.content;
        return skipParsingBodyAsJson ? actualContent : $6043267107e2d71b$export$2e6ed6a4f6d5b8db(actualContent);
    },
    /**
     * A function that takes the body property from an AMQP message, which can come from either
     * the 'data', 'value' or 'sequence' sections of an AMQP message.
     *
     * If the body is not a JSON string the the raw contents will be returned, along with the bodyType
     * indicating which part of the AMQP message the body was decoded from.
     *
     * @param body - The AMQP message body as received from rhea.
     * @param skipParsingBodyAsJson - Boolean to skip running JSON.parse() on message body.
     * @returns The decoded/raw body and the body type.
     */ decodeWithType (body, skipParsingBodyAsJson) {
        try {
            if ($6043267107e2d71b$export$d8479b89ae246380(body)) switch(body.typecode){
                case $6043267107e2d71b$export$1e1cb8ba5c9d4079:
                    return {
                        body: skipParsingBodyAsJson ? body.content : $6043267107e2d71b$export$2e6ed6a4f6d5b8db(body.content),
                        bodyType: "data"
                    };
                case $6043267107e2d71b$export$b9a197febc714f62:
                    // typecode:
                    // handle sequences
                    return {
                        body: body.content,
                        bodyType: "sequence"
                    };
                case $6043267107e2d71b$export$8b8493acb38f8c5b:
                    // value
                    return {
                        body: body.content,
                        bodyType: "value"
                    };
            }
            else {
                // not sure - we have to try to infer the proper bodyType and content
                if ((0, (/*@__PURE__*/$parcel$interopDefault($ecfddc481ab00b65$exports)))(body)) // This indicates that we are getting the AMQP described type. Let us try decoding it.
                return {
                    body: skipParsingBodyAsJson ? body : $6043267107e2d71b$export$2e6ed6a4f6d5b8db(body),
                    bodyType: "data"
                };
                else return {
                    body: body,
                    bodyType: "value"
                };
            }
        } catch (err) {
            (0, $f014dc9d393cdf62$export$af88d00dbe7f521).verbose("[decode] An error occurred while decoding the received message body. The error is: %O", err);
            throw err;
        }
    }
};
function $6043267107e2d71b$export$d8479b89ae246380(possibleSection) {
    return possibleSection != null && typeof possibleSection.typecode === "number" && (possibleSection.typecode === $6043267107e2d71b$export$1e1cb8ba5c9d4079 || possibleSection.typecode === $6043267107e2d71b$export$8b8493acb38f8c5b || possibleSection.typecode === $6043267107e2d71b$export$b9a197febc714f62);
}
function $6043267107e2d71b$export$2e6ed6a4f6d5b8db(body) {
    let processedBody = body;
    try {
        // Trying to stringify and JSON.parse() anything else will fail flat and we shall return
        // the original type back
        const bodyStr = processedBody.toString("utf8");
        processedBody = JSON.parse(bodyStr);
    } catch (err) {
        (0, $f014dc9d393cdf62$export$af88d00dbe7f521).verbose("[decode] An error occurred while trying JSON.parse() on the received body. The error is %O", err);
    }
    return processedBody;
}





var $d7965bb09cbe6503$export$8ea2432f7b480e4d;
(function(DispositionType) {
    DispositionType["complete"] = "complete";
    DispositionType["deadletter"] = "deadletter";
    DispositionType["abandon"] = "abandon";
    DispositionType["defer"] = "defer";
})($d7965bb09cbe6503$export$8ea2432f7b480e4d || ($d7965bb09cbe6503$export$8ea2432f7b480e4d = {}));
function $d7965bb09cbe6503$export$b2021888e3a99c26(msg) {
    if (msg.contentType != null && typeof msg.contentType !== "string") return new TypeError("The property 'contentType' on the message must be of type 'string'");
    if (msg.subject != null && typeof msg.subject !== "string") return new TypeError("The property 'label' on the message must be of type 'string'");
    if (msg.to != null && typeof msg.to !== "string") return new TypeError("The property 'to' on the message must be of type 'string'");
    if (msg.replyTo != null && typeof msg.replyTo !== "string") return new TypeError("The property 'replyTo' on the message must be of type 'string'");
    if (msg.replyToSessionId != null && typeof msg.replyToSessionId !== "string") return new TypeError("The property 'replyToSessionId' on the message must be of type 'string'");
    if (msg.timeToLive != null && typeof msg.timeToLive !== "number") return new TypeError("The property 'timeToLive' on the message must be of type 'number'");
    if (msg.sessionId != null && typeof msg.sessionId !== "string") return new TypeError("The property 'sessionId' on the message must be of type 'string'");
    if (msg.messageId != null && typeof msg.messageId !== "string" && typeof msg.messageId !== "number" && !(0, $6FDNW.Buffer).isBuffer(msg.messageId)) return new TypeError("The property 'messageId' on the message must be of type string, number or Buffer");
    if (msg.correlationId != null && typeof msg.correlationId !== "string" && typeof msg.correlationId !== "number" && !(0, $6FDNW.Buffer).isBuffer(msg.correlationId)) return new TypeError("The property 'correlationId' on the message must be of type string, number or Buffer");
    return;
}
function $d7965bb09cbe6503$export$cca86c1f4325d7b8(msg, encoder) {
    var _a, _b;
    let amqpMsg;
    if ($d7965bb09cbe6503$export$343d74d5bc10101e(msg)) amqpMsg = Object.assign(Object.assign({}, (0, $aa042c06b256ae25$export$d37f949cd101d3b1).toRheaMessage(msg)), {
        body: encoder.encode(msg.body, (_a = msg.bodyType) !== null && _a !== void 0 ? _a : "data")
    });
    else {
        let bodyType = "data";
        if ($d7965bb09cbe6503$export$e16e656b26422dd1(msg)) /*
             * TODO: this is a bit complicated.
             *
             * It seems reasonable to expect to be able to round-trip a message (ie,
             * receive a message, and then send it again, possibly to another queue / topic).
             * If the user does that we need to make sure to respect their original AMQP
             * type so when the message is re - encoded we don't put 'body' into the wrong spot.
             *
             * The complication is that we need to decide if we're okay with respecting a field
             * from the rawAmqpMessage, which up until now we've treated as just vestigial
             * information on send. My hope is that the use case of "alter the sb message in some
             * incompatible way with the underying _rawAmqpMessage.bodyType" is not common
             * enough for us to try to do anything more than what I'm doing here.
             */ bodyType = (_b = msg._rawAmqpMessage.bodyType) !== null && _b !== void 0 ? _b : "data";
        // TODO: it seems sensible that we'd also do this for AMQPAnnotated message.
        const validationError = $d7965bb09cbe6503$export$b2021888e3a99c26(msg);
        if (validationError) throw validationError;
        amqpMsg = {
            body: encoder.encode(msg.body, bodyType),
            message_annotations: {}
        };
        amqpMsg.ttl = msg.timeToLive;
    }
    if (amqpMsg.ttl != null && amqpMsg.ttl !== (0, $807770c0815ec6f8$export$a002182e51710d39).maxDurationValue) {
        amqpMsg.creation_time = new Date();
        amqpMsg.absolute_expiry_time = new Date(Math.min((0, $807770c0815ec6f8$export$a002182e51710d39).maxAbsoluteExpiryTime, amqpMsg.creation_time.getTime() + amqpMsg.ttl));
    }
    if ($d7965bb09cbe6503$export$343d74d5bc10101e(msg)) return amqpMsg;
    if (msg.applicationProperties != null) amqpMsg.application_properties = msg.applicationProperties;
    if (msg.contentType != null) amqpMsg.content_type = msg.contentType;
    if (msg.sessionId != null) {
        if (msg.sessionId.length > (0, $807770c0815ec6f8$export$a002182e51710d39).maxSessionIdLength) throw new Error("Length of 'sessionId' property on the message cannot be greater than 128 characters.");
        amqpMsg.group_id = msg.sessionId;
    }
    if (msg.replyTo != null) amqpMsg.reply_to = msg.replyTo;
    if (msg.to != null) amqpMsg.to = msg.to;
    if (msg.subject != null) amqpMsg.subject = msg.subject;
    $d7965bb09cbe6503$export$26ddb388a8c85837(amqpMsg, msg.messageId);
    if (msg.correlationId != null) amqpMsg.correlation_id = msg.correlationId;
    if (msg.replyToSessionId != null) amqpMsg.reply_to_group_id = msg.replyToSessionId;
    if (msg.partitionKey != null) {
        if (msg.partitionKey.length > (0, $807770c0815ec6f8$export$a002182e51710d39).maxPartitionKeyLength) throw new Error("Length of 'partitionKey' property on the message cannot be greater than 128 characters.");
        amqpMsg.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).partitionKey] = msg.partitionKey;
    }
    // Will be required later for implementing Transactions
    // if (msg.viaPartitionKey != null) {
    //   if (msg.viaPartitionKey.length > Constants.maxPartitionKeyLength) {
    //     throw new Error(
    //       "Length of 'viaPartitionKey' property on the message cannot be greater than 128 characters."
    //     );
    //   }
    //   amqpMsg.message_annotations![Constants.viaPartitionKey] = msg.viaPartitionKey;
    // }
    $d7965bb09cbe6503$export$c8d318bbbb5351d8(amqpMsg, msg.scheduledEnqueueTimeUtc);
    (0, $f014dc9d393cdf62$export$bb8c8b6a9c29dff9).verbose("SBMessage to RheaMessage: %O", amqpMsg);
    return amqpMsg;
}
function $d7965bb09cbe6503$export$26ddb388a8c85837(rheaMessage, messageId) {
    if (messageId != null) {
        if (typeof messageId === "string" && messageId.length > (0, $807770c0815ec6f8$export$a002182e51710d39).maxMessageIdLength) throw new Error(`Length of 'messageId' property on the message cannot be greater than ${(0, $807770c0815ec6f8$export$a002182e51710d39).maxMessageIdLength} characters.`);
        rheaMessage.message_id = messageId;
    }
}
function $d7965bb09cbe6503$export$c8d318bbbb5351d8(rheaMessage, scheduledEnqueuedTimeUtc) {
    var _a;
    if (scheduledEnqueuedTimeUtc != null) {
        rheaMessage.message_annotations = (_a = rheaMessage.message_annotations) !== null && _a !== void 0 ? _a : {};
        rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).scheduledEnqueueTime] = scheduledEnqueuedTimeUtc;
    }
}
function $d7965bb09cbe6503$export$d697904b8f80158a(rheaMessage, options) {
    var _a, _b;
    if (!rheaMessage) rheaMessage = {
        body: undefined
    };
    const { skipParsingBodyAsJson: skipParsingBodyAsJson , delivery: delivery , shouldReorderLockToken: shouldReorderLockToken , skipConvertingDate: skipConvertingDate = false  } = options;
    const { body: body , bodyType: bodyType  } = (0, $6043267107e2d71b$export$317b368fb2b0354d).decodeWithType(rheaMessage.body, skipParsingBodyAsJson);
    const sbmsg = {
        body: body
    };
    if (rheaMessage.application_properties != null) sbmsg.applicationProperties = skipConvertingDate ? rheaMessage.application_properties : $d7965bb09cbe6503$var$convertDatesToNumbers(rheaMessage.application_properties);
    if (rheaMessage.content_type != null) sbmsg.contentType = rheaMessage.content_type;
    if (rheaMessage.group_id != null) sbmsg.sessionId = rheaMessage.group_id;
    if (rheaMessage.reply_to != null) sbmsg.replyTo = rheaMessage.reply_to;
    if (rheaMessage.to != null) sbmsg.to = rheaMessage.to;
    if (rheaMessage.ttl != null) sbmsg.timeToLive = rheaMessage.ttl;
    if (rheaMessage.subject != null) sbmsg.subject = rheaMessage.subject;
    if (rheaMessage.message_id != null) sbmsg.messageId = rheaMessage.message_id;
    if (rheaMessage.correlation_id != null) sbmsg.correlationId = rheaMessage.correlation_id;
    if (rheaMessage.reply_to_group_id != null) sbmsg.replyToSessionId = rheaMessage.reply_to_group_id;
    if (rheaMessage.message_annotations != null) {
        if (rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).partitionKey] != null) sbmsg.partitionKey = rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).partitionKey];
        // Will be required later for implementing Transactions
        // if (msg.message_annotations[Constants.viaPartitionKey] != null) {
        //   sbmsg.viaPartitionKey = msg.message_annotations[Constants.viaPartitionKey];
        // }
        if (rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).scheduledEnqueueTime] != null) sbmsg.scheduledEnqueueTimeUtc = rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).scheduledEnqueueTime];
    }
    const props = {
        state: "active"
    };
    if (rheaMessage.message_annotations != null) {
        if (rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).deadLetterSource] != null) props.deadLetterSource = rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).deadLetterSource];
        const messageState = rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).messageState];
        if (messageState === 1) props.state = "deferred";
        else if (messageState === 2) props.state = "scheduled";
        if (rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).enqueueSequenceNumber] != null) props.enqueuedSequenceNumber = rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).enqueueSequenceNumber];
        if (rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).sequenceNumber] != null) {
            if ((0, $6FDNW.Buffer).isBuffer(rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).sequenceNumber])) props.sequenceNumber = (0, (/*@__PURE__*/$parcel$interopDefault($c2bd6b1b7ffc7b0d$exports))).fromBytesBE(rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).sequenceNumber]);
            else props.sequenceNumber = (0, (/*@__PURE__*/$parcel$interopDefault($c2bd6b1b7ffc7b0d$exports))).fromNumber(rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).sequenceNumber]);
        }
        if (rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).enqueuedTime] != null) props.enqueuedTimeUtc = new Date(rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).enqueuedTime]);
        if (rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).lockedUntil] != null) props.lockedUntilUtc = new Date(rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).lockedUntil]);
    }
    if (rheaMessage.ttl == null) rheaMessage.ttl = (0, $807770c0815ec6f8$export$a002182e51710d39).maxDurationValue;
    if (props.enqueuedTimeUtc) props.expiresAtUtc = new Date(Math.min(props.enqueuedTimeUtc.getTime() + rheaMessage.ttl, (0, $807770c0815ec6f8$export$a002182e51710d39).maxDurationValue));
    const rawMessage = (0, $aa042c06b256ae25$export$d37f949cd101d3b1).fromRheaMessage(rheaMessage);
    rawMessage.bodyType = bodyType;
    if (rawMessage.applicationProperties) rawMessage.applicationProperties = skipConvertingDate ? rawMessage.applicationProperties : $d7965bb09cbe6503$var$convertDatesToNumbers(rawMessage.applicationProperties);
    if (rawMessage.deliveryAnnotations) rawMessage.deliveryAnnotations = skipConvertingDate ? rawMessage.deliveryAnnotations : $d7965bb09cbe6503$var$convertDatesToNumbers(rawMessage.deliveryAnnotations);
    if (rawMessage.messageAnnotations) rawMessage.messageAnnotations = skipConvertingDate ? rawMessage.messageAnnotations : $d7965bb09cbe6503$var$convertDatesToNumbers(rawMessage.messageAnnotations);
    const rcvdsbmsg = Object.assign(Object.assign(Object.assign({
        _rawAmqpMessage: rawMessage,
        deliveryCount: rheaMessage.delivery_count,
        lockToken: delivery && delivery.tag && delivery.tag.length !== 0 ? (0, $4973e2e602c1cc10$exports.uuid_to_string)(shouldReorderLockToken === true ? (0, $3402f46f0a1b2976$export$79654292bb147350)(typeof delivery.tag === "string" ? (0, $6FDNW.Buffer).from(delivery.tag) : delivery.tag) : typeof delivery.tag === "string" ? (0, $6FDNW.Buffer).from(delivery.tag) : delivery.tag) : undefined
    }, sbmsg), props), {
        deadLetterReason: (_a = sbmsg.applicationProperties) === null || _a === void 0 ? void 0 : _a.DeadLetterReason,
        deadLetterErrorDescription: (_b = sbmsg.applicationProperties) === null || _b === void 0 ? void 0 : _b.DeadLetterErrorDescription
    });
    (0, $f014dc9d393cdf62$export$bb8c8b6a9c29dff9).verbose("AmqpMessage to ServiceBusReceivedMessage: %O", rcvdsbmsg);
    return rcvdsbmsg;
}
function $d7965bb09cbe6503$export$a4ad9bafa2e8daa7(possible) {
    return (0, $a7961d970a7496cb$export$44aa3a8a1abdb9b6)(possible, [
        "body"
    ]);
}
function $d7965bb09cbe6503$export$343d74d5bc10101e(possible) {
    return (0, $a7961d970a7496cb$export$44aa3a8a1abdb9b6)(possible, [
        "body",
        "bodyType"
    ]) && possible.constructor.name !== $d7965bb09cbe6503$export$a482b14703d155cd.name;
}
function $d7965bb09cbe6503$export$e16e656b26422dd1(possible) {
    return $d7965bb09cbe6503$export$a4ad9bafa2e8daa7(possible) && "_rawAmqpMessage" in possible;
}
class $d7965bb09cbe6503$export$a482b14703d155cd {
    /**
     * @internal
     */ constructor(msg, delivery, shouldReorderLockToken, receiveMode, skipParsingBodyAsJson, skipConvertingDate){
        const _a = $d7965bb09cbe6503$export$d697904b8f80158a(msg, {
            skipParsingBodyAsJson: skipParsingBodyAsJson,
            delivery: delivery,
            shouldReorderLockToken: shouldReorderLockToken,
            skipConvertingDate: skipConvertingDate
        }), { _rawAmqpMessage: _rawAmqpMessage  } = _a, restOfMessageProps = (0, $9187fda58d09cc70$export$3c9a16f847548506)(_a, [
            "_rawAmqpMessage"
        ]);
        this._rawAmqpMessage = _rawAmqpMessage; // need to initialize _rawAmqpMessage property to make compiler happy
        Object.assign(this, restOfMessageProps);
        this.state = restOfMessageProps.state; // to suppress error TS2564: Property 'state' has no initializer and is not definitely assigned in the constructor.
        // Lock on a message is applicable only in peekLock mode, but the service sets
        // the lock token even in receiveAndDelete mode if the entity in question is partitioned.
        if (receiveMode === "receiveAndDelete") this.lockToken = undefined;
        this.delivery = delivery;
    }
    /**
     * Creates a clone of the current message to allow it to be re-sent to the queue
     * @returns ServiceBusMessage
     */ clone() {
        // We are returning a ServiceBusMessage object because that object can then be sent to Service Bus
        const clone = {
            body: this.body,
            contentType: this.contentType,
            correlationId: this.correlationId,
            subject: this.subject,
            messageId: this.messageId,
            partitionKey: this.partitionKey,
            replyTo: this.replyTo,
            replyToSessionId: this.replyToSessionId,
            scheduledEnqueueTimeUtc: this.scheduledEnqueueTimeUtc,
            sessionId: this.sessionId,
            timeToLive: this.timeToLive,
            to: this.to,
            applicationProperties: this.applicationProperties
        };
        return clone;
    }
}
/**
 * Converts any Date objects into a number representing date.getTime().
 * Recursively checks for any Date objects in arrays and objects.
 * @internal
 */ function $d7965bb09cbe6503$var$convertDatesToNumbers(thing) {
    // fast exit
    if (!(0, $a7961d970a7496cb$export$4e62c701997796c1)(thing)) return thing;
    // When 'thing' is a Date, return the number representation
    if (typeof thing === "object" && (0, $a7961d970a7496cb$export$44aa3a8a1abdb9b6)(thing, [
        "getTime"
    ]) && typeof thing.getTime === "function") return thing.getTime();
    /*
      Examples:
      [0, 'foo', new Date(), { nested: new Date()}]
    */ if (Array.isArray(thing)) {
        const result = [];
        for (const element of thing)result.push($d7965bb09cbe6503$var$convertDatesToNumbers(element));
        return result;
    }
    /*
      Examples:
      { foo: new Date(), children: { nested: new Date() }}
    */ if (typeof thing === "object" && (0, $a7961d970a7496cb$export$4e62c701997796c1)(thing)) {
        const thingShallowCopy = Object.assign({}, thing);
        for (const key of Object.keys(thingShallowCopy))thingShallowCopy[key] = $d7965bb09cbe6503$var$convertDatesToNumbers(thingShallowCopy[key]);
        return thingShallowCopy;
    }
    return thing;
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Describes the type of supported tokens.
 */ var $fa81cf07f25ed995$export$f435f793048e7a0f;
(function(TokenType) {
    /**
     * The "jwt" token type. Used with AADTokenCredential.
     */ TokenType["CbsTokenTypeJwt"] = "jwt";
    /**
     * The sas token type. Used with SharedKeyCredential.
     */ TokenType["CbsTokenTypeSas"] = "servicebus.windows.net:sastoken";
})($fa81cf07f25ed995$export$f435f793048e7a0f || ($fa81cf07f25ed995$export$f435f793048e7a0f = {}));





// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


const $c6ec964bc6c55a71$export$1beb79c34f82fcc3 = new Map([
    [
        "MessagingEntityNotFoundError",
        "MessagingEntityNotFound"
    ],
    [
        "MessageLockLostError",
        "MessageLockLost"
    ],
    [
        "MessageNotFoundError",
        "MessageNotFound"
    ],
    [
        "MessageTooLargeError",
        "MessageSizeExceeded"
    ],
    [
        "MessagingEntityAlreadyExistsError",
        "MessagingEntityAlreadyExists"
    ],
    [
        "MessagingEntityDisabledError",
        "MessagingEntityDisabled"
    ],
    [
        "QuotaExceededError",
        "QuotaExceeded"
    ],
    [
        "ServerBusyError",
        "ServiceBusy"
    ],
    [
        "OperationTimeoutError",
        "ServiceTimeout"
    ],
    [
        "ServiceCommunicationError",
        "ServiceCommunicationProblem"
    ],
    [
        "SessionCannotBeLockedError",
        "SessionCannotBeLocked"
    ],
    [
        "SessionLockLostError",
        "SessionLockLost"
    ],
    [
        "UnauthorizedError",
        "UnauthorizedAccess"
    ]
]);
class $c6ec964bc6c55a71$export$a7174187385dd2e2 extends (0, $3d84b7093289460f$export$3b8d39dfe8534909) {
    constructor(messageOrError, code){
        const message = typeof messageOrError === "string" ? messageOrError : messageOrError.message;
        super(message);
        if (typeof messageOrError === "string") this.code = code !== null && code !== void 0 ? code : "GeneralError";
        else {
            for(const prop in messageOrError)this[prop] = messageOrError[prop];
            this.code = $c6ec964bc6c55a71$export$a7174187385dd2e2.normalizeMessagingCode(messageOrError.code);
            // For GeneralErrors, prefix the error message with the MessagingError code to provide
            // more context to the user.
            if (this.code === "GeneralError" && messageOrError.code) this.message = `${messageOrError.code}: ${this.message}`;
        }
        this.name = "ServiceBusError";
    }
    static normalizeMessagingCode(oldCode) {
        if (oldCode == null || !$c6ec964bc6c55a71$export$1beb79c34f82fcc3.has(oldCode)) return "GeneralError";
        return $c6ec964bc6c55a71$export$1beb79c34f82fcc3.get(oldCode);
    }
}
function $c6ec964bc6c55a71$export$8bd4f04fa736e48c(err) {
    if ($c6ec964bc6c55a71$export$97a7570e751c66ee(err)) return err;
    const translatedError = (0, $3d84b7093289460f$export$d73ee8ef04f5226a)(err);
    if ((0, $3d84b7093289460f$export$db537eabf43c4bfd)(translatedError)) return new $c6ec964bc6c55a71$export$a7174187385dd2e2(translatedError);
    return translatedError;
}
function $c6ec964bc6c55a71$export$97a7570e751c66ee(err) {
    return (0, $a7961d970a7496cb$export$44aa3a8a1abdb9b6)(err, [
        "name"
    ]) && err.name === "ServiceBusError";
}


class $12c81f6e1047261d$export$3ba4e37e9c27f9bb {
    /**
     * Creates a new ClientEntity instance.
     * @param baseName - The base name to use for the link. A unique ID will be appended to this.
     * @param entityPath - The entity path (ex: 'your-queue')
     * @param context - The connection context.
     * @param options - Options that can be provided while creating the LinkEntity.
     */ constructor(baseName, entityPath, context, _linkType, _logger, options){
        this.baseName = baseName;
        this.entityPath = entityPath;
        this._linkType = _linkType;
        this._logger = _logger;
        /**
         * Indicates that close() has been called on this link and
         * that it should not be allowed to reopen.
         */ this._wasClosedPermanently = false;
        /**
         * A lock that ensures that opening and closing this
         * link properly cooperate.
         */ this._openLock = (0, $4973e2e602c1cc10$exports.generate_uuid)();
        if (!options) options = {};
        this._context = context;
        this.address = options.address || "";
        this.audience = options.audience || "";
        this.name = (0, $3402f46f0a1b2976$export$798a797a6d4e253e)(baseName);
        this._logPrefix = `[${context.connectionId}|${this._linkType}:${this.name}]`;
    }
    get logPrefix() {
        return this._logPrefix;
    }
    /**
     * Determines whether the AMQP link is open. If open then returns true else returns false.
     */ isOpen() {
        const result = this._link ? this._link.isOpen() : false;
        this._logger.verbose(`${this._logPrefix} is open? ${result}`);
        return result;
    }
    /**
     * Initializes this LinkEntity, setting this._link with the result of  `createRheaLink`, which
     * is implemented by child classes.
     *
     * @returns A Promise that resolves when the link has been properly initialized
     * @throws `AbortError` if the link has been closed via 'close'
     */ async initLink(options, abortSignal) {
        // we'll check that the connection isn't in the process of recycling (and if so, wait for it to complete)
        await this._context.readyToOpenLink();
        this._logger.verbose(`${this._logPrefix} Attempting to acquire lock token ${this._openLock} for initializing link`);
        return (0, $29b64d391bfe12b4$export$47162a90c11c56c9).acquire(this._openLock, ()=>{
            this._logger.verbose(`${this._logPrefix} Lock ${this._openLock} acquired for initializing link`);
            return this._initLinkImpl(options, abortSignal);
        }, {
            abortSignal: abortSignal,
            timeoutInMs: (0, $807770c0815ec6f8$export$a002182e51710d39).defaultOperationTimeoutInMs
        });
    }
    async _initLinkImpl(options, abortSignal) {
        const checkAborted = ()=>{
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) throw new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)((0, $807770c0815ec6f8$export$ec529641dbabb04c));
        };
        const connectionId = this._context.connectionId;
        checkAborted();
        if (options.name) {
            this.name = options.name;
            this._logPrefix = `[${connectionId}|${this._linkType}:${this.name}]`;
        }
        if (this._wasClosedPermanently) {
            this._logger.verbose(`${this._logPrefix} Link has been permanently closed. Not reopening.`);
            throw new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)(`Link has been permanently closed. Not reopening.`);
        }
        if (this.isOpen()) {
            this._logger.verbose(`${this._logPrefix} Link is already open. Returning.`);
            return;
        }
        this._logger.verbose(`${this._logPrefix} Is not open and is not currently connecting. Opening.`);
        try {
            await this._negotiateClaim({
                abortSignal: abortSignal,
                setTokenRenewal: false,
                timeoutInMs: (0, $807770c0815ec6f8$export$a002182e51710d39).defaultOperationTimeoutInMs
            });
            checkAborted();
            this.checkIfConnectionReady();
            this._logger.verbose(`${this._logPrefix} Creating with options %O`, options);
            this._link = await this.createRheaLink(options);
            checkAborted();
            this._ensureTokenRenewal();
            this._logger.verbose(`${this._logPrefix} Link has been created.`);
        } catch (err) {
            this._logger.logError(err, `${this._logPrefix} Error thrown when creating the link`);
            await this.closeLinkImpl();
            throw err;
        }
    }
    /**
     * Clears token renewal for current link, removes current LinkEntity instance from cache,
     * and closes the underlying AMQP link.
     * Once closed, this instance of LinkEntity is not meant to be re-used.
     */ async close() {
        // Set the flag to indicate that this instance of LinkEntity is not meant to be re-used.
        this._wasClosedPermanently = true;
        this._logger.verbose(`${this.logPrefix} permanently closing this link.`);
        this.removeLinkFromContext();
        await this.closeLink();
        this._logger.verbose(`${this.logPrefix} permanently closed this link.`);
    }
    /**
     * Closes the internally held rhea link, stops the token renewal timer and sets
     * the this._link field to undefined.
     */ closeLink() {
        this._logger.verbose(`${this._logPrefix} Attempting to acquire lock token ${this._openLock} for closing link`);
        return (0, $29b64d391bfe12b4$export$47162a90c11c56c9).acquire(this._openLock, ()=>{
            this._logger.verbose(`${this._logPrefix} Lock ${this._openLock} acquired for closing link`);
            return this.closeLinkImpl();
        }, {
            abortSignal: undefined,
            timeoutInMs: undefined
        });
    }
    async closeLinkImpl() {
        this._logger.verbose(`${this._logPrefix} closeLinkImpl() called`);
        clearTimeout(this._tokenRenewalTimer);
        this._tokenRenewalTimer = undefined;
        if (this._link) try {
            const link = this._link;
            this._link = undefined;
            // This should take care of closing the link and it's underlying session. This should also
            // remove them from the internal map.
            await link.close();
            this._logger.verbose(`${this._logPrefix} closed.`);
        } catch (err) {
            this._logger.logError(err, `${this._logPrefix} An error occurred while closing the link`);
        }
    }
    /**
     * Provides the current type of the ClientEntity.
     * @returns The entity type.
     */ get _type() {
        let result = "LinkEntity";
        if (this.constructor && this.constructor.name) result = this.constructor.name;
        return result;
    }
    get wasClosedPermanently() {
        return this._wasClosedPermanently;
    }
    get link() {
        return this._link;
    }
    /**
     * Negotiates the cbs claim for the ClientEntity.
     * @param setTokenRenewal - Set the token renewal timer. Default false.
     */ async _negotiateClaim({ abortSignal: abortSignal , setTokenRenewal: setTokenRenewal , timeoutInMs: timeoutInMs  }) {
        this._logger.verbose(`${this._logPrefix} negotiateclaim() has been called`);
        // Wait for the connectionContext to be ready to open the link.
        this.checkIfConnectionReady();
        // Acquire the lock and establish a cbs session if it does not exist on the connection.
        // Although node.js is single threaded, we need a locking mechanism to ensure that a
        // race condition does not happen while creating a shared resource (in this case the
        // cbs session, since we want to have exactly 1 cbs session per connection).
        this._logger.verbose("%s Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: '%s' with address: '%s'.", this.logPrefix, this._context.cbsSession.cbsLock, this._type, this.name, this.address);
        const startTime = Date.now();
        if (!this._context.cbsSession.isOpen()) await (0, $29b64d391bfe12b4$export$47162a90c11c56c9).acquire(this._context.cbsSession.cbsLock, ()=>{
            this.checkIfConnectionReady();
            return this._context.cbsSession.init({
                abortSignal: abortSignal,
                timeoutInMs: timeoutInMs
            });
        }, {
            abortSignal: abortSignal,
            timeoutInMs: timeoutInMs - (Date.now() - startTime)
        });
        let tokenObject;
        let tokenType;
        if ((0, $6a6c5885a1b92eeb$export$5bb8cb442c22efaf)(this._context.tokenCredential)) {
            tokenObject = this._context.tokenCredential.getToken(this.audience);
            tokenType = (0, $fa81cf07f25ed995$export$f435f793048e7a0f).CbsTokenTypeSas;
            // renew sas token in every 45 minutes
            this._tokenTimeout = 2700000;
        } else {
            const aadToken = await this._context.tokenCredential.getToken((0, $807770c0815ec6f8$export$a002182e51710d39).aadServiceBusScope);
            if (!aadToken) throw new Error(`Failed to get token from the provided "TokenCredential" object`);
            tokenObject = aadToken;
            tokenType = (0, $fa81cf07f25ed995$export$f435f793048e7a0f).CbsTokenTypeJwt;
            this._tokenTimeout = tokenObject.expiresOnTimestamp - Date.now() - 120000;
        }
        this._logger.verbose("%s %s: calling negotiateClaim for audience '%s'.", this.logPrefix, this._type, this.audience);
        // Acquire the lock to negotiate the CBS claim.
        this._logger.verbose("%s Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.", this.logPrefix, this._context.negotiateClaimLock, this._type, this.name, this.address);
        if (!tokenObject) throw new Error("Token cannot be null");
        await (0, $29b64d391bfe12b4$export$47162a90c11c56c9).acquire(this._context.negotiateClaimLock, ()=>{
            this.checkIfConnectionReady();
            return this._context.cbsSession.negotiateClaim(this.audience, tokenObject.token, tokenType, {
                abortSignal: abortSignal,
                timeoutInMs: timeoutInMs - (Date.now() - startTime)
            });
        }, {
            abortSignal: abortSignal,
            timeoutInMs: timeoutInMs - (Date.now() - startTime)
        });
        this._logger.verbose("%s Negotiated claim for %s '%s' with with address: %s", this.logPrefix, this._type, this.name, this.address);
        if (setTokenRenewal) this._ensureTokenRenewal();
    }
    /**
     * Checks to see if the connection is in a "reopening" state. If it is
     * we need to _not_ use it otherwise we'll trigger some race conditions
     * within rhea (for instance, errors about _process not being defined).
     */ checkIfConnectionReady() {
        if (!this._context.isConnectionClosing()) return;
        this._logger.verbose(`${this._logPrefix} Connection is reopening, aborting link initialization.`);
        const err = new (0, $c6ec964bc6c55a71$export$a7174187385dd2e2)("Connection is reopening, aborting link initialization.", "GeneralError");
        err.retryable = true;
        throw err;
    }
    /**
     * Ensures that the token is renewed within the predefined renewal margin.
     */ _ensureTokenRenewal() {
        if (!this._tokenTimeout) return;
        // Clear the existing token renewal timer.
        // This scenario can happen if the connection goes down and is brought back up
        // before the `nextRenewalTimeout` was reached.
        if (this._tokenRenewalTimer) clearTimeout(this._tokenRenewalTimer);
        this._tokenRenewalTimer = setTimeout(async ()=>{
            try {
                await this._negotiateClaim({
                    setTokenRenewal: true,
                    abortSignal: undefined,
                    timeoutInMs: (0, $807770c0815ec6f8$export$a002182e51710d39).defaultOperationTimeoutInMs
                });
            } catch (err) {
                this._logger.logError(err, "%s %s '%s' with address %s, an error occurred while renewing the token", this.logPrefix, this._type, this.name, this.address);
            }
        }, this._tokenTimeout);
        this._logger.verbose("%s %s '%s' with address %s, has next token renewal in %d milliseconds @(%s).", this.logPrefix, this._type, this.name, this.address, this._tokenTimeout, new Date(Date.now() + this._tokenTimeout).toString());
    }
}




// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.




const $f4faabfcfe4aedfc$export$ab45ab8711aa1ebf = "The queue or topic name provided does not match the EntityPath in the connection string passed to the ServiceBusClient constructor.";
const $f4faabfcfe4aedfc$export$2a7d1d2aeb270d35 = "'maxMessageCount' must be a number greater than 0.";
function $f4faabfcfe4aedfc$export$136df9204559429f(context) {
    if (context && context.wasConnectionCloseCalled) {
        const errorMessage = "The underlying AMQP connection is closed.";
        const error = new Error(errorMessage);
        (0, $f014dc9d393cdf62$export$af88d00dbe7f521).warning(`[${context.connectionId}] %O`, error);
        throw error;
    }
}
function $f4faabfcfe4aedfc$export$b3043c42d7e2faae(entityPath) {
    return `The sender for "${entityPath}" has been closed and can no longer be used. ` + `Please create a new sender using the "createSender" method on the ServiceBusClient.`;
}
function $f4faabfcfe4aedfc$export$b84680138471c3a3(entityPath, sessionId) {
    if (!(0, $a7961d970a7496cb$export$4e62c701997796c1)(sessionId)) return `The receiver for "${entityPath}" has been closed and can no longer be used. ` + `Please create a new receiver using the "createReceiver" method on the ServiceBusClient.`;
    return `The receiver for session "${sessionId}" in "${entityPath}" has been closed and can no ` + `longer be used. Please create a new receiver using the "acceptSession" or "acceptNextSession" method on the ServiceBusClient.`;
}
function $f4faabfcfe4aedfc$export$683aa5b1f4396e5d(entityPath, sessionId) {
    if (!(0, $a7961d970a7496cb$export$4e62c701997796c1)(sessionId)) return `The receiver for "${entityPath}" is already receiving messages.`;
    return `The receiver for session "${sessionId}" for "${entityPath}" is already receiving messages.`;
}
function $f4faabfcfe4aedfc$export$f0c638a8242b4a49(connectionId, parameterName, parameterValue) {
    if (parameterValue === undefined || parameterValue === null) {
        const error = new TypeError(`Missing parameter "${parameterName}"`);
        (0, $f014dc9d393cdf62$export$af88d00dbe7f521).warning(`[${connectionId}] %O`, error);
        throw error;
    }
}
function $f4faabfcfe4aedfc$export$731df47d11cad7fa(connectionId, parameterName, parameterValue, expectedType) {
    if (typeof parameterValue !== expectedType) {
        const error = new TypeError(`The parameter "${parameterName}" should be of type "${expectedType}"`);
        (0, $f014dc9d393cdf62$export$af88d00dbe7f521).warning(`[${connectionId}] %O`, error);
        throw error;
    }
}
function $f4faabfcfe4aedfc$export$d0c336de1cbf0354(connectionId, parameterName, parameterValue) {
    if (Array.isArray(parameterValue)) return $f4faabfcfe4aedfc$export$17c4385c978082b1(connectionId, parameterName, parameterValue);
    if ((0, (/*@__PURE__*/$parcel$interopDefault($c2bd6b1b7ffc7b0d$exports))).isLong(parameterValue)) return;
    const error = new TypeError(`The parameter "${parameterName}" should be of type "Long"`);
    (0, $f014dc9d393cdf62$export$af88d00dbe7f521).warning(`[${connectionId}] %O`, error);
    throw error;
}
function $f4faabfcfe4aedfc$export$17c4385c978082b1(connectionId, parameterName, parameterValue) {
    if (parameterValue.every((item)=>(0, (/*@__PURE__*/$parcel$interopDefault($c2bd6b1b7ffc7b0d$exports))).isLong(item))) return;
    const error = new TypeError(`The parameter "${parameterName}" should be an array of type "Long"`);
    (0, $f014dc9d393cdf62$export$af88d00dbe7f521).warning(`[${connectionId}] %O`, error);
    throw error;
}
function $f4faabfcfe4aedfc$export$24c1510fe425393c(connectionId, parameterName, parameterValue) {
    if (parameterValue !== "") return;
    const error = new TypeError(`Empty string not allowed in parameter "${parameterName}"`);
    (0, $f014dc9d393cdf62$export$af88d00dbe7f521).warning(`[${connectionId}] %O`, error);
    throw error;
}
const $f4faabfcfe4aedfc$export$45f2d15ef7724152 = "The operation is not supported in 'receiveAndDelete' receive mode.";
const $f4faabfcfe4aedfc$export$1c7e5b76f9c7ea4d = "This operation is not supported for peeked messages. Only messages received using 'receiveMessages()', 'subscribe()' and 'getMessageIterator()' methods on the receiver in 'peekLock' receive mode can be settled.";
const $f4faabfcfe4aedfc$export$571766634c511d39 = "The message has either been deleted or already settled";
function $f4faabfcfe4aedfc$export$a8e335484e7a74b0(message, receiveMode, connectionId) {
    let error;
    if (receiveMode === "receiveAndDelete") error = new Error($f4faabfcfe4aedfc$export$45f2d15ef7724152);
    else if (!message.lockToken) error = new Error($f4faabfcfe4aedfc$export$1c7e5b76f9c7ea4d);
    if (error) {
        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, "[%s] An error occurred for message with id '%s'", connectionId, message.messageId);
        throw error;
    }
}
const $f4faabfcfe4aedfc$export$ac1ff5404ea34fad = "The fields 'partitionKey' and 'sessionId' cannot have different values.";
function $f4faabfcfe4aedfc$export$967aa9e81b482b79(msg, errorMessageForWrongType) {
    if (!(0, $d7965bb09cbe6503$export$a4ad9bafa2e8daa7)(msg) && !(0, $d7965bb09cbe6503$export$343d74d5bc10101e)(msg)) throw new TypeError(errorMessageForWrongType);
    if ((0, $d7965bb09cbe6503$export$a4ad9bafa2e8daa7)(msg)) {
        if (msg.partitionKey && msg.sessionId && msg.partitionKey !== msg.sessionId) throw new TypeError($f4faabfcfe4aedfc$export$ac1ff5404ea34fad);
    }
}
const $f4faabfcfe4aedfc$export$8484f288912a9358 = "Provided value for 'messages' must be of type: ServiceBusMessage, AmqpAnnotatedMessage, ServiceBusMessageBatch or an array of type ServiceBusMessage or AmqpAnnotatedMessage.";
const $f4faabfcfe4aedfc$export$5c1e262b654d0f82 = "Provided value for 'message' must be of type: ServiceBusMessage or AmqpAnnotatedMessage.";




var $6FDNW = parcelRequire("6FDNW");



/**
 * @internal
 */ const $066fbc893467d414$var$sqlRuleProperties = [
    "sqlExpression"
];
function $066fbc893467d414$var$isSqlRuleFilter(obj) {
    if (obj) return $066fbc893467d414$var$sqlRuleProperties.some((validProperty)=>(0, $a7961d970a7496cb$export$44aa3a8a1abdb9b6)(obj, [
            validProperty
        ]));
    return false;
}
/**
 * @internal
 */ const $066fbc893467d414$var$correlationProperties = [
    "correlationId",
    "messageId",
    "to",
    "replyTo",
    "subject",
    "sessionId",
    "replyToSessionId",
    "contentType",
    "applicationProperties"
];
function $066fbc893467d414$var$isCorrelationRuleFilter(obj) {
    if (obj) return $066fbc893467d414$var$correlationProperties.some((validProperty)=>(0, $a7961d970a7496cb$export$44aa3a8a1abdb9b6)(obj, [
            validProperty
        ]));
    return false;
}
class $066fbc893467d414$export$72fc7afd6c6b156a extends (0, $12c81f6e1047261d$export$3ba4e37e9c27f9bb) {
    /**
     * Instantiates the management client.
     * @param context - The connection context
     * @param entityPath - The name/path of the entity (queue/topic/subscription name)
     * for which the management request needs to be made.
     * @param options - Options to be provided for creating the
     * "$management" client.
     */ constructor(context, entityPath, options){
        super(`${entityPath}/$management`, entityPath, context, "mgmt", (0, $f014dc9d393cdf62$export$af6f5d5234509fc9), {
            address: options && options.address ? options.address : (0, $807770c0815ec6f8$export$a002182e51710d39).management,
            audience: options && options.audience ? options.audience : `${context.config.endpoint}${entityPath}/$management`
        });
        /**
         * The reply to Guid for the management client.
         */ this.replyTo = (0, $4973e2e602c1cc10$exports.generate_uuid)();
        /**
         * Provides the sequence number of the last peeked message.
         */ this._lastPeekedSequenceNumber = (0, (/*@__PURE__*/$parcel$interopDefault($c2bd6b1b7ffc7b0d$exports))).ZERO;
        this._context = context;
    }
    ensureUniqueReplyToForRequest() {
        if (!this.isOpen()) this.replyTo = (0, $4973e2e602c1cc10$exports.generate_uuid)();
    }
    async _init(abortSignal) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        try {
            const rxopt = {
                source: {
                    address: this.address
                },
                name: this.replyTo,
                target: {
                    address: this.replyTo
                },
                onSessionError: (context)=>{
                    const sbError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(context.session.error);
                    (0, $f014dc9d393cdf62$export$af6f5d5234509fc9).logError(sbError, `${this.logPrefix} An error occurred on the session for request/response links for $management`);
                }
            };
            const sropt = {
                target: {
                    address: this.address
                },
                onError: (context)=>{
                    const ehError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(context.sender.error);
                    (0, $f014dc9d393cdf62$export$af6f5d5234509fc9).logError(ehError, `${this.logPrefix} An error occurred on the $management sender link`);
                }
            };
            // Even if multiple parallel requests reach here, the initLink secures a lock
            // to ensure there won't be multiple initializations
            await this.initLink({
                senderOptions: sropt,
                receiverOptions: rxopt
            }, abortSignal);
        } catch (err) {
            const translatedError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$af6f5d5234509fc9).logError(translatedError, `${this.logPrefix} An error occurred while establishing the $management links`);
            throw translatedError;
        }
    }
    async createRheaLink(// eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        const rheaLink = await (0, $187bcb0b4cae0f22$export$ed126bc9a2a90e3e).create(this._context.connection, options.senderOptions, options.receiverOptions);
        // Attach listener for the `receiver_error` events to log the errors.
        // "message" event listener is added in core-amqp.
        // "rhea" doesn't allow setting only the "onError" handler in the options if it is not accompanied by an "onMessage" handler.
        // Hence, not passing onError handler in the receiver options, adding a handler below.
        rheaLink.receiver.on((0, $4973e2e602c1cc10$exports.ReceiverEvents).receiverError, (context)=>{
            const ehError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(context.receiver.error);
            (0, $f014dc9d393cdf62$export$af6f5d5234509fc9).logError(ehError, `${this.logPrefix} An error occurred on the $management receiver link`);
        });
        return rheaLink;
    }
    /**
     * Given array of typed values, returns the element in given index
     */ _safelyGetTypedValueFromArray(data, index) {
        return Array.isArray(data) && data.length > index && data[index] ? data[index].value : undefined;
    }
    _decodeApplicationPropertiesMap(obj) {
        if (!(0, $4973e2e602c1cc10$exports.types).is_map(obj)) throw new Error("object to decode is not of Map types");
        const array = obj.value;
        const result = {};
        for(let i = 0; i < array.length; i += 2){
            const key = array[i].value;
            result[key] = array[i + 1].value;
        }
        return result;
    }
    async _makeManagementRequest(request, internalLogger, sendRequestOptions = {}) {
        var _a;
        if (request.message_id === undefined) request.message_id = (0, $4973e2e602c1cc10$exports.generate_uuid)();
        const retryTimeoutInMs = (_a = sendRequestOptions.timeoutInMs) !== null && _a !== void 0 ? _a : (0, $807770c0815ec6f8$export$a002182e51710d39).defaultOperationTimeoutInMs;
        const initOperationStartTime = Date.now();
        const actionAfterTimeout = (reject)=>{
            const desc = `The request with message_id "${request.message_id}" timed out. Please try again later.`;
            const e = {
                name: "OperationTimeoutError",
                message: desc
            };
            reject(e);
        };
        let waitTimer;
        // eslint-disable-next-line promise/param-names
        const operationTimeout = new Promise((_, reject)=>{
            waitTimer = setTimeout(()=>actionAfterTimeout(reject), retryTimeoutInMs);
        });
        internalLogger.verbose(`${this.logPrefix} Acquiring lock to get the management req res link.`);
        try {
            if (!this.isOpen()) await Promise.race([
                this._init(sendRequestOptions === null || sendRequestOptions === void 0 ? void 0 : sendRequestOptions.abortSignal),
                operationTimeout
            ]);
        } finally{
            clearTimeout(waitTimer);
        }
        // time taken by the init operation
        const timeTakenByInit = Date.now() - initOperationStartTime;
        // Left over time
        sendRequestOptions.timeoutInMs = retryTimeoutInMs - timeTakenByInit;
        try {
            if (!request.message_id) request.message_id = (0, $4973e2e602c1cc10$exports.generate_uuid)();
            return await this.link.sendRequest(request, sendRequestOptions);
        } catch (err) {
            const translatedError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            internalLogger.logError(translatedError, "%s An error occurred during send on management request-response link with address '%s'", this.logPrefix, this.address);
            throw translatedError;
        }
    }
    /**
     * Closes the AMQP management session to the ServiceBus namespace for this client,
     * returning a promise that will be resolved when disconnection is completed.
     */ async close() {
        try {
            // Always clear the timeout, as the isOpen check may report
            // false without ever having cleared the timeout otherwise.
            // NOTE: management link currently doesn't have a separate concept of "detaching" like
            // the other links do. When we add handling of this (via the onDetached call, like other links)
            // we can change this back to closeLink("permanent").
            await this.closeLink();
            (0, $f014dc9d393cdf62$export$af6f5d5234509fc9).verbose("Successfully closed the management session.");
        } catch (err) {
            (0, $f014dc9d393cdf62$export$af6f5d5234509fc9).logError(err, `${this.logPrefix} An error occurred while closing the management session`);
            throw err;
        }
    }
    /**
     * Fetches the next batch of active messages. The first call to `peek()` fetches the first
     * active message for this client. Each subsequent call fetches the subsequent message in the
     * entity.
     *
     * Unlike a `received` message, `peeked` message will not have lock token associated with it,
     * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`. This method will
     * also fetch even Deferred messages (but not Deadlettered message).
     *
     * @param messageCount - The number of messages to retrieve. Default value `1`.
     * @param omitMessageBody - Whether to omit message body when peeking. Default value `false`.
     */ async peek(messageCount, omitMessageBody, options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), messageCount, undefined, omitMessageBody, options);
    }
    /**
     * Fetches the next batch of active messages in the current MessageSession. The first call to
     * `peek()` fetches the first active message for this client. Each subsequent call fetches the
     * subsequent message in the entity.
     *
     * Unlike a `received` message, `peeked` message will not have lock token associated with it,
     * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`.  This method will
     * also fetch even Deferred messages (but not Deadlettered message).
     *
     * @param sessionId - The sessionId from which messages need to be peeked.
     * @param messageCount - The number of messages to retrieve. Default value `1`.
     * @param omitMessageBody - Whether to omit message body when peeking Default value `false`.
     */ async peekMessagesBySession(sessionId, messageCount, omitMessageBody, options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), messageCount, sessionId, omitMessageBody, options);
    }
    /**
     * Peeks the desired number of messages from the specified sequence number.
     *
     * @param fromSequenceNumber - The sequence number from where to read the message.
     * @param messageCount - The number of messages to retrieve. Default value `1`.
     * @param sessionId - The sessionId from which messages need to be peeked.
     * @param omitMessageBody - Whether to omit message body when peeking. Default value `false`.
     */ async peekBySequenceNumber(fromSequenceNumber, maxMessageCount, sessionId, omitMessageBody, options) {
        var _a, _b;
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        const connId = this._context.connectionId;
        // Checks for fromSequenceNumber
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(connId, "fromSequenceNumber", fromSequenceNumber);
        (0, $f4faabfcfe4aedfc$export$d0c336de1cbf0354)(connId, "fromSequenceNumber", fromSequenceNumber);
        // Checks for maxMessageCount
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(this._context.connectionId, "maxMessageCount", maxMessageCount);
        (0, $f4faabfcfe4aedfc$export$731df47d11cad7fa)(this._context.connectionId, "maxMessageCount", maxMessageCount, "number");
        if (isNaN(maxMessageCount) || maxMessageCount < 1) throw new TypeError((0, $f4faabfcfe4aedfc$export$2a7d1d2aeb270d35));
        const messageList = [];
        try {
            const messageBody = {};
            messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).fromSequenceNumber] = (0, $4973e2e602c1cc10$exports.types).wrap_long((0, $6FDNW.Buffer).from(fromSequenceNumber.toBytesBE()));
            messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).messageCount] = (0, $4973e2e602c1cc10$exports.types).wrap_int(maxMessageCount);
            if ((0, $a7961d970a7496cb$export$4e62c701997796c1)(sessionId)) messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).sessionIdMapKey] = sessionId;
            if ((0, $a7961d970a7496cb$export$4e62c701997796c1)(omitMessageBody)) {
                const omitMessageBodyKey = "omit-message-body"; // TODO: Service Bus specific. Put it somewhere
                messageBody[omitMessageBodyKey] = (0, $4973e2e602c1cc10$exports.types).wrap_boolean(omitMessageBody);
            }
            this.ensureUniqueReplyToForRequest();
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: (0, $807770c0815ec6f8$export$a002182e51710d39).operations.peekMessage
                }
            };
            if (options === null || options === void 0 ? void 0 : options.associatedLinkName) request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
            request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).trackingId] = (0, $4973e2e602c1cc10$exports.generate_uuid)();
            // TODO: it'd be nice to attribute this peek request to the actual receiver that made it. So have them pass in a
            // log prefix rather than just falling back to the management links.
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Peek by sequence number request body: %O.", this.logPrefix, request.body);
            const result = await this._makeManagementRequest(request, (0, $f014dc9d393cdf62$export$e0718a134caff0cf), options);
            if (result.application_properties.statusCode !== 204) {
                const messages = result.body.messages;
                for (const msg of messages){
                    const decodedMessage = (0, $4973e2e602c1cc10$exports.message).decode(msg.message);
                    const message = (0, $d7965bb09cbe6503$export$d697904b8f80158a)(decodedMessage, {
                        skipParsingBodyAsJson: (_a = options === null || options === void 0 ? void 0 : options.skipParsingBodyAsJson) !== null && _a !== void 0 ? _a : false,
                        skipConvertingDate: (_b = options === null || options === void 0 ? void 0 : options.skipConvertingDate) !== null && _b !== void 0 ? _b : false
                    });
                    messageList.push(message);
                    this._lastPeekedSequenceNumber = message.sequenceNumber;
                }
            }
        } catch (err) {
            const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${this.logPrefix} An error occurred while sending the request to peek messages to $management endpoint`);
            // statusCode == 404 then do not throw
            if (error.code !== (0, $3d84b7093289460f$export$b65b7fa0413f4b3d)["com.microsoft:message-not-found"]) throw error;
        }
        return messageList;
    }
    /**
     * Renews the lock on the message. The lock will be renewed based on the setting specified on
     * the queue.
     *
     * When a message is received in `PeekLock` mode, the message is locked on the server for this
     * receiver instance for a duration as specified during the Queue/Subscription creation
     * (LockDuration). If processing of the message requires longer than this duration, the
     * lock needs to be renewed. For each renewal, it resets the time the message is locked by the
     * LockDuration set on the Entity.
     *
     * @param lockToken - Lock token of the message
     * @param options - Options that can be set while sending the request.
     * @returns New lock token expiry date and time in UTC format.
     */ // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    async renewLock(lockToken, options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        if (!options) options = {};
        if (options.timeoutInMs == null) options.timeoutInMs = 5000;
        try {
            const messageBody = {};
            messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).lockTokens] = (0, $4973e2e602c1cc10$exports.types).wrap_array([
                (0, $4973e2e602c1cc10$exports.string_to_uuid)(lockToken)
            ], 0x98, undefined);
            this.ensureUniqueReplyToForRequest();
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: (0, $807770c0815ec6f8$export$a002182e51710d39).operations.renewLock
                }
            };
            request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).trackingId] = (0, $4973e2e602c1cc10$exports.generate_uuid)();
            if (options.associatedLinkName) request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).associatedLinkName] = options.associatedLinkName;
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("[%s] Renew message Lock request: %O.", this._context.connectionId, request);
            const result = await this._makeManagementRequest(request, (0, $f014dc9d393cdf62$export$e0718a134caff0cf), {
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
                requestName: "renewLock"
            });
            const lockedUntilUtc = new Date(result.body.expirations[0]);
            return lockedUntilUtc;
        } catch (err) {
            const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
            throw error;
        }
    }
    /**
     * Schedules an array of messages to appear on Service Bus at a later time.
     *
     * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.
     * @param messages - An array of messages that needs to be scheduled.
     * @returns The sequence numbers of messages that were scheduled.
     */ async scheduleMessages(scheduledEnqueueTimeUtc, messages, options) {
        var _a;
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        if (!messages.length) return [];
        const messageBody = [];
        for(let i = 0; i < messages.length; i++){
            const item = messages[i];
            try {
                const rheaMessage = (0, $d7965bb09cbe6503$export$cca86c1f4325d7b8)(item, (0, $6043267107e2d71b$export$317b368fb2b0354d));
                (0, $d7965bb09cbe6503$export$26ddb388a8c85837)(rheaMessage, rheaMessage.message_id || (0, $4973e2e602c1cc10$exports.generate_uuid)());
                (0, $d7965bb09cbe6503$export$c8d318bbbb5351d8)(rheaMessage, scheduledEnqueueTimeUtc);
                const entry = {
                    message: (0, $4973e2e602c1cc10$exports.message).encode(rheaMessage),
                    "message-id": rheaMessage.message_id
                };
                if (rheaMessage.group_id) entry[(0, $807770c0815ec6f8$export$a002182e51710d39).sessionIdMapKey] = rheaMessage.group_id;
                if ((_a = rheaMessage.message_annotations) === null || _a === void 0 ? void 0 : _a[(0, $807770c0815ec6f8$export$a002182e51710d39).partitionKey]) entry["partition-key"] = rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).partitionKey];
                // Will be required later for implementing Transactions
                // if (item.viaPartitionKey) {
                //   entry["via-partition-key"] = item.viaPartitionKey;
                // }
                const wrappedEntry = (0, $4973e2e602c1cc10$exports.types).wrap_map(entry);
                messageBody.push(wrappedEntry);
            } catch (err) {
                const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
                (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(error, `${this.logPrefix} An error occurred while encoding the item at position ${i} in the messages array`);
                throw error;
            }
        }
        this.ensureUniqueReplyToForRequest();
        try {
            const request = {
                body: {
                    messages: messageBody
                },
                reply_to: this.replyTo,
                application_properties: {
                    operation: (0, $807770c0815ec6f8$export$a002182e51710d39).operations.scheduleMessage
                }
            };
            if (options === null || options === void 0 ? void 0 : options.associatedLinkName) request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
            request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).trackingId] = (0, $4973e2e602c1cc10$exports.generate_uuid)();
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).verbose("%s Schedule messages request body: %O.", this.logPrefix, request.body);
            const result = await this._makeManagementRequest(request, (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3), options);
            const sequenceNumbers = result.body[(0, $807770c0815ec6f8$export$a002182e51710d39).sequenceNumbers];
            const sequenceNumbersAsLong = [];
            for(let i = 0; i < sequenceNumbers.length; i++)if (typeof sequenceNumbers[i] === "number") sequenceNumbersAsLong.push((0, (/*@__PURE__*/$parcel$interopDefault($c2bd6b1b7ffc7b0d$exports))).fromNumber(sequenceNumbers[i]));
            else sequenceNumbersAsLong.push((0, (/*@__PURE__*/$parcel$interopDefault($c2bd6b1b7ffc7b0d$exports))).fromBytesBE(sequenceNumbers[i]));
            return sequenceNumbersAsLong;
        } catch (err) {
            const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(error, `${this.logPrefix} An error occurred while sending the request to schedule messages to $management endpoint`);
            throw error;
        }
    }
    /**
     * Cancels an array of messages that were scheduled.
     * @param sequenceNumbers - An Array of sequence numbers of the message to be cancelled.
     */ async cancelScheduledMessages(sequenceNumbers, options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        if (!sequenceNumbers.length) return;
        const messageBody = {};
        messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).sequenceNumbers] = [];
        for(let i = 0; i < sequenceNumbers.length; i++){
            const sequenceNumber = sequenceNumbers[i];
            try {
                messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).sequenceNumbers].push((0, $6FDNW.Buffer).from(sequenceNumber.toBytesBE()));
            } catch (err) {
                const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
                (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(error, `${this.logPrefix} An error occurred while encoding the item at position ${i} in the sequenceNumbers array`);
                throw error;
            }
        }
        try {
            messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).sequenceNumbers] = (0, $4973e2e602c1cc10$exports.types).wrap_array(messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).sequenceNumbers], 0x81, undefined);
            this.ensureUniqueReplyToForRequest();
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: (0, $807770c0815ec6f8$export$a002182e51710d39).operations.cancelScheduledMessage
                }
            };
            if (options === null || options === void 0 ? void 0 : options.associatedLinkName) request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
            request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).trackingId] = (0, $4973e2e602c1cc10$exports.generate_uuid)();
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).verbose("%s Cancel scheduled messages request body: %O.", this.logPrefix, request.body);
            await this._makeManagementRequest(request, (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3), options);
            return;
        } catch (err) {
            const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(error, `${this.logPrefix} An error occurred while sending the request to cancel the scheduled message to $management endpoint`);
            throw error;
        }
    }
    /**
     * Receives a list of deferred messages identified by `sequenceNumbers`.
     *
     * @param sequenceNumbers - A list containing the sequence numbers to receive.
     * @param receiveMode - The mode in which the receiver was created.
     * @returns a list of messages identified by the given sequenceNumbers or an empty list if no messages are found.
     * - Throws an error if the messages have not been deferred.
     */ async receiveDeferredMessages(sequenceNumbers, receiveMode, sessionId, options) {
        var _a;
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        if (!sequenceNumbers.length) return [];
        const messageList = [];
        const messageBody = {};
        messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).sequenceNumbers] = [];
        for(let i = 0; i < sequenceNumbers.length; i++){
            const sequenceNumber = sequenceNumbers[i];
            try {
                messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).sequenceNumbers].push((0, $6FDNW.Buffer).from(sequenceNumber.toBytesBE()));
            } catch (err) {
                const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${this.logPrefix} An error occurred while encoding the item at position ${i} in the sequenceNumbers array`);
                throw error;
            }
        }
        try {
            messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).sequenceNumbers] = (0, $4973e2e602c1cc10$exports.types).wrap_array(messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).sequenceNumbers], 0x81, undefined);
            const receiverSettleMode = receiveMode === "receiveAndDelete" ? 0 : 1;
            messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).receiverSettleMode] = (0, $4973e2e602c1cc10$exports.types).wrap_uint(receiverSettleMode);
            if (sessionId != null) messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).sessionIdMapKey] = sessionId;
            this.ensureUniqueReplyToForRequest();
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: (0, $807770c0815ec6f8$export$a002182e51710d39).operations.receiveBySequenceNumber
                }
            };
            if (options === null || options === void 0 ? void 0 : options.associatedLinkName) request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
            request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).trackingId] = (0, $4973e2e602c1cc10$exports.generate_uuid)();
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Receive deferred messages request body: %O.", this.logPrefix, request.body);
            const result = await this._makeManagementRequest(request, (0, $f014dc9d393cdf62$export$e0718a134caff0cf), options);
            const messages = result.body.messages;
            for (const msg of messages){
                const decodedMessage = (0, $4973e2e602c1cc10$exports.message).decode(msg.message);
                const message = new (0, $d7965bb09cbe6503$export$a482b14703d155cd)(decodedMessage, {
                    tag: msg["lock-token"]
                }, false, receiveMode, (_a = options === null || options === void 0 ? void 0 : options.skipParsingBodyAsJson) !== null && _a !== void 0 ? _a : false, false);
                messageList.push(message);
            }
            return messageList;
        } catch (err) {
            const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${this.logPrefix} An error occurred while sending the request to receive deferred messages to $management endpoint`);
            throw error;
        }
    }
    /**
     * Updates the disposition status of deferred messages.
     *
     * @param lockTokens - Message lock tokens to update disposition status.
     * @param dispositionStatus - The disposition status to be set
     * @param options - Optional parameters that can be provided while updating the disposition status.
     */ async updateDispositionStatus(lockToken, dispositionType, // TODO: mgmt link retry<> will come in the next PR.
    options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        if (!options) options = {};
        try {
            let dispositionStatus;
            if (dispositionType === (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).abandon) dispositionStatus = "abandoned";
            else if (dispositionType === (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).complete) dispositionStatus = "completed";
            else if (dispositionType === (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).defer) dispositionStatus = "defered";
            else if (dispositionType === (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).deadletter) dispositionStatus = "suspended";
            else throw new Error(`Provided "dispositionType" - ${dispositionType} is invalid`);
            const messageBody = {};
            const lockTokenBuffer = [];
            lockTokenBuffer.push((0, $4973e2e602c1cc10$exports.string_to_uuid)(lockToken));
            messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).lockTokens] = (0, $4973e2e602c1cc10$exports.types).wrap_array(lockTokenBuffer, 0x98, undefined);
            messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).dispositionStatus] = dispositionStatus;
            if (options.deadLetterDescription != null) messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).deadLetterDescription] = options.deadLetterDescription;
            if (options.deadLetterReason != null) messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).deadLetterReason] = options.deadLetterReason;
            if (options.propertiesToModify != null) messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).propertiesToModify] = options.propertiesToModify;
            if (options.sessionId != null) messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).sessionIdMapKey] = options.sessionId;
            this.ensureUniqueReplyToForRequest();
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: (0, $807770c0815ec6f8$export$a002182e51710d39).operations.updateDisposition
                }
            };
            if (options.associatedLinkName) request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).associatedLinkName] = options.associatedLinkName;
            request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).trackingId] = (0, $4973e2e602c1cc10$exports.generate_uuid)();
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Update disposition status request body: %O.", this.logPrefix, request.body);
            await this._makeManagementRequest(request, (0, $f014dc9d393cdf62$export$e0718a134caff0cf), options);
        } catch (err) {
            const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${this.logPrefix} An error occurred while sending the request to update disposition status to $management endpoint`);
            throw error;
        }
    }
    /**
     * Renews the lock for the specified session.
     *
     * @param sessionId - Id of the session for which the lock needs to be renewed
     * @param options - Options that can be set while sending the request.
     * @returns New lock token expiry date and time in UTC format.
     */ async renewSessionLock(sessionId, options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        try {
            const messageBody = {};
            messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).sessionIdMapKey] = sessionId;
            this.ensureUniqueReplyToForRequest();
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: (0, $807770c0815ec6f8$export$a002182e51710d39).operations.renewSessionLock
                }
            };
            request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).trackingId] = (0, $4973e2e602c1cc10$exports.generate_uuid)();
            if (options === null || options === void 0 ? void 0 : options.associatedLinkName) request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Renew Session Lock request body: %O.", this.logPrefix, request.body);
            const result = await this._makeManagementRequest(request, (0, $f014dc9d393cdf62$export$e0718a134caff0cf), options);
            const lockedUntilUtc = new Date(result.body.expiration);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Lock for session '%s' will expire at %s.", this.logPrefix, sessionId, lockedUntilUtc.toString());
            return lockedUntilUtc;
        } catch (err) {
            const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
            throw error;
        }
    }
    /**
     * Sets the state of the specified session.
     *
     * @param sessionId - The session for which the state needs to be set
     * @param state - The state that needs to be set.
     */ async setSessionState(sessionId, state, options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        try {
            const messageBody = {};
            messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).sessionIdMapKey] = sessionId;
            messageBody["session-state"] = (0, $3402f46f0a1b2976$export$fc336dbfaf62f18f)(state);
            this.ensureUniqueReplyToForRequest();
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: (0, $807770c0815ec6f8$export$a002182e51710d39).operations.setSessionState
                }
            };
            if (options === null || options === void 0 ? void 0 : options.associatedLinkName) request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
            request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).trackingId] = (0, $4973e2e602c1cc10$exports.generate_uuid)();
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Set Session state request body: %O.", this.logPrefix, request.body);
            await this._makeManagementRequest(request, (0, $f014dc9d393cdf62$export$e0718a134caff0cf), options);
        } catch (err) {
            const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
            throw error;
        }
    }
    /**
     * Gets the state of the specified session.
     *
     * @param sessionId - The session for which the state needs to be retrieved.
     * @returns The state of that session
     */ async getSessionState(sessionId, options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        try {
            const messageBody = {};
            messageBody[(0, $807770c0815ec6f8$export$a002182e51710d39).sessionIdMapKey] = sessionId;
            this.ensureUniqueReplyToForRequest();
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: (0, $807770c0815ec6f8$export$a002182e51710d39).operations.getSessionState
                }
            };
            if (options === null || options === void 0 ? void 0 : options.associatedLinkName) request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).associatedLinkName] = options === null || options === void 0 ? void 0 : options.associatedLinkName;
            request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).trackingId] = (0, $4973e2e602c1cc10$exports.generate_uuid)();
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Get session state request body: %O.", this.logPrefix, request.body);
            const result = await this._makeManagementRequest(request, (0, $f014dc9d393cdf62$export$e0718a134caff0cf), options);
            return result.body["session-state"] ? (0, $6043267107e2d71b$export$2e6ed6a4f6d5b8db)(result.body["session-state"]) : result.body["session-state"];
        } catch (err) {
            const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
            throw error;
        }
    }
    /**
     * Lists the sessions on the ServiceBus Queue/Topic.
     * @param lastUpdateTime - Filter to include only sessions updated after a given time.
     * @param skip - The number of sessions to skip
     * @param top - Maximum numer of sessions.
     * @returns A list of session ids.
     */ async listMessageSessions(skip, top, lastUpdatedTime, options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        const defaultLastUpdatedTimeForListingSessions = 259200000; // 3 * 24 * 3600 * 1000
        if (typeof skip !== "number") throw new Error("'skip' is a required parameter and must be of type 'number'.");
        if (typeof top !== "number") throw new Error("'top' is a required parameter and must be of type 'number'.");
        if (lastUpdatedTime && !(lastUpdatedTime instanceof Date)) throw new Error("'lastUpdatedTime' must be of type 'Date'.");
        if (!lastUpdatedTime) lastUpdatedTime = new Date(Date.now() - defaultLastUpdatedTimeForListingSessions);
        try {
            const messageBody = {};
            messageBody["last-updated-time"] = lastUpdatedTime;
            messageBody["skip"] = (0, $4973e2e602c1cc10$exports.types).wrap_int(skip);
            messageBody["top"] = (0, $4973e2e602c1cc10$exports.types).wrap_int(top);
            this.ensureUniqueReplyToForRequest();
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: (0, $807770c0815ec6f8$export$a002182e51710d39).operations.enumerateSessions
                }
            };
            request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).trackingId] = (0, $4973e2e602c1cc10$exports.generate_uuid)();
            (0, $f014dc9d393cdf62$export$af6f5d5234509fc9).verbose("%s List sessions request body: %O.", this.logPrefix, request.body);
            const response = await this._makeManagementRequest(request, (0, $f014dc9d393cdf62$export$af6f5d5234509fc9), options);
            return response && response.body && response.body["sessions-ids"] || [];
        } catch (err) {
            const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$af6f5d5234509fc9).logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
            throw error;
        }
    }
    /**
     * Get all the rules on the Subscription.
     * @returns A list of rules.
     */ async getRules(options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        try {
            this.ensureUniqueReplyToForRequest();
            const request = {
                body: {
                    top: (options === null || options === void 0 ? void 0 : options.maxCount) ? (0, $4973e2e602c1cc10$exports.types).wrap_int(options.maxCount) : (0, $4973e2e602c1cc10$exports.types).wrap_int((0, $8cc22362d89dbe31$export$84cf8d4e39776cfd)),
                    skip: (options === null || options === void 0 ? void 0 : options.skip) ? (0, $4973e2e602c1cc10$exports.types).wrap_int(options.skip) : (0, $4973e2e602c1cc10$exports.types).wrap_int(0)
                },
                reply_to: this.replyTo,
                application_properties: {
                    operation: (0, $807770c0815ec6f8$export$a002182e51710d39).operations.enumerateRules
                }
            };
            request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).trackingId] = (0, $4973e2e602c1cc10$exports.generate_uuid)();
            (0, $f014dc9d393cdf62$export$af6f5d5234509fc9).verbose("%s Get rules request body: %O.", this.logPrefix, request.body);
            const response = await this._makeManagementRequest(request, (0, $f014dc9d393cdf62$export$af6f5d5234509fc9), options);
            if (response.application_properties.statusCode === 204 || !response.body || !Array.isArray(response.body.rules)) return [];
            // Reference: https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-request-response#response-11
            const result = response.body.rules || [];
            const rules = [];
            result.forEach((x)=>{
                const ruleDescriptor = x["rule-description"];
                let filter;
                // We use the first three elements of the `ruleDescriptor.value` to get filter, action, name
                if (!ruleDescriptor || !ruleDescriptor.descriptor || ruleDescriptor.descriptor.value !== (0, $807770c0815ec6f8$export$a002182e51710d39).descriptorCodes.ruleDescriptionList || !Array.isArray(ruleDescriptor.value) || ruleDescriptor.value.length < 3) return;
                const filtersRawData = ruleDescriptor.value[0];
                const actionsRawData = ruleDescriptor.value[1];
                let sqlRuleAction;
                if (actionsRawData.descriptor.value === (0, $807770c0815ec6f8$export$a002182e51710d39).descriptorCodes.sqlRuleActionList && Array.isArray(actionsRawData.value) && actionsRawData.value.length) sqlRuleAction = {
                    sqlExpression: this._safelyGetTypedValueFromArray(actionsRawData.value, 0)
                };
                else sqlRuleAction = {};
                switch(filtersRawData.descriptor.value){
                    case (0, $807770c0815ec6f8$export$a002182e51710d39).descriptorCodes.trueFilterList:
                        filter = {
                            sqlExpression: "1=1"
                        };
                        break;
                    case (0, $807770c0815ec6f8$export$a002182e51710d39).descriptorCodes.falseFilterList:
                        filter = {
                            sqlExpression: "1=0"
                        };
                        break;
                    case (0, $807770c0815ec6f8$export$a002182e51710d39).descriptorCodes.sqlFilterList:
                        filter = {
                            sqlExpression: this._safelyGetTypedValueFromArray(filtersRawData.value, 0)
                        };
                        break;
                    case (0, $807770c0815ec6f8$export$a002182e51710d39).descriptorCodes.correlationFilterList:
                        filter = {
                            correlationId: this._safelyGetTypedValueFromArray(filtersRawData.value, 0),
                            messageId: this._safelyGetTypedValueFromArray(filtersRawData.value, 1),
                            to: this._safelyGetTypedValueFromArray(filtersRawData.value, 2),
                            replyTo: this._safelyGetTypedValueFromArray(filtersRawData.value, 3),
                            subject: this._safelyGetTypedValueFromArray(filtersRawData.value, 4),
                            sessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 5),
                            replyToSessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 6),
                            contentType: this._safelyGetTypedValueFromArray(filtersRawData.value, 7),
                            applicationProperties: Array.isArray(filtersRawData.value) && filtersRawData.value.length > 8 && filtersRawData.value[8] ? this._decodeApplicationPropertiesMap(filtersRawData.value[8]) : undefined
                        };
                        break;
                    default:
                        throw new Error(`${this.logPrefix} Found unexpected descriptor code for the filter: ${filtersRawData.descriptor.value}`);
                }
                const rule = {
                    name: ruleDescriptor.value[2].value,
                    filter: filter,
                    action: sqlRuleAction
                };
                rules.push(rule);
            });
            return rules;
        } catch (err) {
            const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$af6f5d5234509fc9).logError(error, `${this.logPrefix} An error occurred while sending the get rules request to $management endpoint`);
            throw error;
        }
    }
    /**
     * Removes the rule on the Subscription identified by the given rule name.
     */ async removeRule(ruleName, options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(this._context.connectionId, "ruleName", ruleName);
        ruleName = String(ruleName);
        (0, $f4faabfcfe4aedfc$export$24c1510fe425393c)(this._context.connectionId, "ruleName", ruleName);
        try {
            this.ensureUniqueReplyToForRequest();
            const request = {
                body: {
                    "rule-name": (0, $4973e2e602c1cc10$exports.types).wrap_string(ruleName)
                },
                reply_to: this.replyTo,
                application_properties: {
                    operation: (0, $807770c0815ec6f8$export$a002182e51710d39).operations.removeRule
                }
            };
            request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).trackingId] = (0, $4973e2e602c1cc10$exports.generate_uuid)();
            (0, $f014dc9d393cdf62$export$af6f5d5234509fc9).verbose("%s Remove Rule request body: %O.", this.logPrefix, request.body);
            await this._makeManagementRequest(request, (0, $f014dc9d393cdf62$export$af6f5d5234509fc9), options);
        } catch (err) {
            const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$af6f5d5234509fc9).logError(error, `${this.logPrefix} An error occurred while sending the remove rule request to $management endpoint`);
            throw error;
        }
    }
    /**
     * Adds a rule on the subscription as defined by the given rule name, filter and action
     * @param ruleName - Name of the rule
     * @param filter - A Boolean, SQL expression or a Correlation filter
     * @param sqlRuleActionExpression - Action to perform if the message satisfies the filtering expression
     */ async addRule(ruleName, filter, sqlRuleActionExpression, options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(this._context.connectionId, "ruleName", ruleName);
        ruleName = String(ruleName);
        (0, $f4faabfcfe4aedfc$export$24c1510fe425393c)(this._context.connectionId, "ruleName", ruleName);
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(this._context.connectionId, "filter", filter);
        if (!$066fbc893467d414$var$isSqlRuleFilter(filter) && !$066fbc893467d414$var$isCorrelationRuleFilter(filter)) throw new TypeError(`The parameter "filter" should implement either the SqlRuleFilter or the CorrelationRuleFilter interface.`);
        try {
            const ruleDescription = {};
            if ($066fbc893467d414$var$isSqlRuleFilter(filter)) ruleDescription["sql-filter"] = {
                expression: filter.sqlExpression
            };
            else ruleDescription["correlation-filter"] = {
                "correlation-id": filter.correlationId,
                "message-id": filter.messageId,
                to: filter.to,
                "reply-to": filter.replyTo,
                label: filter.subject,
                "session-id": filter.sessionId,
                "reply-to-session-id": filter.replyToSessionId,
                "content-type": filter.contentType,
                properties: filter.applicationProperties
            };
            if (sqlRuleActionExpression !== undefined) ruleDescription["sql-rule-action"] = {
                expression: String(sqlRuleActionExpression)
            };
            this.ensureUniqueReplyToForRequest();
            const request = {
                body: {
                    "rule-name": (0, $4973e2e602c1cc10$exports.types).wrap_string(ruleName),
                    "rule-description": (0, $4973e2e602c1cc10$exports.types).wrap_map(ruleDescription)
                },
                reply_to: this.replyTo,
                application_properties: {
                    operation: (0, $807770c0815ec6f8$export$a002182e51710d39).operations.addRule
                }
            };
            request.application_properties[(0, $807770c0815ec6f8$export$a002182e51710d39).trackingId] = (0, $4973e2e602c1cc10$exports.generate_uuid)();
            (0, $f014dc9d393cdf62$export$af6f5d5234509fc9).verbose("%s Add Rule request body: %O.", this.logPrefix, request.body);
            await this._makeManagementRequest(request, (0, $f014dc9d393cdf62$export$af6f5d5234509fc9), options);
        } catch (err) {
            const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$af6f5d5234509fc9).logError(error, `${this.logPrefix} An error occurred while sending the Add rule request to $management endpoint`);
            throw error;
        }
    }
    removeLinkFromContext() {
        delete this._context.managementClients[this.name];
    }
}
function $066fbc893467d414$export$704ae820b543adcb(item, scheduledEnqueueTimeUtc) {
    const rheaMessage = (0, $d7965bb09cbe6503$export$cca86c1f4325d7b8)(item, (0, $6043267107e2d71b$export$317b368fb2b0354d));
    (0, $d7965bb09cbe6503$export$26ddb388a8c85837)(rheaMessage, rheaMessage.message_id || (0, $4973e2e602c1cc10$exports.generate_uuid)());
    (0, $d7965bb09cbe6503$export$c8d318bbbb5351d8)(rheaMessage, scheduledEnqueueTimeUtc);
    const entry = {
        message: (0, $4973e2e602c1cc10$exports.message).encode(rheaMessage),
        "message-id": rheaMessage.message_id
    };
    rheaMessage.message_annotations = Object.assign(Object.assign({}, rheaMessage.message_annotations), {
        [(0, $807770c0815ec6f8$export$a002182e51710d39).scheduledEnqueueTime]: scheduledEnqueueTimeUtc
    });
    if (rheaMessage.group_id) entry[(0, $807770c0815ec6f8$export$a002182e51710d39).sessionIdMapKey] = rheaMessage.group_id;
    const partitionKey = rheaMessage.message_annotations && rheaMessage.message_annotations[(0, $807770c0815ec6f8$export$a002182e51710d39).partitionKey];
    if (partitionKey) entry["partition-key"] = partitionKey;
    return entry;
}



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Returns information about the platform this function is being run on.
 * @hidden
 * @internal
 */ function $cf4024a4d84d3c02$export$e9efa9a010653387() {
    const navigator = self.navigator;
    const osInfo = {
        key: "OS",
        value: (navigator.oscpu || navigator.platform).replace(" ", "")
    };
    return `${osInfo.key}/${osInfo.value}`;
}



/**
 * @internal
 * Helper method to call onDetached on the non-sessions batching and streaming receivers from the connection context upon seeing an error.
 */ async function $2818e26e2eb99f0d$var$callOnDetachedOnReceivers(connectionContext, contextOrConnectionError, receiverType) {
    const detachCalls = [];
    // Iterating over non-sessions batching and streaming receivers
    for (const receiverName of Object.keys(connectionContext.messageReceivers)){
        const receiver = connectionContext.messageReceivers[receiverName];
        if (receiver && receiver.receiverType === receiverType) {
            (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose("[%s] calling detached on %s receiver '%s'.", connectionContext.connection.id, receiver.receiverType, receiver.name);
            detachCalls.push(receiver.onDetached(contextOrConnectionError).catch((err)=>{
                (0, $f014dc9d393cdf62$export$5801c71a5905b414).logError(err, "[%s] An error occurred while calling onDetached() on the %s receiver '%s'", connectionContext.connection.id, receiver.receiverType, receiver.name);
            }));
        }
    }
    return Promise.all(detachCalls);
}
/**
 * @internal
 * Helper method to call onDetached on the session receivers from the connection context upon seeing an error.
 */ async function $2818e26e2eb99f0d$var$callOnDetachedOnSessionReceivers(connectionContext, contextOrConnectionError) {
    const getSessionError = (sessionId, entityPath)=>{
        const sessionInfo = `The receiver for session "${sessionId}" in "${entityPath}" has been closed and can no longer be used. ` + `Please create a new receiver using the "acceptSession" or "acceptNextSession" method on the ServiceBusClient.`;
        const errorMessage = contextOrConnectionError == null ? `Unknown error occurred on the AMQP connection while receiving messages. ` + sessionInfo : `Error occurred on the AMQP connection while receiving messages. ` + sessionInfo + `\nMore info - \n${contextOrConnectionError}`;
        const error = new (0, $c6ec964bc6c55a71$export$a7174187385dd2e2)(errorMessage, "SessionLockLost");
        error.retryable = false;
        return error;
    };
    const detachCalls = [];
    for (const receiverName of Object.keys(connectionContext.messageSessions)){
        const receiver = connectionContext.messageSessions[receiverName];
        (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose("[%s] calling detached on %s receiver(sessions).", connectionContext.connection.id, receiver.name);
        detachCalls.push(receiver.onDetached(getSessionError(receiver.sessionId, receiver.entityPath)).catch((err)=>{
            (0, $f014dc9d393cdf62$export$5801c71a5905b414).logError(err, "[%s] An error occurred while calling onDetached() on the session receiver(sessions) '%s'", connectionContext.connection.id, receiver.name);
        }));
    }
    return Promise.all(detachCalls);
}
/**
 * @internal
 * Helper method to get the number of receivers of specified type from the connectionContext.
 */ function $2818e26e2eb99f0d$var$getNumberOfReceivers(connectionContext, receiverType) {
    if (receiverType === "session") {
        const receivers = connectionContext.messageSessions;
        return Object.keys(receivers).length;
    }
    const receivers = connectionContext.messageReceivers;
    const receiverNames = Object.keys(receivers);
    const count = receiverNames.reduce((acc, name)=>receivers[name].receiverType === receiverType ? ++acc : acc, 0);
    return count;
}
var $2818e26e2eb99f0d$export$af54d3055d90c64e;
(function(ConnectionContext) {
    function create(config, tokenCredential, options) {
        var _a;
        if (!options) options = {};
        const userAgent = `${(0, $3402f46f0a1b2976$export$868f6999e4c7a5e7)((_a = options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix)} ${(0, $cf4024a4d84d3c02$export$e9efa9a010653387)()}`;
        const parameters = {
            config: config,
            // re-enabling this will be a post-GA discussion similar to event-hubs.
            // dataTransformer: options.dataTransformer,
            isEntityPathRequired: false,
            connectionProperties: {
                product: "MSJSClient",
                userAgent: userAgent,
                version: (0, $8cc22362d89dbe31$export$8c36c31580f051c6).version
            }
        };
        // Let us create the base context and then add ServiceBus specific ConnectionContext properties.
        const connectionContext = (0, $ef5478def9dddfa3$export$17f3d3e3f5d0e9cb).create(parameters);
        connectionContext.tokenCredential = tokenCredential;
        connectionContext.senders = {};
        connectionContext.messageReceivers = {};
        connectionContext.messageSessions = {};
        connectionContext.managementClients = {};
        let waitForConnectionRefreshResolve;
        let waitForConnectionRefreshPromise;
        Object.assign(connectionContext, {
            isConnectionClosing () {
                // When the connection is not open, but the remote end is open,
                // then the rhea connection is in the process of terminating.
                return Boolean(!this.connection.isOpen() && this.connection.isRemoteOpen());
            },
            async readyToOpenLink () {
                (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`[${this.connectionId}] Waiting until the connection is ready to open link.`);
                // Check that the connection isn't in the process of closing.
                // This can happen when the idle timeout has been reached but
                // the underlying socket is waiting to be destroyed.
                if (this.isConnectionClosing()) {
                    (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`[${this.connectionId}] Connection is closing, waiting for disconnected event`);
                    // Wait for the disconnected event that indicates the underlying socket has closed.
                    await this.waitForDisconnectedEvent();
                }
                // Wait for the connection to be reset.
                await this.waitForConnectionReset();
                (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`[${this.connectionId}] Connection is ready to open link.`);
            },
            waitForDisconnectedEvent () {
                return new Promise((resolve)=>{
                    (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`[${this.connectionId}] Attempting to reinitialize connection` + ` but the connection is in the process of closing.` + ` Waiting for the disconnect event before continuing.`);
                    this.connection.once((0, $4973e2e602c1cc10$exports.ConnectionEvents).disconnected, resolve);
                });
            },
            waitForConnectionReset () {
                // Check if the connection is currently in the process of disconnecting.
                if (waitForConnectionRefreshPromise) {
                    (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`[${this.connectionId}] Waiting for connection reset`);
                    return waitForConnectionRefreshPromise;
                }
                (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`[${this.connectionId}] Connection not waiting to be reset. Resolving immediately.`);
                return Promise.resolve();
            },
            getReceiverFromCache (receiverName, sessionId) {
                if (sessionId != null && this.messageSessions[receiverName]) return this.messageSessions[receiverName];
                if (this.messageReceivers[receiverName]) return this.messageReceivers[receiverName];
                let existingReceivers = "";
                if (sessionId != null) {
                    for (const messageSessionName of Object.keys(this.messageSessions))if (this.messageSessions[messageSessionName].sessionId === sessionId) {
                        existingReceivers = this.messageSessions[messageSessionName].name;
                        break;
                    }
                } else existingReceivers += (existingReceivers ? ", " : "") + Object.keys(this.messageReceivers).join(",");
                (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose("[%s] Failed to find receiver '%s' among existing receivers: %s", this.connectionId, receiverName, existingReceivers);
                return;
            },
            getManagementClient (entityPath) {
                if (!this.managementClients[entityPath]) this.managementClients[entityPath] = new (0, $066fbc893467d414$export$72fc7afd6c6b156a)(this, entityPath, {
                    address: `${entityPath}/$management`
                });
                return this.managementClients[entityPath];
            }
        });
        // Define listeners to be added to the connection object for
        // "connection_open" and "connection_error" events.
        const onConnectionOpen = ()=>{
            connectionContext.wasConnectionCloseCalled = false;
            (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose("[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.", connectionContext.connection.id, connectionContext.wasConnectionCloseCalled);
        };
        const disconnected = async (context)=>{
            if (waitForConnectionRefreshPromise) return;
            waitForConnectionRefreshPromise = new Promise((resolve)=>{
                waitForConnectionRefreshResolve = resolve;
            });
            const connectionError = context.connection && context.connection.error ? context.connection.error : undefined;
            if (connectionError) (0, $f014dc9d393cdf62$export$5801c71a5905b414).logError(connectionError, "[%s] Error (context.connection.error) occurred on the amqp connection", connectionContext.connection.id);
            const contextError = context.error;
            if (contextError) (0, $f014dc9d393cdf62$export$5801c71a5905b414).logError(contextError, "[%s] Error (context.error) occurred on the amqp connection", connectionContext.connection.id);
            const state = {
                wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,
                numSenders: Object.keys(connectionContext.senders).length,
                numReceivers: Object.keys(connectionContext.messageReceivers).length + Object.keys(connectionContext.messageSessions).length
            };
            // Clear internal map maintained by rhea to avoid reconnecting of old links once the
            // connection is back up.
            connectionContext.connection.removeAllSessions();
            // Close the cbs session to ensure all the event handlers are released.
            await connectionContext.cbsSession.close();
            // Close the management sessions to ensure all the event handlers are released.
            for (const entityPath of Object.keys(connectionContext.managementClients))await connectionContext.managementClients[entityPath].close();
            if (state.wasConnectionCloseCalled) ;
            else {
                // Calling onDetached on sender
                if (state.numSenders) {
                    // We don't do recovery for the sender:
                    //   Because we don't want to keep the sender active all the time
                    //   and the "next" send call would bear the burden of creating the link.
                    // Call onDetached() on sender so that it can gracefully shutdown
                    //   by cleaning up the timers and closing the links.
                    // We don't call onDetached for sender after `refreshConnection()`
                    //   because any new send calls that potentially initialize links would also get affected if called later.
                    (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${state.numSenders} ` + `senders. We should not reconnect.`);
                    const detachCalls = [];
                    for (const senderName of Object.keys(connectionContext.senders)){
                        const sender = connectionContext.senders[senderName];
                        if (sender) {
                            (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose("[%s] calling detached on sender '%s'.", connectionContext.connection.id, sender.name);
                            detachCalls.push(sender.onDetached().catch((err)=>{
                                (0, $f014dc9d393cdf62$export$5801c71a5905b414).logError(err, "[%s] An error occurred while calling onDetached() the sender '%s'", connectionContext.connection.id, sender.name);
                            }));
                        }
                    }
                    await Promise.all(detachCalls);
                }
                // Calling onDetached on batching receivers for the same reasons as sender
                const numBatchingReceivers = $2818e26e2eb99f0d$var$getNumberOfReceivers(connectionContext, "batching");
                if (numBatchingReceivers) {
                    (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numBatchingReceivers} ` + `batching receivers. We should not reconnect.`);
                    // Call onDetached() on receivers so that batching receivers it can gracefully close any ongoing batch operation
                    await $2818e26e2eb99f0d$var$callOnDetachedOnReceivers(connectionContext, connectionError || contextError, "batching");
                }
                // Calling onDetached on session receivers
                const numSessionReceivers = $2818e26e2eb99f0d$var$getNumberOfReceivers(connectionContext, "session");
                if (numSessionReceivers) {
                    (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numSessionReceivers} ` + `session receivers. We should close them.`);
                    await $2818e26e2eb99f0d$var$callOnDetachedOnSessionReceivers(connectionContext, connectionError || contextError);
                }
            }
            await refreshConnection();
            waitForConnectionRefreshResolve();
            waitForConnectionRefreshPromise = undefined;
            // The connection should always be brought back up if the sdk did not call connection.close()
            // and there was at least one receiver link on the connection before it went down.
            (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose("[%s] state: %O", connectionContext.connectionId, state);
            // Calling onDetached on streaming receivers
            const numStreamingReceivers = $2818e26e2eb99f0d$var$getNumberOfReceivers(connectionContext, "streaming");
            if (!state.wasConnectionCloseCalled && numStreamingReceivers) {
                (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numStreamingReceivers} ` + `streaming receivers. We should reconnect.`);
                // Calling `onDetached()` on streaming receivers after the refreshConnection() since `onDetached()` would
                // recover the streaming receivers and that would only be possible after the connection is refreshed.
                //
                // This is different from the batching receiver since `onDetached()` for the batching receiver would
                // return the outstanding messages and close the receive link.
                await $2818e26e2eb99f0d$var$callOnDetachedOnReceivers(connectionContext, connectionError || contextError, "streaming");
            }
        };
        const protocolError = async (context)=>{
            if (context.connection && context.connection.error) (0, $f014dc9d393cdf62$export$5801c71a5905b414).logError(context.connection.error, "[%s] Error (context.connection.error) occurred on the amqp connection", connectionContext.connection.id);
            if (context.error) (0, $f014dc9d393cdf62$export$5801c71a5905b414).logError(context.error, "[%s] Error (context.error) occurred on the amqp connection", connectionContext.connection.id);
        };
        const error = async (context)=>{
            if (context.connection && context.connection.error) (0, $f014dc9d393cdf62$export$5801c71a5905b414).logError(context.connection.error, "[%s] Error (context.connection.error) occurred on the amqp connection", connectionContext.connection.id);
            if (context.error) (0, $f014dc9d393cdf62$export$5801c71a5905b414).logError(context.error, "[%s] Error (context.error) occurred on the amqp connection", connectionContext.connection.id);
        };
        async function refreshConnection() {
            const originalConnectionId = connectionContext.connectionId;
            try {
                await cleanConnectionContext();
            } catch (err) {
                (0, $f014dc9d393cdf62$export$5801c71a5905b414).logError(err, `[${connectionContext.connectionId}] There was an error closing the connection before reconnecting`);
            }
            // Create a new connection, id, locks, and cbs client.
            connectionContext.refreshConnection();
            addConnectionListeners(connectionContext.connection);
            (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`The connection "${originalConnectionId}" has been updated to "${connectionContext.connectionId}".`);
        }
        function addConnectionListeners(connection) {
            // Add listeners on the connection object.
            connection.on((0, $4973e2e602c1cc10$exports.ConnectionEvents).connectionOpen, onConnectionOpen);
            connection.on((0, $4973e2e602c1cc10$exports.ConnectionEvents).disconnected, disconnected);
            connection.on((0, $4973e2e602c1cc10$exports.ConnectionEvents).protocolError, protocolError);
            connection.on((0, $4973e2e602c1cc10$exports.ConnectionEvents).error, error);
        }
        async function cleanConnectionContext() {
            // Remove listeners from the connection object.
            connectionContext.connection.removeListener((0, $4973e2e602c1cc10$exports.ConnectionEvents).connectionOpen, onConnectionOpen);
            connectionContext.connection.removeListener((0, $4973e2e602c1cc10$exports.ConnectionEvents).disconnected, disconnected);
            connectionContext.connection.removeListener((0, $4973e2e602c1cc10$exports.ConnectionEvents).protocolError, protocolError);
            connectionContext.connection.removeListener((0, $4973e2e602c1cc10$exports.ConnectionEvents).error, error);
            // Close the connection
            await connectionContext.connection.close();
        }
        addConnectionListeners(connectionContext.connection);
        (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose("[%s] Created connection context successfully.", connectionContext.connectionId);
        return connectionContext;
    }
    ConnectionContext.create = create;
    /**
     * Closes the AMQP connection created by this ServiceBusClient along with AMQP links for
     * sender/receivers created by the queue/topic/subscription clients created by this
     * ServiceBusClient.
     * Once closed,
     * - the clients created by this ServiceBusClient cannot be used to send/receive messages anymore.
     * - this ServiceBusClient cannot be used to create any new queues/topics/subscriptions clients.
     */ async function close(context) {
        const logPrefix = `[${context.connectionId}]`;
        try {
            (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`${logPrefix} Permanently closing the amqp connection on the client.`);
            const senderNames = Object.keys(context.senders);
            const messageReceiverNames = Object.keys(context.messageReceivers);
            const messageSessionNames = Object.keys(context.messageSessions);
            const managementClientsEntityPaths = Object.keys(context.managementClients);
            (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`${logPrefix} Permanently closing all the senders(${senderNames.length}), MessageReceivers(${messageReceiverNames.length}), MessageSessions(${messageSessionNames.length}), and ManagementClients(${managementClientsEntityPaths.length}).`);
            await Promise.all([
                ...senderNames.map((n)=>context.senders[n].close()),
                ...messageReceiverNames.map((n)=>context.messageReceivers[n].close()),
                ...messageSessionNames.map((n)=>context.messageSessions[n].close()),
                ...managementClientsEntityPaths.map((p)=>context.managementClients[p].close())
            ]);
            (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`${logPrefix} Permanently closing cbsSession`);
            await context.cbsSession.close();
            (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`${logPrefix} Permanently closing internal connection`);
            await context.connection.close();
            context.wasConnectionCloseCalled = true;
            (0, $f014dc9d393cdf62$export$5801c71a5905b414).verbose(`[${logPrefix} Permanently closed the amqp connection on the client.`);
        } catch (err) {
            const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));
            (0, $f014dc9d393cdf62$export$5801c71a5905b414).logError(err, `${logPrefix} An error occurred while closing the connection`);
            throw errObj;
        }
    }
    ConnectionContext.close = close;
})($2818e26e2eb99f0d$export$af54d3055d90c64e || ($2818e26e2eb99f0d$export$af54d3055d90c64e = {}));


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

function $fb8bf6f006d93be9$export$7b10bf5edda69ef(connectionString) {
    const parsedResult = (0, $29b64d391bfe12b4$export$6369f286b474466d)(connectionString);
    if (!parsedResult.Endpoint) throw new Error("Connection string should have an Endpoint key.");
    if (parsedResult.SharedAccessSignature) {
        if (parsedResult.SharedAccessKey || parsedResult.SharedAccessKeyName) throw new Error("Connection string cannot have both SharedAccessSignature and SharedAccessKey keys.");
    } else if (parsedResult.SharedAccessKey && !parsedResult.SharedAccessKeyName) throw new Error("Connection string with SharedAccessKey should have SharedAccessKeyName.");
    else if (!parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) throw new Error("Connection string with SharedAccessKeyName should have SharedAccessKey as well.");
    const output = {
        fullyQualifiedNamespace: (parsedResult.Endpoint.match(".*://([^/]*)") || [])[1],
        endpoint: parsedResult.Endpoint
    };
    if (parsedResult.EntityPath) output.entityPath = parsedResult.EntityPath;
    if (parsedResult.SharedAccessSignature) output.sharedAccessSignature = parsedResult.SharedAccessSignature;
    if (parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {
        output.sharedAccessKey = parsedResult.SharedAccessKey;
        output.sharedAccessKeyName = parsedResult.SharedAccessKeyName;
    }
    return output;
}


function $7d8eaab9edb7677c$export$d444a365980dc194(endpoint) {
    const hostMatch = endpoint.match(/.*:\/\/([^/]*)/);
    if (!hostMatch) throw new TypeError(`Invalid endpoint missing host: ${endpoint}`);
    const [, host] = hostMatch;
    const [hostname, port] = host.split(":");
    return {
        host: host,
        hostname: hostname,
        port: port
    };
}
/**
 * Updates the provided ConnectionConfig to use the custom endpoint address.
 * @param config - An existing connection configuration to be updated.
 * @param customEndpointAddress - The custom endpoint address to use.
 */ function $7d8eaab9edb7677c$var$setCustomEndpointAddress(config, customEndpointAddress) {
    // The amqpHostname should match the host prior to using the custom endpoint.
    config.amqpHostname = config.host;
    const { hostname: hostname , port: port  } = $7d8eaab9edb7677c$export$d444a365980dc194(customEndpointAddress);
    // Since we specify the port separately, set host to the customEndpointAddress hostname.
    config.host = hostname;
    if (port) config.port = parseInt(port, 10);
}
function $7d8eaab9edb7677c$export$8069d52fa4374515(connectionString, credential, options) {
    var _a, _b;
    const config = (0, $12a9a1e1ce930860$export$33fc4efe54a49ad2).create(connectionString);
    config.webSocket = (_a = options === null || options === void 0 ? void 0 : options.webSocketOptions) === null || _a === void 0 ? void 0 : _a.webSocket;
    config.webSocketEndpointPath = "$servicebus/websocket";
    config.webSocketConstructorOptions = (_b = options === null || options === void 0 ? void 0 : options.webSocketOptions) === null || _b === void 0 ? void 0 : _b.webSocketConstructorOptions;
    if (options === null || options === void 0 ? void 0 : options.customEndpointAddress) $7d8eaab9edb7677c$var$setCustomEndpointAddress(config, options.customEndpointAddress);
    return (0, $2818e26e2eb99f0d$export$af54d3055d90c64e).create(config, credential, options);
}
function $7d8eaab9edb7677c$export$ab02efcdbbb2a67f(connectionString, options = {}) {
    const parsed = (0, $fb8bf6f006d93be9$export$7b10bf5edda69ef)(connectionString);
    const sasTokenProvider = (0, $2b2ee06118a0ba22$export$cd7ed918a1ce0ac)(parsed);
    return $7d8eaab9edb7677c$export$8069d52fa4374515(connectionString, sasTokenProvider, options);
}
function $7d8eaab9edb7677c$export$93bb568e3dbacc71(credential, host, options = {}) {
    if (typeof host !== "string") throw new TypeError("`host` parameter is not a string");
    let tokenProvider;
    // host, credential and options based constructor was invoked
    if (!host.endsWith("/")) host += "/";
    if ((0, $720970adf00c6270$export$9117b72f7d656ea5)(credential) || (0, $c156b569e523edc4$export$3b616d4df4414a6e)(credential)) tokenProvider = (0, $2b2ee06118a0ba22$export$cd7ed918a1ce0ac)(credential);
    else tokenProvider = credential;
    const connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;`;
    return $7d8eaab9edb7677c$export$8069d52fa4374515(connectionString, tokenProvider, options);
}
function $7d8eaab9edb7677c$export$da9938f57f3e8de5(connectionString) {
    const entityPathMatch = connectionString.match(/^.+EntityPath=(.+?);{0,1}$/);
    if (entityPathMatch != null && entityPathMatch.length === 2) return entityPathMatch[1];
    else throw new Error("No entity name present in the connection string");
}



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.





// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.



function $93fbc5f601f11887$export$a3b49e7a5b7540c(logPrefix, delivery, deliveryDispositionMap) {
    if (delivery) {
        const id = delivery.id;
        const state = delivery.remote_state;
        const settled = delivery.remote_settled;
        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Delivery with id %d, remote_settled: %s, remote_state: %o has been received.", logPrefix, id, settled, state && state.error ? state.error : state);
        if (settled && deliveryDispositionMap.has(id)) {
            const promise = deliveryDispositionMap.get(id);
            clearTimeout(promise.timer);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Found the delivery with id %d in the map and cleared the timer.", logPrefix, id);
            const deleteResult = deliveryDispositionMap.delete(id);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Successfully deleted the delivery with id %d from the map.", logPrefix, id, deleteResult);
            if (state && state.error && (state.error.condition || state.error.description)) {
                const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(state.error);
                return promise.reject(error);
            }
            return promise.resolve();
        }
    }
}
// Placed in Service Bus for now and can be promoted to core-amqp if also useful for Event Hubs in the future.
const $93fbc5f601f11887$var$timeoutName = `${(0, $807770c0815ec6f8$export$a002182e51710d39).vendorString}:timeout`;
function $93fbc5f601f11887$export$fcc21102ff437d0e(name, receiveMode, source, clientId, handlers, timeoutInMs) {
    const properties = timeoutInMs !== undefined ? {
        [(0, $807770c0815ec6f8$export$a002182e51710d39).receiverIdentifierName]: clientId,
        [$93fbc5f601f11887$var$timeoutName]: timeoutInMs
    } : {
        [(0, $807770c0815ec6f8$export$a002182e51710d39).receiverIdentifierName]: clientId
    };
    const rcvrOptions = Object.assign({
        name: name,
        // "autoaccept" being true in the "receiveAndDelete" mode sets the "settled" flag to true on the deliveries
        // which helps in clearing the circular buffer(size=2048) as it is needed to receive messages after 2048 of them are received.
        autoaccept: receiveMode === "receiveAndDelete" ? true : false,
        // receiveAndDelete -> first(0), peekLock -> second (1)
        rcv_settle_mode: receiveMode === "receiveAndDelete" ? 0 : 1,
        // receiveAndDelete -> settled (1), peekLock -> unsettled (0)
        snd_settle_mode: receiveMode === "receiveAndDelete" ? 1 : 0,
        source: source,
        target: clientId,
        credit_window: 0,
        properties: properties
    }, handlers);
    return rcvrOptions;
}



class $9a38b32fea5afae9$export$e3d8ffa5f5c3660f extends (0, $12c81f6e1047261d$export$3ba4e37e9c27f9bb) {
    constructor(identifier, context, entityPath, receiverType, options){
        super(entityPath, entityPath, context, receiverType, (0, $f014dc9d393cdf62$export$e0718a134caff0cf), {
            address: entityPath,
            audience: `${context.config.endpoint}${entityPath}`
        });
        this.identifier = identifier;
        /**
         * Maintains a map of deliveries that
         * are being actively disposed. It acts as a store for correlating the responses received for
         * active dispositions.
         */ this._deliveryDispositionMap = new Map();
        this.receiverType = receiverType;
        this.receiveMode = options.receiveMode || "peekLock";
        // If explicitly set to false then autoComplete is false else true (default).
        this.autoComplete = options.autoCompleteMessages === false ? options.autoCompleteMessages : true;
        this._lockRenewer = options.lockRenewer;
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     */ _createReceiverOptions(useNewName, handlers) {
        const rcvrOptions = (0, $93fbc5f601f11887$export$fcc21102ff437d0e)(useNewName ? (0, $3402f46f0a1b2976$export$798a797a6d4e253e)(this.baseName) : this.name, this.receiveMode, {
            address: this.address
        }, this.identifier, Object.assign({
            onSettled: (context)=>{
                return (0, $93fbc5f601f11887$export$a3b49e7a5b7540c)(this.logPrefix, context.delivery, this._deliveryDispositionMap);
            }
        }, handlers));
        return rcvrOptions;
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     */ async _init(options, abortSignal) {
        try {
            await this.initLink(options, abortSignal);
            // It is possible for someone to close the receiver and then start it again.
            // Thus make sure that the receiver is present in the client cache.
            this._context.messageReceivers[this.name] = this;
        } catch (err) {
            const translatedError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(translatedError, "%s An error occured while creating the receiver", this.logPrefix);
            // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.
            if (translatedError.code === "OperationTimeoutError") translatedError.message = "Failed to create a receiver within allocated time and retry attempts.";
            throw translatedError;
        }
    }
    createRheaLink(options, _abortSignal) {
        return this._context.connection.createReceiver(options);
    }
    /**
     * Clears lock renewal timers on all active messages, clears token remewal for current receiver,
     * removes current MessageReceiver instance from cache, and closes the underlying AMQP receiver.
     * @returns Promise<void>.
     */ async close() {
        var _a;
        (_a = this._lockRenewer) === null || _a === void 0 || _a.stopAll(this);
        await super.close();
    }
    /**
     * Settles the message with the specified disposition.
     * @param message - The ServiceBus Message that needs to be settled.
     * @param operation - The disposition type.
     * @param options - Optional parameters that can be provided while disposing the message.
     */ async settleMessage(message, operation, options) {
        return new Promise((resolve, reject)=>{
            var _a, _b, _c;
            if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) return reject(new Error(`operation: '${operation}' is not a valid operation.`));
            (_a = this._lockRenewer) === null || _a === void 0 || _a.stop(this, message);
            const delivery = message.delivery;
            const timer = setTimeout(()=>{
                this._deliveryDispositionMap.delete(delivery.id);
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Disposition for delivery id: %d, did not complete in %d milliseconds. Hence rejecting the promise with timeout error.", this.logPrefix, delivery.id, (0, $807770c0815ec6f8$export$a002182e51710d39).defaultOperationTimeoutInMs);
                const e = {
                    condition: (0, $3d84b7093289460f$export$65de4560c7cb6642).ServiceUnavailableError,
                    description: "Operation to settle the message has timed out. The disposition of the message may or may not be successful"
                };
                return reject((0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(e));
            }, (_c = (_b = options.retryOptions) === null || _b === void 0 ? void 0 : _b.timeoutInMs) !== null && _c !== void 0 ? _c : (0, $807770c0815ec6f8$export$a002182e51710d39).defaultOperationTimeoutInMs);
            this._deliveryDispositionMap.set(delivery.id, {
                resolve: resolve,
                reject: reject,
                timer: timer
            });
            if (operation === (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).complete) delivery.accept();
            else if (operation === (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).abandon) {
                const params = {
                    undeliverable_here: false
                };
                if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;
                delivery.modified(params);
            } else if (operation === (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).defer) {
                const params = {
                    undeliverable_here: true
                };
                if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;
                delivery.modified(params);
            } else if (operation === (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).deadletter) {
                const error = {
                    condition: (0, $807770c0815ec6f8$export$a002182e51710d39).deadLetterName,
                    info: Object.assign(Object.assign({}, options.propertiesToModify), {
                        DeadLetterReason: options.deadLetterReason,
                        DeadLetterErrorDescription: options.deadLetterDescription
                    })
                };
                delivery.reject(error);
            }
        });
    }
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.




class $3b2f2ffa8f8d3149$export$c9e7a1bffd742ae {
    constructor(_getCurrentReceiver){
        this._getCurrentReceiver = _getCurrentReceiver;
        this._isSuspended = true;
    }
    _getCurrentReceiverOrError() {
        const currentReceiverData = this._getCurrentReceiver();
        if (currentReceiverData.receiver == null) return "is undefined";
        if (!currentReceiverData.receiver.isOpen()) return "is not open";
        if (this._isSuspended) return "is suspended";
        return currentReceiverData;
    }
    /**
     * Adds credits to the receiver, respecting any state that
     * indicates the receiver is closed or should not continue
     * to receive more messages.
     *
     * @param credits - Number of credits to add.
     * or `stopReceivingMessages` has been called.
     */ addCredit(credits) {
        const currentReceiverOrError = this._getCurrentReceiverOrError();
        if (typeof currentReceiverOrError === "string") {
            const errorMessage = `Cannot request messages on the receiver since it ${currentReceiverOrError}.`;
            if (currentReceiverOrError === "is suspended") // if a user has suspended the receiver we should consider this a non-retryable
            // error since it absolutely requires user intervention.
            throw new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)(errorMessage);
            throw new (0, $c6ec964bc6c55a71$export$a7174187385dd2e2)(errorMessage, "GeneralError");
        }
        if (currentReceiverOrError.receiver != null) {
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${currentReceiverOrError.logPrefix} Adding ${credits} credits`);
            currentReceiverOrError.receiver.addCredit(credits);
        }
    }
    /**
     * Drains the credits for the receiver and prevents the `receiverHelper.addCredit()` method from adding credits.
     * Call `resume()` to enable the `addCredit()` method.
     */ async suspend() {
        const { receiver: receiver , logPrefix: logPrefix  } = this._getCurrentReceiver();
        this._isSuspended = true;
        if (!this._isValidReceiver(receiver)) return;
        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${logPrefix} User has requested to stop receiving new messages, attempting to drain.`);
        return this.drain();
    }
    /**
     * Resets tracking so `addCredit` works again by toggling the `_isSuspended` flag.
     */ resume() {
        this._isSuspended = false;
    }
    isSuspended() {
        return this._isSuspended;
    }
    /**
     * Initiates a drain for the current receiver and resolves when
     * the drain has completed.
     *
     * NOTE: This method returns immediately if the receiver is not valid or if there
     * are no pending credits on the receiver (ie: `receiver.credit === 0`).
     */ async drain() {
        const { receiver: receiver , logPrefix: logPrefix  } = this._getCurrentReceiver();
        if (!this._isValidReceiver(receiver)) // TODO: should we throw?
        return;
        if (receiver.credit === 0) // nothing to drain
        return;
        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${logPrefix} Receiver is starting drain. Remaining credits; ${receiver.credit}`);
        const drainPromise = new Promise((resolve)=>{
            receiver.once((0, $4973e2e602c1cc10$exports.ReceiverEvents).receiverDrained, ()=>{
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${logPrefix} Receiver has been drained.`);
                receiver.drain = false;
                resolve();
            });
            receiver.drainCredit();
        });
        return drainPromise;
    }
    _isValidReceiver(receiver) {
        return receiver != null && receiver.isOpen();
    }
}



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint-disable eqeqeq */ 

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Checks whether a network connection is detected.
 * @internal
 */ function $c39f0dfb421bb968$export$275ef79ad735a490() {
    return Promise.resolve(self.navigator.onLine);
}




/**
 * Determines whether the object is a Delivery object.
 * @internal
 */ function $da0e8ee01baeae47$var$isDelivery(obj) {
    let result = false;
    if (obj && typeof obj.id === "number" && typeof obj.settled === "boolean" && typeof obj.remote_settled === "boolean" && typeof obj.format === "number") result = true;
    return result;
}
var $da0e8ee01baeae47$export$56412ee12c2689b3;
(function(RetryMode) {
    RetryMode[RetryMode["Exponential"] = 0] = "Exponential";
    RetryMode[RetryMode["Fixed"] = 1] = "Fixed";
})($da0e8ee01baeae47$export$56412ee12c2689b3 || ($da0e8ee01baeae47$export$56412ee12c2689b3 = {}));
var $da0e8ee01baeae47$export$f9f3e456e3c6243f;
(function(RetryOperationType) {
    RetryOperationType["cbsAuth"] = "cbsAuth";
    RetryOperationType["connection"] = "connection";
    RetryOperationType["management"] = "management";
    RetryOperationType["receiverLink"] = "receiverLink";
    RetryOperationType["senderLink"] = "senderLink";
    RetryOperationType["sendMessage"] = "sendMessage";
    RetryOperationType["receiveMessage"] = "receiveMessage";
    RetryOperationType["session"] = "session";
    RetryOperationType["messageSettlement"] = "settlement";
})($da0e8ee01baeae47$export$f9f3e456e3c6243f || ($da0e8ee01baeae47$export$f9f3e456e3c6243f = {}));
/**
 * Validates the retry config.
 * @internal
 */ function $da0e8ee01baeae47$var$validateRetryConfig(config) {
    if (!config.operation) throw new TypeError("Missing 'operation' in retry configuration");
    if (!config.connectionId) throw new TypeError("Missing 'connectionId' in retry configuration");
    if (!config.operationType) throw new TypeError("Missing 'operationType' in retry configuration");
}
/**
 * Calculates delay between retries, in milliseconds.
 * @internal
 */ function $da0e8ee01baeae47$var$calculateDelay(attemptCount, retryDelayInMs, maxRetryDelayInMs, mode) {
    if (mode === $da0e8ee01baeae47$export$56412ee12c2689b3.Exponential) {
        const boundedRandDelta = retryDelayInMs * 0.8 + Math.floor(Math.random() * (retryDelayInMs * 1.2 - retryDelayInMs * 0.8));
        const incrementDelta = boundedRandDelta * (Math.pow(2, attemptCount) - 1);
        return Math.min(incrementDelta, maxRetryDelayInMs);
    }
    return retryDelayInMs;
}
async function $da0e8ee01baeae47$export$9369b12211e1fce4(config) {
    $da0e8ee01baeae47$var$validateRetryConfig(config);
    if (!config.retryOptions) config.retryOptions = {};
    if (config.retryOptions.maxRetries == undefined || config.retryOptions.maxRetries < 0) config.retryOptions.maxRetries = (0, $807770c0815ec6f8$export$a002182e51710d39).defaultMaxRetries;
    if (config.retryOptions.retryDelayInMs == undefined || config.retryOptions.retryDelayInMs < 0) config.retryOptions.retryDelayInMs = (0, $807770c0815ec6f8$export$a002182e51710d39).defaultDelayBetweenOperationRetriesInMs;
    if (config.retryOptions.maxRetryDelayInMs == undefined || config.retryOptions.maxRetryDelayInMs < 0) config.retryOptions.maxRetryDelayInMs = (0, $807770c0815ec6f8$export$a002182e51710d39).defaultMaxDelayForExponentialRetryInMs;
    if (config.retryOptions.mode == undefined) config.retryOptions.mode = $da0e8ee01baeae47$export$56412ee12c2689b3.Fixed;
    let lastError;
    let result;
    let success = false;
    const totalNumberOfAttempts = config.retryOptions.maxRetries + 1;
    for(let i = 1; i <= totalNumberOfAttempts; i++){
        (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] Attempt number for '%s': %d.", config.connectionId, config.operationType, i);
        try {
            result = await config.operation();
            success = true;
            (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] Success for '%s', after attempt number: %d.", config.connectionId, config.operationType, i);
            if (result && !$da0e8ee01baeae47$var$isDelivery(result)) (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] Success result for '%s': %O", config.connectionId, config.operationType, result);
            break;
        } catch (_err) {
            let err = _err;
            if (!err.translated) err = (0, $3d84b7093289460f$export$d73ee8ef04f5226a)(err);
            if (!err.retryable && err.name === "ServiceCommunicationError" && config.connectionHost) {
                const isConnected = await (0, $c39f0dfb421bb968$export$275ef79ad735a490)(config.connectionHost);
                if (!isConnected) {
                    err.name = "ConnectionLostError";
                    err.retryable = true;
                }
            }
            lastError = err;
            (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] Error occurred for '%s' in attempt number %d: %O", config.connectionId, config.operationType, i, err);
            if (lastError && lastError.retryable && totalNumberOfAttempts > i) {
                const targetDelayInMs = $da0e8ee01baeae47$var$calculateDelay(i, config.retryOptions.retryDelayInMs, config.retryOptions.maxRetryDelayInMs, config.retryOptions.mode);
                (0, $36f34de7efabe9df$export$af88d00dbe7f521).verbose("[%s] Sleeping for %d milliseconds for '%s'.", config.connectionId, targetDelayInMs, config.operationType);
                await (0, $29b64d391bfe12b4$export$1391212d75b2ee65)(targetDelayInMs, config.abortSignal, `The retry operation has been cancelled by the user.`);
                continue;
            } else break;
        }
    }
    if (success) return result;
    else throw lastError;
}





// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.






// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


const $b8a2d14549c57ac7$var$StandardAbortMessage = "The operation was aborted.";
function $b8a2d14549c57ac7$export$1391212d75b2ee65(timeInMs, options) {
    return new Promise((resolve, reject)=>{
        let timer = undefined;
        let onAborted = undefined;
        const rejectOnAbort = ()=>{
            var _a;
            return reject(new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)((_a = options === null || options === void 0 ? void 0 : options.abortErrorMsg) !== null && _a !== void 0 ? _a : $b8a2d14549c57ac7$var$StandardAbortMessage));
        };
        const removeListeners = ()=>{
            if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) options.abortSignal.removeEventListener("abort", onAborted);
        };
        onAborted = ()=>{
            if ((0, $a7961d970a7496cb$export$4e62c701997796c1)(timer)) clearTimeout(timer);
            removeListeners();
            return rejectOnAbort();
        };
        if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) return rejectOnAbort();
        timer = setTimeout(()=>{
            removeListeners();
            resolve();
        }, timeInMs);
        if (options === null || options === void 0 ? void 0 : options.abortSignal) options.abortSignal.addEventListener("abort", onAborted);
    });
}



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

const $14342bb4fa4d757f$export$e7cdb891a9ee1b17 = "Diagnostic-Id";
function $14342bb4fa4d757f$export$9bea097ef11100d9(message, options, entityPath, host) {
    var _a, _b, _c;
    // check if the event has already been instrumented
    const previouslyInstrumented = Boolean((_a = message.applicationProperties) === null || _a === void 0 ? void 0 : _a[$14342bb4fa4d757f$export$e7cdb891a9ee1b17]);
    if (previouslyInstrumented) return {
        message: message,
        spanContext: undefined
    };
    const { span: messageSpan , updatedOptions: updatedOptions  } = (0, $10b26da869f0d653$export$fd8e54df9573b5e4).startSpan("message", options, (0, $10b26da869f0d653$export$d2129a31a8b4253f)({
        entityPath: entityPath,
        host: host
    }, "producer"));
    try {
        if (!messageSpan.isRecording()) return {
            message: message,
            spanContext: undefined
        };
        const traceParent = (0, $10b26da869f0d653$export$fd8e54df9573b5e4).createRequestHeaders((_b = updatedOptions.tracingOptions) === null || _b === void 0 ? void 0 : _b.tracingContext)["traceparent"];
        if (traceParent) // create a copy so the original isn't modified
        message = Object.assign(Object.assign({}, message), {
            applicationProperties: Object.assign(Object.assign({}, message.applicationProperties), {
                [$14342bb4fa4d757f$export$e7cdb891a9ee1b17]: traceParent
            })
        });
        return {
            message: message,
            spanContext: (_c = updatedOptions.tracingOptions) === null || _c === void 0 ? void 0 : _c.tracingContext
        };
    } finally{
        messageSpan.end();
    }
}
function $14342bb4fa4d757f$export$5d22a619cc3705a0(message) {
    if (!message.applicationProperties || !message.applicationProperties[$14342bb4fa4d757f$export$e7cdb891a9ee1b17]) return;
    const diagnosticId = message.applicationProperties[$14342bb4fa4d757f$export$e7cdb891a9ee1b17];
    return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).parseTraceparentHeader(diagnosticId);
}
/**
 * Provides an iterable over messages, whether it is a single message or multiple
 * messages.
 *
 * @param receivedMessages - A single message or a set of messages
 * @internal
 */ function* $14342bb4fa4d757f$var$getReceivedMessages(receivedMessages) {
    if (!Array.isArray(receivedMessages)) yield receivedMessages;
    else for (const message of receivedMessages)yield message;
}
function $14342bb4fa4d757f$export$a2478bc4652823e9(receivedMessages, receiver, connectionConfig) {
    var _a;
    const spanLinks = [];
    for (const receivedMessage of $14342bb4fa4d757f$var$getReceivedMessages(receivedMessages)){
        const tracingContext = $14342bb4fa4d757f$export$5d22a619cc3705a0(receivedMessage);
        if (tracingContext) spanLinks.push({
            tracingContext: tracingContext,
            attributes: {
                enqueuedTime: (_a = receivedMessage.enqueuedTimeUtc) === null || _a === void 0 ? void 0 : _a.getTime()
            }
        });
    }
    return Object.assign({
        spanLinks: spanLinks,
        spanKind: "consumer"
    }, (0, $10b26da869f0d653$export$d2129a31a8b4253f)({
        host: connectionConfig.host,
        entityPath: receiver.entityPath
    }));
}


function $e4f5d79c9cac0816$export$42a658e3d1d65dcf(handlers) {
    if (handlers && handlers.processMessage instanceof Function && handlers.processError instanceof Function) return;
    throw new TypeError('Invalid "MessageHandlers" provided.');
}
function $e4f5d79c9cac0816$export$d0444fcc39ce3e12(receiver, options) {
    return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* getMessageIterator_1() {
        while(true){
            const messages = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(receiver.receiveMessages(1, options));
            if (messages.length === 0) continue;
            yield yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(messages[0]);
        }
    });
}
function $e4f5d79c9cac0816$export$e148c2aba7ad0b3a(handlers, loggerParam = (0, $f014dc9d393cdf62$export$e0718a134caff0cf)) {
    return async (args)=>{
        try {
            args.error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(args.error);
            await handlers.processError(args);
        } catch (err) {
            loggerParam.logError(err, `An error was thrown from the user's processError handler`);
        }
    };
}
function $e4f5d79c9cac0816$export$fbd7e56e722b700b(message, context, entityPath, retryOptions) {
    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("[%s] Completing the message with id '%s'.", context.connectionId, message.messageId);
    const tracingContext = (0, $14342bb4fa4d757f$export$5d22a619cc3705a0)(message);
    const spanLinks = tracingContext ? [
        {
            tracingContext: tracingContext
        }
    ] : [];
    return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServicebusReceiver.complete", {}, ()=>$e4f5d79c9cac0816$export$d2bfc00156a1d32e(message, (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).complete, context, entityPath, {
            retryOptions: retryOptions
        }), Object.assign({
        spanLinks: spanLinks
    }, (0, $10b26da869f0d653$export$d2129a31a8b4253f)({
        entityPath: entityPath,
        host: context.config.host
    }, "client")));
}
function $e4f5d79c9cac0816$export$402a56cd3be588c3(message, context, entityPath, propertiesToModify, retryOptions) {
    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("[%s] Abandoning the message with id '%s'.", context.connectionId, message.messageId);
    const tracingContext = (0, $14342bb4fa4d757f$export$5d22a619cc3705a0)(message);
    const spanLinks = tracingContext ? [
        {
            tracingContext: tracingContext
        }
    ] : [];
    return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServicebusReceiver.abandon", {}, ()=>$e4f5d79c9cac0816$export$d2bfc00156a1d32e(message, (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).abandon, context, entityPath, {
            propertiesToModify: propertiesToModify,
            retryOptions: retryOptions
        }), Object.assign({
        spanLinks: spanLinks
    }, (0, $10b26da869f0d653$export$d2129a31a8b4253f)({
        entityPath: entityPath,
        host: context.config.host
    }, "client")));
}
function $e4f5d79c9cac0816$export$8277e8e47fef2719(message, context, entityPath, propertiesToModify, retryOptions) {
    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("[%s] Deferring the message with id '%s'.", context.connectionId, message.messageId);
    const tracingContext = (0, $14342bb4fa4d757f$export$5d22a619cc3705a0)(message);
    const spanLinks = tracingContext ? [
        {
            tracingContext: tracingContext
        }
    ] : [];
    return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusReceiver.defer", {}, ()=>$e4f5d79c9cac0816$export$d2bfc00156a1d32e(message, (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).defer, context, entityPath, {
            retryOptions: retryOptions,
            propertiesToModify: propertiesToModify
        }), Object.assign({
        spanLinks: spanLinks
    }, (0, $10b26da869f0d653$export$d2129a31a8b4253f)({
        entityPath: entityPath,
        host: context.config.host
    }, "client")));
}
function $e4f5d79c9cac0816$export$b52a045fd4426c36(message, context, entityPath, propertiesToModify, retryOptions) {
    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("[%s] Deadlettering the message with id '%s'.", context.connectionId, message.messageId);
    const actualPropertiesToModify = Object.assign({}, propertiesToModify);
    // these two fields are handled specially and don't need to be in here.
    delete actualPropertiesToModify.deadLetterErrorDescription;
    delete actualPropertiesToModify.deadLetterReason;
    const dispositionStatusOptions = {
        propertiesToModify: actualPropertiesToModify,
        deadLetterReason: propertiesToModify === null || propertiesToModify === void 0 ? void 0 : propertiesToModify.deadLetterReason,
        deadLetterDescription: propertiesToModify === null || propertiesToModify === void 0 ? void 0 : propertiesToModify.deadLetterErrorDescription,
        retryOptions: retryOptions
    };
    const tracingContext = (0, $14342bb4fa4d757f$export$5d22a619cc3705a0)(message);
    const spanLinks = tracingContext ? [
        {
            tracingContext: tracingContext
        }
    ] : [];
    return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusReceiver.deadLetter", {}, ()=>$e4f5d79c9cac0816$export$d2bfc00156a1d32e(message, (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).deadletter, context, entityPath, dispositionStatusOptions), Object.assign({
        spanLinks: spanLinks
    }, (0, $10b26da869f0d653$export$d2129a31a8b4253f)({
        entityPath: entityPath,
        host: context.config.host
    }, "client")));
}
function $e4f5d79c9cac0816$export$d2bfc00156a1d32e(message, operation, context, entityPath, options, _settleMessageOperation = $e4f5d79c9cac0816$export$2efac0cff8f1e937) {
    return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)({
        connectionId: context.connectionId,
        operation: ()=>{
            return _settleMessageOperation(message, operation, context, entityPath, options);
        },
        operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).messageSettlement,
        abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
        retryOptions: options === null || options === void 0 ? void 0 : options.retryOptions
    });
}
async function $e4f5d79c9cac0816$export$2efac0cff8f1e937(message, operation, context, entityPath, options) {
    const isDeferredMessage = !message.delivery.link;
    const receiver = isDeferredMessage ? undefined : context.getReceiverFromCache(message.delivery.link.name, message.sessionId);
    const associatedLinkName = receiver === null || receiver === void 0 ? void 0 : receiver.name;
    let error;
    if (message.delivery.remote_settled) error = new Error((0, $f4faabfcfe4aedfc$export$571766634c511d39));
    else if (!isDeferredMessage && (!receiver || !receiver.isOpen()) && (0, $a7961d970a7496cb$export$4e62c701997796c1)(message.sessionId)) error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)({
        description: `Failed to ${operation} the message as the AMQP link with which the message was ` + `received is no longer alive.`,
        condition: (0, $3d84b7093289460f$export$65de4560c7cb6642).SessionLockLostError
    });
    if (error) {
        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, "[%s] An error occurred when settling a message with id '%s'", context.connectionId, message.messageId);
        throw error;
    }
    // Message Settlement with managementLink
    // 1. If the received message is deferred as such messages can only be settled using managementLink
    // 2. If the associated receiver link is not available. This does not apply to messages from sessions as we need a lock on the session to do so.
    if (isDeferredMessage || (!receiver || !receiver.isOpen()) && !(0, $a7961d970a7496cb$export$4e62c701997796c1)(message.sessionId)) return context.getManagementClient(entityPath).updateDispositionStatus(message.lockToken, operation, Object.assign(Object.assign({}, options), {
        associatedLinkName: associatedLinkName,
        sessionId: message.sessionId
    })).catch((err)=>{
        throw (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
    });
    return receiver.settleMessage(message, operation, options).catch((err)=>{
        throw (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
    });
}
/**
 * Calculates delay between retries, in milliseconds.
 */ function $e4f5d79c9cac0816$var$calculateDelay(attemptCount, retryDelayInMs, maxRetryDelayInMs, mode) {
    if (mode === (0, $da0e8ee01baeae47$export$56412ee12c2689b3).Exponential) {
        const boundedRandDelta = retryDelayInMs * 0.8 + Math.floor(Math.random() * (retryDelayInMs * 1.2 - retryDelayInMs * 0.8));
        const incrementDelta = boundedRandDelta * (Math.pow(2, attemptCount) - 1);
        return Math.min(incrementDelta, maxRetryDelayInMs);
    }
    return retryDelayInMs;
}
async function $e4f5d79c9cac0816$export$1e31d489c4e93d7(args, retryFn = (0, $da0e8ee01baeae47$export$9369b12211e1fce4)) {
    let numRetryCycles = 0;
    const config = args.retryConfig;
    if (!config.retryOptions) config.retryOptions = {};
    // eslint-disable-next-line eqeqeq
    if (config.retryOptions.retryDelayInMs == undefined || config.retryOptions.retryDelayInMs < 0) config.retryOptions.retryDelayInMs = (0, $807770c0815ec6f8$export$a002182e51710d39).defaultDelayBetweenOperationRetriesInMs;
    if (// eslint-disable-next-line eqeqeq
    config.retryOptions.maxRetryDelayInMs == undefined || config.retryOptions.maxRetryDelayInMs < 0) config.retryOptions.maxRetryDelayInMs = (0, $807770c0815ec6f8$export$a002182e51710d39).defaultMaxDelayForExponentialRetryInMs;
    if (!config.retryOptions.mode) config.retryOptions.mode = (0, $da0e8ee01baeae47$export$56412ee12c2689b3).Fixed;
    // The retries are broken up into cycles, giving the user some control over how often
    // we actually attempt to retry.
    // eslint-disable-next-line no-constant-condition
    while(true){
        ++numRetryCycles;
        try {
            return await retryFn(args.retryConfig);
        } catch (err) {
            // if the user aborts the operation we're immediately done.
            // AbortError is also thrown by linkEntity.init() if the connection has been
            // permanently closed.
            if (err.name === "AbortError") {
                (0, $f014dc9d393cdf62$export$af88d00dbe7f521).warning(`${args.logPrefix} AbortError caught, ending retries.`);
                throw err;
            }
            // we only report the error here - this avoids spamming the user with too many
            // redundant reports of errors while still providing them incremental status on failures.
            try {
                args.onError(err);
            } catch (error) {
                (0, $f014dc9d393cdf62$export$af88d00dbe7f521).error("args.onerror has thrown", error);
            }
            args.logger.logError(err, `${args.logPrefix} Error thrown in retry cycle ${numRetryCycles}, restarting retry cycle with retry options`, args.retryConfig);
            const delayInMs = $e4f5d79c9cac0816$var$calculateDelay(numRetryCycles, config.retryOptions.retryDelayInMs, config.retryOptions.maxRetryDelayInMs, config.retryOptions.mode);
            (0, $f014dc9d393cdf62$export$af88d00dbe7f521).verbose("[%s] Sleeping for %d milliseconds for '%s'.", config.connectionId, delayInMs, config.operationType);
            await (0, $b8a2d14549c57ac7$export$1391212d75b2ee65)(delayInMs, {
                abortSignal: config.abortSignal,
                abortErrorMsg: "Retry cycle has been cancelled by the user."
            });
            continue;
        }
    }
}





class $05d1aefd355be7fa$export$fef7d8f40dbed75d extends (0, $9a38b32fea5afae9$export$e3d8ffa5f5c3660f) {
    /**
     * Instantiate a new Streaming receiver for receiving messages with handlers.
     *
     * @param identifier - the name used to identifier the receiver
     * @param connectionContext - The client entity context.
     * @param options - Options for how you'd like to connect.
     */ constructor(identifier, connectionContext, entityPath, options){
        super(identifier, connectionContext, entityPath, "streaming", options);
        /**
         * The maximum number of messages that should be
         * processed concurrently while in streaming mode. Once this limit has been reached, more
         * messages will not be received until the user's message handler has completed processing current message.
         * Default: 1
         */ this.maxConcurrentCalls = 1;
        /**
         * Indicates whether the receiver is already actively
         * running `onDetached`.
         * This is expected to be true while the receiver attempts
         * to bring its link back up due to a retryable issue.
         */ this._isDetaching = false;
        /**
         * The user's message handlers, wrapped so any thrown exceptions are properly logged
         * or forwarded to the user's processError handler.
         */ this._messageHandlers = ()=>{
            throw new Error("messageHandlers are not set.");
        };
        /**
         * Used so we can stub out retry in tests.
         */ this._retryForeverFn = (0, $e4f5d79c9cac0816$export$1e31d489c4e93d7);
        if (typeof (options === null || options === void 0 ? void 0 : options.maxConcurrentCalls) === "number" && (options === null || options === void 0 ? void 0 : options.maxConcurrentCalls) > 0) this.maxConcurrentCalls = options.maxConcurrentCalls;
        this._retryOptions = (options === null || options === void 0 ? void 0 : options.retryOptions) || {};
        this._receiverHelper = new (0, $3b2f2ffa8f8d3149$export$c9e7a1bffd742ae)(()=>({
                receiver: this.link,
                logPrefix: this.logPrefix
            }));
        this._onAmqpClose = async (context)=>{
            var _a;
            const receiverError = context.receiver && context.receiver.error;
            const receiver = this.link || context.receiver;
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(receiverError, `${this.logPrefix} 'receiver_close' event occurred. The associated error is`);
            (_a = this._lockRenewer) === null || _a === void 0 || _a.stopAll(this);
            if (receiver && !receiver.isItselfClosed()) await this.onDetached(receiverError);
            else (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s 'receiver_close' event occurred on the receiver '%s' with address '%s' because the sdk initiated it. Hence not calling detached from the _onAmqpClose() handler.", this.logPrefix, this.name, this.address);
        };
        this._onSessionClose = async (context)=>{
            var _a;
            const receiver = this.link || context.receiver;
            const sessionError = context.session && context.session.error;
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(sessionError, `${this.logPrefix} 'session_close' event occurred. The associated error is`);
            (_a = this._lockRenewer) === null || _a === void 0 || _a.stopAll(this);
            if (receiver && !receiver.isSessionItselfClosed()) await this.onDetached(sessionError);
            else (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s 'session_close' event occurred on the session of receiver '%s' with address '%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose() handler.", this.logPrefix, this.name, this.address);
        };
        this._onAmqpError = (context)=>{
            const receiverError = context.receiver && context.receiver.error;
            if (receiverError) {
                const sbError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(receiverError);
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(sbError, `${this.logPrefix} 'receiver_error' event occurred. The associated error is`);
                this._messageHandlers().processError({
                    error: sbError,
                    errorSource: "receive",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier: identifier
                });
            }
        };
        this._onSessionError = (context)=>{
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(sessionError);
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(sbError, `${this.logPrefix} 'session_error' event occurred. The associated error is`);
                this._messageHandlers().processError({
                    error: sbError,
                    errorSource: "receive",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier: identifier
                });
            }
        };
        this._onAmqpMessage = async (context)=>{
            var _a, _b, _c, _d;
            // If the receiver got closed in PeekLock mode, avoid processing the message as we
            // cannot settle the message.
            if (this.receiveMode === "peekLock" && (!this.link || !this.link.isOpen())) {
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Not calling the user's message handler for the current message as the receiver is closed", this.logPrefix);
                return;
            }
            const bMessage = new (0, $d7965bb09cbe6503$export$a482b14703d155cd)(context.message, context.delivery, true, this.receiveMode, (_a = options.skipParsingBodyAsJson) !== null && _a !== void 0 ? _a : false, (_b = options.skipConvertingDate) !== null && _b !== void 0 ? _b : false);
            (_c = this._lockRenewer) === null || _c === void 0 || _c.start(this, bMessage, (err)=>{
                this._messageHandlers().processError({
                    error: err,
                    errorSource: "renewLock",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier: identifier
                });
            });
            try {
                await this._messageHandlers().processMessage(bMessage);
            } catch (err) {
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(err, "%s An error occurred while running user's message handler for the message with id '%s' on the receiver '%s'", this.logPrefix, bMessage.messageId, this.name);
                // Do not want renewLock to happen unnecessarily, while abandoning the message. Hence,
                // doing this here. Otherwise, this should be done in finally.
                (_d = this._lockRenewer) === null || _d === void 0 || _d.stop(this, bMessage);
                const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
                // Nothing much to do if user's message handler throws. Let us try abandoning the message.
                if (!bMessage.delivery.remote_settled && error.code !== (0, $3d84b7093289460f$export$b65b7fa0413f4b3d)["com.microsoft:message-lock-lost"] && this.receiveMode === "peekLock" && this.isOpen() // only try to abandon the messages if the connection is still open
                ) try {
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, "%s Abandoning the message with id '%s' on the receiver '%s' since an error occured: %O.", this.logPrefix, bMessage.messageId, this.name, error);
                    await (0, $e4f5d79c9cac0816$export$402a56cd3be588c3)(bMessage, this._context, entityPath, undefined, this._retryOptions);
                } catch (abandonError) {
                    const translatedError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(abandonError);
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(translatedError, "%s An error occurred while abandoning the message with id '%s' on the receiver '%s'", this.logPrefix, bMessage.messageId, this.name);
                    this._messageHandlers().processError({
                        error: translatedError,
                        errorSource: "abandon",
                        entityPath: this.entityPath,
                        fullyQualifiedNamespace: this._context.config.host,
                        identifier: identifier
                    });
                }
                return;
            } finally{
                try {
                    this._receiverHelper.addCredit(1);
                } catch (err) {
                    // if we're aborting out of the receive operation we don't need to report it (the user already
                    // knows the link is being torn down or stopped)
                    if (err.name !== "AbortError") {
                        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(err, `[${this.logPrefix}] Failed to add credit after receiving message`);
                        await this._reportInternalError(err);
                    }
                }
            }
            // If we've made it this far, then user's message handler completed fine. Let us try
            // completing the message.
            if (this.autoComplete && this.receiveMode === "peekLock" && !bMessage.delivery.remote_settled) try {
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Auto completing the message with id '%s' on the receiver.", this.logPrefix, bMessage.messageId);
                await (0, $e4f5d79c9cac0816$export$fbd7e56e722b700b)(bMessage, this._context, entityPath, this._retryOptions);
            } catch (completeError) {
                const translatedError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(completeError);
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(translatedError, "%s An error occurred while completing the message with id '%s' on the receiver '%s'", this.logPrefix, bMessage.messageId, this.name);
                this._messageHandlers().processError({
                    error: translatedError,
                    errorSource: "complete",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier: identifier
                });
            }
        };
    }
    /**
     * Whether we are currently subscribed (or subscribing) for receiving messages.
     * (this is irrespective of receiver state, etc... - it's just a simple flag to prevent
     * multiple subscribe() calls from happening on this instance)
     */ get isSubscribeActive() {
        return !this._receiverHelper.isSuspended();
    }
    _reportInternalError(error) {
        const messageHandlers = this._messageHandlers();
        if (messageHandlers.forwardInternalErrors) {
            const errorArgs = {
                error: error,
                entityPath: this.entityPath,
                errorSource: "internal",
                fullyQualifiedNamespace: this._context.config.host,
                identifier: this.identifier
            };
            return messageHandlers.processError(errorArgs);
        }
        return Promise.resolve();
    }
    _getHandlers() {
        return {
            onMessage: (context)=>this._onAmqpMessage(context).catch((err)=>this._reportInternalError(err)),
            onClose: (context)=>this._onAmqpClose(context).catch((err)=>this._reportInternalError(err)),
            onSessionClose: (context)=>this._onSessionClose(context).catch((err)=>this._reportInternalError(err)),
            onError: this._onAmqpError,
            onSessionError: this._onSessionError
        };
    }
    async stopReceivingMessages() {
        await this._receiverHelper.suspend();
        if (this._subscribeCallPromise) await this._subscribeCallPromise;
    }
    async close() {
        await this._receiverHelper.suspend();
        return super.close();
    }
    /**
     * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session.
     *
     * Any errors thrown by this function will also be sent to the messageHandlers.processError function
     * _and_ thrown, ultimately from this method.
     *
     * NOTE: This function retries _infinitely_ until success! It is completely up to the user to break
     * out of this retry cycle otherwise by:
     * 1. closing the receiver
     * 2. Calling `close` on the subscription instance they received when they initially called subscribe().
     * 3. aborting the abortSignal they passed in when calling subscribe (this also applies to initialization calls in onDetach)
     *
     * @param onMessage - The message handler to receive servicebus messages.
     * @param onError - The error handler to receive an error that occurs while receivin messages.
     */ async subscribe(messageHandlers, subscribeOptions) {
        // these options and message handlers will be re-used if/when onDetach is called.
        this._subscribeOptions = subscribeOptions;
        this._setMessageHandlers(messageHandlers, subscribeOptions);
        let promiseResolve;
        this._subscribeCallPromise = new Promise((resolve)=>{
            promiseResolve = resolve;
        });
        try {
            this._receiverHelper.resume();
            return await this._subscribeImpl("subscribe");
        } catch (err) {
            // callers aren't going to be in a good position to forward this error properly
            // so we do it here.
            await this._messageHandlers().processError({
                entityPath: this.entityPath,
                fullyQualifiedNamespace: this._context.config.host,
                errorSource: "receive",
                error: err,
                identifier: this.identifier
            });
            throw err;
        } finally{
            promiseResolve === null || promiseResolve === void 0 || promiseResolve();
            this._subscribeCallPromise = undefined;
        }
    }
    /**
     * Wraps the individual message handlers with tracing and proper error handling
     * and assigns them to `this._messageHandlers`
     *
     * @param userHandlers - The user's message handlers
     * @param operationOptions - The subscribe(options)
     */ _setMessageHandlers(userHandlers, operationOptions) {
        var _a;
        const messageHandlers = {
            processError: async (args)=>{
                try {
                    args.error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(args.error);
                    await userHandlers.processError(args);
                } catch (err) {
                    await this._reportInternalError(err);
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(err, `An error was thrown from the user's processError handler`);
                }
            },
            processMessage: async (message)=>{
                try {
                    await (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("StreamReceiver.process", operationOptions !== null && operationOptions !== void 0 ? operationOptions : {}, ()=>userHandlers.processMessage(message), (0, $14342bb4fa4d757f$export$a2478bc4652823e9)(message, this, this._context.config));
                } catch (err) {
                    this._messageHandlers().processError({
                        error: err,
                        errorSource: "processMessageCallback",
                        entityPath: this.entityPath,
                        fullyQualifiedNamespace: this._context.config.host,
                        identifier: this.identifier
                    });
                    throw err;
                }
            },
            postInitialize: async ()=>{
                if (!userHandlers.postInitialize) return;
                return userHandlers.postInitialize().catch((err)=>this._messageHandlers().processError({
                        error: err,
                        errorSource: "processMessageCallback",
                        entityPath: this.entityPath,
                        fullyQualifiedNamespace: this._context.config.host,
                        identifier: this.identifier
                    }));
            },
            preInitialize: async ()=>{
                if (!userHandlers.preInitialize) return;
                return userHandlers.preInitialize().catch((err)=>this._messageHandlers().processError({
                        error: err,
                        errorSource: "processMessageCallback",
                        entityPath: this.entityPath,
                        fullyQualifiedNamespace: this._context.config.host,
                        identifier: this.identifier
                    }));
            },
            forwardInternalErrors: (_a = userHandlers.forwardInternalErrors) !== null && _a !== void 0 ? _a : false
        };
        this._messageHandlers = ()=>messageHandlers;
    }
    /**
     * Subscribes using the already assigned `this._messageHandlers` and `this._subscribeOptions`
     *
     * @returns A promise that will resolve when a link is created and we successfully add credits to it.
     */ async _subscribeImpl(caller) {
        var _a;
        try {
            // we don't expect to ever get an error from retryForever but bugs
            // do happen.
            return await this._retryForeverFn({
                retryConfig: {
                    connectionId: this._context.connection.id,
                    operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).receiverLink,
                    abortSignal: (_a = this._subscribeOptions) === null || _a === void 0 ? void 0 : _a.abortSignal,
                    retryOptions: this._retryOptions,
                    operation: ()=>this._initAndAddCreditOperation(caller)
                },
                onError: (err)=>this._messageHandlers().processError({
                        error: err,
                        errorSource: "receive",
                        entityPath: this.entityPath,
                        fullyQualifiedNamespace: this._context.config.host,
                        identifier: this.identifier
                    }),
                logPrefix: this.logPrefix,
                logger: $f014dc9d393cdf62$export$e0718a134caff0cf
            });
        } catch (err) {
            try {
                await this._receiverHelper.suspend();
            } catch (error) {
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${this.logPrefix} receiver.suspend threw an error`);
            }
            throw err;
        }
    }
    /**
     * Initializes the link and adds credits. If any of these operations fail any created link will
     * be closed.
     *
     * @param caller - The caller which dictates whether or not we create a new name for our created link.
     * @param catchAndReportError - A function and reports an error but does not throw it.
     */ async _initAndAddCreditOperation(caller) {
        var _a;
        if (this._receiverHelper.isSuspended()) // user has suspended us while we were initializing
        // the connection. Abort this attempt - if they attempt
        // resubscribe we'll just reinitialize.
        // This checks should happen before throwErrorIfConnectionClosed(); otherwise
        // we won't be able to break out of the retry-for-ever loops when user suspend us.
        throw new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)("Receiver was suspended during initialization.");
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        await this._messageHandlers().preInitialize();
        if (this._receiverHelper.isSuspended()) // Need to check again as user can suspend us in preInitialize()
        throw new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)("Receiver was suspended during initialization.");
        await this._init(this._createReceiverOptions(caller === "detach", this._getHandlers()), (_a = this._subscribeOptions) === null || _a === void 0 ? void 0 : _a.abortSignal);
        try {
            await this._messageHandlers().postInitialize();
            this._receiverHelper.addCredit(this.maxConcurrentCalls);
        } catch (err) {
            try {
                await this.closeLink();
            } catch (error) {
                await this._messageHandlers().processError({
                    error: error,
                    errorSource: "receive",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier: this.identifier
                });
            }
            throw err;
        }
    }
    /**
     * Will reconnect the receiver link if necessary.
     * @param receiverError - The receiver error or connection error, if any.
     */ async onDetached(receiverError) {
        try {
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${this.logPrefix} onDetached: reinitializing link.`);
            // User explicitly called `close` on the receiver, so link is already closed
            // and we can exit early.
            if (this.wasClosedPermanently) {
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${this.logPrefix} onDetached: link has been closed permanently, not reinitializing. `);
                return;
            }
            // Prevent multiple onDetached invocations from running concurrently.
            if (this._isDetaching) {
                // This can happen when the network connection goes down for some amount of time.
                // The first connection `disconnect` will trigger `onDetached` and attempt to retry
                // creating the connection/receiver link.
                // While those retry attempts fail (until the network connection comes back up),
                // we'll continue to see connection `disconnect` errors.
                // These should be ignored until the already running `onDetached` completes
                // its retry attempts or errors.
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${this.logPrefix} onDetached: Call to detached on streaming receiver '${this.name}' is already in progress.`);
                return;
            }
            this._isDetaching = true;
            const translatedError = receiverError ? (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(receiverError) : receiverError;
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(translatedError, `${this.logPrefix} onDetached: Reinitializing receiver because of error`);
            // Clears the token renewal timer. Closes the link and its session if they are open.
            // Removes the link and its session if they are present in rhea's cache.
            await this.closeLink();
        } catch (err) {
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${this.logPrefix} onDetached: Encountered an error when closing the previous link: `, err);
        }
        try {
            await this._subscribeImpl("detach");
        } finally{
            this._isDetaching = false;
        }
    }
    removeLinkFromContext() {
        delete this._context.messageReceivers[this.name];
    }
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.









class $83f93614d540afee$export$9d0845ea0b55e35f extends (0, $9a38b32fea5afae9$export$e3d8ffa5f5c3660f) {
    /**
     * Instantiate a new BatchingReceiver.
     *
     * @param identifier - name to identify this receiver.
     * @param connectionContext - The client entity context.
     * @param options - Options for how you'd like to connect.
     */ constructor(identifier, connectionContext, entityPath, options){
        var _a, _b;
        super(identifier, connectionContext, entityPath, "batching", options);
        this._batchingReceiverLite = new $83f93614d540afee$export$fb8e488ce17d0b7a(connectionContext, entityPath, async (abortSignal)=>{
            let lastError;
            const rcvrOptions = this._createReceiverOptions(false, {
                onError: (context)=>{
                    var _a;
                    lastError = (_a = context === null || context === void 0 ? void 0 : context.receiver) === null || _a === void 0 ? void 0 : _a.error;
                },
                onSessionError: (context)=>{
                    var _a;
                    lastError = (_a = context === null || context === void 0 ? void 0 : context.session) === null || _a === void 0 ? void 0 : _a.error;
                },
                onClose: async ()=>{
                /** Nothing to do here - the next call will just fail so they'll get an appropriate error from somewhere else. */ },
                onSessionClose: async ()=>{
                /** Nothing to do here - the next call will just fail so they'll get an appropriate error from somewhere else. */ },
                onMessage: async ()=>{
                /** Nothing to do here -  we don't add credits initially so we don't need to worry about handling any messages.*/ }
            });
            await this._init(rcvrOptions, abortSignal);
            if (lastError != null) throw lastError;
            return this.link;
        }, this.receiveMode, (_a = options.skipParsingBodyAsJson) !== null && _a !== void 0 ? _a : false, (_b = options.skipConvertingDate) !== null && _b !== void 0 ? _b : false);
    }
    get isReceivingMessages() {
        return this._batchingReceiverLite.isReceivingMessages;
    }
    /**
     * To be called when connection is disconnected to gracefully close ongoing receive request.
     * @param connectionError - The connection error if any.
     */ async onDetached(connectionError) {
        await this.closeLink();
        if (connectionError == null) connectionError = new Error("Unknown error occurred on the AMQP connection while receiving messages.");
        this._batchingReceiverLite.terminate(connectionError);
    }
    /**
     * Receives a batch of messages from a ServiceBus Queue/Topic.
     * @param maxMessageCount - The maximum number of messages to receive.
     * In Peeklock mode, this number is capped at 2047 due to constraints of the underlying buffer.
     * @param maxWaitTimeInMs - The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.
     * @param maxTimeAfterFirstMessageInMs - The total amount of time to wait after the first message
     * has been received. Defaults to 1 second.
     * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
     * @returns A promise that resolves with an array of Message objects.
     */ async receive(maxMessageCount, maxWaitTimeInMs, maxTimeAfterFirstMessageInMs, options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        try {
            const messages = await this._batchingReceiverLite.receiveMessages(Object.assign({
                maxMessageCount: maxMessageCount,
                maxWaitTimeInMs: maxWaitTimeInMs,
                maxTimeAfterFirstMessageInMs: maxTimeAfterFirstMessageInMs
            }, options));
            if (this._lockRenewer) for (const message of messages)this._lockRenewer.start(this, message, (_error)=>{
            // the auto lock renewer already logs this in a detailed way. So this hook is mainly here
            // to potentially forward the error to the user (which we're not doing yet)
            });
            return messages;
        } catch (error) {
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, "[%s] Rejecting receiveMessages()", this.logPrefix);
            throw error;
        }
    }
    static create(clientId, context, entityPath, options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(context);
        const bReceiver = new $83f93614d540afee$export$9d0845ea0b55e35f(clientId, context, entityPath, options);
        context.messageReceivers[bReceiver.name] = bReceiver;
        return bReceiver;
    }
    removeLinkFromContext() {
        delete this._context.messageReceivers[this.name];
    }
}
function $83f93614d540afee$export$de7f734aaa3a168(maxWaitTimeInMs, maxTimeAfterFirstMessageInMs) {
    const startTimeMs = Date.now();
    return ()=>{
        const remainingTimeMs = maxWaitTimeInMs - (Date.now() - startTimeMs);
        if (remainingTimeMs < 0) return 0;
        return Math.min(remainingTimeMs, maxTimeAfterFirstMessageInMs);
    };
}
class $83f93614d540afee$export$fb8e488ce17d0b7a {
    constructor(_connectionContext, entityPath, _getCurrentReceiver, _receiveMode, _skipParsingBodyAsJson, _skipConvertingDate){
        this._connectionContext = _connectionContext;
        this.entityPath = entityPath;
        this._getCurrentReceiver = _getCurrentReceiver;
        this._receiveMode = _receiveMode;
        this._createServiceBusMessage = (context)=>{
            return new (0, $d7965bb09cbe6503$export$a482b14703d155cd)(context.message, context.delivery, true, this._receiveMode, _skipParsingBodyAsJson, _skipConvertingDate);
        };
        this._getRemainingWaitTimeInMsFn = (maxWaitTimeInMs, maxTimeAfterFirstMessageInMs)=>$83f93614d540afee$export$de7f734aaa3a168(maxWaitTimeInMs, maxTimeAfterFirstMessageInMs);
        this.isReceivingMessages = false;
    }
    /**
     * Receives a set of messages,
     *
     * @internal
     * @hidden
     */ async receiveMessages(args) {
        try {
            this.isReceivingMessages = true;
            const receiver = await this._getCurrentReceiver(args.abortSignal);
            if (receiver == null) // (was somehow closed in between the init() and the return)
            throw new (0, $c6ec964bc6c55a71$export$a7174187385dd2e2)("Link closed before receiving messages.", "GeneralError");
            const messages = await new Promise((resolve, reject)=>this._receiveMessagesImpl(receiver, args, resolve, reject));
            return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("BatchingReceiverLite.process", args, ()=>messages, (0, $14342bb4fa4d757f$export$a2478bc4652823e9)(messages, this, this._connectionContext.config));
        } finally{
            this._closeHandler = undefined;
            this.isReceivingMessages = false;
        }
    }
    /**
     * Closes the receiver (optionally with an error), cancelling any current operations.
     *
     * @param connectionError - An optional error (rhea doesn't always deliver one for certain disconnection events)
     */ terminate(connectionError) {
        if (this._closeHandler) {
            this._closeHandler(connectionError);
            this._closeHandler = undefined;
        }
    }
    _receiveMessagesImpl(receiver, args, origResolve, origReject) {
        const getRemainingWaitTimeInMs = this._getRemainingWaitTimeInMsFn(args.maxWaitTimeInMs, args.maxTimeAfterFirstMessageInMs);
        const brokeredMessages = [];
        const loggingPrefix = `[${receiver.connection.id}|r:${receiver.name}]`;
        let totalWaitTimer;
        // eslint-disable-next-line prefer-const
        let cleanupBeforeResolveOrReject;
        const reject = (err)=>{
            cleanupBeforeResolveOrReject();
            origReject(err);
        };
        const resolveImmediately = (result)=>{
            cleanupBeforeResolveOrReject();
            origResolve(result);
        };
        const resolveAfterPendingMessageCallbacks = (result)=>{
            // NOTE: through rhea-promise, most of our event handlers are made asynchronous by calling setTimeout(emit).
            // However, a small set (*error and drain) execute immediately. This can lead to a situation where the logical
            // ordering of events is correct but the execution order is incorrect because the events are not all getting
            // put into the task queue the same way.
            // setTimeout() ensures that we resolve _after_ any already-queued onMessage handlers that may
            // be waiting in the task queue.
            setTimeout(()=>{
                cleanupBeforeResolveOrReject();
                origResolve(result);
            });
        };
        const onError = (context)=>{
            var _a, _b, _c;
            const eventType = ((_a = context.session) === null || _a === void 0 ? void 0 : _a.error) != null ? "session_error" : "receiver_error";
            let error = ((_b = context.session) === null || _b === void 0 ? void 0 : _b.error) || ((_c = context.receiver) === null || _c === void 0 ? void 0 : _c.error);
            if (error) {
                error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(error);
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${loggingPrefix} '${eventType}' event occurred. Received an error`);
            } else error = new (0, $c6ec964bc6c55a71$export$a7174187385dd2e2)("An error occurred while receiving messages.", "GeneralError");
            reject(error);
        };
        this._closeHandler = (error)=>{
            if (// no error, just closing. Go ahead and return what we have.
            error == null || // Return the collected messages if in ReceiveAndDelete mode because otherwise they are lost forever
            this._receiveMode === "receiveAndDelete" && brokeredMessages.length) {
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${loggingPrefix} Closing. Resolving with ${brokeredMessages.length} messages.`);
                return resolveAfterPendingMessageCallbacks(brokeredMessages);
            }
            reject((0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(error));
        };
        let abortSignalCleanupFunction = undefined;
        // Final action to be performed after
        // - maxMessageCount is reached or
        // - maxWaitTime is passed or
        // - newMessageWaitTimeoutInSeconds is passed since the last message was received
        this._finalAction = ()=>{
            if (receiver.drain) // If a drain is already in process then we should let it complete. Some messages might still be in flight, but they will
            // arrive before the drain completes.
            return;
            // Drain any pending credits.
            if (receiver.isOpen() && receiver.credit > 0) {
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${loggingPrefix} Draining leftover credits(${receiver.credit}).`);
                receiver.drainCredit();
            } else {
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${loggingPrefix} Resolving receiveMessages() with ${brokeredMessages.length} messages.`);
                // we can resolve immediately (ie, no setTimeout call) because we have no
                // remaining messages (thus nothing to wait for)
                resolveImmediately(brokeredMessages);
            }
        };
        // Action to be performed on the "message" event.
        const onReceiveMessage = async (context)=>{
            // TODO: this appears to be aggravating a bug that we need to look into more deeply.
            // The same timeout+drain sequence should work fine for receiveAndDelete but it appears
            // to cause problems.
            if (this._receiveMode === "peekLock") {
                if (brokeredMessages.length === 0) {
                    // We'll now remove the old timer (which was the overall `maxWaitTimeMs` timer)
                    // and replace it with another timer that is a (probably) much shorter interval.
                    //
                    // This allows the user to get access to received messages earlier and also gives us
                    // a chance to have fewer messages internally that could get lost if the user's
                    // app crashes.
                    if (totalWaitTimer) clearTimeout(totalWaitTimer);
                    const remainingWaitTimeInMs = getRemainingWaitTimeInMs();
                    totalWaitTimer = setTimeout(()=>{
                        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${loggingPrefix} Batching, waited for ${remainingWaitTimeInMs} milliseconds after receiving the first message.`);
                        this._finalAction();
                    }, remainingWaitTimeInMs);
                }
            }
            try {
                const data = this._createServiceBusMessage(context);
                brokeredMessages.push(data);
                // NOTE: we used to actually "lose" any extra messages. At this point I've fixed the areas that were causing us to receive
                // extra messages but if this bug arises in some other way it's better to return the message than it would be to let it be
                // silently dropped on the floor.
                if (brokeredMessages.length > args.maxMessageCount) (0, $f014dc9d393cdf62$export$e0718a134caff0cf).warning(`More messages arrived than expected: ${args.maxMessageCount} vs ${brokeredMessages.length}`);
            } catch (err) {
                const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(err, `${loggingPrefix} Received an error while converting AmqpMessage to ServiceBusMessage`);
                reject(errObj);
            }
            if (brokeredMessages.length >= args.maxMessageCount) this._finalAction();
        };
        const onClose = async (context)=>{
            var _a, _b, _c;
            const type = ((_a = context.session) === null || _a === void 0 ? void 0 : _a.error) != null ? "session_closed" : "receiver_closed";
            const error = ((_b = context.session) === null || _b === void 0 ? void 0 : _b.error) || ((_c = context.receiver) === null || _c === void 0 ? void 0 : _c.error);
            if (error) (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${loggingPrefix} '${type}' event occurred. The associated error`);
        };
        // Action to be performed on the "receiver_drained" event.
        const onReceiveDrain = ()=>{
            receiver.removeListener((0, $4973e2e602c1cc10$exports.ReceiverEvents).receiverDrained, onReceiveDrain);
            receiver.drain = false;
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${loggingPrefix} Drained, resolving receiveMessages() with ${brokeredMessages.length} messages.`);
            resolveAfterPendingMessageCallbacks(brokeredMessages);
        };
        cleanupBeforeResolveOrReject = ()=>{
            if (receiver != null) {
                receiver.removeListener((0, $4973e2e602c1cc10$exports.ReceiverEvents).receiverError, onError);
                receiver.removeListener((0, $4973e2e602c1cc10$exports.ReceiverEvents).message, onReceiveMessage);
                receiver.session.removeListener((0, $4973e2e602c1cc10$exports.SessionEvents).sessionError, onError);
                receiver.removeListener((0, $4973e2e602c1cc10$exports.ReceiverEvents).receiverClose, onClose);
                receiver.session.removeListener((0, $4973e2e602c1cc10$exports.SessionEvents).sessionClose, onClose);
                receiver.removeListener((0, $4973e2e602c1cc10$exports.ReceiverEvents).receiverDrained, onReceiveDrain);
            }
            if (totalWaitTimer) clearTimeout(totalWaitTimer);
            if (abortSignalCleanupFunction) abortSignalCleanupFunction();
            abortSignalCleanupFunction = undefined;
        };
        abortSignalCleanupFunction = (0, $3402f46f0a1b2976$export$97f8ca01894ba2ff)((err)=>{
            reject(err);
        }, args.abortSignal);
        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${loggingPrefix} Adding credit for receiving ${args.maxMessageCount} messages.`);
        // By adding credit here, we let the service know that at max we can handle `maxMessageCount`
        // number of messages concurrently. We will return the user an array of messages that can
        // be of size upto maxMessageCount. Then the user needs to accordingly dispose
        // (complete/abandon/defer/deadletter) the messages from the array.
        receiver.addCredit(args.maxMessageCount);
        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${loggingPrefix} Setting the wait timer for ${args.maxWaitTimeInMs} milliseconds.`);
        totalWaitTimer = setTimeout(()=>{
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${loggingPrefix} Batching, waited for max wait time ${args.maxWaitTimeInMs} milliseconds.`);
            this._finalAction();
        }, args.maxWaitTimeInMs);
        receiver.on((0, $4973e2e602c1cc10$exports.ReceiverEvents).message, onReceiveMessage);
        receiver.on((0, $4973e2e602c1cc10$exports.ReceiverEvents).receiverError, onError);
        receiver.on((0, $4973e2e602c1cc10$exports.ReceiverEvents).receiverClose, onClose);
        receiver.on((0, $4973e2e602c1cc10$exports.ReceiverEvents).receiverDrained, onReceiveDrain);
        receiver.session.on((0, $4973e2e602c1cc10$exports.SessionEvents).sessionError, onError);
        receiver.session.on((0, $4973e2e602c1cc10$exports.SessionEvents).sessionClose, onClose);
    }
}




// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


class $b652862b83644fc9$export$46e751174cfd95d5 {
    constructor(_context, _maxAutoRenewDurationInMs){
        this._context = _context;
        this._maxAutoRenewDurationInMs = _maxAutoRenewDurationInMs;
        /**
         * A map of link names to individual maps for each
         * link that map a message ID to its auto-renewal timer.
         */ this._messageRenewLockTimers = new Map();
        this._calculateRenewAfterDuration = (0, $3402f46f0a1b2976$export$b445d5bd96910ece);
    }
    /**
     * Creates an AutoLockRenewer.
     *
     * @param linkEntity - Your link entity instance (probably 'this')
     * @param context - The connection context for your link entity (probably 'this._context')
     * @param options - The ReceiveOptions passed through to your message receiver.
     * @returns if the lock mode is peek lock (or if is unspecified, thus defaulting to peekLock)
     * and the options.maxAutoLockRenewalDurationInMs is greater than 0..Otherwise, returns undefined.
     */ static create(context, maxAutoRenewLockDurationInMs, receiveMode) {
        if (receiveMode !== "peekLock") return undefined;
        if (maxAutoRenewLockDurationInMs <= 0) return undefined;
        return new $b652862b83644fc9$export$46e751174cfd95d5(context, maxAutoRenewLockDurationInMs);
    }
    /**
     * Cancels all pending lock renewals for messages on given link and removes all entries from our internal cache.
     */ stopAll(linkEntity) {
        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${linkEntity.logPrefix} Clearing message renew lock timers for all the active messages.`);
        const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);
        if (messagesForLink == null) return;
        for (const messageId of messagesForLink.keys())this._stopAndRemoveById(linkEntity, messagesForLink, messageId);
        this._messageRenewLockTimers.delete(linkEntity.name);
    }
    /**
     * Stops lock renewal for a single message.
     *
     * @param bMessage - The message whose lock renewal we will stop.
     */ stop(linkEntity, bMessage) {
        const messageId = bMessage.messageId;
        const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);
        if (messagesForLink == null) return;
        this._stopAndRemoveById(linkEntity, messagesForLink, messageId);
    }
    /**
     * Starts lock renewal for a single message.
     *
     * @param bMessage - The message whose lock renewal we will start.
     */ start(linkEntity, bMessage, onError) {
        try {
            const logPrefix = linkEntity.logPrefix;
            if (bMessage.lockToken == null) throw new Error(`Can't start auto lock renewal for message with message id '${bMessage.messageId}' since it does not have a lock token.`);
            const lockToken = bMessage.lockToken;
            const linkMessageMap = this._getOrCreateMapForLink(linkEntity);
            // - We need to renew locks before they expire by looking at bMessage.lockedUntilUtc.
            // - This autorenewal needs to happen **NO MORE** than maxAutoRenewDurationInMs
            // - We should be able to clear the renewal timer when the user's message handler
            // is done (whether it succeeds or fails).
            // Setting the messageId with undefined value in the linkMessageMap because we
            // track state by checking the presence of messageId in the map. It is removed from the map
            // when an attempt is made to settle the message (either by the user or by the sdk) OR
            // when the execution of user's message handler completes.
            linkMessageMap.set(bMessage.messageId, undefined);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${logPrefix} message with id '${bMessage.messageId}' is locked until ${bMessage.lockedUntilUtc.toString()}.`);
            const totalAutoLockRenewDuration = Date.now() + this._maxAutoRenewDurationInMs;
            const totalAutoLockRenewDurationDate = new Date(totalAutoLockRenewDuration);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${logPrefix} Total autolockrenew duration for message with id '${bMessage.messageId}' is: ${totalAutoLockRenewDurationDate.toString()}`);
            const autoRenewLockTask = ()=>{
                const renewalNeededToMaintainLock = // if the lock expires _after_ our max auto-renew duration there's no reason to
                // spin up an auto-renewer - it's already held for the duration.
                totalAutoLockRenewDurationDate > bMessage.lockedUntilUtc;
                if (!renewalNeededToMaintainLock) {
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${logPrefix} Autolockrenew not needed as message's lockedUntilUtc ${bMessage.lockedUntilUtc} is after the total autolockrenew duration ${totalAutoLockRenewDurationDate} for message with messageId '${bMessage.messageId}'. Hence we will stop the autoLockRenewTask.`);
                    this.stop(linkEntity, bMessage);
                } else if (Date.now() >= totalAutoLockRenewDuration) {
                    // once we've exceeded the max amount of time we'll renew we can stop.
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${logPrefix} Current time ${new Date()} exceeds the total autolockrenew duration ${totalAutoLockRenewDurationDate} for message with messageId '${bMessage.messageId}'. Hence we will stop the autoLockRenewTask.`);
                    this.stop(linkEntity, bMessage);
                } else if (linkMessageMap.has(bMessage.messageId)) {
                    // TODO: We can run into problems with clock skew between the client and the server.
                    // It would be better to calculate the duration based on the "lockDuration" property
                    // of the queue. However, we do not have the management plane of the client ready for
                    // now. Hence we rely on the lockedUntilUtc property on the message set by ServiceBus.
                    const amount = this._calculateRenewAfterDuration(bMessage.lockedUntilUtc);
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${logPrefix} Sleeping for ${amount} milliseconds while renewing the lock for message with id '${bMessage.messageId}'`);
                    // Setting the value of the messageId to the actual timer. This will be cleared when
                    // an attempt is made to settle the message (either by the user or by the sdk) OR
                    // when the execution of user's message handler completes.
                    const autoRenewTimer = setTimeout(async ()=>{
                        try {
                            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${logPrefix} Attempting to renew the lock for message with id '${bMessage.messageId}'.`);
                            bMessage.lockedUntilUtc = await this._context.getManagementClient(linkEntity.entityPath).renewLock(lockToken, {
                                associatedLinkName: linkEntity.name
                            });
                            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${logPrefix} Successfully renewed the lock for message with id '${bMessage.messageId}'. Starting next auto-lock-renew cycle for message.`);
                            autoRenewLockTask();
                        } catch (err) {
                            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(err, `${logPrefix} An error occurred while auto renewing the message lock '${bMessage.lockToken}' for message with id '${bMessage.messageId}'`);
                            onError(err);
                        }
                    }, amount);
                    // Prevent the active Timer from keeping the Node.js event loop active.
                    if (typeof autoRenewTimer.unref === "function") autoRenewTimer.unref();
                    linkMessageMap.set(bMessage.messageId, autoRenewTimer);
                } else (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${logPrefix} Looks like the message lock renew timer has already been cleared for message with id '${bMessage.messageId}'.`);
            };
            // start
            autoRenewLockTask();
        } catch (err) {
            onError(err);
        }
    }
    _getOrCreateMapForLink(linkEntity) {
        if (!this._messageRenewLockTimers.has(linkEntity.name)) this._messageRenewLockTimers.set(linkEntity.name, new Map());
        return this._messageRenewLockTimers.get(linkEntity.name);
    }
    _stopAndRemoveById(linkEntity, linkMessageMap, messageId) {
        if (messageId == null) throw new Error("Failed to stop auto lock renewal - no message ID");
        // TODO: messageId doesn't actually need to be unique. Perhaps we should use lockToken
        // instead?
        if (linkMessageMap.has(messageId)) {
            clearTimeout(linkMessageMap.get(messageId));
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`${linkEntity.logPrefix} Cleared the message renew lock timer for message with id '${messageId}'.`);
            linkMessageMap.delete(messageId);
        }
    }
}







const $9b4f6ddf5fbb620a$export$2dab46386d3e1c89 = 1000;
class $9b4f6ddf5fbb620a$export$d0175b409ed11669 {
    /**
     * @throws Error if the underlying connection is closed.
     */ constructor(_context, entityPath, receiveMode, maxAutoRenewLockDurationInMs, skipParsingBodyAsJson, skipConvertingDate = false, retryOptions = {}, identifier){
        this._context = _context;
        this.entityPath = entityPath;
        this.receiveMode = receiveMode;
        this.skipParsingBodyAsJson = skipParsingBodyAsJson;
        this.skipConvertingDate = skipConvertingDate;
        /**
         * Denotes if close() was called on this receiver
         */ this._isClosed = false;
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(_context);
        this._retryOptions = retryOptions;
        this._lockRenewer = (0, $b652862b83644fc9$export$46e751174cfd95d5).create(this._context, maxAutoRenewLockDurationInMs, receiveMode);
        this.identifier = (0, $3402f46f0a1b2976$export$dad746c31d112b77)(this.entityPath, identifier);
    }
    get logPrefix() {
        return `[${this._context.connectionId}|receiver:${this.entityPath}]`;
    }
    _throwIfAlreadyReceiving() {
        if (this._isReceivingMessages()) {
            const errorMessage = (0, $f4faabfcfe4aedfc$export$683aa5b1f4396e5d)(this.entityPath);
            const error = new Error(errorMessage);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${this.logPrefix} is already receiving`);
            throw error;
        }
    }
    _throwIfReceiverOrConnectionClosed() {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        if (this.isClosed) {
            const errorMessage = (0, $f4faabfcfe4aedfc$export$b84680138471c3a3)(this.entityPath);
            const error = new Error(errorMessage);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${this.logPrefix} is closed`);
            throw error;
        }
    }
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    async receiveMessages(maxMessageCount, options) {
        this._throwIfReceiverOrConnectionClosed();
        this._throwIfAlreadyReceiving();
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(this._context.connectionId, "maxMessageCount", maxMessageCount);
        (0, $f4faabfcfe4aedfc$export$731df47d11cad7fa)(this._context.connectionId, "maxMessageCount", maxMessageCount, "number");
        if (isNaN(maxMessageCount) || maxMessageCount < 1) throw new TypeError((0, $f4faabfcfe4aedfc$export$2a7d1d2aeb270d35));
        const receiveMessages = async ()=>{
            var _a;
            if (!this._batchingReceiver || !this._context.messageReceivers[this._batchingReceiver.name]) {
                const receiveOptions = {
                    maxConcurrentCalls: 0,
                    receiveMode: this.receiveMode,
                    lockRenewer: this._lockRenewer,
                    skipParsingBodyAsJson: this.skipParsingBodyAsJson,
                    skipConvertingDate: this.skipConvertingDate
                };
                this._batchingReceiver = this._createBatchingReceiver(this._context, this.entityPath, receiveOptions);
            }
            const receivedMessages = await this._batchingReceiver.receive(maxMessageCount, (_a = options === null || options === void 0 ? void 0 : options.maxWaitTimeInMs) !== null && _a !== void 0 ? _a : (0, $807770c0815ec6f8$export$a002182e51710d39).defaultOperationTimeoutInMs, $9b4f6ddf5fbb620a$export$2dab46386d3e1c89, options !== null && options !== void 0 ? options : {});
            return receivedMessages;
        };
        const config = {
            connectionHost: this._context.config.host,
            connectionId: this._context.connectionId,
            operation: receiveMessages,
            operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).receiveMessage,
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
            retryOptions: this._retryOptions
        };
        return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config).catch((err)=>{
            throw (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
        });
    }
    getMessageIterator(options) {
        return (0, $e4f5d79c9cac0816$export$d0444fcc39ce3e12)(this, options);
    }
    async receiveDeferredMessages(sequenceNumbers, options = {}) {
        this._throwIfReceiverOrConnectionClosed();
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
        (0, $f4faabfcfe4aedfc$export$d0c336de1cbf0354)(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
        const deferredSequenceNumbers = Array.isArray(sequenceNumbers) ? sequenceNumbers : [
            sequenceNumbers
        ];
        const receiveDeferredMessagesOperationPromise = async ()=>{
            const deferredMessages = await this._context.getManagementClient(this.entityPath).receiveDeferredMessages(deferredSequenceNumbers, this.receiveMode, undefined, Object.assign(Object.assign({}, options), {
                associatedLinkName: this._getAssociatedReceiverName(),
                requestName: "receiveDeferredMessages",
                timeoutInMs: this._retryOptions.timeoutInMs
            }));
            return deferredMessages;
        };
        const config = {
            operation: receiveDeferredMessagesOperationPromise,
            connectionId: this._context.connectionId,
            operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).management,
            retryOptions: this._retryOptions,
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
        };
        return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config);
    }
    // ManagementClient methods # Begin
    async peekMessages(maxMessageCount, options = {}) {
        var _a;
        this._throwIfReceiverOrConnectionClosed();
        const managementRequestOptions = Object.assign(Object.assign({}, options), {
            associatedLinkName: this._getAssociatedReceiverName(),
            requestName: "peekMessages",
            timeoutInMs: (_a = this._retryOptions) === null || _a === void 0 ? void 0 : _a.timeoutInMs
        });
        const peekOperationPromise = async ()=>{
            if (options.fromSequenceNumber !== undefined) return this._context.getManagementClient(this.entityPath).peekBySequenceNumber(options.fromSequenceNumber, maxMessageCount, undefined, options.omitMessageBody, managementRequestOptions);
            else return this._context.getManagementClient(this.entityPath).peek(maxMessageCount, options.omitMessageBody, managementRequestOptions);
        };
        const config = {
            operation: peekOperationPromise,
            connectionId: this._context.connectionId,
            operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).management,
            retryOptions: this._retryOptions,
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
        };
        return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config);
    }
    subscribe(handlers, options) {
        var _a, _b;
        (0, $e4f5d79c9cac0816$export$42a658e3d1d65dcf)(handlers);
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        this._throwIfReceiverOrConnectionClosed();
        this._throwIfAlreadyReceiving();
        options = Object.assign(Object.assign({}, options !== null && options !== void 0 ? options : {}), {
            autoCompleteMessages: (_a = options === null || options === void 0 ? void 0 : options.autoCompleteMessages) !== null && _a !== void 0 ? _a : true
        });
        // When the user "stops" a streaming receiver (via the returned instance from 'subscribe' we just suspend
        // it, leaving the link open). This allows users to stop the flow of messages but still be able to settle messages
        // since the link itself hasn't been shut down.
        //
        // Users can, if they want, restart their subscription (since we've got a link already established).
        // So you'll have an instance here if the user has done:
        // 1. const subscription = receiver.subscribe()
        // 2. subscription.stop()
        // 3. receiver.subscribe()
        this._streamingReceiver = (_b = this._streamingReceiver) !== null && _b !== void 0 ? _b : new (0, $05d1aefd355be7fa$export$fef7d8f40dbed75d)(this.identifier, this._context, this.entityPath, Object.assign(Object.assign({}, options), {
            receiveMode: this.receiveMode,
            retryOptions: this._retryOptions,
            lockRenewer: this._lockRenewer,
            skipParsingBodyAsJson: this.skipParsingBodyAsJson,
            skipConvertingDate: this.skipConvertingDate
        }));
        // this ensures that if the outer service bus client is closed that  this receiver is cleaned up.
        // this mostly affects us if we're in the middle of init() - the connection (and receiver) are not yet
        // open but we do need to close the receiver to exit the init() loop.
        this._context.messageReceivers[this._streamingReceiver.name] = this._streamingReceiver;
        this._streamingReceiver.subscribe(handlers, options).catch((_)=>{
            // (the error will already have been reported to the user)
            if (this._streamingReceiver) delete this._context.messageReceivers[this._streamingReceiver.name];
        });
        return {
            close: async ()=>{
                var _a;
                return (_a = this._streamingReceiver) === null || _a === void 0 ? void 0 : _a.stopReceivingMessages();
            }
        };
    }
    async completeMessage(message) {
        this._throwIfReceiverOrConnectionClosed();
        (0, $f4faabfcfe4aedfc$export$a8e335484e7a74b0)(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return (0, $e4f5d79c9cac0816$export$fbd7e56e722b700b)(msgImpl, this._context, this.entityPath, this._retryOptions);
    }
    async abandonMessage(message, propertiesToModify) {
        this._throwIfReceiverOrConnectionClosed();
        (0, $f4faabfcfe4aedfc$export$a8e335484e7a74b0)(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return (0, $e4f5d79c9cac0816$export$402a56cd3be588c3)(msgImpl, this._context, this.entityPath, propertiesToModify, this._retryOptions);
    }
    async deferMessage(message, propertiesToModify) {
        this._throwIfReceiverOrConnectionClosed();
        (0, $f4faabfcfe4aedfc$export$a8e335484e7a74b0)(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return (0, $e4f5d79c9cac0816$export$8277e8e47fef2719)(msgImpl, this._context, this.entityPath, propertiesToModify, this._retryOptions);
    }
    async deadLetterMessage(message, options) {
        this._throwIfReceiverOrConnectionClosed();
        (0, $f4faabfcfe4aedfc$export$a8e335484e7a74b0)(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return (0, $e4f5d79c9cac0816$export$b52a045fd4426c36)(msgImpl, this._context, this.entityPath, options, this._retryOptions);
    }
    async renewMessageLock(message) {
        this._throwIfReceiverOrConnectionClosed();
        (0, $f4faabfcfe4aedfc$export$a8e335484e7a74b0)(message, this.receiveMode, this._context.connectionId);
        const tracingContext = (0, $14342bb4fa4d757f$export$5d22a619cc3705a0)(message);
        const spanLinks = tracingContext ? [
            {
                tracingContext: tracingContext
            }
        ] : [];
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusReceiver.renewMessageLock", {}, ()=>{
            const msgImpl = message;
            let associatedLinkName;
            if (msgImpl.delivery.link) {
                const associatedReceiver = this._context.getReceiverFromCache(msgImpl.delivery.link.name);
                associatedLinkName = associatedReceiver === null || associatedReceiver === void 0 ? void 0 : associatedReceiver.name;
            }
            return this._context.getManagementClient(this.entityPath).renewLock(message.lockToken, {
                associatedLinkName: associatedLinkName
            }).then((lockedUntil)=>{
                message.lockedUntilUtc = lockedUntil;
                return lockedUntil;
            });
        }, Object.assign({
            spanLinks: spanLinks
        }, (0, $10b26da869f0d653$export$d2129a31a8b4253f)({
            entityPath: this.entityPath,
            host: this._context.config.host
        }, "client")));
    }
    async close() {
        try {
            this._isClosed = true;
            if (this._context.connection && this._context.connection.isOpen()) {
                // Close the streaming receiver.
                if (this._streamingReceiver) await this._streamingReceiver.close();
                // Close the batching receiver.
                if (this._batchingReceiver) await this._batchingReceiver.close();
            }
        } catch (err) {
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(err, `${this.logPrefix} An error occurred while closing the Receiver`);
            throw err;
        }
    }
    /**
     * Indicates whether the receiver is currently receiving messages or not.
     * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.
     */ _isReceivingMessages() {
        if (this._streamingReceiver && this._streamingReceiver.isOpen() && this._streamingReceiver.isSubscribeActive) return true;
        if (this._batchingReceiver && this._batchingReceiver.isOpen() && this._batchingReceiver.isReceivingMessages) return true;
        return false;
    }
    _createBatchingReceiver(context, entityPath, options) {
        const receiver = (0, $83f93614d540afee$export$9d0845ea0b55e35f).create(this.identifier, context, entityPath, options);
        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose(`[${this.logPrefix}] receiver '${receiver.name}' created, with maxConcurrentCalls set to ${options.maxConcurrentCalls}.`);
        return receiver;
    }
    /**
     * Helper function to retrieve any active receiver name, regardless of streaming or
     * batching if it exists. This is used for optimization on the service side
     */ _getAssociatedReceiverName() {
        if (this._streamingReceiver && this._streamingReceiver.isOpen()) return this._streamingReceiver.name;
        if (this._batchingReceiver && this._batchingReceiver.isOpen() && this._batchingReceiver.isReceivingMessages) return this._batchingReceiver.name;
        return;
    }
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.








class $23fa95c974a3c272$export$ee7da49ff4de6f04 {
    /**
     * @internal
     * @throws Error if the underlying connection is closed.
     * @throws Error if an open receiver is already existing for given sessionId.
     */ constructor(_messageSession, _context, entityPath, receiveMode, _retryOptions = {}){
        this._messageSession = _messageSession;
        this._context = _context;
        this.entityPath = entityPath;
        this.receiveMode = receiveMode;
        this._retryOptions = _retryOptions;
        /**
         * Denotes if close() was called on this receiver
         */ this._isClosed = false;
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(_context);
        this.sessionId = _messageSession.sessionId;
        this.identifier = _messageSession.identifier;
    }
    get logPrefix() {
        return `[${this._context.connectionId}|session:${this.entityPath}]`;
    }
    _throwIfReceiverOrConnectionClosed() {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        if (this.isClosed) {
            if (this._isClosed) {
                const errorMessage = (0, $f4faabfcfe4aedfc$export$b84680138471c3a3)(this.entityPath, this.sessionId);
                const error = new Error(errorMessage);
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${this.logPrefix} already closed`);
                throw error;
            }
            const amqpError = {
                condition: (0, $3d84b7093289460f$export$65de4560c7cb6642).SessionLockLostError,
                description: `The session lock has expired on the session with id ${this.sessionId}`
            };
            throw (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(amqpError);
        }
    }
    _throwIfAlreadyReceiving() {
        if (this._isReceivingMessages()) {
            const errorMessage = (0, $f4faabfcfe4aedfc$export$683aa5b1f4396e5d)(this.entityPath, this.sessionId);
            const error = new Error(errorMessage);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${this.logPrefix} is already receiving.`);
            throw error;
        }
    }
    get isClosed() {
        return this._isClosed || !this._context.messageSessions[this._messageSession.name] || !this._messageSession.isOpen();
    }
    /**
     * The time in UTC until which the session is locked.
     * Every time `renewSessionLock()` is called, this time gets updated to current time plus the lock
     * duration as specified during the Queue/Subscription creation.
     *
     * When the lock on the session expires
     * - The current receiver can no longer be used to receive more messages.
     * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.
     * - Messages that were received in `peekLock` mode with this receiver but not yet settled
     * will land back in the Queue/Subscription with their delivery count incremented.
     *
     * @readonly
     */ get sessionLockedUntilUtc() {
        return this._messageSession.sessionLockedUntilUtc;
    }
    /**
     * Renews the lock on the session for the duration as specified during the Queue/Subscription
     * creation. You can check the `sessionLockedUntilUtc` property for the time when the lock expires.
     *
     * When the lock on the session expires
     * - The current receiver can no longer be used to receive mode messages.
     * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.
     * - Messages that were received in `peekLock` mode with this receiver but not yet settled
     * will land back in the Queue/Subscription with their delivery count incremented.
     *
     * @param options - Options bag to pass an abort signal or tracing options.
     * @returns New lock token expiry date and time in UTC format.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws `ServiceBusError` if the service returns an error while renewing session lock.
     */ async renewSessionLock(options) {
        this._throwIfReceiverOrConnectionClosed();
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusSessionReceiver.renewSessionLock", options !== null && options !== void 0 ? options : {}, (updatedOptions)=>{
            const renewSessionLockOperationPromise = async ()=>{
                this._messageSession.sessionLockedUntilUtc = await this._context.getManagementClient(this.entityPath).renewSessionLock(this.sessionId, Object.assign(Object.assign({}, updatedOptions), {
                    associatedLinkName: this._messageSession.name,
                    requestName: "renewSessionLock",
                    timeoutInMs: this._retryOptions.timeoutInMs
                }));
                return this._messageSession.sessionLockedUntilUtc;
            };
            const config = {
                operation: renewSessionLockOperationPromise,
                connectionId: this._context.connectionId,
                operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config);
        });
    }
    /**
     * Sets the state on the Session. For more on session states, see
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}
     * @param state - The state that needs to be set.
     * @param options - Options bag to pass an abort signal or tracing options.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws `ServiceBusError` if the service returns an error while setting the session state.
     */ async setSessionState(state, options = {}) {
        this._throwIfReceiverOrConnectionClosed();
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusSessionReceiver.setSessionState", options !== null && options !== void 0 ? options : {}, (updatedOptions)=>{
            const setSessionStateOperationPromise = async ()=>{
                await this._context.getManagementClient(this.entityPath).setSessionState(this.sessionId, state, Object.assign(Object.assign({}, updatedOptions), {
                    associatedLinkName: this._messageSession.name,
                    requestName: "setState",
                    timeoutInMs: this._retryOptions.timeoutInMs
                }));
                return;
            };
            const config = {
                operation: setSessionStateOperationPromise,
                connectionId: this._context.connectionId,
                operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config);
        });
    }
    /**
     * Gets the state of the Session. For more on session states, see
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}
     * @param options - Options bag to pass an abort signal or tracing options.
     * @returns The state of that session
     * @throws Error if the underlying connection or receiver is closed.
     * @throws `ServiceBusError` if the service returns an error while retrieving session state.
     */ async getSessionState(options = {}) {
        this._throwIfReceiverOrConnectionClosed();
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusSessionReceiver.getSessionState", options !== null && options !== void 0 ? options : {}, (updatedOptions)=>{
            const getSessionStateOperationPromise = async ()=>{
                return this._context.getManagementClient(this.entityPath).getSessionState(this.sessionId, Object.assign(Object.assign({}, updatedOptions), {
                    associatedLinkName: this._messageSession.name,
                    requestName: "getState",
                    timeoutInMs: this._retryOptions.timeoutInMs
                }));
            };
            const config = {
                operation: getSessionStateOperationPromise,
                connectionId: this._context.connectionId,
                operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            };
            return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config);
        });
    }
    async peekMessages(maxMessageCount, options = {}) {
        var _a;
        this._throwIfReceiverOrConnectionClosed();
        const managementRequestOptions = Object.assign(Object.assign({}, options), {
            associatedLinkName: this._messageSession.name,
            requestName: "peekMessages",
            timeoutInMs: (_a = this._retryOptions) === null || _a === void 0 ? void 0 : _a.timeoutInMs
        });
        const peekOperationPromise = async ()=>{
            if (options.fromSequenceNumber !== undefined) return this._context.getManagementClient(this.entityPath).peekBySequenceNumber(options.fromSequenceNumber, maxMessageCount, this.sessionId, options.omitMessageBody, managementRequestOptions);
            else return this._context.getManagementClient(this.entityPath).peekMessagesBySession(this.sessionId, maxMessageCount, options.omitMessageBody, managementRequestOptions);
        };
        const config = {
            operation: peekOperationPromise,
            connectionId: this._context.connectionId,
            operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).management,
            retryOptions: this._retryOptions,
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
        };
        return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config);
    }
    async receiveDeferredMessages(sequenceNumbers, options = {}) {
        this._throwIfReceiverOrConnectionClosed();
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
        (0, $f4faabfcfe4aedfc$export$d0c336de1cbf0354)(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
        const deferredSequenceNumbers = Array.isArray(sequenceNumbers) ? sequenceNumbers : [
            sequenceNumbers
        ];
        const receiveDeferredMessagesOperationPromise = async ()=>{
            const deferredMessages = await this._context.getManagementClient(this.entityPath).receiveDeferredMessages(deferredSequenceNumbers, this.receiveMode, this.sessionId, Object.assign(Object.assign({}, options), {
                associatedLinkName: this._messageSession.name,
                requestName: "receiveDeferredMessages",
                timeoutInMs: this._retryOptions.timeoutInMs
            }));
            return deferredMessages;
        };
        const config = {
            operation: receiveDeferredMessagesOperationPromise,
            connectionId: this._context.connectionId,
            operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).management,
            retryOptions: this._retryOptions,
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
        };
        return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config);
    }
    async receiveMessages(maxMessageCount, options) {
        this._throwIfReceiverOrConnectionClosed();
        this._throwIfAlreadyReceiving();
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(this._context.connectionId, "maxMessageCount", maxMessageCount);
        (0, $f4faabfcfe4aedfc$export$731df47d11cad7fa)(this._context.connectionId, "maxMessageCount", maxMessageCount, "number");
        if (isNaN(maxMessageCount) || maxMessageCount < 1) throw new TypeError((0, $f4faabfcfe4aedfc$export$2a7d1d2aeb270d35));
        const receiveBatchOperationPromise = async ()=>{
            var _a;
            const receivedMessages = await this._messageSession.receiveMessages(maxMessageCount, (_a = options === null || options === void 0 ? void 0 : options.maxWaitTimeInMs) !== null && _a !== void 0 ? _a : (0, $807770c0815ec6f8$export$a002182e51710d39).defaultOperationTimeoutInMs, (0, $9b4f6ddf5fbb620a$export$2dab46386d3e1c89), options !== null && options !== void 0 ? options : {});
            return receivedMessages;
        };
        const config = {
            operation: receiveBatchOperationPromise,
            connectionId: this._context.connectionId,
            operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).receiveMessage,
            retryOptions: this._retryOptions,
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
        };
        return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config).catch((err)=>{
            throw (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
        });
    }
    subscribe(handlers, options) {
        // TODO - receiverOptions for subscribe??
        (0, $e4f5d79c9cac0816$export$42a658e3d1d65dcf)(handlers);
        options = options !== null && options !== void 0 ? options : {};
        const processError = (0, $e4f5d79c9cac0816$export$e148c2aba7ad0b3a)(handlers);
        this._registerMessageHandler(async (message)=>{
            return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("SessionReceiver.process", options !== null && options !== void 0 ? options : {}, ()=>handlers.processMessage(message), (0, $14342bb4fa4d757f$export$a2478bc4652823e9)(message, this, this._context.config));
        }, processError, options);
        return {
            close: async ()=>{
                var _a;
                return (_a = this._messageSession) === null || _a === void 0 ? void 0 : _a.receiverHelper.suspend();
            }
        };
    }
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the SessionReceiver.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control whether messages should be automatically completed
     * or if the lock on the session should be automatically renewed. You can control the
     * maximum number of messages that should be concurrently processed. You can
     * also provide a timeout in milliseconds to denote the amount of time to wait for a new message
     * before closing the receiver.
     *
     * @throws Error if the underlying connection or receiver is closed.
     * @throws Error if the receiver is already in state of receiving messages.
     * @throws `ServiceBusError` if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.
     */ _registerMessageHandler(onMessage, onError, options) {
        this._throwIfReceiverOrConnectionClosed();
        this._throwIfAlreadyReceiving();
        const connId = this._context.connectionId;
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(connId, "onMessage", onMessage);
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(connId, "onError", onError);
        if (typeof onMessage !== "function") throw new TypeError("The parameter 'onMessage' must be of type 'function'.");
        if (typeof onError !== "function") throw new TypeError("The parameter 'onError' must be of type 'function'.");
        try {
            this._messageSession.subscribe(onMessage, onError, options);
        } catch (err) {
            onError({
                error: err,
                errorSource: "receive",
                entityPath: this.entityPath,
                fullyQualifiedNamespace: this._context.config.host,
                identifier: this.identifier
            });
        }
    }
    getMessageIterator(options) {
        return (0, $e4f5d79c9cac0816$export$d0444fcc39ce3e12)(this, options);
    }
    async completeMessage(message) {
        this._throwIfReceiverOrConnectionClosed();
        (0, $f4faabfcfe4aedfc$export$a8e335484e7a74b0)(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return (0, $e4f5d79c9cac0816$export$fbd7e56e722b700b)(msgImpl, this._context, this.entityPath, this._retryOptions);
    }
    async abandonMessage(message, propertiesToModify) {
        this._throwIfReceiverOrConnectionClosed();
        (0, $f4faabfcfe4aedfc$export$a8e335484e7a74b0)(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return (0, $e4f5d79c9cac0816$export$402a56cd3be588c3)(msgImpl, this._context, this.entityPath, propertiesToModify, this._retryOptions);
    }
    async deferMessage(message, propertiesToModify) {
        this._throwIfReceiverOrConnectionClosed();
        (0, $f4faabfcfe4aedfc$export$a8e335484e7a74b0)(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return (0, $e4f5d79c9cac0816$export$8277e8e47fef2719)(msgImpl, this._context, this.entityPath, propertiesToModify, this._retryOptions);
    }
    async deadLetterMessage(message, options) {
        this._throwIfReceiverOrConnectionClosed();
        (0, $f4faabfcfe4aedfc$export$a8e335484e7a74b0)(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return (0, $e4f5d79c9cac0816$export$b52a045fd4426c36)(msgImpl, this._context, this.entityPath, options, this._retryOptions);
    }
    async renewMessageLock() {
        throw new Error("Renewing message lock is an invalid operation when working with sessions.");
    }
    async close() {
        try {
            await this._messageSession.close();
        } catch (err) {
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(err, "%s An error occurred while closing the SessionReceiver for session %s", this.logPrefix, this.sessionId);
            throw err;
        } finally{
            this._isClosed = true;
        }
    }
    /**
     * Indicates whether the receiver is currently receiving messages or not.
     * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.
     */ _isReceivingMessages() {
        return this._messageSession ? this._messageSession.isReceivingMessages : false;
    }
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.






// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

function $1ce0f4c8de779fbd$export$f7747088dee76bb2(pagedResult) {
    var _a;
    const iter = $1ce0f4c8de779fbd$var$getItemAsyncIterator(pagedResult);
    return {
        next () {
            return iter.next();
        },
        [Symbol.asyncIterator] () {
            return this;
        },
        byPage: (_a = pagedResult === null || pagedResult === void 0 ? void 0 : pagedResult.byPage) !== null && _a !== void 0 ? _a : (settings)=>{
            const { continuationToken: continuationToken , maxPageSize: maxPageSize  } = settings !== null && settings !== void 0 ? settings : {};
            return $1ce0f4c8de779fbd$var$getPageAsyncIterator(pagedResult, {
                pageLink: continuationToken,
                maxPageSize: maxPageSize
            });
        }
    };
}
function $1ce0f4c8de779fbd$var$getItemAsyncIterator(pagedResult) {
    return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* getItemAsyncIterator_1() {
        var e_1, _a, e_2, _b;
        const pages = $1ce0f4c8de779fbd$var$getPageAsyncIterator(pagedResult);
        const firstVal = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(pages.next());
        // if the result does not have an array shape, i.e. TPage = TElement, then we return it as is
        if (!Array.isArray(firstVal.value)) {
            // can extract elements from this page
            const { toElements: toElements  } = pagedResult;
            if (toElements) {
                yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)((yield* (0, $9187fda58d09cc70$export$bbd80228419bb833)((0, $9187fda58d09cc70$export$e3b29a3d6162315f)(toElements(firstVal.value)))));
                try {
                    for(var pages_1 = (0, $9187fda58d09cc70$export$e3b29a3d6162315f)(pages), pages_1_1; pages_1_1 = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(pages_1.next()), !pages_1_1.done;){
                        const page = pages_1_1.value;
                        yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)((yield* (0, $9187fda58d09cc70$export$bbd80228419bb833)((0, $9187fda58d09cc70$export$e3b29a3d6162315f)(toElements(page)))));
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally{
                    try {
                        if (pages_1_1 && !pages_1_1.done && (_a = pages_1.return)) yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_a.call(pages_1));
                    } finally{
                        if (e_1) throw e_1.error;
                    }
                }
            } else {
                yield yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(firstVal.value);
                // `pages` is of type `AsyncIterableIterator<TPage>` but TPage = TElement in this case
                yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)((yield* (0, $9187fda58d09cc70$export$bbd80228419bb833)((0, $9187fda58d09cc70$export$e3b29a3d6162315f)(pages))));
            }
        } else {
            yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)((yield* (0, $9187fda58d09cc70$export$bbd80228419bb833)((0, $9187fda58d09cc70$export$e3b29a3d6162315f)(firstVal.value))));
            try {
                for(var pages_2 = (0, $9187fda58d09cc70$export$e3b29a3d6162315f)(pages), pages_2_1; pages_2_1 = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(pages_2.next()), !pages_2_1.done;){
                    const page = pages_2_1.value;
                    // pages is of type `AsyncIterableIterator<TPage>` so `page` is of type `TPage`. In this branch,
                    // it must be the case that `TPage = TElement[]`
                    yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)((yield* (0, $9187fda58d09cc70$export$bbd80228419bb833)((0, $9187fda58d09cc70$export$e3b29a3d6162315f)(page))));
                }
            } catch (e_2_1) {
                e_2 = {
                    error: e_2_1
                };
            } finally{
                try {
                    if (pages_2_1 && !pages_2_1.done && (_b = pages_2.return)) yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(_b.call(pages_2));
                } finally{
                    if (e_2) throw e_2.error;
                }
            }
        }
    });
}
function $1ce0f4c8de779fbd$var$getPageAsyncIterator(pagedResult, options = {}) {
    return (0, $9187fda58d09cc70$export$e427f37a30a4de9b)(this, arguments, function* getPageAsyncIterator_1() {
        const { pageLink: pageLink , maxPageSize: maxPageSize  } = options;
        let response = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(pagedResult.getPage(pageLink !== null && pageLink !== void 0 ? pageLink : pagedResult.firstPageLink, maxPageSize));
        if (!response) return yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(void 0);
        yield yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(response.page);
        while(response.nextPageLink){
            response = yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(pagedResult.getPage(response.nextPageLink, maxPageSize));
            if (!response) return yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(void 0);
            yield yield (0, $9187fda58d09cc70$export$10c90e4f7922046c)(response.page);
        }
    });
}




class $6a447896987a8cc3$export$ac3acc534f5b7921 {
    /**
     * @internal
     * @throws Error if the underlying connection is closed.
     */ constructor(_context, _entityPath, _retryOptions = {}){
        this._context = _context;
        this._entityPath = _entityPath;
        this._retryOptions = _retryOptions;
        /**
         * Denotes if close() was called on this sender
         */ this._isClosed = false;
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(_context);
        this.entityPath = _entityPath;
        this.name = (0, $3402f46f0a1b2976$export$798a797a6d4e253e)("ruleManager");
    }
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    async createRule(ruleName, filter, ruleActionOrOperationOptions, options = {}) {
        let sqlRuleAction = undefined;
        let operOptions;
        if (ruleActionOrOperationOptions) {
            if ((0, $02cef6d7b305ba6a$export$fe1f0ef55e4df00d)(ruleActionOrOperationOptions)) {
                // Overload#2 - where the sqlExpression in the ruleAction is defined
                sqlRuleAction = ruleActionOrOperationOptions;
                operOptions = options;
            } else // Overload#1 - where the sqlExpression in the ruleAction is undefined
            operOptions = Object.assign(Object.assign({}, ruleActionOrOperationOptions), options);
        }
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusRuleManager.createRule", operOptions !== null && operOptions !== void 0 ? operOptions : {}, async (updatedOptions)=>{
            const addRuleOperationPromise = async ()=>{
                return this._context.getManagementClient(this._entityPath).addRule(ruleName, filter, sqlRuleAction === null || sqlRuleAction === void 0 ? void 0 : sqlRuleAction.sqlExpression, Object.assign(Object.assign({}, updatedOptions), {
                    associatedLinkName: this.name,
                    requestName: "addRule",
                    timeoutInMs: this._retryOptions.timeoutInMs
                }));
            };
            const config = {
                operation: addRuleOperationPromise,
                connectionId: this._context.connectionId,
                operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).management,
                retryOptions: this._retryOptions,
                abortSignal: updatedOptions === null || updatedOptions === void 0 ? void 0 : updatedOptions.abortSignal
            };
            return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config);
        });
    }
    /**
     * Get all rules associated with the subscription.
     */ async getRules(options) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusRuleManager.getRules", options !== null && options !== void 0 ? options : {}, async (updatedOptions)=>{
            const getRulesOperationPromise = async ()=>{
                return this._context.getManagementClient(this._entityPath).getRules(Object.assign(Object.assign({}, updatedOptions), {
                    associatedLinkName: this.name,
                    requestName: "getRules",
                    timeoutInMs: this._retryOptions.timeoutInMs
                }));
            };
            const config = {
                operation: getRulesOperationPromise,
                connectionId: this._context.connectionId,
                operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).management,
                retryOptions: this._retryOptions,
                abortSignal: updatedOptions === null || updatedOptions === void 0 ? void 0 : updatedOptions.abortSignal
            };
            return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config);
        });
    }
    /**
     * Returns an async iterable iterator to list all the rules
     * under the specified subscription.
     *
     * .byPage() returns an async iterable iterator to list the rules in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */ listRules(// eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        (0, $f014dc9d393cdf62$export$f4fc36e28d2894a8).verbose(`Performing operation - listRules() with options: %j`, options);
        const pagedResult = {
            firstPageLink: 0,
            getPage: async (pageLink, maxPageSize)=>{
                const top = maxPageSize !== null && maxPageSize !== void 0 ? maxPageSize : 100;
                const rules = await this.getRules(Object.assign({
                    skip: pageLink,
                    maxCount: top
                }, options));
                return rules.length ? {
                    page: rules,
                    nextPageLink: rules.length > 0 ? pageLink + rules.length : undefined
                } : undefined;
            }
        };
        return (0, $1ce0f4c8de779fbd$export$f7747088dee76bb2)(pagedResult);
    }
    /**
     * Deletes a rule.
     */ async deleteRule(ruleName, options = {}) {
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusRuleManager.deleteRule", options, async (updatedOptions)=>{
            const removeRuleOperationPromise = async ()=>{
                return this._context.getManagementClient(this._entityPath).removeRule(ruleName, Object.assign(Object.assign({}, updatedOptions), {
                    associatedLinkName: this.name,
                    requestName: "removeRule",
                    timeoutInMs: this._retryOptions.timeoutInMs
                }));
            };
            const config = {
                operation: removeRuleOperationPromise,
                connectionId: this._context.connectionId,
                operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).management,
                retryOptions: this._retryOptions,
                abortSignal: updatedOptions === null || updatedOptions === void 0 ? void 0 : updatedOptions.abortSignal
            };
            return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config);
        });
    }
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.







// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.





/**
 * @internal
 * The amount of bytes to reserve as overhead for a small message.
 */ const $c25d6293774dd987$var$smallMessageOverhead = 5;
/**
 * @internal
 * The amount of bytes to reserve as overhead for a large message.
 */ const $c25d6293774dd987$var$largeMessageOverhead = 8;
/**
 * @internal
 * The maximum number of bytes that a message may be to be considered small.
 */ const $c25d6293774dd987$var$smallMessageMaxBytes = 255;
class $c25d6293774dd987$export$a12968219c1b5781 {
    /**
     * ServiceBusMessageBatch should not be constructed using `new ServiceBusMessageBatch()`
     * Use the `createBatch()` method on your `Sender` instead.
     * @internal
     * @hidden
     */ constructor(_context, _maxSizeInBytes){
        this._context = _context;
        this._maxSizeInBytes = _maxSizeInBytes;
        /**
         * Encoded amqp messages.
         */ this._encodedMessages = [];
        /**
         * List of 'message' span contexts.
         */ this._spanContexts = [];
        this._sizeInBytes = 0;
        this._batchMessageProperties = {};
    }
    /**
     * The maximum size of the batch, in bytes.
     * @readonly
     */ get maxSizeInBytes() {
        return this._maxSizeInBytes;
    }
    /**
     * Size of the `ServiceBusMessageBatch` instance after the messages added to it have been
     * encoded into a single AMQP message.
     * @readonly
     */ get sizeInBytes() {
        return this._sizeInBytes;
    }
    /**
     * Number of messages in the `ServiceBusMessageBatch` instance.
     * @readonly
     */ get count() {
        return this._encodedMessages.length;
    }
    /**
     * Gets the "message" span contexts that were created when adding messages to the batch.
     * @internal
     * @hidden
     */ get _messageSpanContexts() {
        return this._spanContexts;
    }
    /**
     * Generates an AMQP message that contains the provided encoded messages and annotations.
     *
     * @param encodedMessages - The already encoded messages to include in the AMQP batch.
     * @param annotations - The message annotations to set on the batch.
     * @param applicationProperties - The application properties to set on the batch.
     * @param messageProperties - The message properties to set on the batch.
     */ _generateBatch(encodedMessages, annotations, applicationProperties, messageProperties) {
        const batchEnvelope = {
            body: (0, $4973e2e602c1cc10$exports.message).data_sections(encodedMessages),
            message_annotations: annotations,
            application_properties: applicationProperties
        };
        if (messageProperties) {
            for (const prop of (0, $4973e2e602c1cc10$exports.messageProperties))if (messageProperties[prop]) batchEnvelope[prop] = messageProperties[prop];
        }
        return (0, $4973e2e602c1cc10$exports.message).encode(batchEnvelope);
    }
    /**
     * Represents the single AMQP message which is the result of encoding all the events
     * added into the `ServiceBusMessageBatch` instance.
     *
     * This is not meant for the user to use directly.
     *
     * When the `ServiceBusMessageBatch` instance is passed to the `sendBatch()` method on the `Sender`,
     * this single batched AMQP message is what gets sent over the wire to the service.
     * @readonly
     */ _generateMessage() {
        return this._generateBatch(this._encodedMessages, this._batchAnnotations, this._batchApplicationProperties, this._batchMessageProperties);
    }
    /**
     * Tries to add a message to the batch if permitted by the batch's size limit.
     * **NOTE**: Always remember to check the return value of this method, before calling it again
     * for the next message.
     *
     * @param originalMessage - An individual service bus message.
     * @returns A boolean value indicating if the message has been added to the batch or not.
     */ tryAddMessage(originalMessage, options = {}) {
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(this._context.connectionId, "message", originalMessage);
        (0, $f4faabfcfe4aedfc$export$967aa9e81b482b79)(originalMessage, (0, $f4faabfcfe4aedfc$export$5c1e262b654d0f82));
        const { message: message , spanContext: spanContext  } = (0, $14342bb4fa4d757f$export$9bea097ef11100d9)(originalMessage, options, this._context.config.entityPath, this._context.config.host);
        // Convert ServiceBusMessage to AmqpMessage.
        const amqpMessage = (0, $d7965bb09cbe6503$export$cca86c1f4325d7b8)(message, (0, $6043267107e2d71b$export$317b368fb2b0354d));
        const encodedMessage = (0, $4973e2e602c1cc10$exports.message).encode(amqpMessage);
        let currentSize = this._sizeInBytes;
        // The first time an event is added, we need to calculate
        // the overhead of creating an AMQP batch, including the
        // message_annotations, application_properties and message_properties
        // that are taken from the 1st message.
        if (this.count === 0) {
            if (amqpMessage.message_annotations) this._batchAnnotations = amqpMessage.message_annotations;
            if (amqpMessage.application_properties) this._batchApplicationProperties = amqpMessage.application_properties;
            for (const prop of (0, $4973e2e602c1cc10$exports.messageProperties))if (amqpMessage[prop]) this._batchMessageProperties[prop] = amqpMessage[prop];
            // Figure out the overhead of creating a batch by generating an empty batch
            // with the expected batch annotations.
            currentSize += this._generateBatch([], this._batchAnnotations, this._batchApplicationProperties, this._batchMessageProperties).length;
        }
        const messageSize = encodedMessage.length;
        const messageOverhead = messageSize <= $c25d6293774dd987$var$smallMessageMaxBytes ? $c25d6293774dd987$var$smallMessageOverhead : $c25d6293774dd987$var$largeMessageOverhead;
        currentSize += messageSize + messageOverhead;
        // Check if the size of the batch exceeds the maximum allowed size
        // once we add the new event to it.
        if (currentSize > this._maxSizeInBytes) return false;
        // The message will fit in the batch, so it is now safe to store it.
        this._encodedMessages.push(encodedMessage);
        if (spanContext) this._spanContexts.push(spanContext);
        this._sizeInBytes = currentSize;
        return true;
    }
}





class $5a3e170085792353$export$9a6491f300f3bd5c extends (0, $12c81f6e1047261d$export$3ba4e37e9c27f9bb) {
    constructor(identifier, connectionContext, entityPath, retryOptions){
        super(entityPath, entityPath, connectionContext, "sender", (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3), {
            address: entityPath,
            audience: `${connectionContext.config.endpoint}${entityPath}`
        });
        this.identifier = identifier;
        this._retryOptions = retryOptions;
        this._onAmqpError = (context)=>{
            const senderError = context.sender && context.sender.error;
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(senderError, "%s 'sender_error' event occurred on the sender '%s' with address '%s'. The associated error", this.logPrefix, this.name, this.address);
        // TODO: Consider rejecting promise in trySendBatch() or createBatch()
        };
        this._onSessionError = (context)=>{
            const sessionError = context.session && context.session.error;
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(sessionError, "%s 'session_error' event occurred on the session of sender '%s' with address '%s'. The associated error", this.logPrefix, this.name, this.address);
        // TODO: Consider rejecting promise in trySendBatch() or createBatch()
        };
        this._onAmqpClose = async (context)=>{
            const senderError = context.sender && context.sender.error;
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(senderError, `${this.logPrefix} 'sender_close' event occurred. The associated error is`);
            await this.onDetached().catch((err)=>{
                (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(err, `${this.logPrefix} error when closing sender after 'sender_close' event`);
            });
        };
        this._onSessionClose = async (context)=>{
            const sessionError = context.session && context.session.error;
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(sessionError, `${this.logPrefix} 'session_close' event occurred. The associated error is`);
            await this.onDetached().catch((err)=>{
                (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(err, `${this.logPrefix} error when closing sender after 'session_close' event`);
            });
        };
    }
    _createSenderOptions(newName) {
        if (newName) this.name = (0, $3402f46f0a1b2976$export$798a797a6d4e253e)(this.baseName);
        const srOptions = {
            name: this.name,
            target: {
                address: this.address
            },
            source: this.identifier,
            onError: this._onAmqpError,
            onClose: this._onAmqpClose,
            onSessionError: this._onSessionError,
            onSessionClose: this._onSessionClose
        };
        (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).verbose(`${this.logPrefix} Creating sender with options: %O`, srOptions);
        return srOptions;
    }
    /**
     * Tries to send the message to ServiceBus if there is enough credit to send them
     * and the circular buffer has available space to settle the message after sending them.
     *
     * We have implemented a synchronous send over here in the sense that we shall be waiting
     * for the message to be accepted or rejected and accordingly resolve or reject the promise.
     *
     * @param encodedMessage - The encoded message to be sent to ServiceBus.
     * @param sendBatch - Boolean indicating whether the encoded message represents a batch of messages or not
     */ _trySend(encodedMessage, sendBatch, options) {
        const abortSignal = options === null || options === void 0 ? void 0 : options.abortSignal;
        const timeoutInMs = !(0, $a7961d970a7496cb$export$4e62c701997796c1)(this._retryOptions.timeoutInMs) ? (0, $807770c0815ec6f8$export$a002182e51710d39).defaultOperationTimeoutInMs : this._retryOptions.timeoutInMs;
        const sendEventPromise = async ()=>{
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const initStartTime = Date.now();
            if (!this.isOpen()) try {
                await (0, $3402f46f0a1b2976$export$302134c8253a54bb)({
                    actionFn: ()=>this.open(undefined, options === null || options === void 0 ? void 0 : options.abortSignal),
                    abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
                    timeoutMs: timeoutInMs,
                    timeoutMessage: `[${this._context.connectionId}] Sender "${this.name}" ` + `with address "${this.address}", was not able to send the message right now, due ` + `to operation timeout.`
                });
            } catch (err) {
                const translatedError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
                (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(translatedError, "%s An error occurred while creating the sender", this.logPrefix, this.name);
                throw translatedError;
            }
            const timeTakenByInit = Date.now() - initStartTime;
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).verbose("%s Sender '%s', credit: %d available: %d", this.logPrefix, this.name, (_a = this.link) === null || _a === void 0 ? void 0 : _a.credit, (_d = (_c = (_b = this.link) === null || _b === void 0 ? void 0 : _b.session) === null || _c === void 0 ? void 0 : _c.outgoing) === null || _d === void 0 ? void 0 : _d.available());
            let waitTimeForSendable = 1000;
            if (!((_e = this.link) === null || _e === void 0 ? void 0 : _e.sendable()) && timeoutInMs - timeTakenByInit > waitTimeForSendable) {
                (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).verbose("%s Sender '%s', waiting for 1 second for sender to become sendable", this.logPrefix, this.name);
                await (0, $29b64d391bfe12b4$export$1391212d75b2ee65)(waitTimeForSendable);
                (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).verbose("%s Sender '%s' after waiting for a second, credit: %d available: %d", this.logPrefix, this.name, (_f = this.link) === null || _f === void 0 ? void 0 : _f.credit, (_j = (_h = (_g = this.link) === null || _g === void 0 ? void 0 : _g.session) === null || _h === void 0 ? void 0 : _h.outgoing) === null || _j === void 0 ? void 0 : _j.available());
            } else waitTimeForSendable = 0;
            if (!((_k = this.link) === null || _k === void 0 ? void 0 : _k.sendable())) {
                // let us retry to send the message after some time.
                const msg = `[${this.logPrefix}] Sender "${this.name}", ` + `cannot send the message right now. Please try later.`;
                (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).warning(msg);
                const amqpError = {
                    condition: (0, $3d84b7093289460f$export$65de4560c7cb6642).SenderBusyError,
                    description: msg
                };
                throw (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(amqpError);
            }
            if (timeoutInMs <= timeTakenByInit + waitTimeForSendable) {
                const desc = `${this.logPrefix} Sender "${this.name}" ` + `with address "${this.address}", was not able to send the message right now, due ` + `to operation timeout.`;
                (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).warning(desc);
                const e = {
                    condition: (0, $3d84b7093289460f$export$65de4560c7cb6642).ServiceUnavailableError,
                    description: desc
                };
                throw (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(e);
            }
            try {
                const delivery = await this.link.send(encodedMessage, {
                    format: sendBatch ? 0x80013700 : 0,
                    timeoutInSeconds: (timeoutInMs - timeTakenByInit - waitTimeForSendable) / 1000,
                    abortSignal: abortSignal
                });
                (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).verbose("%s Sender '%s', sent message with delivery id: %d", this.logPrefix, this.name, delivery.id);
            } catch (error) {
                const translatedError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(error.innerError || error);
                (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(translatedError, `${this.logPrefix} An error occurred while sending the message`);
                throw translatedError;
            }
        };
        const config = {
            operation: sendEventPromise,
            connectionId: this._context.connectionId,
            operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).sendMessage,
            retryOptions: this._retryOptions,
            abortSignal: abortSignal
        };
        return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config);
    }
    createRheaLink(options) {
        return this._context.connection.createAwaitableSender(options);
    }
    /**
     * Initializes the sender session on the connection.
     */ async open(options, abortSignal) {
        try {
            if (!options) options = this._createSenderOptions();
            await this.initLink(options, abortSignal);
        } catch (err) {
            const translatedError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(translatedError, `${this.logPrefix} An error occurred while creating the sender`);
            // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.
            if (translatedError.code === "OperationTimeoutError") translatedError.message = "Failed to create a sender within allocated time and retry attempts.";
            throw translatedError;
        }
    }
    /**
     * Closes the rhea link.
     * To be called when connection is disconnected, onAmqpClose and onSessionClose events.
     */ async onDetached() {
        // Clears the token renewal timer. Closes the link and its session if they are open.
        // Removes the link and its session if they are present in rhea's cache.
        await this.closeLink();
    }
    /**
     * Determines whether the AMQP sender link is open. If open then returns true else returns false.
     */ isOpen() {
        const result = this.link == null ? false : this.link.isOpen();
        (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).verbose("%s Sender '%s' with address '%s' is open? -> %s", this.logPrefix, this.name, this.address, result);
        return result;
    }
    /**
     * Sends the given message, with the given options on this link
     *
     * @param data - Message to send. Will be sent as UTF8-encoded JSON string.
     */ async send(data, options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        try {
            const amqpMessage = (0, $d7965bb09cbe6503$export$cca86c1f4325d7b8)(data, (0, $6043267107e2d71b$export$317b368fb2b0354d));
            // TODO: this body of logic is really similar to what's in sendMessages. Unify what we can.
            const encodedMessage = (0, $4973e2e602c1cc10$exports.message).encode(amqpMessage);
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).verbose("%s Sender '%s', trying to send message: %O", this.logPrefix, this.name, data);
            return await this._trySend(encodedMessage, false, options);
        } catch (err) {
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(err, "%s An error occurred while sending the message: %O\nError", this.logPrefix, data);
            throw err;
        }
    }
    /**
     * Returns maximum message size on the AMQP sender link.
     *
     * Options to configure the `createBatch` method on the `Sender`.
     * - `maxSizeInBytes`: The upper limit for the size of batch.
     *
     * Example usage:
     * ```js
     * {
     *     retryOptions: { maxRetries: 5; timeoutInMs: 10 }
     * }
     * ```
     */ async getMaxMessageSize(options = {}) {
        const retryOptions = options.retryOptions || {};
        if (this.isOpen()) return this.link.maxMessageSize;
        const config = {
            operation: async ()=>{
                await this.open(undefined, options === null || options === void 0 ? void 0 : options.abortSignal);
                if (this.link) return this.link.maxMessageSize;
                throw new (0, $c6ec964bc6c55a71$export$a7174187385dd2e2)("Link failed to initialize, cannot get max message size.", "GeneralError");
            },
            connectionId: this._context.connectionId,
            operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).senderLink,
            retryOptions: retryOptions,
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
        };
        return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config);
    }
    async createBatch(options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        let maxMessageSize = await this.getMaxMessageSize({
            retryOptions: this._retryOptions,
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
        });
        if (options === null || options === void 0 ? void 0 : options.maxSizeInBytes) {
            if (options.maxSizeInBytes > maxMessageSize) {
                const error = new Error(`Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link.`);
                throw error;
            }
            maxMessageSize = options.maxSizeInBytes;
        }
        return new (0, $c25d6293774dd987$export$a12968219c1b5781)(this._context, maxMessageSize);
    }
    async sendBatch(batchMessage, options) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        try {
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).verbose("%s Sender '%s', sending encoded batch message.", this.logPrefix, this.name, batchMessage);
            return await this._trySend(batchMessage._generateMessage(), true, options);
        } catch (err) {
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(err, "%s Sender '%s': An error occurred while sending the messages: %O\nError", this.logPrefix, this.name, batchMessage);
            throw err;
        }
    }
    static create(identifier, context, entityPath, retryOptions) {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(context);
        const sbSender = new $5a3e170085792353$export$9a6491f300f3bd5c(identifier, context, entityPath, retryOptions);
        context.senders[sbSender.name] = sbSender;
        return sbSender;
    }
    removeLinkFromContext() {
        delete this._context.senders[this.name];
    }
}









class $7c819730788b41d6$export$385e32dcb8110119 {
    /**
     * @internal
     * @throws Error if the underlying connection is closed.
     */ constructor(_context, _entityPath, retryOptions = {}, identifier){
        this._context = _context;
        this._entityPath = _entityPath;
        /**
         * Denotes if close() was called on this sender
         */ this._isClosed = false;
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(_context);
        this.entityPath = _entityPath;
        this.identifier = (0, $3402f46f0a1b2976$export$dad746c31d112b77)(this.entityPath, identifier);
        this._sender = (0, $5a3e170085792353$export$9a6491f300f3bd5c).create(this.identifier, this._context, _entityPath, retryOptions);
        this._retryOptions = retryOptions;
    }
    get logPrefix() {
        return `[${this._context.connectionId}|sender:${this.entityPath}]`;
    }
    _throwIfSenderOrConnectionClosed() {
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(this._context);
        if (this.isClosed) {
            const errorMessage = (0, $f4faabfcfe4aedfc$export$b3043c42d7e2faae)(this._entityPath);
            const error = new Error(errorMessage);
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(error, `[${this._context.connectionId}] is closed`);
            throw error;
        }
    }
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    async sendMessages(messages, options) {
        this._throwIfSenderOrConnectionClosed();
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(this._context.connectionId, "messages", messages);
        if (!$7c819730788b41d6$export$22b5d5ee393e1a13(messages) && !Array.isArray(messages)) {
            // Case 1: Single message
            (0, $f4faabfcfe4aedfc$export$967aa9e81b482b79)(messages, (0, $f4faabfcfe4aedfc$export$8484f288912a9358));
            const originalMessage = messages;
            const { message: message , spanContext: spanContext  } = (0, $14342bb4fa4d757f$export$9bea097ef11100d9)(originalMessage, options !== null && options !== void 0 ? options : {}, this.entityPath, this._context.config.host);
            const spanLinks = spanContext ? [
                {
                    tracingContext: spanContext
                }
            ] : [];
            return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusSender.send", options !== null && options !== void 0 ? options : {}, (updatedOptions)=>this._sender.send(message, updatedOptions), Object.assign({
                spanLinks: spanLinks
            }, (0, $10b26da869f0d653$export$d2129a31a8b4253f)({
                entityPath: this.entityPath,
                host: this._context.config.host
            }, "client")));
        }
        let batch;
        if ($7c819730788b41d6$export$22b5d5ee393e1a13(messages)) // Case 2: Batch message
        batch = messages;
        else {
            // Case 3: Array of messages
            batch = await this.createMessageBatch(options);
            for (const message of messages){
                (0, $f4faabfcfe4aedfc$export$967aa9e81b482b79)(message, (0, $f4faabfcfe4aedfc$export$8484f288912a9358));
                if (!batch.tryAddMessage(message, options)) // this is too big - throw an error
                throw new (0, $c6ec964bc6c55a71$export$a7174187385dd2e2)("Messages were too big to fit in a single batch. Remove some messages and try again or create your own batch using createBatch(), which gives more fine-grained control.", "MessageSizeExceeded");
            }
        }
        const spanLinks = batch._messageSpanContexts.map((tracingContext)=>{
            return {
                tracingContext: tracingContext
            };
        });
        return (0, $10b26da869f0d653$export$fd8e54df9573b5e4).withSpan("ServiceBusSender.send", options !== null && options !== void 0 ? options : {}, (updatedOptions)=>this._sender.sendBatch(batch, updatedOptions), Object.assign({
            spanLinks: spanLinks
        }, (0, $10b26da869f0d653$export$d2129a31a8b4253f)({
            entityPath: this.entityPath,
            host: this._context.config.host
        }, "client")));
    }
    async createMessageBatch(options) {
        this._throwIfSenderOrConnectionClosed();
        return this._sender.createBatch(options);
    }
    async scheduleMessages(messages, scheduledEnqueueTimeUtc, options = {}) {
        this._throwIfSenderOrConnectionClosed();
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(this._context.connectionId, "scheduledEnqueueTimeUtc", scheduledEnqueueTimeUtc);
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(this._context.connectionId, "messages", messages);
        const messagesToSchedule = Array.isArray(messages) ? messages : [
            messages
        ];
        for (const message of messagesToSchedule)(0, $f4faabfcfe4aedfc$export$967aa9e81b482b79)(message, (0, $f4faabfcfe4aedfc$export$8484f288912a9358));
        const scheduleMessageOperationPromise = async ()=>{
            return this._context.getManagementClient(this._entityPath).scheduleMessages(scheduledEnqueueTimeUtc, messagesToSchedule, Object.assign(Object.assign({}, options), {
                associatedLinkName: this._sender.name,
                requestName: "scheduleMessages",
                timeoutInMs: this._retryOptions.timeoutInMs
            }));
        };
        const config = {
            operation: scheduleMessageOperationPromise,
            connectionId: this._context.connectionId,
            operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).management,
            retryOptions: this._retryOptions,
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
        };
        return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config);
    }
    async cancelScheduledMessages(sequenceNumbers, options = {}) {
        this._throwIfSenderOrConnectionClosed();
        (0, $f4faabfcfe4aedfc$export$f0c638a8242b4a49)(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
        (0, $f4faabfcfe4aedfc$export$d0c336de1cbf0354)(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
        const sequenceNumbersToCancel = Array.isArray(sequenceNumbers) ? sequenceNumbers : [
            sequenceNumbers
        ];
        const cancelSchedulesMessagesOperationPromise = async ()=>{
            return this._context.getManagementClient(this._entityPath).cancelScheduledMessages(sequenceNumbersToCancel, Object.assign(Object.assign({}, options), {
                associatedLinkName: this._sender.name,
                requestName: "cancelScheduledMessages",
                timeoutInMs: this._retryOptions.timeoutInMs
            }));
        };
        const config = {
            operation: cancelSchedulesMessagesOperationPromise,
            connectionId: this._context.connectionId,
            operationType: (0, $da0e8ee01baeae47$export$f9f3e456e3c6243f).management,
            retryOptions: this._retryOptions,
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
        };
        return (0, $da0e8ee01baeae47$export$9369b12211e1fce4)(config);
    }
    // async open(options?: OperationOptionsBase): Promise<void> {
    //   this._throwIfSenderOrConnectionClosed();
    //   const config: RetryConfig<void> = {
    //     // TODO: Pass tracing options too
    //     operation: () => this._sender.open(undefined, options?.abortSignal),
    //     connectionId: this._context.connectionId,
    //     operationType: RetryOperationType.senderLink,
    //     retryOptions: this._retryOptions,
    //     abortSignal: options?.abortSignal
    //   };
    //   return retry<void>(config);
    // }
    async close() {
        try {
            this._isClosed = true;
            await this._sender.close();
        } catch (err) {
            (0, $f014dc9d393cdf62$export$eed4bd3850cd4ef3).logError(err, `${this.logPrefix} An error occurred while closing the Sender`);
            throw err;
        }
    }
}
function $7c819730788b41d6$export$22b5d5ee393e1a13(messageBatchOrAnything) {
    if (messageBatchOrAnything == null) return false;
    const possibleBatch = messageBatchOrAnything;
    return typeof possibleBatch.tryAddMessage === "function" && typeof possibleBatch.maxSizeInBytes === "number" && typeof possibleBatch.sizeInBytes === "number";
}



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.














class $d645316141e21c2b$export$99b2ec6d27e1ec38 extends (0, $12c81f6e1047261d$export$3ba4e37e9c27f9bb) {
    /**
     * Constructs a MessageSession instance which lets you receive messages as batches
     * or via callbacks using subscribe.
     *
     * @param _providedSessionId - The sessionId provided by the user. This can be the
     * name of a session ID to open (empty string is also valid) or it can be undefined,
     * to indicate we want the next unlocked non-empty session.
     */ constructor(identifier, connectionContext, entityPath, _providedSessionId, options){
        super(entityPath, entityPath, connectionContext, "session", (0, $f014dc9d393cdf62$export$e0718a134caff0cf), {
            address: entityPath,
            audience: `${connectionContext.config.endpoint}${entityPath}`
        });
        this.identifier = identifier;
        this._providedSessionId = _providedSessionId;
        /**
         * The maximum number of messages that should be
         * processed concurrently in a session while in streaming mode. Once this limit has been reached,
         * more messages will not be received until the user's message handler has completed processing current message.
         * - **Default**: `1` (message in a session at a time).
         */ this.maxConcurrentCalls = 1;
        /**
         * Maintains a map of deliveries that
         * are being actively disposed. It acts as a store for correlating the responses received for
         * active dispositions.
         */ this._deliveryDispositionMap = new Map();
        this._receiverHelper = new (0, $3b2f2ffa8f8d3149$export$c9e7a1bffd742ae)(()=>({
                receiver: this.link,
                logPrefix: this.logPrefix
            }));
        this._retryOptions = options.retryOptions;
        this.autoComplete = false;
        if ((0, $a7961d970a7496cb$export$4e62c701997796c1)(this._providedSessionId)) this.sessionId = this._providedSessionId;
        this.receiveMode = options.receiveMode || "peekLock";
        this.skipParsingBodyAsJson = options.skipParsingBodyAsJson;
        this.skipConvertingDate = options.skipConvertingDate;
        this.maxAutoRenewDurationInMs = options.maxAutoLockRenewalDurationInMs != null ? options.maxAutoLockRenewalDurationInMs : 300000;
        this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;
        this.autoRenewLock = this.maxAutoRenewDurationInMs > 0 && this.receiveMode === "peekLock";
        this._isReceivingMessagesForSubscriber = false;
        this._batchingReceiverLite = new (0, $83f93614d540afee$export$fb8e488ce17d0b7a)(connectionContext, entityPath, async (_abortSignal)=>{
            return this.link;
        }, this.receiveMode, this.skipParsingBodyAsJson, this.skipConvertingDate);
        // setting all the handlers
        this._onSettled = (context)=>{
            const delivery = context.delivery;
            (0, $93fbc5f601f11887$export$a3b49e7a5b7540c)(this.logPrefix, delivery, this._deliveryDispositionMap);
        };
        this._notifyError = (args)=>{
            if (this._onError) {
                this._onError(args);
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Notified the user's error handler about the error received by the Receiver", this.logPrefix);
            }
        };
        this._onAmqpError = (context)=>{
            const receiverError = context.receiver && context.receiver.error;
            if (receiverError) {
                const sbError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(receiverError);
                if (sbError.code === "SessionLockLostError") sbError.message = `The session lock has expired on the session with id ${this.sessionId}.`;
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(sbError, "%s An error occurred for Receiver", this.logPrefix);
                this._notifyError({
                    error: sbError,
                    errorSource: "receive",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier: this.identifier
                });
            }
        };
        this._onSessionError = (context)=>{
            const connectionId = this._context.connectionId;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(sessionError);
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(sbError, "[%s] An error occurred on the session for Receiver '%s': %O.", connectionId, this.name, sbError);
                this._notifyError({
                    error: sbError,
                    errorSource: "receive",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier: this.identifier
                });
            }
        };
        this._onAmqpClose = async (context)=>{
            const connectionId = this._context.connectionId;
            const receiverError = context.receiver && context.receiver.error;
            const receiver = this.link || context.receiver;
            if (receiverError) {
                const sbError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(receiverError);
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(sbError, "[%s] 'receiver_close' event occurred for receiver '%s' for sessionId '%s'. The associated error is: %O", connectionId, this.name, this.sessionId, sbError);
            // no need to notify the user's error handler since rhea guarantees that receiver_error
            // will always be emitted before receiver_close.
            }
            if (receiver && !receiver.isItselfClosed()) {
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s 'receiver_close' event occurred on the receiver for sessionId '%s' and the sdk did not initiate this. Hence, let's gracefully close the receiver.", this.logPrefix, this.sessionId);
                try {
                    await this.close();
                } catch (err) {
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(err, "%s An error occurred while closing the receiver for sessionId '%s'.", this.logPrefix, this.sessionId);
                }
            } else (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s 'receiver_close' event occurred on the receiver for sessionId '%s' because the sdk initiated it. Hence no need to gracefully close the receiver", this.logPrefix, this.sessionId);
        };
        this._onSessionClose = async (context)=>{
            const receiver = this.link || context.receiver;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(sessionError);
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(sbError, "%s 'session_close' event occurred for receiver for sessionId '%s'. The associated error is", this.logPrefix, this.sessionId);
            // no need to notify the user's error handler since rhea guarantees that session_error
            // will always be emitted before session_close.
            }
            if (receiver && !receiver.isSessionItselfClosed()) {
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s 'session_close' event occurred on the receiver for sessionId '%s' and the sdk did not initiate this. Hence, let's gracefully close the receiver.", this.logPrefix, this.sessionId);
                try {
                    await this.close();
                } catch (err) {
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(err, "%s An error occurred while closing the receiver for sessionId '%s'", this.logPrefix, this.sessionId);
                }
            } else (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s 'session_close' event occurred on the receiver for sessionId'%s' because the sdk initiated it. Hence no need to gracefully close the receiver", this.logPrefix, this.sessionId);
        };
    }
    /**
     * Denotes if we are currently receiving messages
     */ get isReceivingMessages() {
        return this._batchingReceiverLite.isReceivingMessages || this._isReceivingMessagesForSubscriber;
    }
    get receiverHelper() {
        return this._receiverHelper;
    }
    /**
     * Ensures that the session lock is renewed before it expires. The lock will not be renewed for
     * more than the configured totalAutoLockRenewDuration.
     */ _ensureSessionLockRenewal() {
        if (this.autoRenewLock && new Date(this._totalAutoLockRenewDuration) > this.sessionLockedUntilUtc && Date.now() < this._totalAutoLockRenewDuration && this.isOpen()) {
            const nextRenewalTimeout = (0, $3402f46f0a1b2976$export$b445d5bd96910ece)(this.sessionLockedUntilUtc);
            this._sessionLockRenewalTimer = setTimeout(async ()=>{
                try {
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Attempting to renew the session lock for MessageSession '%s' with name '%s'.", this.logPrefix, this.sessionId, this.name);
                    this.sessionLockedUntilUtc = await this._context.getManagementClient(this.entityPath).renewSessionLock(this.sessionId, {
                        associatedLinkName: this.name,
                        timeoutInMs: 10000
                    });
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Successfully renewed the session lock for MessageSession '%s' with name '%s'.", this.logPrefix, this.sessionId, this.name);
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Calling _ensureSessionLockRenewal() again for MessageSession '%s'.", this.logPrefix, this.sessionId);
                    this._ensureSessionLockRenewal();
                } catch (err) {
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(err, "%s An error occurred while renewing the session lock for MessageSession '%s'", this.logPrefix, this.sessionId);
                }
            }, nextRenewalTimeout);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s MessageSession '%s' has next session lock renewal in %d milliseconds @(%s).", this.logPrefix, this.sessionId, nextRenewalTimeout, new Date(Date.now() + nextRenewalTimeout).toString());
        }
    }
    createRheaLink(options, _abortSignal) {
        return this._context.connection.createReceiver(options);
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     */ async _init(opts = {}) {
        try {
            const sessionOptions = this._createMessageSessionOptions(this.identifier, opts.timeoutInMs);
            await this.initLink(sessionOptions, opts.abortSignal);
            if (this.link == null) throw new Error("INTERNAL ERROR: failed to create receiver but without an error.");
            const receivedSessionId = this.link.source && this.link.source.filter && this.link.source.filter[(0, $807770c0815ec6f8$export$a002182e51710d39).sessionFilterName];
            let errorMessage = "";
            if (this._providedSessionId == null && receivedSessionId == null) // Ideally this code path should never be reached as `MessageSession.createReceiver()` should fail instead
            // TODO: https://github.com/Azure/azure-sdk-for-js/issues/9775 to figure out why this code path indeed gets hit.
            errorMessage = `Failed to create a receiver. No unlocked sessions available.`;
            else if (this._providedSessionId != null && receivedSessionId !== this._providedSessionId) // This code path is reached if the session is already locked by another receiver.
            // TODO: Check why the service would not throw an error or just timeout instead of giving a misleading successful receiver
            errorMessage = `Failed to create a receiver for the requested session '${this._providedSessionId}'. It may be locked by another receiver.`;
            if (errorMessage) {
                const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)({
                    description: errorMessage,
                    condition: (0, $3d84b7093289460f$export$65de4560c7cb6642).SessionCannotBeLockedError
                });
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, this.logPrefix);
                throw error;
            }
            if (this._providedSessionId == null) this.sessionId = receivedSessionId;
            this.sessionLockedUntilUtc = (0, $3402f46f0a1b2976$export$7474b3e128eefec5)(this.link.properties["com.microsoft:locked-until-utc"]);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Session with id '%s' is locked until: '%s'.", this.logPrefix, this.sessionId, this.sessionLockedUntilUtc.toISOString());
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Receiver created with receiver options: %O", this.logPrefix, sessionOptions);
            if (!this._context.messageSessions[this.name]) this._context.messageSessions[this.name] = this;
            this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;
            this._ensureSessionLockRenewal();
        } catch (err) {
            const errObj = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(errObj, "%s An error occured while creating the receiver", this.logPrefix);
            // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.
            if (errObj.code === "OperationTimeoutError") {
                if (this._providedSessionId) errObj.message = `Failed to create a receiver for the requested session '${this._providedSessionId}' within allocated time and retry attempts.`;
                else errObj.message = "Failed to create a receiver within allocated time and retry attempts.";
            }
            throw errObj;
        }
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     */ _createMessageSessionOptions(clientId, timeoutInMs) {
        const rcvrOptions = (0, $93fbc5f601f11887$export$fcc21102ff437d0e)(this.name, this.receiveMode, {
            address: this.address,
            filter: {
                [(0, $807770c0815ec6f8$export$a002182e51710d39).sessionFilterName]: this.sessionId
            }
        }, clientId, {
            onClose: (context)=>this._onAmqpClose(context).catch(()=>{
                /* */ }),
            onSessionClose: (context)=>this._onSessionClose(context).catch(()=>{
                /* */ }),
            onError: this._onAmqpError,
            onSessionError: this._onSessionError,
            onSettled: this._onSettled
        }, timeoutInMs);
        return rcvrOptions;
    }
    /**
     * Closes the underlying AMQP receiver link.
     */ async close(error) {
        try {
            this._isReceivingMessagesForSubscriber = false;
            if (this._sessionLockRenewalTimer) clearTimeout(this._sessionLockRenewalTimer);
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Cleared the timers for 'no new message received' task and 'session lock renewal' task.", this.logPrefix);
            await super.close();
            this._batchingReceiverLite.terminate(error);
        } catch (err) {
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(err, "%s An error occurred while closing the message session with id '%s'", this.logPrefix, this.sessionId);
        }
    }
    /**
     * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
     */ isOpen() {
        const result = this.link && this.link.isOpen();
        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Receiver for sessionId '%s' is open? -> %s", this.logPrefix, this.sessionId, result);
        return result;
    }
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the SessionReceiver or set the property
     * `newMessageWaitTimeoutInMs` in the options to provide a timeout.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control whether messages should be automatically completed. You can
     * also provide a timeout in milliseconds to denote the amount of time to wait for a new message
     * before closing the receiver.
     */ subscribe(onMessage, onError, options) {
        this.receiverHelper.resume();
        this._subscribeImpl(onMessage, onError, options);
    }
    _subscribeImpl(onMessage, onError, options) {
        var _a;
        if (!options) options = {};
        if ((_a = options.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) throw new (0, $d8f75e1baa6fdbda$export$18b052ffd8c84d7)((0, $807770c0815ec6f8$export$ec529641dbabb04c));
        this._isReceivingMessagesForSubscriber = true;
        if (typeof options.maxConcurrentCalls === "number" && options.maxConcurrentCalls > 0) this.maxConcurrentCalls = options.maxConcurrentCalls;
        // If explicitly set to false then autoComplete is false else true (default).
        this.autoComplete = options.autoCompleteMessages === false ? options.autoCompleteMessages : true;
        this._onMessage = onMessage;
        this._onError = onError;
        if (this.link && this.link.isOpen()) {
            const onSessionMessage = async (context)=>{
                // If the receiver got closed in PeekLock mode, avoid processing the message as we
                // cannot settle the message.
                if (this.receiveMode === "peekLock" && (!this.link || !this.link.isOpen())) {
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Not calling the user's message handler for the current message as the receiver is closed", this.logPrefix);
                    return;
                }
                const bMessage = new (0, $d7965bb09cbe6503$export$a482b14703d155cd)(context.message, context.delivery, true, this.receiveMode, this.skipParsingBodyAsJson, this.skipConvertingDate);
                try {
                    await this._onMessage(bMessage);
                } catch (err) {
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(err, "%s An error occurred while running user's message handler for the message with id '%s' on the receiver", this.logPrefix, bMessage.messageId);
                    this._onError({
                        error: err,
                        errorSource: "processMessageCallback",
                        entityPath: this.entityPath,
                        fullyQualifiedNamespace: this._context.config.host,
                        identifier: this.identifier
                    });
                    const error = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(err);
                    // Nothing much to do if user's message handler throws. Let us try abandoning the message.
                    if (!bMessage.delivery.remote_settled && this.receiveMode === "peekLock" && this.isOpen() // only try to abandon the messages if the connection is still open
                    ) try {
                        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, "%s Abandoning the message with id '%s' on the receiver since an error occured", this.logPrefix, bMessage.messageId);
                        await (0, $e4f5d79c9cac0816$export$402a56cd3be588c3)(bMessage, this._context, this.entityPath, undefined, this._retryOptions);
                    } catch (abandonError) {
                        const translatedError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(abandonError);
                        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(translatedError, "%s An error occurred while abandoning the message with id '%s' on the receiver", this.logPrefix, bMessage.messageId, translatedError);
                        this._notifyError({
                            error: translatedError,
                            errorSource: "abandon",
                            entityPath: this.entityPath,
                            fullyQualifiedNamespace: this._context.config.host,
                            identifier: this.identifier
                        });
                    }
                    return;
                } finally{
                    try {
                        this.receiverHelper.addCredit(1);
                    } catch (err) {
                        // this isn't something we expect in normal operation - we'd only get here
                        // because of a bug in our code.
                        this.processCreditError(err);
                    }
                }
                // If we've made it this far, then user's message handler completed fine. Let us try
                // completing the message.
                if (this.autoComplete && this.receiveMode === "peekLock" && !bMessage.delivery.remote_settled) try {
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("%s Auto completing the message with id '%s' on the receiver.", this.logPrefix, bMessage.messageId);
                    await (0, $e4f5d79c9cac0816$export$fbd7e56e722b700b)(bMessage, this._context, this.entityPath, this._retryOptions);
                } catch (completeError) {
                    const translatedError = (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(completeError);
                    (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(translatedError, "%s An error occurred while completing the message with id '%s' on the receiver", this.logPrefix, bMessage.messageId);
                    this._notifyError({
                        error: translatedError,
                        errorSource: "complete",
                        entityPath: this.entityPath,
                        fullyQualifiedNamespace: this._context.config.host,
                        identifier: this.identifier
                    });
                }
            };
            // setting the "message" event listener.
            this.link.on((0, $4973e2e602c1cc10$exports.ReceiverEvents).message, onSessionMessage);
            try {
                this.receiverHelper.addCredit(this.maxConcurrentCalls);
            } catch (err) {
                // this isn't something we expect in normal operation - we'd only get here
                // because of a bug in our code.
                this.processCreditError(err);
            }
        } else {
            this._isReceivingMessagesForSubscriber = false;
            const msg = `MessageSession with sessionId '${this.sessionId}' and name '${this.name}' ` + `has either not been created or is not open.`;
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("[%s] %s", this._context.connectionId, msg);
            this._notifyError({
                error: new Error(msg),
                // This is _probably_ the right error code since we require that
                // the message session is created before we even give back the receiver. So it not
                // being open at this point is either:
                //
                // 1. we didn't acquire the lock
                // 2. the connection was broken (we don't reconnect)
                //
                // If any of these becomes untrue you'll probably want to re-evaluate this classification.
                errorSource: "receive",
                entityPath: this.entityPath,
                fullyQualifiedNamespace: this._context.config.host,
                identifier: this.identifier
            });
        }
    }
    processCreditError(err) {
        if (err.name === "AbortError") // if we fail to add credits because the user has asked us to stop
        // then this isn't an error - it's normal.
        return;
        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(err, "Cannot request messages on the receiver");
        const error = new (0, $c6ec964bc6c55a71$export$a7174187385dd2e2)("Cannot request messages on the receiver", "SessionLockLost");
        error.retryable = false;
        // from the user's perspective this is a fatal link error and they should retry
        // opening the link.
        this._onError({
            error: error,
            errorSource: "processMessageCallback",
            entityPath: this.entityPath,
            fullyQualifiedNamespace: this._context.config.host,
            identifier: this.identifier
        });
    }
    /**
     * Returns a batch of messages based on given count and timeout over an AMQP receiver link
     * from a Queue/Subscription.
     *
     * @param maxMessageCount - The maximum number of messages to receive from Queue/Subscription.
     * @param maxWaitTimeInMs - The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.
     * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
     * @returns A promise that resolves with an array of Message objects.
     */ async receiveMessages(maxMessageCount, maxWaitTimeInMs, maxTimeAfterFirstMessageInMs, options) {
        try {
            return await this._batchingReceiverLite.receiveMessages(Object.assign({
                maxMessageCount: maxMessageCount,
                maxWaitTimeInMs: maxWaitTimeInMs,
                maxTimeAfterFirstMessageInMs: maxTimeAfterFirstMessageInMs
            }, options));
        } catch (error) {
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).logError(error, `${this.logPrefix} Rejecting receiveMessages() with error`);
            throw error;
        }
    }
    /**
     * To be called when connection is disconnected to gracefully close ongoing receive request.
     * @param connectionError - The connection error if any.
     */ async onDetached(connectionError) {
        (0, $f014dc9d393cdf62$export$e0718a134caff0cf).error((0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(connectionError), `${this.logPrefix} onDetached: closing link (session receiver will not reconnect)`);
        try {
            // Notifying so that the streaming receiver knows about the error
            this._notifyError({
                entityPath: this.entityPath,
                fullyQualifiedNamespace: this._context.config.host,
                error: (0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(connectionError),
                errorSource: "receive",
                identifier: this.identifier
            });
        } catch (error) {
            (0, $f014dc9d393cdf62$export$e0718a134caff0cf).error((0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(error), `${this.logPrefix} onDetached: unexpected error seen when tried calling "_notifyError" with ${(0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(connectionError)}`);
        }
        await this.close(connectionError);
    }
    /**
     * Settles the message with the specified disposition.
     * @param message - The ServiceBus Message that needs to be settled.
     * @param operation - The disposition type.
     * @param options - Optional parameters that can be provided while disposing the message.
     */ async settleMessage(message, operation, options) {
        return new Promise((resolve, reject)=>{
            if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) return reject(new Error(`operation: '${operation}' is not a valid operation.`));
            const delivery = message.delivery;
            const timer = setTimeout(()=>{
                this._deliveryDispositionMap.delete(delivery.id);
                (0, $f014dc9d393cdf62$export$e0718a134caff0cf).verbose("[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. Hence rejecting the promise with timeout error", this._context.connectionId, delivery.id, (0, $807770c0815ec6f8$export$a002182e51710d39).defaultOperationTimeoutInMs);
                const e = {
                    condition: (0, $3d84b7093289460f$export$65de4560c7cb6642).ServiceUnavailableError,
                    description: "Operation to settle the message has timed out. The disposition of the message may or may not be successful"
                };
                return reject((0, $c6ec964bc6c55a71$export$8bd4f04fa736e48c)(e));
            }, (0, $807770c0815ec6f8$export$a002182e51710d39).defaultOperationTimeoutInMs);
            this._deliveryDispositionMap.set(delivery.id, {
                resolve: resolve,
                reject: reject,
                timer: timer
            });
            if (operation === (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).complete) delivery.accept();
            else if (operation === (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).abandon) {
                const params = {
                    undeliverable_here: false
                };
                if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;
                delivery.modified(params);
            } else if (operation === (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).defer) {
                const params = {
                    undeliverable_here: true
                };
                if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;
                delivery.modified(params);
            } else if (operation === (0, $d7965bb09cbe6503$export$8ea2432f7b480e4d).deadletter) {
                const error = {
                    condition: (0, $807770c0815ec6f8$export$a002182e51710d39).deadLetterName,
                    info: Object.assign(Object.assign({}, options.propertiesToModify), {
                        DeadLetterReason: options.deadLetterReason,
                        DeadLetterErrorDescription: options.deadLetterDescription
                    })
                };
                delivery.reject(error);
            }
        });
    }
    /**
     * Creates a new instance of the MessageSession based on the provided parameters.
     * @param identifier - name to identify the message session
     * @param context - The client entity context
     * @param options - Options that can be provided while creating the MessageSession.
     */ static async create(identifier, context, entityPath, sessionId, options) {
        var _a, _b;
        (0, $f4faabfcfe4aedfc$export$136df9204559429f)(context);
        const messageSession = new $d645316141e21c2b$export$99b2ec6d27e1ec38(identifier, context, entityPath, sessionId, options);
        let timeoutInMs;
        // Only passing client timeout in link properties for accepting next available
        // session as this is the only long-polling scenario.
        if (sessionId === undefined) {
            timeoutInMs = (_b = (_a = options.retryOptions) === null || _a === void 0 ? void 0 : _a.timeoutInMs) !== null && _b !== void 0 ? _b : (0, $807770c0815ec6f8$export$a002182e51710d39).defaultOperationTimeoutInMs;
            // The number of milliseconds to use as the basis for calculating a random jitter amount
            // opening receiver links. This is intended to ensure that multiple
            // session operations don't timeout at the same exact moment.
            const openReceiveLinkBaseJitterInMs = 100;
            // The amount of time to subtract from the client timeout when setting the server timeout when attempting to
            // accept the next available session. This will decrease the likelihood that the client times out before receiving a
            // response from the server.
            const openReceiveLinkBufferInMs = 20;
            // The amount minimum threshold for the server timeout for which we will subtract the "openReceiveLinkBufferInMs".
            // If the server timeout is less than this, we will not subtract the additional buffer.
            const openReceiveLinkBufferThresholdInMs = 1000;
            // Subtract a random amount up to 100ms from the operation timeout as the jitter when attempting to open next available session link.
            // This prevents excessive resource usage when using high amounts of concurrency and accepting the next available session.
            // Take the min of 1% of the total timeout and the base jitter amount so that we don't end up subtracting more than 1% of the total timeout.
            const jitterBaseInMs = Math.min(timeoutInMs * 0.01, openReceiveLinkBaseJitterInMs);
            // We set the operation timeout on the properties not only to include the jitter, but also because the server will otherwise
            // restrict the maximum timeout to 1 minute and 5 seconds, regardless of the client timeout. We only do this for accepting next available
            // session as this is the only long-polling scenario.
            timeoutInMs = Math.floor(timeoutInMs - jitterBaseInMs * Math.random());
            // Subtract an additional constant buffer to reduce the likelihood that the client times out before the service which leads to unnecessary
            // network traffic. If the timeout is too short, we won't do this.
            if (timeoutInMs >= openReceiveLinkBufferThresholdInMs) timeoutInMs -= openReceiveLinkBufferInMs;
        }
        await messageSession._init({
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
            timeoutInMs: timeoutInMs
        });
        return messageSession;
    }
    removeLinkFromContext() {
        delete this._context.messageSessions[this.name];
    }
}



// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

function $43756a4357e43706$export$a7f7c87d18538ca4(thing) {
    return (0, $5bfba789bf6c5d92$export$59ba6af2e517603a)(thing) || (0, $720970adf00c6270$export$9117b72f7d656ea5)(thing) || (0, $c156b569e523edc4$export$3b616d4df4414a6e)(thing);
}



class $6bbe8d50b3f46688$export$47e06d551fd975d4 {
    constructor(fullyQualifiedNamespaceOrConnectionString1, credentialOrOptions2, options3){
        if ((0, $43756a4357e43706$export$a7f7c87d18538ca4)(credentialOrOptions2)) {
            const fullyQualifiedNamespace = fullyQualifiedNamespaceOrConnectionString1;
            const credential = credentialOrOptions2;
            this._clientOptions = options3 || {};
            this._connectionContext = (0, $7d8eaab9edb7677c$export$93bb568e3dbacc71)(credential, fullyQualifiedNamespace, this._clientOptions);
        } else {
            const connectionString = fullyQualifiedNamespaceOrConnectionString1;
            this._clientOptions = credentialOrOptions2 || {};
            this._connectionContext = (0, $7d8eaab9edb7677c$export$ab02efcdbbb2a67f)(connectionString, this._clientOptions);
        }
        this.fullyQualifiedNamespace = this._connectionContext.config.host;
        this.identifier = (0, $3402f46f0a1b2976$export$dad746c31d112b77)(this.fullyQualifiedNamespace, this._clientOptions.identifier);
        this._clientOptions.retryOptions = this._clientOptions.retryOptions || {};
        const timeoutInMs = this._clientOptions.retryOptions.timeoutInMs;
        if ((0, $a7961d970a7496cb$export$4e62c701997796c1)(timeoutInMs) && (typeof timeoutInMs !== "number" || !isFinite(timeoutInMs) || timeoutInMs <= 0)) throw new Error(`${timeoutInMs} is an invalid value for retryOptions.timeoutInMs`);
    }
    createReceiver(queueOrTopicName1, optionsOrSubscriptionName2, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options3) {
        var _a, _b;
        $6bbe8d50b3f46688$var$validateEntityPath(this._connectionContext.config, queueOrTopicName1);
        // NOTE: we don't currently have any options for this kind of receiver but
        // when we do make sure you pass them in and extract them.
        const { entityPath: entityPath , receiveMode: receiveMode , options: options  } = $6bbe8d50b3f46688$export$27ae52a8cbde64db(queueOrTopicName1, optionsOrSubscriptionName2, options3);
        let entityPathWithSubQueue = entityPath;
        if (options === null || options === void 0 ? void 0 : options.subQueueType) switch(options === null || options === void 0 ? void 0 : options.subQueueType){
            case "deadLetter":
                entityPathWithSubQueue += "/$DeadLetterQueue";
                break;
            case "transferDeadLetter":
                entityPathWithSubQueue += "/$Transfer/$DeadLetterQueue";
                break;
            default:
                throw new Error(`Invalid subQueueType '${options === null || options === void 0 ? void 0 : options.subQueueType}' provided. Valid values are 'deadLetter' and 'transferDeadLetter'`);
        }
        const maxLockAutoRenewDurationInMs = (options === null || options === void 0 ? void 0 : options.maxAutoLockRenewalDurationInMs) != null ? options.maxAutoLockRenewalDurationInMs : 300000;
        return new (0, $9b4f6ddf5fbb620a$export$d0175b409ed11669)(this._connectionContext, entityPathWithSubQueue, receiveMode, maxLockAutoRenewDurationInMs, (_a = options === null || options === void 0 ? void 0 : options.skipParsingBodyAsJson) !== null && _a !== void 0 ? _a : false, (_b = options === null || options === void 0 ? void 0 : options.skipConvertingDate) !== null && _b !== void 0 ? _b : false, this._clientOptions.retryOptions, options === null || options === void 0 ? void 0 : options.identifier);
    }
    /**
     * Creates an instance of {@link ServiceBusRuleManager} that is used to manage
     * the rules for a subscription.
     *
     * @param topicName - the topic to create {@link ServiceBusRuleManager}
     * @param subscriptionName - the subscription specific to the specified topic to create a {@link ServiceBusRuleManager} for.
     * @returns a {@link ServiceBusRuleManager} scoped to the specified subscription and topic.
     */ createRuleManager(topicName, subscriptionName) {
        $6bbe8d50b3f46688$var$validateEntityPath(this._connectionContext.config, topicName);
        const { entityPath: entityPath  } = $6bbe8d50b3f46688$export$27ae52a8cbde64db(topicName, subscriptionName);
        return new (0, $6a447896987a8cc3$export$ac3acc534f5b7921)(this._connectionContext, entityPath, this._clientOptions.retryOptions);
    }
    async acceptSession(queueOrTopicName1, optionsOrSubscriptionNameOrSessionId2, optionsOrSessionId3, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options4) {
        var _a, _b;
        $6bbe8d50b3f46688$var$validateEntityPath(this._connectionContext.config, queueOrTopicName1);
        let sessionId;
        let entityPath;
        let receiveMode;
        let options;
        if (typeof queueOrTopicName1 === "string" && typeof optionsOrSubscriptionNameOrSessionId2 === "string" && typeof optionsOrSessionId3 === "string") {
            // subscription constructor
            sessionId = optionsOrSessionId3;
            ({ entityPath: entityPath , receiveMode: receiveMode , options: options  } = $6bbe8d50b3f46688$export$27ae52a8cbde64db(queueOrTopicName1, optionsOrSubscriptionNameOrSessionId2, // skip the session ID parameter (3)
            options4));
        } else if (typeof queueOrTopicName1 === "string" && typeof optionsOrSubscriptionNameOrSessionId2 === "string" && typeof optionsOrSessionId3 !== "string") {
            // queue constructor (but only because we know we're not a subscription constructor)
            sessionId = optionsOrSubscriptionNameOrSessionId2;
            ({ entityPath: entityPath , receiveMode: receiveMode , options: options  } = $6bbe8d50b3f46688$export$27ae52a8cbde64db(queueOrTopicName1, // skip the session ID parameter (2)
            optionsOrSessionId3, undefined));
        } else throw new Error("Unhandled set of parameters");
        const messageSession = await (0, $d645316141e21c2b$export$99b2ec6d27e1ec38).create((0, $3402f46f0a1b2976$export$dad746c31d112b77)(entityPath, options === null || options === void 0 ? void 0 : options.identifier), this._connectionContext, entityPath, sessionId, {
            maxAutoLockRenewalDurationInMs: options === null || options === void 0 ? void 0 : options.maxAutoLockRenewalDurationInMs,
            receiveMode: receiveMode,
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
            retryOptions: this._clientOptions.retryOptions,
            skipParsingBodyAsJson: (_a = options === null || options === void 0 ? void 0 : options.skipParsingBodyAsJson) !== null && _a !== void 0 ? _a : false,
            skipConvertingDate: (_b = options === null || options === void 0 ? void 0 : options.skipConvertingDate) !== null && _b !== void 0 ? _b : false
        });
        const sessionReceiver = new (0, $23fa95c974a3c272$export$ee7da49ff4de6f04)(messageSession, this._connectionContext, entityPath, receiveMode, this._clientOptions.retryOptions);
        return sessionReceiver;
    }
    async acceptNextSession(queueOrTopicName1, optionsOrSubscriptionName2, // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options3) {
        var _a, _b;
        $6bbe8d50b3f46688$var$validateEntityPath(this._connectionContext.config, queueOrTopicName1);
        const { entityPath: entityPath , receiveMode: receiveMode , options: options  } = $6bbe8d50b3f46688$export$27ae52a8cbde64db(queueOrTopicName1, optionsOrSubscriptionName2, options3);
        const messageSession = await (0, $d645316141e21c2b$export$99b2ec6d27e1ec38).create((0, $3402f46f0a1b2976$export$dad746c31d112b77)(entityPath, options === null || options === void 0 ? void 0 : options.identifier), this._connectionContext, entityPath, undefined, {
            maxAutoLockRenewalDurationInMs: options === null || options === void 0 ? void 0 : options.maxAutoLockRenewalDurationInMs,
            receiveMode: receiveMode,
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
            retryOptions: this._clientOptions.retryOptions,
            skipParsingBodyAsJson: (_a = options === null || options === void 0 ? void 0 : options.skipParsingBodyAsJson) !== null && _a !== void 0 ? _a : false,
            skipConvertingDate: (_b = options === null || options === void 0 ? void 0 : options.skipConvertingDate) !== null && _b !== void 0 ? _b : false
        });
        const sessionReceiver = new (0, $23fa95c974a3c272$export$ee7da49ff4de6f04)(messageSession, this._connectionContext, entityPath, receiveMode, this._clientOptions.retryOptions);
        return sessionReceiver;
    }
    /**
     * Creates a Sender which can be used to send messages, schedule messages to be
     * sent at a later time and cancel such scheduled messages. No connection is made
     * to the service until one of the methods on the sender is called.
     * @param queueOrTopicName - The name of a queue or topic to send messages to.
     */ createSender(queueOrTopicName, options = {}) {
        $6bbe8d50b3f46688$var$validateEntityPath(this._connectionContext.config, queueOrTopicName);
        return new (0, $7c819730788b41d6$export$385e32dcb8110119)(this._connectionContext, queueOrTopicName, this._clientOptions.retryOptions, options.identifier);
    }
    /**
     * Closes the underlying AMQP connection.
     * NOTE: this will also disconnect any Receiver or Sender instances created from this
     * instance.
     */ close() {
        return (0, $2818e26e2eb99f0d$export$af54d3055d90c64e).close(this._connectionContext);
    }
}
function $6bbe8d50b3f46688$export$27ae52a8cbde64db(queueOrTopicName1, optionsOrSubscriptionName2, definitelyOptions3) {
    let entityPath;
    let options;
    if (typeof optionsOrSubscriptionName2 === "string") {
        const topic = queueOrTopicName1;
        const subscription = optionsOrSubscriptionName2;
        entityPath = `${topic}/Subscriptions/${subscription}`;
        options = definitelyOptions3;
    } else {
        entityPath = queueOrTopicName1;
        options = optionsOrSubscriptionName2;
    }
    let receiveMode;
    if (!options || !(0, $a7961d970a7496cb$export$4e62c701997796c1)(options.receiveMode) || options.receiveMode === "peekLock") receiveMode = "peekLock";
    else if (options.receiveMode === "receiveAndDelete") receiveMode = "receiveAndDelete";
    else throw new TypeError(`Invalid receiveMode '${options === null || options === void 0 ? void 0 : options.receiveMode}' provided. Valid values are 'peekLock' and 'receiveAndDelete'`);
    options === null || options === void 0 || delete options.receiveMode;
    return {
        entityPath: entityPath,
        receiveMode: receiveMode,
        options: options
    };
}
/**
 * Validates that the EntityPath in the connection string (if any) matches with the
 * queue or topic name passed to the methods that create senders and receivers.
 *
 * @internal
 */ function $6bbe8d50b3f46688$var$validateEntityPath(connectionConfig, queueOrTopicName) {
    if (connectionConfig.entityPath && connectionConfig.entityPath !== queueOrTopicName) throw new Error((0, $f4faabfcfe4aedfc$export$ab45ab8711aa1ebf));
}


function $e9d38c047157287b$export$6bb76d6eba7e258c(connection) {
    switch(connection.connectionType){
        case 0:
            const connectionDetails = connection.connectionDetails;
            return new (0, $6bbe8d50b3f46688$export$47e06d551fd975d4)(connectionDetails.connectionString);
        default:
            throw new Error("Connection type not supported yet, cannot create client");
    }
}
function $e9d38c047157287b$export$4b31e949f038019f(connection) {
    switch(connection.connectionType){
        case 0:
            const connectionDetails = connection.connectionDetails;
            return new (0, $0f4ecb9a156d839d$export$a0e4807668b2dd72)(connectionDetails.connectionString);
        default:
            throw new Error("Connection type not supported yet, cannot create client");
    }
}
window["servicebusConnections"] = {
    getClient: $e9d38c047157287b$export$6bb76d6eba7e258c,
    getAdminClient: $e9d38c047157287b$export$4b31e949f038019f
};

})();
//# sourceMappingURL=servicebus.js.map
